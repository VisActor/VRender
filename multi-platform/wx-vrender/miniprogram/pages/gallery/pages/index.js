(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VRender = {}));
})(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var Reflect$1;
  (function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
      var root = _typeof(commonjsGlobal) === "object" ? commonjsGlobal : (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" ? self : _typeof(this) === "object" ? this : Function("return this;")();
      var exporter = makeExporter(Reflect);
      if (typeof root.Reflect === "undefined") {
        root.Reflect = Reflect;
      } else {
        exporter = makeExporter(root.Reflect, exporter);
      }
      factory(exporter);
      function makeExporter(target, previous) {
        return function (key, value) {
          if (typeof target[key] !== "function") {
            Object.defineProperty(target, key, {
              configurable: true,
              writable: true,
              value: value
            });
          }
          if (previous) previous(key, value);
        };
      }
    })(function (exporter) {
      var hasOwn = Object.prototype.hasOwnProperty;
      // feature test for Symbol support
      var supportsSymbol = typeof Symbol === "function";
      var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
      var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
      var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
      var supportsProto = {
        __proto__: []
      } instanceof Array; // feature test for __proto__ support
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        // create an object in dictionary mode (a.k.a. "slow" mode in v8)
        create: supportsCreate ? function () {
          return MakeDictionary(Object.create(null));
        } : supportsProto ? function () {
          return MakeDictionary({
            __proto__: null
          });
        } : function () {
          return MakeDictionary({});
        },
        has: downLevel ? function (map, key) {
          return hasOwn.call(map, key);
        } : function (map, key) {
          return key in map;
        },
        get: downLevel ? function (map, key) {
          return hasOwn.call(map, key) ? map[key] : undefined;
        } : function (map, key) {
          return map[key];
        }
      };
      // Load global or shim versions of Map, Set, and WeakMap
      var functionPrototype = Object.getPrototypeOf(Function);
      var usePolyfill = (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
      var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
      var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
      var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
      // [[Metadata]] internal slot
      // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
      var Metadata = new _WeakMap();
      /**
       * Applies a set of decorators to a property of a target object.
       * @param decorators An array of decorators.
       * @param target The target object.
       * @param propertyKey (Optional) The property key to decorate.
       * @param attributes (Optional) The property descriptor for the target key.
       * @remarks Decorators are applied in reverse order.
       * @example
       *
       *     class Example {
       *         // property declarations are not part of ES6, though they are valid in TypeScript:
       *         // static staticProperty;
       *         // property;
       *
       *         constructor(p) { }
       *         static staticMethod(p) { }
       *         method(p) { }
       *     }
       *
       *     // constructor
       *     Example = Reflect.decorate(decoratorsArray, Example);
       *
       *     // property (on constructor)
       *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
       *
       *     // property (on prototype)
       *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
       *
       *     // method (on constructor)
       *     Object.defineProperty(Example, "staticMethod",
       *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
       *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
       *
       *     // method (on prototype)
       *     Object.defineProperty(Example.prototype, "method",
       *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
       *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
       *
       */
      function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
          if (!IsArray(decorators)) throw new TypeError();
          if (!IsObject(target)) throw new TypeError();
          if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError();
          if (IsNull(attributes)) attributes = undefined;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators, target, propertyKey, attributes);
        } else {
          if (!IsArray(decorators)) throw new TypeError();
          if (!IsConstructor(target)) throw new TypeError();
          return DecorateConstructor(decorators, target);
        }
      }
      exporter("decorate", decorate);
      // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
      // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
      /**
       * A default metadata decorator factory that can be used on a class, class member, or parameter.
       * @param metadataKey The key for the metadata entry.
       * @param metadataValue The value for the metadata entry.
       * @returns A decorator function.
       * @remarks
       * If `metadataKey` is already defined for the target and target key, the
       * metadataValue for that key will be overwritten.
       * @example
       *
       *     // constructor
       *     @Reflect.metadata(key, value)
       *     class Example {
       *     }
       *
       *     // property (on constructor, TypeScript only)
       *     class Example {
       *         @Reflect.metadata(key, value)
       *         static staticProperty;
       *     }
       *
       *     // property (on prototype, TypeScript only)
       *     class Example {
       *         @Reflect.metadata(key, value)
       *         property;
       *     }
       *
       *     // method (on constructor)
       *     class Example {
       *         @Reflect.metadata(key, value)
       *         static staticMethod() { }
       *     }
       *
       *     // method (on prototype)
       *     class Example {
       *         @Reflect.metadata(key, value)
       *         method() { }
       *     }
       *
       */
      function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
          if (!IsObject(target)) throw new TypeError();
          if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError();
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
      }
      exporter("metadata", metadata);
      /**
       * Define a unique metadata entry on the target.
       * @param metadataKey A key used to store and retrieve metadata.
       * @param metadataValue A value that contains attached metadata.
       * @param target The target object on which to define metadata.
       * @param propertyKey (Optional) The property key for the target.
       * @example
       *
       *     class Example {
       *         // property declarations are not part of ES6, though they are valid in TypeScript:
       *         // static staticProperty;
       *         // property;
       *
       *         constructor(p) { }
       *         static staticMethod(p) { }
       *         method(p) { }
       *     }
       *
       *     // constructor
       *     Reflect.defineMetadata("custom:annotation", options, Example);
       *
       *     // property (on constructor)
       *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
       *
       *     // property (on prototype)
       *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
       *
       *     // method (on constructor)
       *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
       *
       *     // method (on prototype)
       *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
       *
       *     // decorator factory as metadata-producing annotation.
       *     function MyAnnotation(options): Decorator {
       *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
       *     }
       *
       */
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      exporter("defineMetadata", defineMetadata);
      /**
       * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
       * @param metadataKey A key used to store and retrieve metadata.
       * @param target The target object on which the metadata is defined.
       * @param propertyKey (Optional) The property key for the target.
       * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
       * @example
       *
       *     class Example {
       *         // property declarations are not part of ES6, though they are valid in TypeScript:
       *         // static staticProperty;
       *         // property;
       *
       *         constructor(p) { }
       *         static staticMethod(p) { }
       *         method(p) { }
       *     }
       *
       *     // constructor
       *     result = Reflect.hasMetadata("custom:annotation", Example);
       *
       *     // property (on constructor)
       *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
       *
       *     // property (on prototype)
       *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
       *
       *     // method (on constructor)
       *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
       *
       *     // method (on prototype)
       *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
       *
       */
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasMetadata", hasMetadata);
      /**
       * Gets a value indicating whether the target object has the provided metadata key defined.
       * @param metadataKey A key used to store and retrieve metadata.
       * @param target The target object on which the metadata is defined.
       * @param propertyKey (Optional) The property key for the target.
       * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
       * @example
       *
       *     class Example {
       *         // property declarations are not part of ES6, though they are valid in TypeScript:
       *         // static staticProperty;
       *         // property;
       *
       *         constructor(p) { }
       *         static staticMethod(p) { }
       *         method(p) { }
       *     }
       *
       *     // constructor
       *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
       *
       *     // property (on constructor)
       *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
       *
       *     // property (on prototype)
       *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
       *
       *     // method (on constructor)
       *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
       *
       *     // method (on prototype)
       *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
       *
       */
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("hasOwnMetadata", hasOwnMetadata);
      /**
       * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
       * @param metadataKey A key used to store and retrieve metadata.
       * @param target The target object on which the metadata is defined.
       * @param propertyKey (Optional) The property key for the target.
       * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
       * @example
       *
       *     class Example {
       *         // property declarations are not part of ES6, though they are valid in TypeScript:
       *         // static staticProperty;
       *         // property;
       *
       *         constructor(p) { }
       *         static staticMethod(p) { }
       *         method(p) { }
       *     }
       *
       *     // constructor
       *     result = Reflect.getMetadata("custom:annotation", Example);
       *
       *     // property (on constructor)
       *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
       *
       *     // property (on prototype)
       *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
       *
       *     // method (on constructor)
       *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
       *
       *     // method (on prototype)
       *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
       *
       */
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      exporter("getMetadata", getMetadata);
      /**
       * Gets the metadata value for the provided metadata key on the target object.
       * @param metadataKey A key used to store and retrieve metadata.
       * @param target The target object on which the metadata is defined.
       * @param propertyKey (Optional) The property key for the target.
       * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
       * @example
       *
       *     class Example {
       *         // property declarations are not part of ES6, though they are valid in TypeScript:
       *         // static staticProperty;
       *         // property;
       *
       *         constructor(p) { }
       *         static staticMethod(p) { }
       *         method(p) { }
       *     }
       *
       *     // constructor
       *     result = Reflect.getOwnMetadata("custom:annotation", Example);
       *
       *     // property (on constructor)
       *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
       *
       *     // property (on prototype)
       *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
       *
       *     // method (on constructor)
       *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
       *
       *     // method (on prototype)
       *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
       *
       */
      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter("getOwnMetadata", getOwnMetadata);
      /**
       * Gets the metadata keys defined on the target object or its prototype chain.
       * @param target The target object on which the metadata is defined.
       * @param propertyKey (Optional) The property key for the target.
       * @returns An array of unique metadata keys.
       * @example
       *
       *     class Example {
       *         // property declarations are not part of ES6, though they are valid in TypeScript:
       *         // static staticProperty;
       *         // property;
       *
       *         constructor(p) { }
       *         static staticMethod(p) { }
       *         method(p) { }
       *     }
       *
       *     // constructor
       *     result = Reflect.getMetadataKeys(Example);
       *
       *     // property (on constructor)
       *     result = Reflect.getMetadataKeys(Example, "staticProperty");
       *
       *     // property (on prototype)
       *     result = Reflect.getMetadataKeys(Example.prototype, "property");
       *
       *     // method (on constructor)
       *     result = Reflect.getMetadataKeys(Example, "staticMethod");
       *
       *     // method (on prototype)
       *     result = Reflect.getMetadataKeys(Example.prototype, "method");
       *
       */
      function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }
      exporter("getMetadataKeys", getMetadataKeys);
      /**
       * Gets the unique metadata keys defined on the target object.
       * @param target The target object on which the metadata is defined.
       * @param propertyKey (Optional) The property key for the target.
       * @returns An array of unique metadata keys.
       * @example
       *
       *     class Example {
       *         // property declarations are not part of ES6, though they are valid in TypeScript:
       *         // static staticProperty;
       *         // property;
       *
       *         constructor(p) { }
       *         static staticMethod(p) { }
       *         method(p) { }
       *     }
       *
       *     // constructor
       *     result = Reflect.getOwnMetadataKeys(Example);
       *
       *     // property (on constructor)
       *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
       *
       *     // property (on prototype)
       *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
       *
       *     // method (on constructor)
       *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
       *
       *     // method (on prototype)
       *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
       *
       */
      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      exporter("getOwnMetadataKeys", getOwnMetadataKeys);
      /**
       * Deletes the metadata entry from the target object with the provided key.
       * @param metadataKey A key used to store and retrieve metadata.
       * @param target The target object on which the metadata is defined.
       * @param propertyKey (Optional) The property key for the target.
       * @returns `true` if the metadata entry was found and deleted; otherwise, false.
       * @example
       *
       *     class Example {
       *         // property declarations are not part of ES6, though they are valid in TypeScript:
       *         // static staticProperty;
       *         // property;
       *
       *         constructor(p) { }
       *         static staticMethod(p) { }
       *         method(p) { }
       *     }
       *
       *     // constructor
       *     result = Reflect.deleteMetadata("custom:annotation", Example);
       *
       *     // property (on constructor)
       *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
       *
       *     // property (on prototype)
       *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
       *
       *     // method (on constructor)
       *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
       *
       *     // method (on prototype)
       *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
       *
       */
      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/false);
        if (IsUndefined(metadataMap)) return false;
        if (!metadataMap["delete"](metadataKey)) return false;
        if (metadataMap.size > 0) return true;
        var targetMetadata = Metadata.get(target);
        targetMetadata["delete"](propertyKey);
        if (targetMetadata.size > 0) return true;
        Metadata["delete"](target);
        return true;
      }
      exporter("deleteMetadata", deleteMetadata);
      function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsConstructor(decorated)) throw new TypeError();
            target = decorated;
          }
        }
        return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target, propertyKey, descriptor);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsObject(decorated)) throw new TypeError();
            descriptor = decorated;
          }
        }
        return descriptor;
      }
      function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = Metadata.get(O);
        if (IsUndefined(targetMetadata)) {
          if (!Create) return undefined;
          targetMetadata = new _Map();
          Metadata.set(O, targetMetadata);
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
          if (!Create) return undefined;
          metadataMap = new _Map();
          targetMetadata.set(P, metadataMap);
        }
        return metadataMap;
      }
      // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
      // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
      function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent)) return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
      }
      // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
      // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
        if (IsUndefined(metadataMap)) return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
      // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
      function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P);
        return undefined;
      }
      // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
      // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
        if (IsUndefined(metadataMap)) return undefined;
        return metadataMap.get(MetadataKey);
      }
      // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
      // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/true);
        metadataMap.set(MetadataKey, MetadataValue);
      }
      // 3.1.6.1 OrdinaryMetadataKeys(O, P)
      // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
      function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null) return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0) return ownKeys;
        if (ownKeys.length <= 0) return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
          var key = parentKeys_1[_a];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        return keys;
      }
      // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
      // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
      function OrdinaryOwnMetadataKeys(O, P) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
        if (IsUndefined(metadataMap)) return keys;
        var keysObj = metadataMap.keys();
        var iterator = GetIterator(keysObj);
        var k = 0;
        while (true) {
          var next = IteratorStep(iterator);
          if (!next) {
            keys.length = k;
            return keys;
          }
          var nextValue = IteratorValue(next);
          try {
            keys[k] = nextValue;
          } catch (e) {
            try {
              IteratorClose(iterator);
            } finally {
              throw e;
            }
          }
          k++;
        }
      }
      // 6 ECMAScript Data Typ0es and Values
      // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
      function Type(x) {
        if (x === null) return 1 /* Null */;
        switch (_typeof(x)) {
          case "undefined":
            return 0 /* Undefined */;
          case "boolean":
            return 2 /* Boolean */;
          case "string":
            return 3 /* String */;
          case "symbol":
            return 4 /* Symbol */;
          case "number":
            return 5 /* Number */;
          case "object":
            return x === null ? 1 /* Null */ : 6 /* Object */;
          default:
            return 6 /* Object */;
        }
      }
      // 6.1.1 The Undefined Type
      // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
      function IsUndefined(x) {
        return x === undefined;
      }
      // 6.1.2 The Null Type
      // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
      function IsNull(x) {
        return x === null;
      }
      // 6.1.5 The Symbol Type
      // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
      function IsSymbol(x) {
        return _typeof(x) === "symbol";
      }
      // 6.1.7 The Object Type
      // https://tc39.github.io/ecma262/#sec-object-type
      function IsObject(x) {
        return _typeof(x) === "object" ? x !== null : typeof x === "function";
      }
      // 7.1 Type Conversion
      // https://tc39.github.io/ecma262/#sec-type-conversion
      // 7.1.1 ToPrimitive(input [, PreferredType])
      // https://tc39.github.io/ecma262/#sec-toprimitive
      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0 /* Undefined */:
            return input;
          case 1 /* Null */:
            return input;
          case 2 /* Boolean */:
            return input;
          case 3 /* String */:
            return input;
          case 4 /* Symbol */:
            return input;
          case 5 /* Number */:
            return input;
        }
        var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result)) throw new TypeError();
          return result;
        }
        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
      }
      // 7.1.1.1 OrdinaryToPrimitive(O, hint)
      // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
      function OrdinaryToPrimitive(O, hint) {
        if (hint === "string") {
          var toString_1 = O.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject(result)) return result;
          }
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result)) return result;
          }
        } else {
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result)) return result;
          }
          var toString_2 = O.toString;
          if (IsCallable(toString_2)) {
            var result = toString_2.call(O);
            if (!IsObject(result)) return result;
          }
        }
        throw new TypeError();
      }
      // 7.1.2 ToBoolean(argument)
      // https://tc39.github.io/ecma262/2016/#sec-toboolean
      function ToBoolean(argument) {
        return !!argument;
      }
      // 7.1.12 ToString(argument)
      // https://tc39.github.io/ecma262/#sec-tostring
      function ToString(argument) {
        return "" + argument;
      }
      // 7.1.14 ToPropertyKey(argument)
      // https://tc39.github.io/ecma262/#sec-topropertykey
      function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3 /* String */);
        if (IsSymbol(key)) return key;
        return ToString(key);
      }
      // 7.2 Testing and Comparison Operations
      // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
      // 7.2.2 IsArray(argument)
      // https://tc39.github.io/ecma262/#sec-isarray
      function IsArray(argument) {
        return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
      }
      // 7.2.3 IsCallable(argument)
      // https://tc39.github.io/ecma262/#sec-iscallable
      function IsCallable(argument) {
        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
        return typeof argument === "function";
      }
      // 7.2.4 IsConstructor(argument)
      // https://tc39.github.io/ecma262/#sec-isconstructor
      function IsConstructor(argument) {
        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
        return typeof argument === "function";
      }
      // 7.2.7 IsPropertyKey(argument)
      // https://tc39.github.io/ecma262/#sec-ispropertykey
      function IsPropertyKey(argument) {
        switch (Type(argument)) {
          case 3 /* String */:
            return true;
          case 4 /* Symbol */:
            return true;
          default:
            return false;
        }
      }
      // 7.3 Operations on Objects
      // https://tc39.github.io/ecma262/#sec-operations-on-objects
      // 7.3.9 GetMethod(V, P)
      // https://tc39.github.io/ecma262/#sec-getmethod
      function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null) return undefined;
        if (!IsCallable(func)) throw new TypeError();
        return func;
      }
      // 7.4 Operations on Iterator Objects
      // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method)) throw new TypeError(); // from Call
        var iterator = method.call(obj);
        if (!IsObject(iterator)) throw new TypeError();
        return iterator;
      }
      // 7.4.4 IteratorValue(iterResult)
      // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      // 7.4.5 IteratorStep(iterator)
      // https://tc39.github.io/ecma262/#sec-iteratorstep
      function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
      }
      // 7.4.6 IteratorClose(iterator, completion)
      // https://tc39.github.io/ecma262/#sec-iteratorclose
      function IteratorClose(iterator) {
        var f = iterator["return"];
        if (f) f.call(iterator);
      }
      // 9.1 Ordinary Object Internal Methods and Internal Slots
      // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
      // 9.1.1.1 OrdinaryGetPrototypeOf(O)
      // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
      function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype) return proto;
        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
        // Try to determine the superclass constructor. Compatible implementations
        // must either set __proto__ on a subclass constructor to the superclass constructor,
        // or ensure each class has a valid `constructor` property on its prototype that
        // points back to the constructor.
        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
        // This is the case when in ES6 or when using __proto__ in a compatible browser.
        if (proto !== functionPrototype) return proto;
        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype) return proto;
        // If the constructor was not a function, then we cannot determine the heritage.
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function") return proto;
        // If we have some kind of self-reference, then we cannot determine the heritage.
        if (constructor === O) return proto;
        // we have a pretty good guess at the heritage.
        return constructor;
      }
      // naive Map shim
      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = /** @class */function () {
          function MapIterator(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator.prototype["@@iterator"] = function () {
            return this;
          };
          MapIterator.prototype[iteratorSymbol] = function () {
            return this;
          };
          MapIterator.prototype.next = function () {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return {
                value: result,
                done: false
              };
            }
            return {
              value: undefined,
              done: true
            };
          };
          MapIterator.prototype["throw"] = function (error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator.prototype["return"] = function (value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return {
              value: value,
              done: true
            };
          };
          return MapIterator;
        }();
        return (/** @class */function () {
            function Map() {
              this._keys = [];
              this._values = [];
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            Object.defineProperty(Map.prototype, "size", {
              get: function get() {
                return this._keys.length;
              },
              enumerable: true,
              configurable: true
            });
            Map.prototype.has = function (key) {
              return this._find(key, /*insert*/false) >= 0;
            };
            Map.prototype.get = function (key) {
              var index = this._find(key, /*insert*/false);
              return index >= 0 ? this._values[index] : undefined;
            };
            Map.prototype.set = function (key, value) {
              var index = this._find(key, /*insert*/true);
              this._values[index] = value;
              return this;
            };
            Map.prototype["delete"] = function (key) {
              var index = this._find(key, /*insert*/false);
              if (index >= 0) {
                var size = this._keys.length;
                for (var i = index + 1; i < size; i++) {
                  this._keys[i - 1] = this._keys[i];
                  this._values[i - 1] = this._values[i];
                }
                this._keys.length--;
                this._values.length--;
                if (key === this._cacheKey) {
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                return true;
              }
              return false;
            };
            Map.prototype.clear = function () {
              this._keys.length = 0;
              this._values.length = 0;
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            };
            Map.prototype.keys = function () {
              return new MapIterator(this._keys, this._values, getKey);
            };
            Map.prototype.values = function () {
              return new MapIterator(this._keys, this._values, getValue);
            };
            Map.prototype.entries = function () {
              return new MapIterator(this._keys, this._values, getEntry);
            };
            Map.prototype["@@iterator"] = function () {
              return this.entries();
            };
            Map.prototype[iteratorSymbol] = function () {
              return this.entries();
            };
            Map.prototype._find = function (key, insert) {
              if (this._cacheKey !== key) {
                this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
              }
              if (this._cacheIndex < 0 && insert) {
                this._cacheIndex = this._keys.length;
                this._keys.push(key);
                this._values.push(undefined);
              }
              return this._cacheIndex;
            };
            return Map;
          }()
        );
        function getKey(key, _) {
          return key;
        }
        function getValue(_, value) {
          return value;
        }
        function getEntry(key, value) {
          return [key, value];
        }
      }
      // naive Set shim
      function CreateSetPolyfill() {
        return (/** @class */function () {
            function Set() {
              this._map = new _Map();
            }
            Object.defineProperty(Set.prototype, "size", {
              get: function get() {
                return this._map.size;
              },
              enumerable: true,
              configurable: true
            });
            Set.prototype.has = function (value) {
              return this._map.has(value);
            };
            Set.prototype.add = function (value) {
              return this._map.set(value, value), this;
            };
            Set.prototype["delete"] = function (value) {
              return this._map["delete"](value);
            };
            Set.prototype.clear = function () {
              this._map.clear();
            };
            Set.prototype.keys = function () {
              return this._map.keys();
            };
            Set.prototype.values = function () {
              return this._map.values();
            };
            Set.prototype.entries = function () {
              return this._map.entries();
            };
            Set.prototype["@@iterator"] = function () {
              return this.keys();
            };
            Set.prototype[iteratorSymbol] = function () {
              return this.keys();
            };
            return Set;
          }()
        );
      }
      // naive WeakMap shim
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return (/** @class */function () {
            function WeakMap() {
              this._key = CreateUniqueKey();
            }
            WeakMap.prototype.has = function (target) {
              var table = GetOrCreateWeakMapTable(target, /*create*/false);
              return table !== undefined ? HashMap.has(table, this._key) : false;
            };
            WeakMap.prototype.get = function (target) {
              var table = GetOrCreateWeakMapTable(target, /*create*/false);
              return table !== undefined ? HashMap.get(table, this._key) : undefined;
            };
            WeakMap.prototype.set = function (target, value) {
              var table = GetOrCreateWeakMapTable(target, /*create*/true);
              table[this._key] = value;
              return this;
            };
            WeakMap.prototype["delete"] = function (target) {
              var table = GetOrCreateWeakMapTable(target, /*create*/false);
              return table !== undefined ? delete table[this._key] : false;
            };
            WeakMap.prototype.clear = function () {
              // NOTE: not a real clear, just makes the previous data unreachable
              this._key = CreateUniqueKey();
            };
            return WeakMap;
          }()
        );
        function CreateUniqueKey() {
          var key;
          do key = "@@WeakMap@@" + CreateUUID(); while (HashMap.has(keys, key));
          keys[key] = true;
          return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create) return undefined;
            Object.defineProperty(target, rootKey, {
              value: HashMap.create()
            });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
          for (var i = 0; i < size; ++i) buffer[i] = Math.random() * 0xff | 0;
          return buffer;
        }
        function GenRandomBytes(size) {
          if (typeof Uint8Array === "function") {
            if (typeof crypto !== "undefined") return crypto.getRandomValues(new Uint8Array(size));
            if (typeof msCrypto !== "undefined") return msCrypto.getRandomValues(new Uint8Array(size));
            return FillRandomBytes(new Uint8Array(size), size);
          }
          return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          // mark as random - RFC 4122  4.4
          data[6] = data[6] & 0x4f | 0x40;
          data[8] = data[8] & 0xbf | 0x80;
          var result = "";
          for (var offset = 0; offset < UUID_SIZE; ++offset) {
            var _byte = data[offset];
            if (offset === 4 || offset === 6 || offset === 8) result += "-";
            if (_byte < 16) result += "0";
            result += _byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
      function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect$1 || (Reflect$1 = {}));

  var NAMED_TAG = "named";
  var NAME_TAG = "name";
  var UNMANAGED_TAG = "unmanaged";
  var OPTIONAL_TAG = "optional";
  var INJECT_TAG = "inject";
  var MULTI_INJECT_TAG = "multi_inject";
  var TAGGED = "inversify:tagged";
  var TAGGED_PROP = "inversify:tagged_props";
  var PARAM_TYPES = "inversify:paramtypes";
  var DESIGN_PARAM_TYPES = "design:paramtypes";
  var POST_CONSTRUCT = "post_construct";
  var PRE_DESTROY = "pre_destroy";
  function getNonCustomTagKeys() {
    return [INJECT_TAG, MULTI_INJECT_TAG, NAME_TAG, UNMANAGED_TAG, NAMED_TAG, OPTIONAL_TAG];
  }
  var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();

  var BindingScopeEnum = {
    Request: "Request",
    Singleton: "Singleton",
    Transient: "Transient"
  };
  var BindingTypeEnum = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider"
  };
  var TargetTypeEnum = {
    ClassProperty: "ClassProperty",
    ConstructorArgument: "ConstructorArgument",
    Variable: "Variable"
  };

  var idCounter = 0;
  function id() {
    return idCounter++;
  }

  var Binding = function () {
    function Binding(serviceIdentifier, scope) {
      this.id = id();
      this.activated = false;
      this.serviceIdentifier = serviceIdentifier;
      this.scope = scope;
      this.type = BindingTypeEnum.Invalid;
      this.constraint = function (request) {
        return true;
      };
      this.implementationType = null;
      this.cache = null;
      this.factory = null;
      this.provider = null;
      this.onActivation = null;
      this.onDeactivation = null;
      this.dynamicValue = null;
    }
    Binding.prototype.clone = function () {
      var clone = new Binding(this.serviceIdentifier, this.scope);
      clone.activated = clone.scope === BindingScopeEnum.Singleton ? this.activated : false;
      clone.implementationType = this.implementationType;
      clone.dynamicValue = this.dynamicValue;
      clone.scope = this.scope;
      clone.type = this.type;
      clone.factory = this.factory;
      clone.provider = this.provider;
      clone.constraint = this.constraint;
      clone.onActivation = this.onActivation;
      clone.onDeactivation = this.onDeactivation;
      clone.cache = this.cache;
      return clone;
    };
    return Binding;
  }();

  var DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
  var DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
  var NULL_ARGUMENT = "NULL argument";
  var KEY_NOT_FOUND = "Key Not Found";
  var AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
  var CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
  var NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
  var MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
  var MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
  var UNDEFINED_INJECT_ANNOTATION = function UNDEFINED_INJECT_ANNOTATION(name) {
    return "@inject called with undefined this could mean that the class " + name + " has " + "a circular dependency problem. You can use a LazyServiceIdentifer to  " + "overcome this limitation.";
  };
  var CIRCULAR_DEPENDENCY = "Circular dependency found:";
  var INVALID_BINDING_TYPE = "Invalid binding type:";
  var NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
  var INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
  var INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
  var LAZY_IN_SYNC = function LAZY_IN_SYNC(key) {
    return "You are attempting to construct '" + key + "' in a synchronous way\n but it has asynchronous dependencies.";
  };
  var INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is " + "used as service identifier";
  var INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators " + "must be applied to the parameters of a class constructor or a class property.";
  var ARGUMENTS_LENGTH_MISMATCH = function ARGUMENTS_LENGTH_MISMATCH() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    return "The number of constructor arguments in the derived class " + (values[0] + " must be >= than the number of constructor arguments of its base class.");
  };
  var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options " + "must be an object.";
  var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = "Invalid Container option. Default scope must " + "be a string ('singleton' or 'transient').";
  var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must " + "be a boolean";
  var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must " + "be a boolean";
  var MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
  var ASYNC_UNBIND_REQUIRED = "Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)";
  var POST_CONSTRUCT_ERROR = function POST_CONSTRUCT_ERROR(clazz, errorMessage) {
    return "@postConstruct error in class " + clazz + ": " + errorMessage;
  };
  var PRE_DESTROY_ERROR = function PRE_DESTROY_ERROR(clazz, errorMessage) {
    return "@preDestroy error in class " + clazz + ": " + errorMessage;
  };
  var ON_DEACTIVATION_ERROR = function ON_DEACTIVATION_ERROR(clazz, errorMessage) {
    return "onDeactivation() error in class " + clazz + ": " + errorMessage;
  };
  var CIRCULAR_DEPENDENCY_IN_FACTORY = function CIRCULAR_DEPENDENCY_IN_FACTORY(factoryType, serviceIdentifier) {
    return "It looks like there is a circular dependency in one of the '" + factoryType + "' bindings. Please investigate bindings with" + ("service identifier '" + serviceIdentifier + "'.");
  };
  var STACK_OVERFLOW = "Maximum call stack size exceeded";

  var MetadataReader = function () {
    function MetadataReader() {}
    MetadataReader.prototype.getConstructorMetadata = function (constructorFunc) {
      var compilerGeneratedMetadata = Reflect.getMetadata(PARAM_TYPES, constructorFunc);
      var userGeneratedMetadata = Reflect.getMetadata(TAGGED, constructorFunc);
      return {
        compilerGeneratedMetadata: compilerGeneratedMetadata,
        userGeneratedMetadata: userGeneratedMetadata || {}
      };
    };
    MetadataReader.prototype.getPropertiesMetadata = function (constructorFunc) {
      var userGeneratedMetadata = Reflect.getMetadata(TAGGED_PROP, constructorFunc) || [];
      return userGeneratedMetadata;
    };
    return MetadataReader;
  }();

  var BindingCount = {
    MultipleBindingsAvailable: 2,
    NoBindingsAvailable: 0,
    OnlyOneBindingAvailable: 1
  };

  function isStackOverflowExeption(error) {
    return error instanceof RangeError || error.message === STACK_OVERFLOW;
  }
  var tryAndThrowErrorIfStackOverflow = function tryAndThrowErrorIfStackOverflow(fn, errorCallback) {
    try {
      return fn();
    } catch (error) {
      if (isStackOverflowExeption(error)) {
        error = errorCallback();
      }
      throw error;
    }
  };

  function getServiceIdentifierAsString(serviceIdentifier) {
    if (typeof serviceIdentifier === "function") {
      var _serviceIdentifier = serviceIdentifier;
      return _serviceIdentifier.name;
    } else if (_typeof(serviceIdentifier) === "symbol") {
      return serviceIdentifier.toString();
    } else {
      var _serviceIdentifier = serviceIdentifier;
      return _serviceIdentifier;
    }
  }
  function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
    var registeredBindingsList = "";
    var registeredBindings = getBindings(container, serviceIdentifier);
    if (registeredBindings.length !== 0) {
      registeredBindingsList = "\nRegistered bindings:";
      registeredBindings.forEach(function (binding) {
        var name = "Object";
        if (binding.implementationType !== null) {
          name = getFunctionName(binding.implementationType);
        }
        registeredBindingsList = registeredBindingsList + "\n " + name;
        if (binding.constraint.metaData) {
          registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
        }
      });
    }
    return registeredBindingsList;
  }
  function alreadyDependencyChain(request, serviceIdentifier) {
    if (request.parentRequest === null) {
      return false;
    } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
      return true;
    } else {
      return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
    }
  }
  function dependencyChainToString(request) {
    function _createStringArr(req, result) {
      if (result === void 0) {
        result = [];
      }
      var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
      result.push(serviceIdentifier);
      if (req.parentRequest !== null) {
        return _createStringArr(req.parentRequest, result);
      }
      return result;
    }
    var stringArr = _createStringArr(request);
    return stringArr.reverse().join(" --> ");
  }
  function circularDependencyToException(request) {
    request.childRequests.forEach(function (childRequest) {
      if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
        var services = dependencyChainToString(childRequest);
        throw new Error(CIRCULAR_DEPENDENCY + " " + services);
      } else {
        circularDependencyToException(childRequest);
      }
    });
  }
  function listMetadataForTarget(serviceIdentifierString, target) {
    if (target.isTagged() || target.isNamed()) {
      var m_1 = "";
      var namedTag = target.getNamedTag();
      var otherTags = target.getCustomTags();
      if (namedTag !== null) {
        m_1 += namedTag.toString() + "\n";
      }
      if (otherTags !== null) {
        otherTags.forEach(function (tag) {
          m_1 += tag.toString() + "\n";
        });
      }
      return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
    } else {
      return " " + serviceIdentifierString;
    }
  }
  function getFunctionName(func) {
    if (func.name) {
      return func.name;
    } else {
      var name_1 = func.toString();
      var match = name_1.match(/^function\s*([^\s(]+)/);
      return match ? match[1] : "Anonymous function: " + name_1;
    }
  }
  function getSymbolDescription(symbol) {
    return symbol.toString().slice(7, -1);
  }

  var Context = function () {
    function Context(container) {
      this.id = id();
      this.container = container;
    }
    Context.prototype.addPlan = function (plan) {
      this.plan = plan;
    };
    Context.prototype.setCurrentRequest = function (currentRequest) {
      this.currentRequest = currentRequest;
    };
    return Context;
  }();

  var Metadata = function () {
    function Metadata(key, value) {
      this.key = key;
      this.value = value;
    }
    Metadata.prototype.toString = function () {
      if (this.key === NAMED_TAG) {
        return "named: " + String(this.value).toString() + " ";
      } else {
        return "tagged: { key:" + this.key.toString() + ", value: " + String(this.value) + " }";
      }
    };
    return Metadata;
  }();

  var Plan = function () {
    function Plan(parentContext, rootRequest) {
      this.parentContext = parentContext;
      this.rootRequest = rootRequest;
    }
    return Plan;
  }();

  var LazyServiceIdentifer = function () {
    function LazyServiceIdentifer(cb) {
      this._cb = cb;
    }
    LazyServiceIdentifer.prototype.unwrap = function () {
      return this._cb();
    };
    return LazyServiceIdentifer;
  }();

  var QueryableString = function () {
    function QueryableString(str) {
      this.str = str;
    }
    QueryableString.prototype.startsWith = function (searchString) {
      return this.str.indexOf(searchString) === 0;
    };
    QueryableString.prototype.endsWith = function (searchString) {
      var reverseString = "";
      var reverseSearchString = searchString.split("").reverse().join("");
      reverseString = this.str.split("").reverse().join("");
      return this.startsWith.call({
        str: reverseString
      }, reverseSearchString);
    };
    QueryableString.prototype.contains = function (searchString) {
      return this.str.indexOf(searchString) !== -1;
    };
    QueryableString.prototype.equals = function (compareString) {
      return this.str === compareString;
    };
    QueryableString.prototype.value = function () {
      return this.str;
    };
    return QueryableString;
  }();

  var Target = function () {
    function Target(type, identifier, serviceIdentifier, namedOrTagged) {
      this.id = id();
      this.type = type;
      this.serviceIdentifier = serviceIdentifier;
      var queryableName = _typeof(identifier) === 'symbol' ? getSymbolDescription(identifier) : identifier;
      this.name = new QueryableString(queryableName || "");
      this.identifier = identifier;
      this.metadata = new Array();
      var metadataItem = null;
      if (typeof namedOrTagged === 'string') {
        metadataItem = new Metadata(NAMED_TAG, namedOrTagged);
      } else if (namedOrTagged instanceof Metadata) {
        metadataItem = namedOrTagged;
      }
      if (metadataItem !== null) {
        this.metadata.push(metadataItem);
      }
    }
    Target.prototype.hasTag = function (key) {
      for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
        var m = _a[_i];
        if (m.key === key) {
          return true;
        }
      }
      return false;
    };
    Target.prototype.isArray = function () {
      return this.hasTag(MULTI_INJECT_TAG);
    };
    Target.prototype.matchesArray = function (name) {
      return this.matchesTag(MULTI_INJECT_TAG)(name);
    };
    Target.prototype.isNamed = function () {
      return this.hasTag(NAMED_TAG);
    };
    Target.prototype.isTagged = function () {
      return this.metadata.some(function (metadata) {
        return NON_CUSTOM_TAG_KEYS.every(function (key) {
          return metadata.key !== key;
        });
      });
    };
    Target.prototype.isOptional = function () {
      return this.matchesTag(OPTIONAL_TAG)(true);
    };
    Target.prototype.getNamedTag = function () {
      if (this.isNamed()) {
        return this.metadata.filter(function (m) {
          return m.key === NAMED_TAG;
        })[0];
      }
      return null;
    };
    Target.prototype.getCustomTags = function () {
      if (this.isTagged()) {
        return this.metadata.filter(function (metadata) {
          return NON_CUSTOM_TAG_KEYS.every(function (key) {
            return metadata.key !== key;
          });
        });
      } else {
        return null;
      }
    };
    Target.prototype.matchesNamedTag = function (name) {
      return this.matchesTag(NAMED_TAG)(name);
    };
    Target.prototype.matchesTag = function (key) {
      var _this = this;
      return function (value) {
        for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
          var m = _a[_i];
          if (m.key === key && m.value === value) {
            return true;
          }
        }
        return false;
      };
    };
    return Target;
  }();

  var __spreadArray$2 = undefined && undefined.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  function getDependencies(metadataReader, func) {
    var constructorName = getFunctionName(func);
    return getTargets(metadataReader, constructorName, func, false);
  }
  function getTargets(metadataReader, constructorName, func, isBaseClass) {
    var metadata = metadataReader.getConstructorMetadata(func);
    var serviceIdentifiers = metadata.compilerGeneratedMetadata;
    if (serviceIdentifiers === undefined) {
      var msg = MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
      throw new Error(msg);
    }
    var constructorArgsMetadata = metadata.userGeneratedMetadata;
    var keys = Object.keys(constructorArgsMetadata);
    var hasUserDeclaredUnknownInjections = func.length === 0 && keys.length > 0;
    var hasOptionalParameters = keys.length > func.length;
    var iterations = hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys.length : func.length;
    var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
    var propertyTargets = getClassPropsAsTargets(metadataReader, func, constructorName);
    var targets = __spreadArray$2(__spreadArray$2([], constructorTargets, true), propertyTargets, true);
    return targets;
  }
  function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
    var targetMetadata = constructorArgsMetadata[index.toString()] || [];
    var metadata = formatTargetMetadata(targetMetadata);
    var isManaged = metadata.unmanaged !== true;
    var serviceIdentifier = serviceIdentifiers[index];
    var injectIdentifier = metadata.inject || metadata.multiInject;
    serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;
    if (serviceIdentifier instanceof LazyServiceIdentifer) {
      serviceIdentifier = serviceIdentifier.unwrap();
    }
    if (isManaged) {
      var isObject = serviceIdentifier === Object;
      var isFunction = serviceIdentifier === Function;
      var isUndefined = serviceIdentifier === undefined;
      var isUnknownType = isObject || isFunction || isUndefined;
      if (!isBaseClass && isUnknownType) {
        var msg = MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
        throw new Error(msg);
      }
      var target = new Target(TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
      target.metadata = targetMetadata;
      return target;
    }
    return null;
  }
  function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
    var targets = [];
    for (var i = 0; i < iterations; i++) {
      var index = i;
      var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
      if (target !== null) {
        targets.push(target);
      }
    }
    return targets;
  }
  function _getServiceIdentifierForProperty(inject, multiInject, propertyName, className) {
    var serviceIdentifier = inject || multiInject;
    if (serviceIdentifier === undefined) {
      var msg = MISSING_INJECTABLE_ANNOTATION + " for property " + String(propertyName) + " in class " + className + ".";
      throw new Error(msg);
    }
    return serviceIdentifier;
  }
  function getClassPropsAsTargets(metadataReader, constructorFunc, constructorName) {
    var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
    var targets = [];
    var symbolKeys = Object.getOwnPropertySymbols(classPropsMetadata);
    var stringKeys = Object.keys(classPropsMetadata);
    var keys = stringKeys.concat(symbolKeys);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
      var key = keys_1[_i];
      var targetMetadata = classPropsMetadata[key];
      var metadata = formatTargetMetadata(targetMetadata);
      var identifier = metadata.targetName || key;
      var serviceIdentifier = _getServiceIdentifierForProperty(metadata.inject, metadata.multiInject, key, constructorName);
      var target = new Target(TargetTypeEnum.ClassProperty, identifier, serviceIdentifier);
      target.metadata = targetMetadata;
      targets.push(target);
    }
    var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
    if (baseConstructor !== Object) {
      var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor, constructorName);
      targets = __spreadArray$2(__spreadArray$2([], targets, true), baseTargets, true);
    }
    return targets;
  }
  function getBaseClassDependencyCount(metadataReader, func) {
    var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
    if (baseConstructor !== Object) {
      var baseConstructorName = getFunctionName(baseConstructor);
      var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
      var metadata = targets.map(function (t) {
        return t.metadata.filter(function (m) {
          return m.key === UNMANAGED_TAG;
        });
      });
      var unmanagedCount = [].concat.apply([], metadata).length;
      var dependencyCount = targets.length - unmanagedCount;
      if (dependencyCount > 0) {
        return dependencyCount;
      } else {
        return getBaseClassDependencyCount(metadataReader, baseConstructor);
      }
    } else {
      return 0;
    }
  }
  function formatTargetMetadata(targetMetadata) {
    var targetMetadataMap = {};
    targetMetadata.forEach(function (m) {
      targetMetadataMap[m.key.toString()] = m.value;
    });
    return {
      inject: targetMetadataMap[INJECT_TAG],
      multiInject: targetMetadataMap[MULTI_INJECT_TAG],
      targetName: targetMetadataMap[NAME_TAG],
      unmanaged: targetMetadataMap[UNMANAGED_TAG]
    };
  }

  var Request = function () {
    function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {
      this.id = id();
      this.serviceIdentifier = serviceIdentifier;
      this.parentContext = parentContext;
      this.parentRequest = parentRequest;
      this.target = target;
      this.childRequests = [];
      this.bindings = Array.isArray(bindings) ? bindings : [bindings];
      this.requestScope = parentRequest === null ? new Map() : null;
    }
    Request.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {
      var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);
      this.childRequests.push(child);
      return child;
    };
    return Request;
  }();

  function getBindingDictionary(cntnr) {
    return cntnr._bindingDictionary;
  }
  function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
    var metadataKey = isMultiInject ? MULTI_INJECT_TAG : INJECT_TAG;
    var injectMetadata = new Metadata(metadataKey, serviceIdentifier);
    var target = new Target(targetType, name, serviceIdentifier, injectMetadata);
    if (key !== undefined) {
      var tagMetadata = new Metadata(key, value);
      target.metadata.push(tagMetadata);
    }
    return target;
  }
  function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
    var bindings = getBindings(context.container, target.serviceIdentifier);
    var activeBindings = [];
    if (bindings.length === BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
      context.container.bind(target.serviceIdentifier).toSelf();
      bindings = getBindings(context.container, target.serviceIdentifier);
    }
    if (!avoidConstraints) {
      activeBindings = bindings.filter(function (binding) {
        var request = new Request(binding.serviceIdentifier, context, parentRequest, binding, target);
        return binding.constraint(request);
      });
    } else {
      activeBindings = bindings;
    }
    _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
    return activeBindings;
  }
  function _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {
    switch (bindings.length) {
      case BindingCount.NoBindingsAvailable:
        if (target.isOptional()) {
          return bindings;
        } else {
          var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
          var msg = NOT_REGISTERED;
          msg += listMetadataForTarget(serviceIdentifierString, target);
          msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
          throw new Error(msg);
        }
      case BindingCount.OnlyOneBindingAvailable:
        return bindings;
      case BindingCount.MultipleBindingsAvailable:
      default:
        if (!target.isArray()) {
          var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
          var msg = AMBIGUOUS_MATCH + " " + serviceIdentifierString;
          msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
          throw new Error(msg);
        } else {
          return bindings;
        }
    }
  }
  function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
    var activeBindings;
    var childRequest;
    if (parentRequest === null) {
      activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
      childRequest = new Request(serviceIdentifier, context, null, activeBindings, target);
      var thePlan = new Plan(context, childRequest);
      context.addPlan(thePlan);
    } else {
      activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
      childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
    }
    activeBindings.forEach(function (binding) {
      var subChildRequest = null;
      if (target.isArray()) {
        subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
      } else {
        if (binding.cache) {
          return;
        }
        subChildRequest = childRequest;
      }
      if (binding.type === BindingTypeEnum.Instance && binding.implementationType !== null) {
        var dependencies = getDependencies(metadataReader, binding.implementationType);
        if (!context.container.options.skipBaseClassChecks) {
          var baseClassDependencyCount = getBaseClassDependencyCount(metadataReader, binding.implementationType);
          if (dependencies.length < baseClassDependencyCount) {
            var error = ARGUMENTS_LENGTH_MISMATCH(getFunctionName(binding.implementationType));
            throw new Error(error);
          }
        }
        dependencies.forEach(function (dependency) {
          _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
        });
      }
    });
  }
  function getBindings(container, serviceIdentifier) {
    var bindings = [];
    var bindingDictionary = getBindingDictionary(container);
    if (bindingDictionary.hasKey(serviceIdentifier)) {
      bindings = bindingDictionary.get(serviceIdentifier);
    } else if (container.parent !== null) {
      bindings = getBindings(container.parent, serviceIdentifier);
    }
    return bindings;
  }
  function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
    if (avoidConstraints === void 0) {
      avoidConstraints = false;
    }
    var context = new Context(container);
    var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);
    try {
      _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
      return context;
    } catch (error) {
      if (isStackOverflowExeption(error)) {
        circularDependencyToException(context.plan.rootRequest);
      }
      throw error;
    }
  }
  function createMockRequest(container, serviceIdentifier, key, value) {
    var target = new Target(TargetTypeEnum.Variable, "", serviceIdentifier, new Metadata(key, value));
    var context = new Context(container);
    var request = new Request(serviceIdentifier, context, null, [], target);
    return request;
  }

  function isPromise(object) {
    var isObjectOrFunction = _typeof(object) === 'object' && object !== null || typeof object === 'function';
    return isObjectOrFunction && typeof object.then === "function";
  }
  function isPromiseOrContainsPromise(object) {
    if (isPromise(object)) {
      return true;
    }
    return Array.isArray(object) && object.some(isPromise);
  }

  var __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator$3 = undefined && undefined.__generator || function (thisArg, body) {
    var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };
  var tryGetFromScope = function tryGetFromScope(requestScope, binding) {
    if (binding.scope === BindingScopeEnum.Singleton && binding.activated) {
      return binding.cache;
    }
    if (binding.scope === BindingScopeEnum.Request && requestScope.has(binding.id)) {
      return requestScope.get(binding.id);
    }
    return null;
  };
  var saveToScope = function saveToScope(requestScope, binding, result) {
    if (binding.scope === BindingScopeEnum.Singleton) {
      _saveToSingletonScope(binding, result);
    }
    if (binding.scope === BindingScopeEnum.Request) {
      _saveToRequestScope(requestScope, binding, result);
    }
  };
  var _saveToRequestScope = function _saveToRequestScope(requestScope, binding, result) {
    if (!requestScope.has(binding.id)) {
      requestScope.set(binding.id, result);
    }
  };
  var _saveToSingletonScope = function _saveToSingletonScope(binding, result) {
    binding.cache = result;
    binding.activated = true;
    if (isPromise(result)) {
      void _saveAsyncResultToSingletonScope(binding, result);
    }
  };
  var _saveAsyncResultToSingletonScope = function _saveAsyncResultToSingletonScope(binding, asyncResult) {
    return __awaiter$3(void 0, void 0, void 0, function () {
      var result, ex_1;
      return __generator$3(this, function (_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 2,, 3]);
            return [4, asyncResult];
          case 1:
            result = _a.sent();
            binding.cache = result;
            return [3, 3];
          case 2:
            ex_1 = _a.sent();
            binding.cache = null;
            binding.activated = false;
            throw ex_1;
          case 3:
            return [2];
        }
      });
    });
  };

  var FactoryType;
  (function (FactoryType) {
    FactoryType["DynamicValue"] = "toDynamicValue";
    FactoryType["Factory"] = "toFactory";
    FactoryType["Provider"] = "toProvider";
  })(FactoryType || (FactoryType = {}));

  var ensureFullyBound = function ensureFullyBound(binding) {
    var boundValue = null;
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        boundValue = binding.cache;
        break;
      case BindingTypeEnum.Constructor:
      case BindingTypeEnum.Instance:
        boundValue = binding.implementationType;
        break;
      case BindingTypeEnum.DynamicValue:
        boundValue = binding.dynamicValue;
        break;
      case BindingTypeEnum.Provider:
        boundValue = binding.provider;
        break;
      case BindingTypeEnum.Factory:
        boundValue = binding.factory;
        break;
    }
    if (boundValue === null) {
      var serviceIdentifierAsString = getServiceIdentifierAsString(binding.serviceIdentifier);
      throw new Error(INVALID_BINDING_TYPE + " " + serviceIdentifierAsString);
    }
  };
  var getFactoryDetails = function getFactoryDetails(binding) {
    switch (binding.type) {
      case BindingTypeEnum.Factory:
        return {
          factory: binding.factory,
          factoryType: FactoryType.Factory
        };
      case BindingTypeEnum.Provider:
        return {
          factory: binding.provider,
          factoryType: FactoryType.Provider
        };
      case BindingTypeEnum.DynamicValue:
        return {
          factory: binding.dynamicValue,
          factoryType: FactoryType.DynamicValue
        };
      default:
        throw new Error("Unexpected factory type " + binding.type);
    }
  };

  var __assign$1 = undefined && undefined.__assign || function () {
    __assign$1 = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign$1.apply(this, arguments);
  };
  var __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator$2 = undefined && undefined.__generator || function (thisArg, body) {
    var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };
  var __spreadArray$1 = undefined && undefined.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  function _resolveRequests(childRequests, resolveRequest) {
    return childRequests.reduce(function (resolvedRequests, childRequest) {
      var injection = resolveRequest(childRequest);
      var targetType = childRequest.target.type;
      if (targetType === TargetTypeEnum.ConstructorArgument) {
        resolvedRequests.constructorInjections.push(injection);
      } else {
        resolvedRequests.propertyRequests.push(childRequest);
        resolvedRequests.propertyInjections.push(injection);
      }
      if (!resolvedRequests.isAsync) {
        resolvedRequests.isAsync = isPromiseOrContainsPromise(injection);
      }
      return resolvedRequests;
    }, {
      constructorInjections: [],
      propertyInjections: [],
      propertyRequests: [],
      isAsync: false
    });
  }
  function _createInstance(constr, childRequests, resolveRequest) {
    var result;
    if (childRequests.length > 0) {
      var resolved = _resolveRequests(childRequests, resolveRequest);
      var createInstanceWithInjectionsArg = __assign$1(__assign$1({}, resolved), {
        constr: constr
      });
      if (resolved.isAsync) {
        result = createInstanceWithInjectionsAsync(createInstanceWithInjectionsArg);
      } else {
        result = createInstanceWithInjections(createInstanceWithInjectionsArg);
      }
    } else {
      result = new constr();
    }
    return result;
  }
  function createInstanceWithInjections(args) {
    var _a;
    var instance = new ((_a = args.constr).bind.apply(_a, __spreadArray$1([void 0], args.constructorInjections, false)))();
    args.propertyRequests.forEach(function (r, index) {
      var property = r.target.identifier;
      var injection = args.propertyInjections[index];
      instance[property] = injection;
    });
    return instance;
  }
  function createInstanceWithInjectionsAsync(args) {
    return __awaiter$2(this, void 0, void 0, function () {
      var constructorInjections, propertyInjections;
      return __generator$2(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4, possiblyWaitInjections(args.constructorInjections)];
          case 1:
            constructorInjections = _a.sent();
            return [4, possiblyWaitInjections(args.propertyInjections)];
          case 2:
            propertyInjections = _a.sent();
            return [2, createInstanceWithInjections(__assign$1(__assign$1({}, args), {
              constructorInjections: constructorInjections,
              propertyInjections: propertyInjections
            }))];
        }
      });
    });
  }
  function possiblyWaitInjections(possiblePromiseinjections) {
    return __awaiter$2(this, void 0, void 0, function () {
      var injections, _i, possiblePromiseinjections_1, injection;
      return __generator$2(this, function (_a) {
        injections = [];
        for (_i = 0, possiblePromiseinjections_1 = possiblePromiseinjections; _i < possiblePromiseinjections_1.length; _i++) {
          injection = possiblePromiseinjections_1[_i];
          if (Array.isArray(injection)) {
            injections.push(Promise.all(injection));
          } else {
            injections.push(injection);
          }
        }
        return [2, Promise.all(injections)];
      });
    });
  }
  function _getInstanceAfterPostConstruct(constr, result) {
    var postConstructResult = _postConstruct(constr, result);
    if (isPromise(postConstructResult)) {
      return postConstructResult.then(function () {
        return result;
      });
    } else {
      return result;
    }
  }
  function _postConstruct(constr, instance) {
    var _a, _b;
    if (Reflect.hasMetadata(POST_CONSTRUCT, constr)) {
      var data = Reflect.getMetadata(POST_CONSTRUCT, constr);
      try {
        return (_b = (_a = instance)[data.value]) === null || _b === void 0 ? void 0 : _b.call(_a);
      } catch (e) {
        throw new Error(POST_CONSTRUCT_ERROR(constr.name, e.message));
      }
    }
  }
  function _validateInstanceResolution(binding, constr) {
    if (binding.scope !== BindingScopeEnum.Singleton) {
      _throwIfHandlingDeactivation(binding, constr);
    }
  }
  function _throwIfHandlingDeactivation(binding, constr) {
    var scopeErrorMessage = "Class cannot be instantiated in " + (binding.scope === BindingScopeEnum.Request ? "request" : "transient") + " scope.";
    if (typeof binding.onDeactivation === "function") {
      throw new Error(ON_DEACTIVATION_ERROR(constr.name, scopeErrorMessage));
    }
    if (Reflect.hasMetadata(PRE_DESTROY, constr)) {
      throw new Error(PRE_DESTROY_ERROR(constr.name, scopeErrorMessage));
    }
  }
  function resolveInstance(binding, constr, childRequests, resolveRequest) {
    _validateInstanceResolution(binding, constr);
    var result = _createInstance(constr, childRequests, resolveRequest);
    if (isPromise(result)) {
      return result.then(function (resolvedResult) {
        return _getInstanceAfterPostConstruct(constr, resolvedResult);
      });
    } else {
      return _getInstanceAfterPostConstruct(constr, result);
    }
  }

  var __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator$1 = undefined && undefined.__generator || function (thisArg, body) {
    var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };
  var _resolveRequest = function _resolveRequest(requestScope) {
    return function (request) {
      request.parentContext.setCurrentRequest(request);
      var bindings = request.bindings;
      var childRequests = request.childRequests;
      var targetIsAnArray = request.target && request.target.isArray();
      var targetParentIsNotAnArray = !request.parentRequest || !request.parentRequest.target || !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
      if (targetIsAnArray && targetParentIsNotAnArray) {
        return childRequests.map(function (childRequest) {
          var _f = _resolveRequest(requestScope);
          return _f(childRequest);
        });
      } else {
        if (request.target.isOptional() && bindings.length === 0) {
          return undefined;
        }
        var binding = bindings[0];
        return _resolveBinding(requestScope, request, binding);
      }
    };
  };
  var _resolveFactoryFromBinding = function _resolveFactoryFromBinding(binding, context) {
    var factoryDetails = getFactoryDetails(binding);
    return tryAndThrowErrorIfStackOverflow(function () {
      return factoryDetails.factory.bind(binding)(context);
    }, function () {
      return new Error(CIRCULAR_DEPENDENCY_IN_FACTORY(factoryDetails.factoryType, context.currentRequest.serviceIdentifier.toString()));
    });
  };
  var _getResolvedFromBinding = function _getResolvedFromBinding(requestScope, request, binding) {
    var result;
    var childRequests = request.childRequests;
    ensureFullyBound(binding);
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        result = binding.cache;
        break;
      case BindingTypeEnum.Constructor:
        result = binding.implementationType;
        break;
      case BindingTypeEnum.Instance:
        result = resolveInstance(binding, binding.implementationType, childRequests, _resolveRequest(requestScope));
        break;
      default:
        result = _resolveFactoryFromBinding(binding, request.parentContext);
    }
    return result;
  };
  var _resolveInScope = function _resolveInScope(requestScope, binding, resolveFromBinding) {
    var result = tryGetFromScope(requestScope, binding);
    if (result !== null) {
      return result;
    }
    result = resolveFromBinding();
    saveToScope(requestScope, binding, result);
    return result;
  };
  var _resolveBinding = function _resolveBinding(requestScope, request, binding) {
    return _resolveInScope(requestScope, binding, function () {
      var result = _getResolvedFromBinding(requestScope, request, binding);
      if (isPromise(result)) {
        result = result.then(function (resolved) {
          return _onActivation(request, binding, resolved);
        });
      } else {
        result = _onActivation(request, binding, result);
      }
      return result;
    });
  };
  function _onActivation(request, binding, resolved) {
    var result = _bindingActivation(request.parentContext, binding, resolved);
    var containersIterator = _getContainersIterator(request.parentContext.container);
    var container;
    var containersIteratorResult = containersIterator.next();
    do {
      container = containersIteratorResult.value;
      var context_1 = request.parentContext;
      var serviceIdentifier = request.serviceIdentifier;
      var activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);
      if (isPromise(result)) {
        result = _activateContainerAsync(activationsIterator, context_1, result);
      } else {
        result = _activateContainer(activationsIterator, context_1, result);
      }
      containersIteratorResult = containersIterator.next();
    } while (containersIteratorResult.done !== true && !getBindingDictionary(container).hasKey(request.serviceIdentifier));
    return result;
  }
  var _bindingActivation = function _bindingActivation(context, binding, previousResult) {
    var result;
    if (typeof binding.onActivation === "function") {
      result = binding.onActivation(context, previousResult);
    } else {
      result = previousResult;
    }
    return result;
  };
  var _activateContainer = function _activateContainer(activationsIterator, context, result) {
    var activation = activationsIterator.next();
    while (!activation.done) {
      result = activation.value(context, result);
      if (isPromise(result)) {
        return _activateContainerAsync(activationsIterator, context, result);
      }
      activation = activationsIterator.next();
    }
    return result;
  };
  var _activateContainerAsync = function _activateContainerAsync(activationsIterator, context, resultPromise) {
    return __awaiter$1(void 0, void 0, void 0, function () {
      var result, activation;
      return __generator$1(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4, resultPromise];
          case 1:
            result = _a.sent();
            activation = activationsIterator.next();
            _a.label = 2;
          case 2:
            if (!!activation.done) return [3, 4];
            return [4, activation.value(context, result)];
          case 3:
            result = _a.sent();
            activation = activationsIterator.next();
            return [3, 2];
          case 4:
            return [2, result];
        }
      });
    });
  };
  var _getContainerActivationsForService = function _getContainerActivationsForService(container, serviceIdentifier) {
    var activations = container._activations;
    return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();
  };
  var _getContainersIterator = function _getContainersIterator(container) {
    var containersStack = [container];
    var parent = container.parent;
    while (parent !== null) {
      containersStack.push(parent);
      parent = parent.parent;
    }
    var getNextContainer = function getNextContainer() {
      var nextContainer = containersStack.pop();
      if (nextContainer !== undefined) {
        return {
          done: false,
          value: nextContainer
        };
      } else {
        return {
          done: true,
          value: undefined
        };
      }
    };
    var containersIterator = {
      next: getNextContainer
    };
    return containersIterator;
  };
  function resolve(context) {
    var _f = _resolveRequest(context.plan.rootRequest.requestScope);
    return _f(context.plan.rootRequest);
  }

  var traverseAncerstors = function traverseAncerstors(request, constraint) {
    var parent = request.parentRequest;
    if (parent !== null) {
      return constraint(parent) ? true : traverseAncerstors(parent, constraint);
    } else {
      return false;
    }
  };
  var taggedConstraint = function taggedConstraint(key) {
    return function (value) {
      var constraint = function constraint(request) {
        return request !== null && request.target !== null && request.target.matchesTag(key)(value);
      };
      constraint.metaData = new Metadata(key, value);
      return constraint;
    };
  };
  var namedConstraint = taggedConstraint(NAMED_TAG);
  var typeConstraint = function typeConstraint(type) {
    return function (request) {
      var binding = null;
      if (request !== null) {
        binding = request.bindings[0];
        if (typeof type === "string") {
          var serviceIdentifier = binding.serviceIdentifier;
          return serviceIdentifier === type;
        } else {
          var constructor = request.bindings[0].implementationType;
          return type === constructor;
        }
      }
      return false;
    };
  };

  var BindingWhenSyntax = function () {
    function BindingWhenSyntax(binding) {
      this._binding = binding;
    }
    BindingWhenSyntax.prototype.when = function (constraint) {
      this._binding.constraint = constraint;
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenTargetNamed = function (name) {
      this._binding.constraint = namedConstraint(name);
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenTargetIsDefault = function () {
      this._binding.constraint = function (request) {
        if (request === null) {
          return false;
        }
        var targetIsDefault = request.target !== null && !request.target.isNamed() && !request.target.isTagged();
        return targetIsDefault;
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenTargetTagged = function (tag, value) {
      this._binding.constraint = taggedConstraint(tag)(value);
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenInjectedInto = function (parent) {
      this._binding.constraint = function (request) {
        return request !== null && typeConstraint(parent)(request.parentRequest);
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenParentNamed = function (name) {
      this._binding.constraint = function (request) {
        return request !== null && namedConstraint(name)(request.parentRequest);
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenParentTagged = function (tag, value) {
      this._binding.constraint = function (request) {
        return request !== null && taggedConstraint(tag)(value)(request.parentRequest);
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
      this._binding.constraint = function (request) {
        return request !== null && traverseAncerstors(request, typeConstraint(ancestor));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorIs = function (ancestor) {
      this._binding.constraint = function (request) {
        return request !== null && !traverseAncerstors(request, typeConstraint(ancestor));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorNamed = function (name) {
      this._binding.constraint = function (request) {
        return request !== null && traverseAncerstors(request, namedConstraint(name));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorNamed = function (name) {
      this._binding.constraint = function (request) {
        return request !== null && !traverseAncerstors(request, namedConstraint(name));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
      this._binding.constraint = function (request) {
        return request !== null && traverseAncerstors(request, taggedConstraint(tag)(value));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
      this._binding.constraint = function (request) {
        return request !== null && !traverseAncerstors(request, taggedConstraint(tag)(value));
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
      this._binding.constraint = function (request) {
        return request !== null && traverseAncerstors(request, constraint);
      };
      return new BindingOnSyntax(this._binding);
    };
    BindingWhenSyntax.prototype.whenNoAncestorMatches = function (constraint) {
      this._binding.constraint = function (request) {
        return request !== null && !traverseAncerstors(request, constraint);
      };
      return new BindingOnSyntax(this._binding);
    };
    return BindingWhenSyntax;
  }();

  var BindingOnSyntax = function () {
    function BindingOnSyntax(binding) {
      this._binding = binding;
    }
    BindingOnSyntax.prototype.onActivation = function (handler) {
      this._binding.onActivation = handler;
      return new BindingWhenSyntax(this._binding);
    };
    BindingOnSyntax.prototype.onDeactivation = function (handler) {
      this._binding.onDeactivation = handler;
      return new BindingWhenSyntax(this._binding);
    };
    return BindingOnSyntax;
  }();

  var BindingWhenOnSyntax = function () {
    function BindingWhenOnSyntax(binding) {
      this._binding = binding;
      this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
      this._bindingOnSyntax = new BindingOnSyntax(this._binding);
    }
    BindingWhenOnSyntax.prototype.when = function (constraint) {
      return this._bindingWhenSyntax.when(constraint);
    };
    BindingWhenOnSyntax.prototype.whenTargetNamed = function (name) {
      return this._bindingWhenSyntax.whenTargetNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenTargetIsDefault = function () {
      return this._bindingWhenSyntax.whenTargetIsDefault();
    };
    BindingWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
      return this._bindingWhenSyntax.whenInjectedInto(parent);
    };
    BindingWhenOnSyntax.prototype.whenParentNamed = function (name) {
      return this._bindingWhenSyntax.whenParentNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
      return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
      return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
      return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
      return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };
    BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
      return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };
    BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
      return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };
    BindingWhenOnSyntax.prototype.onActivation = function (handler) {
      return this._bindingOnSyntax.onActivation(handler);
    };
    BindingWhenOnSyntax.prototype.onDeactivation = function (handler) {
      return this._bindingOnSyntax.onDeactivation(handler);
    };
    return BindingWhenOnSyntax;
  }();

  var BindingInSyntax = function () {
    function BindingInSyntax(binding) {
      this._binding = binding;
    }
    BindingInSyntax.prototype.inRequestScope = function () {
      this._binding.scope = BindingScopeEnum.Request;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingInSyntax.prototype.inSingletonScope = function () {
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingInSyntax.prototype.inTransientScope = function () {
      this._binding.scope = BindingScopeEnum.Transient;
      return new BindingWhenOnSyntax(this._binding);
    };
    return BindingInSyntax;
  }();

  var BindingInWhenOnSyntax = function () {
    function BindingInWhenOnSyntax(binding) {
      this._binding = binding;
      this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
      this._bindingOnSyntax = new BindingOnSyntax(this._binding);
      this._bindingInSyntax = new BindingInSyntax(binding);
    }
    BindingInWhenOnSyntax.prototype.inRequestScope = function () {
      return this._bindingInSyntax.inRequestScope();
    };
    BindingInWhenOnSyntax.prototype.inSingletonScope = function () {
      return this._bindingInSyntax.inSingletonScope();
    };
    BindingInWhenOnSyntax.prototype.inTransientScope = function () {
      return this._bindingInSyntax.inTransientScope();
    };
    BindingInWhenOnSyntax.prototype.when = function (constraint) {
      return this._bindingWhenSyntax.when(constraint);
    };
    BindingInWhenOnSyntax.prototype.whenTargetNamed = function (name) {
      return this._bindingWhenSyntax.whenTargetNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenTargetIsDefault = function () {
      return this._bindingWhenSyntax.whenTargetIsDefault();
    };
    BindingInWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenTargetTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
      return this._bindingWhenSyntax.whenInjectedInto(parent);
    };
    BindingInWhenOnSyntax.prototype.whenParentNamed = function (name) {
      return this._bindingWhenSyntax.whenParentNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenParentTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
      return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
      return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
      return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
      return this._bindingWhenSyntax.whenNoAncestorNamed(name);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
      return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
    };
    BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
      return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
    };
    BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
      return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
    };
    BindingInWhenOnSyntax.prototype.onActivation = function (handler) {
      return this._bindingOnSyntax.onActivation(handler);
    };
    BindingInWhenOnSyntax.prototype.onDeactivation = function (handler) {
      return this._bindingOnSyntax.onDeactivation(handler);
    };
    return BindingInWhenOnSyntax;
  }();

  var BindingToSyntax = function () {
    function BindingToSyntax(binding) {
      this._binding = binding;
    }
    BindingToSyntax.prototype.to = function (constructor) {
      this._binding.type = BindingTypeEnum.Instance;
      this._binding.implementationType = constructor;
      return new BindingInWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toSelf = function () {
      if (typeof this._binding.serviceIdentifier !== "function") {
        throw new Error("" + INVALID_TO_SELF_VALUE);
      }
      var self = this._binding.serviceIdentifier;
      return this.to(self);
    };
    BindingToSyntax.prototype.toConstantValue = function (value) {
      this._binding.type = BindingTypeEnum.ConstantValue;
      this._binding.cache = value;
      this._binding.dynamicValue = null;
      this._binding.implementationType = null;
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toDynamicValue = function (func) {
      this._binding.type = BindingTypeEnum.DynamicValue;
      this._binding.cache = null;
      this._binding.dynamicValue = func;
      this._binding.implementationType = null;
      return new BindingInWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toConstructor = function (constructor) {
      this._binding.type = BindingTypeEnum.Constructor;
      this._binding.implementationType = constructor;
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toFactory = function (factory) {
      this._binding.type = BindingTypeEnum.Factory;
      this._binding.factory = factory;
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toFunction = function (func) {
      if (typeof func !== "function") {
        throw new Error(INVALID_FUNCTION_BINDING);
      }
      var bindingWhenOnSyntax = this.toConstantValue(func);
      this._binding.type = BindingTypeEnum.Function;
      this._binding.scope = BindingScopeEnum.Singleton;
      return bindingWhenOnSyntax;
    };
    BindingToSyntax.prototype.toAutoFactory = function (serviceIdentifier) {
      this._binding.type = BindingTypeEnum.Factory;
      this._binding.factory = function (context) {
        var autofactory = function autofactory() {
          return context.container.get(serviceIdentifier);
        };
        return autofactory;
      };
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toAutoNamedFactory = function (serviceIdentifier) {
      this._binding.type = BindingTypeEnum.Factory;
      this._binding.factory = function (context) {
        return function (named) {
          return context.container.getNamed(serviceIdentifier, named);
        };
      };
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toProvider = function (provider) {
      this._binding.type = BindingTypeEnum.Provider;
      this._binding.provider = provider;
      this._binding.scope = BindingScopeEnum.Singleton;
      return new BindingWhenOnSyntax(this._binding);
    };
    BindingToSyntax.prototype.toService = function (service) {
      this.toDynamicValue(function (context) {
        return context.container.get(service);
      });
    };
    return BindingToSyntax;
  }();

  var ContainerSnapshot = function () {
    function ContainerSnapshot() {}
    ContainerSnapshot.of = function (bindings, middleware, activations, deactivations, moduleActivationStore) {
      var snapshot = new ContainerSnapshot();
      snapshot.bindings = bindings;
      snapshot.middleware = middleware;
      snapshot.deactivations = deactivations;
      snapshot.activations = activations;
      snapshot.moduleActivationStore = moduleActivationStore;
      return snapshot;
    };
    return ContainerSnapshot;
  }();

  function isClonable(obj) {
    return _typeof(obj) === 'object' && obj !== null && 'clone' in obj && typeof obj.clone === 'function';
  }

  var Lookup = function () {
    function Lookup() {
      this._map = new Map();
    }
    Lookup.prototype.getMap = function () {
      return this._map;
    };
    Lookup.prototype.add = function (serviceIdentifier, value) {
      if (serviceIdentifier === null || serviceIdentifier === undefined) {
        throw new Error(NULL_ARGUMENT);
      }
      if (value === null || value === undefined) {
        throw new Error(NULL_ARGUMENT);
      }
      var entry = this._map.get(serviceIdentifier);
      if (entry !== undefined) {
        entry.push(value);
      } else {
        this._map.set(serviceIdentifier, [value]);
      }
    };
    Lookup.prototype.get = function (serviceIdentifier) {
      if (serviceIdentifier === null || serviceIdentifier === undefined) {
        throw new Error(NULL_ARGUMENT);
      }
      var entry = this._map.get(serviceIdentifier);
      if (entry !== undefined) {
        return entry;
      } else {
        throw new Error(KEY_NOT_FOUND);
      }
    };
    Lookup.prototype.remove = function (serviceIdentifier) {
      if (serviceIdentifier === null || serviceIdentifier === undefined) {
        throw new Error(NULL_ARGUMENT);
      }
      if (!this._map["delete"](serviceIdentifier)) {
        throw new Error(KEY_NOT_FOUND);
      }
    };
    Lookup.prototype.removeIntersection = function (lookup) {
      var _this = this;
      this.traverse(function (serviceIdentifier, value) {
        var lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : undefined;
        if (lookupActivations !== undefined) {
          var filteredValues = value.filter(function (lookupValue) {
            return !lookupActivations.some(function (moduleActivation) {
              return lookupValue === moduleActivation;
            });
          });
          _this._setValue(serviceIdentifier, filteredValues);
        }
      });
    };
    Lookup.prototype.removeByCondition = function (condition) {
      var _this = this;
      var removals = [];
      this._map.forEach(function (entries, key) {
        var updatedEntries = [];
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
          var entry = entries_1[_i];
          var remove = condition(entry);
          if (remove) {
            removals.push(entry);
          } else {
            updatedEntries.push(entry);
          }
        }
        _this._setValue(key, updatedEntries);
      });
      return removals;
    };
    Lookup.prototype.hasKey = function (serviceIdentifier) {
      if (serviceIdentifier === null || serviceIdentifier === undefined) {
        throw new Error(NULL_ARGUMENT);
      }
      return this._map.has(serviceIdentifier);
    };
    Lookup.prototype.clone = function () {
      var copy = new Lookup();
      this._map.forEach(function (value, key) {
        value.forEach(function (b) {
          return copy.add(key, isClonable(b) ? b.clone() : b);
        });
      });
      return copy;
    };
    Lookup.prototype.traverse = function (func) {
      this._map.forEach(function (value, key) {
        func(key, value);
      });
    };
    Lookup.prototype._setValue = function (serviceIdentifier, value) {
      if (value.length > 0) {
        this._map.set(serviceIdentifier, value);
      } else {
        this._map["delete"](serviceIdentifier);
      }
    };
    return Lookup;
  }();

  var ModuleActivationStore = function () {
    function ModuleActivationStore() {
      this._map = new Map();
    }
    ModuleActivationStore.prototype.remove = function (moduleId) {
      if (this._map.has(moduleId)) {
        var handlers = this._map.get(moduleId);
        this._map["delete"](moduleId);
        return handlers;
      }
      return this._getEmptyHandlersStore();
    };
    ModuleActivationStore.prototype.addDeactivation = function (moduleId, serviceIdentifier, onDeactivation) {
      this._getModuleActivationHandlers(moduleId).onDeactivations.add(serviceIdentifier, onDeactivation);
    };
    ModuleActivationStore.prototype.addActivation = function (moduleId, serviceIdentifier, onActivation) {
      this._getModuleActivationHandlers(moduleId).onActivations.add(serviceIdentifier, onActivation);
    };
    ModuleActivationStore.prototype.clone = function () {
      var clone = new ModuleActivationStore();
      this._map.forEach(function (handlersStore, moduleId) {
        clone._map.set(moduleId, {
          onActivations: handlersStore.onActivations.clone(),
          onDeactivations: handlersStore.onDeactivations.clone()
        });
      });
      return clone;
    };
    ModuleActivationStore.prototype._getModuleActivationHandlers = function (moduleId) {
      var moduleActivationHandlers = this._map.get(moduleId);
      if (moduleActivationHandlers === undefined) {
        moduleActivationHandlers = this._getEmptyHandlersStore();
        this._map.set(moduleId, moduleActivationHandlers);
      }
      return moduleActivationHandlers;
    };
    ModuleActivationStore.prototype._getEmptyHandlersStore = function () {
      var handlersStore = {
        onActivations: new Lookup(),
        onDeactivations: new Lookup()
      };
      return handlersStore;
    };
    return ModuleActivationStore;
  }();

  var __assign = undefined && undefined.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = undefined && undefined.__generator || function (thisArg, body) {
    var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };
  var __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var Container = function () {
    function Container(containerOptions) {
      var options = containerOptions || {};
      if (_typeof(options) !== "object") {
        throw new Error("" + CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
      }
      if (options.defaultScope === undefined) {
        options.defaultScope = BindingScopeEnum.Transient;
      } else if (options.defaultScope !== BindingScopeEnum.Singleton && options.defaultScope !== BindingScopeEnum.Transient && options.defaultScope !== BindingScopeEnum.Request) {
        throw new Error("" + CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
      }
      if (options.autoBindInjectable === undefined) {
        options.autoBindInjectable = false;
      } else if (typeof options.autoBindInjectable !== "boolean") {
        throw new Error("" + CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
      }
      if (options.skipBaseClassChecks === undefined) {
        options.skipBaseClassChecks = false;
      } else if (typeof options.skipBaseClassChecks !== "boolean") {
        throw new Error("" + CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
      }
      this.options = {
        autoBindInjectable: options.autoBindInjectable,
        defaultScope: options.defaultScope,
        skipBaseClassChecks: options.skipBaseClassChecks
      };
      this.id = id();
      this._bindingDictionary = new Lookup();
      this._snapshots = [];
      this._middleware = null;
      this._activations = new Lookup();
      this._deactivations = new Lookup();
      this.parent = null;
      this._metadataReader = new MetadataReader();
      this._moduleActivationStore = new ModuleActivationStore();
    }
    Container.merge = function (container1, container2) {
      var containers = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        containers[_i - 2] = arguments[_i];
      }
      var container = new Container();
      var targetContainers = __spreadArray([container1, container2], containers, true).map(function (targetContainer) {
        return getBindingDictionary(targetContainer);
      });
      var bindingDictionary = getBindingDictionary(container);
      function copyDictionary(origin, destination) {
        origin.traverse(function (_key, value) {
          value.forEach(function (binding) {
            destination.add(binding.serviceIdentifier, binding.clone());
          });
        });
      }
      targetContainers.forEach(function (targetBindingDictionary) {
        copyDictionary(targetBindingDictionary, bindingDictionary);
      });
      return container;
    };
    Container.prototype.load = function () {
      var modules = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        modules[_i] = arguments[_i];
      }
      var getHelpers = this._getContainerModuleHelpersFactory();
      for (var _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
        var currentModule = modules_1[_a];
        var containerModuleHelpers = getHelpers(currentModule.id);
        currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction);
      }
    };
    Container.prototype.loadAsync = function () {
      var modules = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        modules[_i] = arguments[_i];
      }
      return __awaiter(this, void 0, void 0, function () {
        var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
        return __generator(this, function (_b) {
          switch (_b.label) {
            case 0:
              getHelpers = this._getContainerModuleHelpersFactory();
              _a = 0, modules_2 = modules;
              _b.label = 1;
            case 1:
              if (!(_a < modules_2.length)) return [3, 4];
              currentModule = modules_2[_a];
              containerModuleHelpers = getHelpers(currentModule.id);
              return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction, containerModuleHelpers.unbindAsyncFunction, containerModuleHelpers.onActivationFunction, containerModuleHelpers.onDeactivationFunction)];
            case 2:
              _b.sent();
              _b.label = 3;
            case 3:
              _a++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    };
    Container.prototype.unload = function () {
      var _this = this;
      var modules = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        modules[_i] = arguments[_i];
      }
      modules.forEach(function (module) {
        var deactivations = _this._removeModuleBindings(module.id);
        _this._deactivateSingletons(deactivations);
        _this._removeModuleHandlers(module.id);
      });
    };
    Container.prototype.unloadAsync = function () {
      var modules = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        modules[_i] = arguments[_i];
      }
      return __awaiter(this, void 0, void 0, function () {
        var _a, modules_3, module_1, deactivations;
        return __generator(this, function (_b) {
          switch (_b.label) {
            case 0:
              _a = 0, modules_3 = modules;
              _b.label = 1;
            case 1:
              if (!(_a < modules_3.length)) return [3, 4];
              module_1 = modules_3[_a];
              deactivations = this._removeModuleBindings(module_1.id);
              return [4, this._deactivateSingletonsAsync(deactivations)];
            case 2:
              _b.sent();
              this._removeModuleHandlers(module_1.id);
              _b.label = 3;
            case 3:
              _a++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    };
    Container.prototype.bind = function (serviceIdentifier) {
      var scope = this.options.defaultScope || BindingScopeEnum.Transient;
      var binding = new Binding(serviceIdentifier, scope);
      this._bindingDictionary.add(serviceIdentifier, binding);
      return new BindingToSyntax(binding);
    };
    Container.prototype.rebind = function (serviceIdentifier) {
      this.unbind(serviceIdentifier);
      return this.bind(serviceIdentifier);
    };
    Container.prototype.rebindAsync = function (serviceIdentifier) {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4, this.unbindAsync(serviceIdentifier)];
            case 1:
              _a.sent();
              return [2, this.bind(serviceIdentifier)];
          }
        });
      });
    };
    Container.prototype.unbind = function (serviceIdentifier) {
      if (this._bindingDictionary.hasKey(serviceIdentifier)) {
        var bindings = this._bindingDictionary.get(serviceIdentifier);
        this._deactivateSingletons(bindings);
      }
      this._removeServiceFromDictionary(serviceIdentifier);
    };
    Container.prototype.unbindAsync = function (serviceIdentifier) {
      return __awaiter(this, void 0, void 0, function () {
        var bindings;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!this._bindingDictionary.hasKey(serviceIdentifier)) return [3, 2];
              bindings = this._bindingDictionary.get(serviceIdentifier);
              return [4, this._deactivateSingletonsAsync(bindings)];
            case 1:
              _a.sent();
              _a.label = 2;
            case 2:
              this._removeServiceFromDictionary(serviceIdentifier);
              return [2];
          }
        });
      });
    };
    Container.prototype.unbindAll = function () {
      var _this = this;
      this._bindingDictionary.traverse(function (_key, value) {
        _this._deactivateSingletons(value);
      });
      this._bindingDictionary = new Lookup();
    };
    Container.prototype.unbindAllAsync = function () {
      return __awaiter(this, void 0, void 0, function () {
        var promises;
        var _this = this;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              promises = [];
              this._bindingDictionary.traverse(function (_key, value) {
                promises.push(_this._deactivateSingletonsAsync(value));
              });
              return [4, Promise.all(promises)];
            case 1:
              _a.sent();
              this._bindingDictionary = new Lookup();
              return [2];
          }
        });
      });
    };
    Container.prototype.onActivation = function (serviceIdentifier, onActivation) {
      this._activations.add(serviceIdentifier, onActivation);
    };
    Container.prototype.onDeactivation = function (serviceIdentifier, onDeactivation) {
      this._deactivations.add(serviceIdentifier, onDeactivation);
    };
    Container.prototype.isBound = function (serviceIdentifier) {
      var bound = this._bindingDictionary.hasKey(serviceIdentifier);
      if (!bound && this.parent) {
        bound = this.parent.isBound(serviceIdentifier);
      }
      return bound;
    };
    Container.prototype.isCurrentBound = function (serviceIdentifier) {
      return this._bindingDictionary.hasKey(serviceIdentifier);
    };
    Container.prototype.isBoundNamed = function (serviceIdentifier, named) {
      return this.isBoundTagged(serviceIdentifier, NAMED_TAG, named);
    };
    Container.prototype.isBoundTagged = function (serviceIdentifier, key, value) {
      var bound = false;
      if (this._bindingDictionary.hasKey(serviceIdentifier)) {
        var bindings = this._bindingDictionary.get(serviceIdentifier);
        var request_1 = createMockRequest(this, serviceIdentifier, key, value);
        bound = bindings.some(function (b) {
          return b.constraint(request_1);
        });
      }
      if (!bound && this.parent) {
        bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
      }
      return bound;
    };
    Container.prototype.snapshot = function () {
      this._snapshots.push(ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware, this._activations.clone(), this._deactivations.clone(), this._moduleActivationStore.clone()));
    };
    Container.prototype.restore = function () {
      var snapshot = this._snapshots.pop();
      if (snapshot === undefined) {
        throw new Error(NO_MORE_SNAPSHOTS_AVAILABLE);
      }
      this._bindingDictionary = snapshot.bindings;
      this._activations = snapshot.activations;
      this._deactivations = snapshot.deactivations;
      this._middleware = snapshot.middleware;
      this._moduleActivationStore = snapshot.moduleActivationStore;
    };
    Container.prototype.createChild = function (containerOptions) {
      var child = new Container(containerOptions || this.options);
      child.parent = this;
      return child;
    };
    Container.prototype.applyMiddleware = function () {
      var middlewares = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        middlewares[_i] = arguments[_i];
      }
      var initial = this._middleware ? this._middleware : this._planAndResolve();
      this._middleware = middlewares.reduce(function (prev, curr) {
        return curr(prev);
      }, initial);
    };
    Container.prototype.applyCustomMetadataReader = function (metadataReader) {
      this._metadataReader = metadataReader;
    };
    Container.prototype.get = function (serviceIdentifier) {
      var getArgs = this._getNotAllArgs(serviceIdentifier, false);
      return this._getButThrowIfAsync(getArgs);
    };
    Container.prototype.getAsync = function (serviceIdentifier) {
      return __awaiter(this, void 0, void 0, function () {
        var getArgs;
        return __generator(this, function (_a) {
          getArgs = this._getNotAllArgs(serviceIdentifier, false);
          return [2, this._get(getArgs)];
        });
      });
    };
    Container.prototype.getTagged = function (serviceIdentifier, key, value) {
      var getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
      return this._getButThrowIfAsync(getArgs);
    };
    Container.prototype.getTaggedAsync = function (serviceIdentifier, key, value) {
      return __awaiter(this, void 0, void 0, function () {
        var getArgs;
        return __generator(this, function (_a) {
          getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
          return [2, this._get(getArgs)];
        });
      });
    };
    Container.prototype.getNamed = function (serviceIdentifier, named) {
      return this.getTagged(serviceIdentifier, NAMED_TAG, named);
    };
    Container.prototype.getNamedAsync = function (serviceIdentifier, named) {
      return this.getTaggedAsync(serviceIdentifier, NAMED_TAG, named);
    };
    Container.prototype.getAll = function (serviceIdentifier) {
      var getArgs = this._getAllArgs(serviceIdentifier);
      return this._getButThrowIfAsync(getArgs);
    };
    Container.prototype.getAllAsync = function (serviceIdentifier) {
      var getArgs = this._getAllArgs(serviceIdentifier);
      return this._getAll(getArgs);
    };
    Container.prototype.getAllTagged = function (serviceIdentifier, key, value) {
      var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
      return this._getButThrowIfAsync(getArgs);
    };
    Container.prototype.getAllTaggedAsync = function (serviceIdentifier, key, value) {
      var getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);
      return this._getAll(getArgs);
    };
    Container.prototype.getAllNamed = function (serviceIdentifier, named) {
      return this.getAllTagged(serviceIdentifier, NAMED_TAG, named);
    };
    Container.prototype.getAllNamedAsync = function (serviceIdentifier, named) {
      return this.getAllTaggedAsync(serviceIdentifier, NAMED_TAG, named);
    };
    Container.prototype.resolve = function (constructorFunction) {
      var isBound = this.isBound(constructorFunction);
      if (!isBound) {
        this.bind(constructorFunction).toSelf();
      }
      var resolved = this.get(constructorFunction);
      if (!isBound) {
        this.unbind(constructorFunction);
      }
      return resolved;
    };
    Container.prototype._preDestroy = function (constructor, instance) {
      if (Reflect.hasMetadata(PRE_DESTROY, constructor)) {
        var data = Reflect.getMetadata(PRE_DESTROY, constructor);
        return instance[data.value]();
      }
    };
    Container.prototype._removeModuleHandlers = function (moduleId) {
      var moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);
      this._activations.removeIntersection(moduleActivationsHandlers.onActivations);
      this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);
    };
    Container.prototype._removeModuleBindings = function (moduleId) {
      return this._bindingDictionary.removeByCondition(function (binding) {
        return binding.moduleId === moduleId;
      });
    };
    Container.prototype._deactivate = function (binding, instance) {
      var _this = this;
      var constructor = Object.getPrototypeOf(instance).constructor;
      try {
        if (this._deactivations.hasKey(binding.serviceIdentifier)) {
          var result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());
          if (isPromise(result)) {
            return this._handleDeactivationError(result.then(function () {
              return _this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor);
            }), constructor);
          }
        }
        var propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(binding, instance, constructor);
        if (isPromise(propagateDeactivationResult)) {
          return this._handleDeactivationError(propagateDeactivationResult, constructor);
        }
      } catch (ex) {
        throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex.message));
      }
    };
    Container.prototype._handleDeactivationError = function (asyncResult, constructor) {
      return __awaiter(this, void 0, void 0, function () {
        var ex_1;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, 2,, 3]);
              return [4, asyncResult];
            case 1:
              _a.sent();
              return [3, 3];
            case 2:
              ex_1 = _a.sent();
              throw new Error(ON_DEACTIVATION_ERROR(constructor.name, ex_1.message));
            case 3:
              return [2];
          }
        });
      });
    };
    Container.prototype._deactivateContainer = function (instance, deactivationsIterator) {
      var _this = this;
      var deactivation = deactivationsIterator.next();
      while (deactivation.value) {
        var result = deactivation.value(instance);
        if (isPromise(result)) {
          return result.then(function () {
            return _this._deactivateContainerAsync(instance, deactivationsIterator);
          });
        }
        deactivation = deactivationsIterator.next();
      }
    };
    Container.prototype._deactivateContainerAsync = function (instance, deactivationsIterator) {
      return __awaiter(this, void 0, void 0, function () {
        var deactivation;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              deactivation = deactivationsIterator.next();
              _a.label = 1;
            case 1:
              if (!deactivation.value) return [3, 3];
              return [4, deactivation.value(instance)];
            case 2:
              _a.sent();
              deactivation = deactivationsIterator.next();
              return [3, 1];
            case 3:
              return [2];
          }
        });
      });
    };
    Container.prototype._getContainerModuleHelpersFactory = function () {
      var _this = this;
      var setModuleId = function setModuleId(bindingToSyntax, moduleId) {
        bindingToSyntax._binding.moduleId = moduleId;
      };
      var getBindFunction = function getBindFunction(moduleId) {
        return function (serviceIdentifier) {
          var bindingToSyntax = _this.bind(serviceIdentifier);
          setModuleId(bindingToSyntax, moduleId);
          return bindingToSyntax;
        };
      };
      var getUnbindFunction = function getUnbindFunction() {
        return function (serviceIdentifier) {
          return _this.unbind(serviceIdentifier);
        };
      };
      var getUnbindAsyncFunction = function getUnbindAsyncFunction() {
        return function (serviceIdentifier) {
          return _this.unbindAsync(serviceIdentifier);
        };
      };
      var getIsboundFunction = function getIsboundFunction() {
        return function (serviceIdentifier) {
          return _this.isBound(serviceIdentifier);
        };
      };
      var getRebindFunction = function getRebindFunction(moduleId) {
        return function (serviceIdentifier) {
          var bindingToSyntax = _this.rebind(serviceIdentifier);
          setModuleId(bindingToSyntax, moduleId);
          return bindingToSyntax;
        };
      };
      var getOnActivationFunction = function getOnActivationFunction(moduleId) {
        return function (serviceIdentifier, onActivation) {
          _this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);
          _this.onActivation(serviceIdentifier, onActivation);
        };
      };
      var getOnDeactivationFunction = function getOnDeactivationFunction(moduleId) {
        return function (serviceIdentifier, onDeactivation) {
          _this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);
          _this.onDeactivation(serviceIdentifier, onDeactivation);
        };
      };
      return function (mId) {
        return {
          bindFunction: getBindFunction(mId),
          isboundFunction: getIsboundFunction(),
          onActivationFunction: getOnActivationFunction(mId),
          onDeactivationFunction: getOnDeactivationFunction(mId),
          rebindFunction: getRebindFunction(mId),
          unbindFunction: getUnbindFunction(),
          unbindAsyncFunction: getUnbindAsyncFunction()
        };
      };
    };
    Container.prototype._getAll = function (getArgs) {
      return Promise.all(this._get(getArgs));
    };
    Container.prototype._get = function (getArgs) {
      var planAndResolveArgs = __assign(__assign({}, getArgs), {
        contextInterceptor: function contextInterceptor(context) {
          return context;
        },
        targetType: TargetTypeEnum.Variable
      });
      if (this._middleware) {
        var middlewareResult = this._middleware(planAndResolveArgs);
        if (middlewareResult === undefined || middlewareResult === null) {
          throw new Error(INVALID_MIDDLEWARE_RETURN);
        }
        return middlewareResult;
      }
      return this._planAndResolve()(planAndResolveArgs);
    };
    Container.prototype._getButThrowIfAsync = function (getArgs) {
      var result = this._get(getArgs);
      if (isPromiseOrContainsPromise(result)) {
        throw new Error(LAZY_IN_SYNC(getArgs.serviceIdentifier));
      }
      return result;
    };
    Container.prototype._getAllArgs = function (serviceIdentifier) {
      var getAllArgs = {
        avoidConstraints: true,
        isMultiInject: true,
        serviceIdentifier: serviceIdentifier
      };
      return getAllArgs;
    };
    Container.prototype._getNotAllArgs = function (serviceIdentifier, isMultiInject, key, value) {
      var getNotAllArgs = {
        avoidConstraints: false,
        isMultiInject: isMultiInject,
        serviceIdentifier: serviceIdentifier,
        key: key,
        value: value
      };
      return getNotAllArgs;
    };
    Container.prototype._planAndResolve = function () {
      var _this = this;
      return function (args) {
        var context = plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
        context = args.contextInterceptor(context);
        var result = resolve(context);
        return result;
      };
    };
    Container.prototype._deactivateIfSingleton = function (binding) {
      var _this = this;
      if (!binding.activated) {
        return;
      }
      if (isPromise(binding.cache)) {
        return binding.cache.then(function (resolved) {
          return _this._deactivate(binding, resolved);
        });
      }
      return this._deactivate(binding, binding.cache);
    };
    Container.prototype._deactivateSingletons = function (bindings) {
      for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {
        var binding = bindings_1[_i];
        var result = this._deactivateIfSingleton(binding);
        if (isPromise(result)) {
          throw new Error(ASYNC_UNBIND_REQUIRED);
        }
      }
    };
    Container.prototype._deactivateSingletonsAsync = function (bindings) {
      return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              return [4, Promise.all(bindings.map(function (b) {
                return _this._deactivateIfSingleton(b);
              }))];
            case 1:
              _a.sent();
              return [2];
          }
        });
      });
    };
    Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroy = function (binding, instance, constructor) {
      if (this.parent) {
        return this._deactivate.bind(this.parent)(binding, instance);
      } else {
        return this._bindingDeactivationAndPreDestroy(binding, instance, constructor);
      }
    };
    Container.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync = function (binding, instance, constructor) {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!this.parent) return [3, 2];
              return [4, this._deactivate.bind(this.parent)(binding, instance)];
            case 1:
              _a.sent();
              return [3, 4];
            case 2:
              return [4, this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor)];
            case 3:
              _a.sent();
              _a.label = 4;
            case 4:
              return [2];
          }
        });
      });
    };
    Container.prototype._removeServiceFromDictionary = function (serviceIdentifier) {
      try {
        this._bindingDictionary.remove(serviceIdentifier);
      } catch (e) {
        throw new Error(CANNOT_UNBIND + " " + getServiceIdentifierAsString(serviceIdentifier));
      }
    };
    Container.prototype._bindingDeactivationAndPreDestroy = function (binding, instance, constructor) {
      var _this = this;
      if (typeof binding.onDeactivation === "function") {
        var result = binding.onDeactivation(instance);
        if (isPromise(result)) {
          return result.then(function () {
            return _this._preDestroy(constructor, instance);
          });
        }
      }
      return this._preDestroy(constructor, instance);
    };
    Container.prototype._bindingDeactivationAndPreDestroyAsync = function (binding, instance, constructor) {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(typeof binding.onDeactivation === "function")) return [3, 2];
              return [4, binding.onDeactivation(instance)];
            case 1:
              _a.sent();
              _a.label = 2;
            case 2:
              return [4, this._preDestroy(constructor, instance)];
            case 3:
              _a.sent();
              return [2];
          }
        });
      });
    };
    return Container;
  }();

  var ContainerModule = function () {
    function ContainerModule(registry) {
      this.id = id();
      this.registry = registry;
    }
    return ContainerModule;
  }();

  function getFirstArrayDuplicate(array) {
    var seenValues = new Set();
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
      var entry = array_1[_i];
      if (seenValues.has(entry)) {
        return entry;
      } else {
        seenValues.add(entry);
      }
    }
    return undefined;
  }

  function targetIsConstructorFunction(target) {
    return target.prototype !== undefined;
  }
  function _throwIfMethodParameter(parameterName) {
    if (parameterName !== undefined) {
      throw new Error(INVALID_DECORATOR_OPERATION);
    }
  }
  function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
    _throwIfMethodParameter(parameterName);
    _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
  }
  function tagProperty(annotationTarget, propertyName, metadata) {
    if (targetIsConstructorFunction(annotationTarget)) {
      throw new Error(INVALID_DECORATOR_OPERATION);
    }
    _tagParameterOrProperty(TAGGED_PROP, annotationTarget.constructor, propertyName, metadata);
  }
  function _ensureNoMetadataKeyDuplicates(metadata) {
    var metadatas = [];
    if (Array.isArray(metadata)) {
      metadatas = metadata;
      var duplicate = getFirstArrayDuplicate(metadatas.map(function (md) {
        return md.key;
      }));
      if (duplicate !== undefined) {
        throw new Error(DUPLICATED_METADATA + " " + duplicate.toString());
      }
    } else {
      metadatas = [metadata];
    }
    return metadatas;
  }
  function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
    var metadatas = _ensureNoMetadataKeyDuplicates(metadata);
    var paramsOrPropertiesMetadata = {};
    if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
      paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
    }
    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
    if (paramOrPropertyMetadata === undefined) {
      paramOrPropertyMetadata = [];
    } else {
      var _loop_1 = function _loop_1(m) {
        if (metadatas.some(function (md) {
          return md.key === m.key;
        })) {
          throw new Error(DUPLICATED_METADATA + " " + m.key.toString());
        }
      };
      for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
        var m = paramOrPropertyMetadata_1[_i];
        _loop_1(m);
      }
    }
    paramOrPropertyMetadata.push.apply(paramOrPropertyMetadata, metadatas);
    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
    Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
  }
  function createTaggedDecorator(metadata) {
    return function (target, targetKey, indexOrPropertyDescriptor) {
      if (typeof indexOrPropertyDescriptor === "number") {
        tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
      } else {
        tagProperty(target, targetKey, metadata);
      }
    };
  }

  function injectable() {
    return function (target) {
      if (Reflect.hasOwnMetadata(PARAM_TYPES, target)) {
        throw new Error(DUPLICATED_INJECTABLE_DECORATOR);
      }
      var types = Reflect.getMetadata(DESIGN_PARAM_TYPES, target) || [];
      Reflect.defineMetadata(PARAM_TYPES, types, target);
      return target;
    };
  }

  function named(name) {
    return createTaggedDecorator(new Metadata(NAMED_TAG, name));
  }

  function injectBase(metadataKey) {
    return function (serviceIdentifier) {
      return function (target, targetKey, indexOrPropertyDescriptor) {
        if (serviceIdentifier === undefined) {
          var className = typeof target === "function" ? target.name : target.constructor.name;
          throw new Error(UNDEFINED_INJECT_ANNOTATION(className));
        }
        return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
      };
    };
  }

  var inject = injectBase(INJECT_TAG);

  var multiInject = injectBase(MULTI_INJECT_TAG);

  function propertyEventDecorator(eventKey, errorMessage) {
    return function () {
      return function (target, propertyKey) {
        var metadata = new Metadata(eventKey, propertyKey);
        if (Reflect.hasOwnMetadata(eventKey, target.constructor)) {
          throw new Error(errorMessage);
        }
        Reflect.defineMetadata(eventKey, metadata, target.constructor);
      };
    };
  }

  var postConstruct = propertyEventDecorator(POST_CONSTRUCT, MULTIPLE_POST_CONSTRUCT_METHODS);

  function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };

  const ContributionProvider = Symbol('ContributionProvider');
  class ContributionProviderCache {
      caches;
      serviceIdentifier;
      container;
      constructor(serviceIdentifier, container) {
          this.serviceIdentifier = serviceIdentifier;
          this.container = container;
      }
      getContributions() {
          if (!this.caches) {
              this.caches = [];
              this.container && this.caches.push(...this.container.getAll(this.serviceIdentifier));
          }
          return this.caches;
      }
  }
  function bindContributionProvider(bind, id) {
      bind(ContributionProvider)
          .toDynamicValue(({ container }) => new ContributionProviderCache(id, container))
          .inSingletonScope()
          .whenTargetNamed(id);
  }

  class Hook {
      _args;
      name;
      taps;
      constructor(args, name) {
          this._args = args;
          this.name = name;
          this.taps = [];
      }
      tap(options, fn) {
          this._tap('sync', options, fn);
      }
      unTap(options, fn) {
          const name = typeof options === 'string' ? options.trim() : options.name;
          if (name) {
              this.taps = this.taps.filter(tap => tap.name !== name && (!fn || tap.fn === fn));
          }
      }
      _parseOptions(type, options, fn) {
          let _options;
          if (typeof options === 'string') {
              _options = {
                  name: options.trim()
              };
          }
          else if (typeof options !== 'object' || options === null) {
              throw new Error('Invalid tap options');
          }
          if (typeof _options.name !== 'string' || _options.name === '') {
              throw new Error('Missing name for tap');
          }
          _options = Object.assign({ type, fn }, _options);
          return _options;
      }
      _tap(type, options, fn) {
          this._insert(this._parseOptions(type, options, fn));
      }
      _insert(item) {
          let before;
          if (typeof item.before === 'string') {
              before = new Set([item.before]);
          }
          else if (Array.isArray(item.before)) {
              before = new Set(item.before);
          }
          let stage = 0;
          if (typeof item.stage === 'number') {
              stage = item.stage;
          }
          let i = this.taps.length;
          while (i > 0) {
              i--;
              const x = this.taps[i];
              this.taps[i + 1] = x;
              const xStage = x.stage || 0;
              if (before) {
                  if (before.has(x.name)) {
                      before.delete(x.name);
                      continue;
                  }
                  if (before.size > 0) {
                      continue;
                  }
              }
              if (xStage > stage) {
                  continue;
              }
              i++;
              break;
          }
          this.taps[i] = item;
      }
  }

  class SyncHook extends Hook {
      call(...args) {
          const cbs = this.taps.map(t => t.fn);
          cbs.forEach(cb => cb(...args));
          return undefined;
      }
  }

  const EnvContribution = Symbol.for('EnvContribution');
  const Global = Symbol.for('Global');

  const defaultEnv = 'browser';
  exports.DefaultGlobal = class DefaultGlobal {
      contributions;
      _env;
      get env() {
          return this._env;
      }
      envContribution;
      get devicePixelRatio() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.getDevicePixelRatio();
      }
      get supportEvent() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.supportEvent;
      }
      get supportsTouchEvents() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.supportsTouchEvents;
      }
      get supportsPointerEvents() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.supportsPointerEvents;
      }
      get supportsMouseEvents() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.supportsMouseEvents;
      }
      get applyStyles() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.applyStyles;
      }
      envParams;
      constructor(contributions) {
          this.contributions = contributions;
          this.hooks = {
              onSetEnv: new SyncHook(['lastEnv', 'env', 'global'])
          };
          this.measureTextMethod = 'native';
      }
      bindContribution(params) {
          const promiseArr = [];
          this.contributions.getContributions().forEach(contribution => {
              const data = contribution.configure(this, params);
              if (data && data.then) {
                  promiseArr.push(data);
              }
          });
          if (promiseArr.length) {
              return Promise.all(promiseArr);
          }
      }
      setEnv(env, params) {
          if (!(params && params.force === true) && this._env === env) {
              return;
          }
          this.deactiveCurrentEnv();
          return this.activeEnv(env, params);
      }
      deactiveCurrentEnv() {
          this.envContribution && this.envContribution.release();
      }
      activeEnv(env, params) {
          const lastEnv = this._env;
          this._env = env;
          const data = this.bindContribution(params);
          if (data && data.then) {
              return data.then(() => {
                  this.envParams = params;
                  this.hooks.onSetEnv.call(lastEnv, env, this);
              });
          }
          this.envParams = params;
          this.hooks.onSetEnv.call(lastEnv, env, this);
      }
      setActiveEnvContribution(contribution) {
          this.envContribution = contribution;
      }
      createCanvas(params) {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.createCanvas(params);
      }
      createOffscreenCanvas(params) {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.createOffscreenCanvas(params);
      }
      releaseCanvas(canvas) {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.releaseCanvas(canvas);
      }
      addEventListener(type, listener, options) {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.removeEventListener(type, listener, options);
      }
      dispatchEvent(event) {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.dispatchEvent(event);
      }
      getRequestAnimationFrame() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.getRequestAnimationFrame();
      }
      getCancelAnimationFrame() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          return this.envContribution.getCancelAnimationFrame();
      }
      getElementById(str) {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          if (!this.envContribution.getElementById) {
              return null;
          }
          return this.envContribution.getElementById(str);
      }
      getRootElement() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          if (!this.envContribution.getRootElement) {
              return null;
          }
          return this.envContribution.getRootElement();
      }
      getDocument() {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          if (!this.envContribution.getDocument) {
              return null;
          }
          return this.envContribution.getDocument();
      }
      mapToCanvasPoint(event, domElement) {
          if (!this._env) {
              this.setEnv(defaultEnv);
          }
          if (!this.envContribution.mapToCanvasPoint) {
              return null;
          }
          return this.envContribution.mapToCanvasPoint(event, domElement);
      }
      loadImage(url) {
          if (!this._env) {
              this.setEnv('browser');
          }
          return this.envContribution.loadImage(url);
      }
      loadSvg(str) {
          if (!this._env) {
              this.setEnv('browser');
          }
          return this.envContribution.loadSvg(str);
      }
      loadJson(url) {
          if (!this._env) {
              this.setEnv('browser');
          }
          return this.envContribution.loadJson(url);
      }
      loadArrayBuffer(url) {
          if (!this._env) {
              this.setEnv('browser');
          }
          return this.envContribution.loadArrayBuffer(url);
      }
      loadBlob(url) {
          if (!this._env) {
              this.setEnv('browser');
          }
          return this.envContribution.loadBlob(url);
      }
  };
  exports.DefaultGlobal = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(EnvContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultGlobal);

  var eventemitter3 = {exports: {}};

  (function (module) {

    var has = Object.prototype.hasOwnProperty,
      prefix = '~';

    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @private
     */
    function Events() {}

    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);

      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }

    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }

    /**
     * Add a listener for a given event.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} once Specify if the listener is a one-time listener.
     * @returns {EventEmitter}
     * @private
     */
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
      }
      var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }

    /**
     * Clear event by name.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} evt The Event name.
     * @private
     */
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
    }

    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }

    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [],
        events,
        name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };

    /**
     * Return the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Array} The registered listeners.
     * @public
     */
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };

    /**
     * Return the number of listeners listening to a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Number} The number of listeners.
     * @public
     */
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };

    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length,
          j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };

    /**
     * Add a listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };

    /**
     * Add a one-time listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };

    /**
     * Remove the listeners of a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {*} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }

        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
      }
      return this;
    };

    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {(String|Symbol)} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };

    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;

    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;

    //
    // Expose the module.
    //
    {
      module.exports = EventEmitter;
    }
  })(eventemitter3);
  var eventemitter3Exports = eventemitter3.exports;
  var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

  var isType = function isType(value, type) {
    return toString.call(value) === "[object ".concat(type, "]");
  };

  var isBoolean = function isBoolean(value) {
    var fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return fuzzy ? "boolean" == typeof value : !0 === value || !1 === value || isType(value, "Boolean");
  };

  var isFunction = function isFunction(value) {
    return "function" == typeof value;
  };

  var isNil = function isNil(value) {
    return null == value;
  };

  var isValid = function isValid(value) {
    return null != value;
  };

  var isObject = function isObject(value) {
    var type = _typeof(value);
    return null !== value && "object" === type || "function" === type;
  };

  var isUndefined = function isUndefined(value) {
    return void 0 === value;
  };

  var isString = function isString(value) {
    var fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var type = _typeof(value);
    return fuzzy ? "string" === type : "string" === type || isType(value, "String");
  };

  var isArray = function isArray(value) {
    return Array.isArray ? Array.isArray(value) : isType(value, "Array");
  };

  var isDate = function isDate(value) {
    return isType(value, "Date");
  };

  var isNumber = function isNumber(value) {
    var fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var type = _typeof(value);
    return fuzzy ? "number" === type : "number" === type || isType(value, "Number");
  };

  var isValidNumber = function isValidNumber(value) {
    return isNumber(value) && Number.isFinite(value);
  };

  var isValidUrl = function isValidUrl(value) {
    return new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(value);
  };

  var isRegExp = function isRegExp(value) {
    return isType(value, "RegExp");
  };

  var isBase64 = function isBase64(value) {
    return new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(value);
  };

  var get = function get(obj, path, defaultValue) {
    var paths = isString(path) ? path.split(".") : path;
    for (var p = 0; p < paths.length; p++) obj = obj ? obj[paths[p]] : void 0;
    return void 0 === obj ? defaultValue : obj;
  };

  var hasOwnProperty = Object.prototype.hasOwnProperty,
    has = function has(object, key) {
      return null != object && hasOwnProperty.call(object, key);
    };

  function getRegExpFlags(re) {
    var flags = "";
    return re.global && (flags += "g"), re.ignoreCase && (flags += "i"), re.multiline && (flags += "m"), flags;
  }
  function clone(parent) {
    var circular = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var prototype = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : void 0;
    var allParents = [],
      allChildren = [];
    return void 0 === circular && (circular = !0), void 0 === depth && (depth = 1 / 0), function _clone(parent, depth) {
      if (null === parent) return null;
      if (0 === depth) return parent;
      var child;
      if ("object" != _typeof(parent)) return parent;
      if (isArray(parent) ? child = [] : isRegExp(parent) ? (child = new RegExp(parent.source, getRegExpFlags(parent)), parent.lastIndex && (child.lastIndex = parent.lastIndex)) : child = isDate(parent) ? new Date(parent.getTime()) : void 0 === prototype ? Object.create(Object.getPrototypeOf(parent)) : Object.create(prototype), circular) {
        var index = allParents.indexOf(parent);
        if (-1 !== index) return allChildren[index];
        allParents.push(parent), allChildren.push(child);
      }
      for (var i in parent) child[i] = _clone(parent[i], depth - 1);
      return child;
    }(parent, depth);
  }

  function arrayEqual(a, b) {
    if (!isArray(a) || !isArray(b)) return !1;
    if (a.length !== b.length) return !1;
    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
    return !0;
  }

  var DEFAULT_ABSOLUTE_TOLERATE = 1e-10,
    DEFAULT_RELATIVE_TOLERATE = 1e-10;
  function isNumberClose(a, b) {
    var relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RELATIVE_TOLERATE;
    var absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ABSOLUTE_TOLERATE;
    var abs = absTol,
      rel = relTol * Math.max(a, b);
    return Math.abs(a - b) <= Math.max(abs, rel);
  }

  var hasRaf = !1;
  try {
    hasRaf = "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame;
  } catch (err) {
    hasRaf = !1;
  }
  hasRaf = !1;

  var epsilon = 1e-12;
  var pi = Math.PI;
  var halfPi$1 = pi / 2;
  var tau = 2 * pi;
  var pi2 = 2 * Math.PI;
  var abs = Math.abs;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var max = Math.max;
  var min = Math.min;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  var pow = Math.pow;
  function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
  }
  function asin(x) {
    return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);
  }
  function pointAt(x1, y1, x2, y2, t) {
    var x, y;
    return "number" == typeof x1 && "number" == typeof x2 && (x = (1 - t) * x1 + t * x2), "number" == typeof y1 && "number" == typeof y2 && (y = (1 - t) * y1 + t * y2), {
      x: x,
      y: y
    };
  }
  function crossProduct$1(dir1, dir2) {
    return dir1[0] * dir2[1] - dir1[1] * dir2[0];
  }
  function fuzzyEqualVec(a, b) {
    return abs(a[0] - b[0]) + abs(a[1] - b[1]) < 1e-12;
  }

  var Point = /*#__PURE__*/function () {
    function Point() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var x1 = arguments.length > 2 ? arguments[2] : undefined;
      var y1 = arguments.length > 3 ? arguments[3] : undefined;
      _classCallCheck(this, Point);
      this.x = 0, this.y = 0, this.x = x, this.y = y, this.x1 = x1, this.y1 = y1;
    }
    _createClass(Point, [{
      key: "clone",
      value: function clone() {
        return new Point(this.x, this.y);
      }
    }, {
      key: "copyFrom",
      value: function copyFrom(p) {
        return this.x = p.x, this.y = p.y, this.x1 = p.x1, this.y1 = p.y1, this.defined = p.defined, this.context = p.context, this;
      }
    }, {
      key: "set",
      value: function set(x, y) {
        return this.x = x, this.y = y, this;
      }
    }, {
      key: "add",
      value: function add(point) {
        return isNumber(point) ? (this.x += point, void (this.y += point)) : (this.x += point.x, this.y += point.y, this);
      }
    }, {
      key: "sub",
      value: function sub(point) {
        return isNumber(point) ? (this.x -= point, void (this.y -= point)) : (this.x -= point.x, this.y -= point.y, this);
      }
    }, {
      key: "multi",
      value: function multi(point) {
        throw new Error("");
      }
    }, {
      key: "div",
      value: function div(point) {
        throw new Error("");
      }
    }]);
    return Point;
  }();
  var PointService = /*#__PURE__*/function () {
    function PointService() {
      _classCallCheck(this, PointService);
    }
    _createClass(PointService, null, [{
      key: "distancePP",
      value: function distancePP(p1, p2) {
        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
      }
    }, {
      key: "distanceNN",
      value: function distanceNN(x, y, x1, y1) {
        return sqrt(pow(x - x1, 2) + pow(y - y1, 2));
      }
    }, {
      key: "distancePN",
      value: function distancePN(point, x, y) {
        return sqrt(pow(x - point.x, 2) + pow(y - point.y, 2));
      }
    }, {
      key: "pointAtPP",
      value: function pointAtPP(p1, p2, t) {
        return new Point((p2.x - p1.x) * t + p1.x, (p2.y - p1.y) * t + p1.y);
      }
    }]);
    return PointService;
  }();

  function transformBoundsWithMatrix(out, bounds, matrix) {
    var x1 = bounds.x1,
      y1 = bounds.y1,
      x2 = bounds.x2,
      y2 = bounds.y2;
    return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x1 + matrix.c * y1 + matrix.e, matrix.b * x1 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y1 + matrix.e, matrix.b * x2 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y2 + matrix.e, matrix.b * x2 + matrix.d * y2 + matrix.f), out.add(matrix.a * x1 + matrix.c * y2 + matrix.e, matrix.b * x1 + matrix.d * y2 + matrix.f), bounds);
  }
  var Bounds = /*#__PURE__*/function () {
    function Bounds(bounds) {
      _classCallCheck(this, Bounds);
      bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
    }
    _createClass(Bounds, [{
      key: "clone",
      value: function clone() {
        return new Bounds(this);
      }
    }, {
      key: "clear",
      value: function clear() {
        return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
      }
    }, {
      key: "empty",
      value: function empty() {
        return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
      }
    }, {
      key: "equals",
      value: function equals(b) {
        return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
      }
    }, {
      key: "setValue",
      value: function setValue() {
        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        return this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this;
      }
    }, {
      key: "set",
      value: function set() {
        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        return x2 < x1 ? (this.x2 = x1, this.x1 = x2) : (this.x1 = x1, this.x2 = x2), y2 < y1 ? (this.y2 = y1, this.y1 = y2) : (this.y1 = y1, this.y2 = y2), this;
      }
    }, {
      key: "add",
      value: function add() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return x < this.x1 && (this.x1 = x), y < this.y1 && (this.y1 = y), x > this.x2 && (this.x2 = x), y > this.y2 && (this.y2 = y), this;
      }
    }, {
      key: "expand",
      value: function expand() {
        var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return isArray(d) ? (this.y1 -= d[0], this.x2 += d[1], this.y2 += d[2], this.x1 -= d[3]) : (this.x1 -= d, this.y1 -= d, this.x2 += d, this.y2 += d), this;
      }
    }, {
      key: "round",
      value: function round() {
        return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
      }
    }, {
      key: "translate",
      value: function translate() {
        var dx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var dy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
      }
    }, {
      key: "rotate",
      value: function rotate() {
        var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var p = this.rotatedPoints(angle, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
      }
    }, {
      key: "scale",
      value: function scale() {
        var sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var p = this.scalePoints(sx, sy, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]);
      }
    }, {
      key: "union",
      value: function union(b) {
        return b.x1 < this.x1 && (this.x1 = b.x1), b.y1 < this.y1 && (this.y1 = b.y1), b.x2 > this.x2 && (this.x2 = b.x2), b.y2 > this.y2 && (this.y2 = b.y2), this;
      }
    }, {
      key: "intersect",
      value: function intersect(b) {
        return b.x1 > this.x1 && (this.x1 = b.x1), b.y1 > this.y1 && (this.y1 = b.y1), b.x2 < this.x2 && (this.x2 = b.x2), b.y2 < this.y2 && (this.y2 = b.y2), this;
      }
    }, {
      key: "encloses",
      value: function encloses(b) {
        return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
      }
    }, {
      key: "alignsWith",
      value: function alignsWith(b) {
        return b && (this.x1 === b.x1 || this.x2 === b.x2 || this.y1 === b.y1 || this.y2 === b.y2);
      }
    }, {
      key: "intersects",
      value: function intersects(b) {
        return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
      }
    }, {
      key: "contains",
      value: function contains() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(p) {
        return !(p.x < this.x1 || p.x > this.x2 || p.y < this.y1 || p.y > this.y2);
      }
    }, {
      key: "width",
      value: function width() {
        return this.empty() ? 0 : this.x2 - this.x1;
      }
    }, {
      key: "height",
      value: function height() {
        return this.empty() ? 0 : this.y2 - this.y1;
      }
    }, {
      key: "scaleX",
      value: function scaleX() {
        var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this.x1 *= s, this.x2 *= s, this;
      }
    }, {
      key: "scaleY",
      value: function scaleY() {
        var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this.y1 *= s, this.y2 *= s, this;
      }
    }, {
      key: "transformWithMatrix",
      value: function transformWithMatrix(matrix) {
        return transformBoundsWithMatrix(this, this, matrix), this;
      }
    }, {
      key: "copy",
      value: function copy(b) {
        return this.x1 = b.x1, this.y1 = b.y1, this.x2 = b.x2, this.y2 = b.y2, this;
      }
    }, {
      key: "rotatedPoints",
      value: function rotatedPoints(angle, x, y) {
        var x1 = this.x1,
          y1 = this.y1,
          x2 = this.x2,
          y2 = this.y2,
          cos = Math.cos(angle),
          sin = Math.sin(angle),
          cx = x - x * cos + y * sin,
          cy = y - x * sin - y * cos;
        return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
      }
    }, {
      key: "scalePoints",
      value: function scalePoints(sx, sy, x, y) {
        var x1 = this.x1,
          y1 = this.y1,
          x2 = this.x2,
          y2 = this.y2;
        return [sx * x1 + (1 - sx) * x, sy * y1 + (1 - sy) * y, sx * x2 + (1 - sx) * x, sy * y2 + (1 - sy) * y];
      }
    }]);
    return Bounds;
  }();
  var AABBBounds = /*#__PURE__*/function (_Bounds) {
    _inherits(AABBBounds, _Bounds);
    var _super = _createSuper(AABBBounds);
    function AABBBounds() {
      _classCallCheck(this, AABBBounds);
      return _super.apply(this, arguments);
    }
    return _createClass(AABBBounds);
  }(Bounds);

  function degreeToRadian(degree) {
    return degree * (Math.PI / 180);
  }
  function radianToDegree(radian) {
    return 180 * radian / Math.PI;
  }
  var clampRadian = function clampRadian() {
    var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (angle < 0) for (; angle < -tau;) angle += tau;else if (angle > 0) for (; angle > tau;) angle -= tau;
    return angle;
  };
  var clampAngleByRadian = clampRadian;
  function getAngleByPoint(center, point) {
    return Math.atan2(point.y - center.y, point.x - center.x);
  }

  var Matrix = /*#__PURE__*/function () {
    function Matrix() {
      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var f = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      _classCallCheck(this, Matrix);
      this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f;
    }
    _createClass(Matrix, [{
      key: "equalToMatrix",
      value: function equalToMatrix(m2) {
        return !(this.e !== m2.e || this.f !== m2.f || this.a !== m2.a || this.d !== m2.d || this.b !== m2.b || this.c !== m2.c);
      }
    }, {
      key: "equalTo",
      value: function equalTo(a, b, c, d, e, f) {
        return !(this.e !== e || this.f !== f || this.a !== a || this.d !== d || this.b !== b || this.c !== c);
      }
    }, {
      key: "setValue",
      value: function setValue(a, b, c, d, e, f) {
        return this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f, this;
      }
    }, {
      key: "reset",
      value: function reset() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
      }
    }, {
      key: "getInverse",
      value: function getInverse() {
        var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f,
          m = new Matrix(),
          dt = a * d - b * c;
        return m.a = d / dt, m.b = -b / dt, m.c = -c / dt, m.d = a / dt, m.e = (c * f - d * e) / dt, m.f = -(a * f - b * e) / dt, m;
      }
    }, {
      key: "rotate",
      value: function rotate(rad) {
        var c = Math.cos(rad),
          s = Math.sin(rad),
          m11 = this.a * c + this.c * s,
          m12 = this.b * c + this.d * s,
          m21 = this.a * -s + this.c * c,
          m22 = this.b * -s + this.d * c;
        return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this;
      }
    }, {
      key: "rotateByCenter",
      value: function rotateByCenter(rad, cx, cy) {
        var cos = Math.cos(rad),
          sin = Math.sin(rad),
          rotateM13 = (1 - cos) * cx + sin * cy,
          rotateM23 = (1 - cos) * cy - sin * cx,
          m11 = cos * this.a - sin * this.b,
          m21 = sin * this.a + cos * this.b,
          m12 = cos * this.c - sin * this.d,
          m22 = sin * this.c + cos * this.d,
          m13 = cos * this.e - sin * this.f + rotateM13,
          m23 = sin * this.e + cos * this.f + rotateM23;
        return this.a = m11, this.b = m21, this.c = m12, this.d = m22, this.e = m13, this.f = m23, this;
      }
    }, {
      key: "scale",
      value: function scale(sx, sy) {
        return this.a *= sx, this.b *= sx, this.c *= sy, this.d *= sy, this;
      }
    }, {
      key: "setScale",
      value: function setScale(sx, sy) {
        return this.b = this.b / this.a * sx, this.c = this.c / this.d * sy, this.a = sx, this.d = sy, this;
      }
    }, {
      key: "transform",
      value: function transform(a, b, c, d, e, f) {
        return this.multiply(a, b, c, d, e, f), this;
      }
    }, {
      key: "translate",
      value: function translate(x, y) {
        return this.e += this.a * x + this.c * y, this.f += this.b * x + this.d * y, this;
      }
    }, {
      key: "transpose",
      value: function transpose() {
        var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
        return this.a = b, this.b = a, this.c = d, this.d = c, this.e = f, this.f = e, this;
      }
    }, {
      key: "multiply",
      value: function multiply(a2, b2, c2, d2, e2, f2) {
        var a1 = this.a,
          b1 = this.b,
          c1 = this.c,
          d1 = this.d,
          m11 = a1 * a2 + c1 * b2,
          m12 = b1 * a2 + d1 * b2,
          m21 = a1 * c2 + c1 * d2,
          m22 = b1 * c2 + d1 * d2,
          dx = a1 * e2 + c1 * f2 + this.e,
          dy = b1 * e2 + d1 * f2 + this.f;
        return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this.e = dx, this.f = dy, this;
      }
    }, {
      key: "interpolate",
      value: function interpolate(m2, t) {
        var m = new Matrix();
        return m.a = this.a + (m2.a - this.a) * t, m.b = this.b + (m2.b - this.b) * t, m.c = this.c + (m2.c - this.c) * t, m.d = this.d + (m2.d - this.d) * t, m.e = this.e + (m2.e - this.e) * t, m.f = this.f + (m2.f - this.f) * t, m;
      }
    }, {
      key: "transformPoint",
      value: function transformPoint(source, target) {
        var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f,
          dt = a * d - b * c,
          nextA = d / dt,
          nextB = -b / dt,
          nextC = -c / dt,
          nextD = a / dt,
          nextE = (c * f - d * e) / dt,
          nextF = -(a * f - b * e) / dt,
          x = source.x,
          y = source.y;
        target.x = x * nextA + y * nextC + nextE, target.y = x * nextB + y * nextD + nextF;
      }
    }, {
      key: "onlyTranslate",
      value: function onlyTranslate() {
        var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        return this.a === scale && 0 === this.b && 0 === this.c && this.d === scale;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
      }
    }, {
      key: "toTransformAttrs",
      value: function toTransformAttrs() {
        var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          delta = a * d - b * c,
          result = {
            x: this.e,
            y: this.f,
            rotateDeg: 0,
            scaleX: 0,
            scaleY: 0,
            skewX: 0,
            skewY: 0
          };
        if (0 !== a || 0 !== b) {
          var r = Math.sqrt(a * a + b * b);
          result.rotateDeg = b > 0 ? Math.acos(a / r) : -Math.acos(a / r), result.scaleX = r, result.scaleY = delta / r, result.skewX = (a * c + b * d) / delta, result.skewY = 0;
        } else if (0 !== c || 0 !== d) {
          var s = Math.sqrt(c * c + d * d);
          result.rotateDeg = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s)), result.scaleX = delta / s, result.scaleY = s, result.skewX = 0, result.skewY = (a * c + b * d) / delta;
        }
        return result.rotateDeg = radianToDegree(result.rotateDeg), result;
      }
    }]);
    return Matrix;
  }();
  function normalTransform(out, origin, x, y, scaleX, scaleY, angle, rotateCenter) {
    var oa = origin.a,
      ob = origin.b,
      oc = origin.c,
      od = origin.d,
      oe = origin.e,
      of = origin.f,
      cosTheta = cos(angle),
      sinTheta = sin(angle);
    var rotateCenterX, rotateCenterY;
    rotateCenter ? (rotateCenterX = rotateCenter[0], rotateCenterY = rotateCenter[1]) : (rotateCenterX = x, rotateCenterY = y);
    var offsetX = rotateCenterX - x,
      offsetY = rotateCenterY - y,
      a1 = oa * cosTheta + oc * sinTheta,
      b1 = ob * cosTheta + od * sinTheta,
      c1 = oc * cosTheta - oa * sinTheta,
      d1 = od * cosTheta - ob * sinTheta;
    out.a = scaleX * a1, out.b = scaleX * b1, out.c = scaleY * c1, out.d = scaleY * d1, out.e = oe + oa * rotateCenterX + oc * rotateCenterY - a1 * offsetX - c1 * offsetY, out.f = of + ob * rotateCenterX + od * rotateCenterY - b1 * offsetX - d1 * offsetY;
  }

  function sub(out, v1, v2) {
    out[0] = v1[0] - v2[0], out[1] = v1[1] - v2[1];
  }
  var x11, x12, y11, y12, x21, x22, y21, y22;
  function isIntersect(left1, right1, left2, right2) {
    var _temp,
      min1 = left1[0],
      max1 = right1[0],
      min2 = left2[0],
      max2 = right2[0];
    return max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), max2 < min2 && (_temp = max2, max2 = min2, min2 = _temp), !(max1 < min2 || max2 < min1) && (min1 = left1[1], max1 = right1[1], min2 = left2[1], max2 = right2[1], max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), max2 < min2 && (_temp = max2, max2 = min2, min2 = _temp), !(max1 < min2 || max2 < min1));
  }
  function getIntersectPoint(left1, right1, left2, right2) {
    if (!isIntersect(left1, right1, left2, right2)) return !1;
    var dir1 = [0, 0],
      dir2 = [0, 0],
      tempVec = [0, 0];
    if (sub(dir1, right1, left1), sub(dir2, right2, left2), fuzzyEqualVec(dir1, dir2)) return !0;
    sub(tempVec, left2, left1);
    var t = crossProduct$1(tempVec, dir2) / crossProduct$1(dir1, dir2);
    return t >= 0 && t <= 1 && [left1[0] + dir1[0] * t, left1[1] + dir1[1] * t];
  }
  function getRectIntersect(bbox1, bbox2, format) {
    var _ref, _ref2, _ref3, _ref4;
    return null === bbox1 ? bbox2 : null === bbox2 ? bbox1 : (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, format && (x11 > x12 && (_ref = [x12, x11], x11 = _ref[0], x12 = _ref[1], _ref), y11 > y12 && (_ref2 = [y12, y11], y11 = _ref2[0], y12 = _ref2[1], _ref2), x21 > x22 && (_ref3 = [x22, x21], x21 = _ref3[0], x22 = _ref3[1], _ref3), y21 > y22 && (_ref4 = [y22, y21], y21 = _ref4[0], y22 = _ref4[1], _ref4)), x11 >= x22 || x12 <= x21 || y11 >= y22 || y12 <= y21 ? {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    } : {
      x1: Math.max(x11, x21),
      y1: Math.max(y11, y21),
      x2: Math.min(x12, x22),
      y2: Math.min(y12, y22)
    });
  }
  var InnerBBox;
  !function (InnerBBox) {
    InnerBBox[InnerBBox.NONE = 0] = "NONE", InnerBBox[InnerBBox.BBOX1 = 1] = "BBOX1", InnerBBox[InnerBBox.BBOX2 = 2] = "BBOX2";
  }(InnerBBox || (InnerBBox = {}));
  function isRectIntersect(bbox1, bbox2, format) {
    var _ref9, _ref10, _ref11, _ref12;
    return !bbox1 || !bbox2 || (format ? (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, x11 > x12 && (_ref9 = [x12, x11], x11 = _ref9[0], x12 = _ref9[1], _ref9), y11 > y12 && (_ref10 = [y12, y11], y11 = _ref10[0], y12 = _ref10[1], _ref10), x21 > x22 && (_ref11 = [x22, x21], x21 = _ref11[0], x22 = _ref11[1], _ref11), y21 > y22 && (_ref12 = [y22, y21], y21 = _ref12[0], y22 = _ref12[1], _ref12), !(x11 > x22 || x12 < x21 || y11 > y22 || y12 < y21)) : !(bbox1.x1 > bbox2.x2 || bbox1.x2 < bbox2.x1 || bbox1.y1 > bbox2.y2 || bbox1.y2 < bbox2.y1));
  }

  var eastAsianCharacterInfo = function eastAsianCharacterInfo(character) {
    var x = character.charCodeAt(0),
      y = 2 === character.length ? character.charCodeAt(1) : 0,
      codePoint = x;
    return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
  };

  function getContextFont$1(text) {
    var defaultAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _text$fontStyle = text.fontStyle,
      fontStyle = _text$fontStyle === void 0 ? defaultAttr.fontStyle : _text$fontStyle,
      _text$fontVariant = text.fontVariant,
      fontVariant = _text$fontVariant === void 0 ? defaultAttr.fontVariant : _text$fontVariant,
      _text$fontWeight = text.fontWeight,
      fontWeight = _text$fontWeight === void 0 ? defaultAttr.fontWeight : _text$fontWeight,
      _text$fontSize = text.fontSize,
      fontSize = _text$fontSize === void 0 ? defaultAttr.fontSize : _text$fontSize,
      _text$fontFamily = text.fontFamily,
      fontFamily = _text$fontFamily === void 0 ? defaultAttr.fontFamily : _text$fontFamily;
    return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize + "px " + (fontFamily || "sans-serif");
  }

  var TextMeasure = /*#__PURE__*/function () {
    function TextMeasure(option, textSpec) {
      _classCallCheck(this, TextMeasure);
      this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = !1, this._notSupportCanvas = !1, this._notSupportCanopus = !1, this._userSpec = {}, this.specialCharSet = "-/: .,@%'\"~", this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
    }
    _createClass(TextMeasure, [{
      key: "initContext",
      value: function initContext() {
        if (this._notSupportCanvas) return !1;
        if (isNil(this._canvas) && (isValid(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil(this._canvas) && isValid(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil(this._context) && isValid(this._canvas)) {
          var context = this._canvas.getContext("2d");
          isValid(context) && (context.save(), context.font = getContextFont$1(this.textSpec), this._contextSaved = !0, this._context = context);
        }
        return !isNil(this._context) || (this._notSupportCanvas = !0, !1);
      }
    }, {
      key: "_initSpec",
      value: function _initSpec() {
        var _a, _b, _c;
        var _this$_option$default = this._option.defaultFontParams,
          defaultFontParams = _this$_option$default === void 0 ? {} : _this$_option$default,
          _this$_userSpec = this._userSpec,
          _this$_userSpec$fontS = _this$_userSpec.fontStyle,
          fontStyle = _this$_userSpec$fontS === void 0 ? defaultFontParams.fontStyle : _this$_userSpec$fontS,
          _this$_userSpec$fontV = _this$_userSpec.fontVariant,
          fontVariant = _this$_userSpec$fontV === void 0 ? defaultFontParams.fontVariant : _this$_userSpec$fontV,
          _this$_userSpec$fontW = _this$_userSpec.fontWeight,
          fontWeight = _this$_userSpec$fontW === void 0 ? null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal" : _this$_userSpec$fontW,
          _this$_userSpec$fontS2 = _this$_userSpec.fontSize,
          fontSize = _this$_userSpec$fontS2 === void 0 ? null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12 : _this$_userSpec$fontS2,
          _this$_userSpec$fontF = _this$_userSpec.fontFamily,
          fontFamily = _this$_userSpec$fontF === void 0 ? null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif" : _this$_userSpec$fontF,
          align = _this$_userSpec.align,
          _this$_userSpec$textA = _this$_userSpec.textAlign,
          textAlign = _this$_userSpec$textA === void 0 ? null != align ? align : "center" : _this$_userSpec$textA,
          baseline = _this$_userSpec.baseline,
          _this$_userSpec$textB = _this$_userSpec.textBaseline,
          textBaseline = _this$_userSpec$textB === void 0 ? null != baseline ? baseline : "middle" : _this$_userSpec$textB,
          ellipsis = _this$_userSpec.ellipsis,
          limit = _this$_userSpec.limit,
          _this$_userSpec$lineH = _this$_userSpec.lineHeight,
          lineHeight = _this$_userSpec$lineH === void 0 ? fontSize : _this$_userSpec$lineH;
        return {
          fontStyle: fontStyle,
          fontVariant: fontVariant,
          fontFamily: fontFamily,
          fontSize: fontSize,
          fontWeight: fontWeight,
          textAlign: textAlign,
          textBaseline: textBaseline,
          ellipsis: ellipsis,
          limit: limit,
          lineHeight: lineHeight
        };
      }
    }, {
      key: "measure",
      value: function measure(text, method) {
        switch (method) {
          case "canopus":
            return this.fullMeasure(text);
          case "canvas":
            return this.measureWithNaiveCanvas(text);
          case "simple":
            return this.quickMeasureWithoutCanvas(text);
          default:
            return this.quickMeasure(text);
        }
      }
    }, {
      key: "fullMeasure",
      value: function fullMeasure(text) {
        if (isNil(text)) return {
          width: 0,
          height: 0
        };
        if (isNil(this._option.getTextBounds) || !this._notSupportCanopus) return this.measureWithNaiveCanvas(text);
        var _this$textSpec = this.textSpec,
          fontFamily = _this$textSpec.fontFamily,
          fontSize = _this$textSpec.fontSize,
          fontWeight = _this$textSpec.fontWeight,
          textAlign = _this$textSpec.textAlign,
          textBaseline = _this$textSpec.textBaseline,
          ellipsis = _this$textSpec.ellipsis,
          limit = _this$textSpec.limit,
          lineHeight = _this$textSpec.lineHeight;
        var size;
        try {
          var bounds = this._option.getTextBounds({
            text: text,
            fontFamily: fontFamily,
            fontSize: fontSize,
            fontWeight: fontWeight,
            textAlign: textAlign,
            textBaseline: textBaseline,
            ellipsis: !!ellipsis,
            maxLineWidth: limit || 1 / 0,
            lineHeight: lineHeight
          });
          size = {
            width: bounds.width(),
            height: bounds.height()
          };
        } catch (e) {
          this._notSupportCanopus = !0, size = this.measureWithNaiveCanvas(text);
        }
        return size;
      }
    }, {
      key: "measureWithNaiveCanvas",
      value: function measureWithNaiveCanvas(text) {
        return this._measureReduce(text, this._measureWithNaiveCanvas.bind(this));
      }
    }, {
      key: "_measureWithNaiveCanvas",
      value: function _measureWithNaiveCanvas(text) {
        if (!this.initContext()) return this._quickMeasureWithoutCanvas(text);
        var metrics = this._context.measureText(text),
          _this$textSpec2 = this.textSpec,
          fontSize = _this$textSpec2.fontSize,
          lineHeight = _this$textSpec2.lineHeight;
        return {
          width: metrics.width,
          height: null != lineHeight ? lineHeight : fontSize
        };
      }
    }, {
      key: "quickMeasure",
      value: function quickMeasure(text) {
        return this._measureReduce(text, this._quickMeasure.bind(this));
      }
    }, {
      key: "_quickMeasure",
      value: function _quickMeasure(text) {
        var totalSize = {
          width: 0,
          height: 0
        };
        for (var i = 0; i < text.length; i++) {
          var _char = text[i];
          var size = this._measureSpecialChar(_char);
          isNil(size) && TextMeasure.NUMBERS_CHAR_SET.includes(_char) && (size = this._measureNumberChar()), isNil(size) && ["F", "W"].includes(eastAsianCharacterInfo(_char)) && (size = this._measureFullSizeChar()), isNil(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height);
        }
        return totalSize;
      }
    }, {
      key: "quickMeasureWithoutCanvas",
      value: function quickMeasureWithoutCanvas(text) {
        return this._measureReduce(text, this._quickMeasureWithoutCanvas.bind(this));
      }
    }, {
      key: "_quickMeasureWithoutCanvas",
      value: function _quickMeasureWithoutCanvas(text) {
        var totalSize = {
            width: 0,
            height: 0
          },
          _this$textSpec3 = this.textSpec,
          fontSize = _this$textSpec3.fontSize,
          lineHeight = _this$textSpec3.lineHeight;
        for (var i = 0; i < text.length; i++) {
          var _char2 = text[i],
            size = ["F", "W"].includes(eastAsianCharacterInfo(_char2)) ? 1 : .53;
          totalSize.width += size * fontSize;
        }
        return totalSize.height = null != lineHeight ? lineHeight : fontSize, totalSize;
      }
    }, {
      key: "_measureReduce",
      value: function _measureReduce(text, processor) {
        var _this$textSpec4 = this.textSpec,
          fontSize = _this$textSpec4.fontSize,
          lineHeight = _this$textSpec4.lineHeight,
          defaultResult = {
            width: 0,
            height: 0
          };
        if (isNil(text)) return defaultResult;
        if (isArray(text)) {
          var textArr = text.filter(isValid).map(function (s) {
            return s.toString();
          });
          return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
            width: textArr.reduce(function (maxWidth, cur) {
              return Math.max(maxWidth, processor(cur).width);
            }, 0),
            height: textArr.length * ((null != lineHeight ? lineHeight : fontSize) + 1) + 1
          };
        }
        return processor(text.toString());
      }
    }, {
      key: "_measureNumberChar",
      value: function _measureNumberChar() {
        if (isNil(this._numberCharSize)) {
          var numberBounds = this._standardMethod(TextMeasure.NUMBERS_CHAR_SET);
          this._numberCharSize = {
            width: numberBounds.width / TextMeasure.NUMBERS_CHAR_SET.length,
            height: numberBounds.height
          };
        }
        return this._numberCharSize;
      }
    }, {
      key: "_measureFullSizeChar",
      value: function _measureFullSizeChar() {
        return isNil(this._fullCharSize) && (this._fullCharSize = this._standardMethod(TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
      }
    }, {
      key: "_measureLetterChar",
      value: function _measureLetterChar() {
        if (isNil(this._letterCharSize)) {
          var alphabetBounds = this._standardMethod(TextMeasure.ALPHABET_CHAR_SET);
          this._letterCharSize = {
            width: alphabetBounds.width / TextMeasure.ALPHABET_CHAR_SET.length,
            height: alphabetBounds.height
          };
        }
        return this._letterCharSize;
      }
    }, {
      key: "_measureSpecialChar",
      value: function _measureSpecialChar(_char3) {
        return isValid(this._specialCharSizeMap[_char3]) ? this._specialCharSizeMap[_char3] : this.specialCharSet.includes(_char3) ? (this._specialCharSizeMap[_char3] = this._standardMethod(_char3), this._specialCharSizeMap[_char3]) : null;
      }
    }, {
      key: "release",
      value: function release() {
        isValid(this._canvas) && (this._canvas = null), isValid(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = !1), this._context = null);
      }
    }]);
    return TextMeasure;
  }();
  TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure.NUMBERS_CHAR_SET = "0123456789", TextMeasure.FULL_SIZE_CHAR = "";

  const circleThreshold = tau - 1e-8;
  class BoundsContext {
      bounds;
      constructor(bounds) {
          this.init(bounds);
      }
      init(bounds) {
          this.bounds = bounds;
      }
      arc(cx, cy, r, sa, ea, ccw) {
          if (Math.abs(ea - sa) > circleThreshold) {
              this.bounds.add(cx - r, cy - r);
              this.bounds.add(cx + r, cy + r);
              return;
          }
          let xmin = Infinity;
          let xmax = -Infinity;
          let ymin = Infinity;
          let ymax = -Infinity;
          let s;
          let i;
          let x;
          let y;
          function update(a) {
              x = r * Math.cos(a);
              y = r * Math.sin(a);
              if (x < xmin) {
                  xmin = x;
              }
              if (x > xmax) {
                  xmax = x;
              }
              if (y < ymin) {
                  ymin = y;
              }
              if (y > ymax) {
                  ymax = y;
              }
          }
          update(sa);
          update(ea);
          if (ea !== sa) {
              sa = sa % tau;
              if (sa < 0) {
                  sa += tau;
              }
              ea = ea % tau;
              if (ea < 0) {
                  ea += tau;
              }
              if (ea < sa) {
                  ccw = !ccw;
                  s = sa;
                  sa = ea;
                  ea = s;
              }
              if (ccw) {
                  ea -= tau;
                  s = sa - (sa % halfPi$1);
                  for (i = 0; i < 4 && s > ea; ++i, s -= halfPi$1) {
                      update(s);
                  }
              }
              else {
                  s = sa - (sa % halfPi$1) + halfPi$1;
                  for (i = 0; i < 4 && s < ea; ++i, s = s + halfPi$1) {
                      update(s);
                  }
              }
          }
          this.bounds.add(cx + xmin, cy + ymin);
          this.bounds.add(cx + xmax, cy + ymax);
      }
      arcTo(x1, y1, x2, y2, radius) {
          throw new Error('arcTo');
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
          this.bounds.add(cp1x, cp1y);
          this.bounds.add(cp2x, cp2y);
          this.bounds.add(x, y);
      }
      closePath() {
      }
      ellipse() {
          throw new Error('ellipse');
      }
      lineTo(x, y) {
          this.bounds.add(x, y);
      }
      moveTo(x, y) {
          this.bounds.add(x, y);
      }
      quadraticCurveTo(cpx, cpy, x, y) {
          this.bounds.add(cpx, cpy);
          this.bounds.add(x, y);
      }
      rect(x, y, w, h) {
          this.bounds.add(x, y);
          this.bounds.add(x + w, y + h);
      }
      clear() {
          this.bounds.clear();
      }
      release(...params) {
          return;
      }
  }

  class CurvePath {
      curves;
      bounds;
      constructor() {
          this.curves = [];
          this.bounds = new AABBBounds();
      }
      getCurveLengths() {
          return this.curves.map(curve => curve.getLength());
      }
      getPointAt(t) {
          return { x: 0, y: 0 };
      }
      getLength() {
          return 0;
      }
      getBounds() {
          return this.bounds;
      }
  }

  const rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi;
  const commandLengths = {
      m: 2,
      l: 2,
      h: 1,
      v: 1,
      c: 6,
      s: 4,
      q: 4,
      t: 2,
      a: 7,
      M: 2,
      L: 2,
      H: 1,
      V: 1,
      C: 6,
      S: 4,
      Q: 4,
      T: 2,
      A: 7
  };
  const enumCommandMap = {
      A: 0,
      AT: 1,
      C: 2,
      Z: 3,
      E: 4,
      L: 5,
      M: 6,
      Q: 7,
      R: 8
  };
  let currPath;
  let coordsStr;
  let commandChar;
  let coordStr;
  let coordNumber;
  let standardCommandLen;
  function parseSvgPath(str) {
      if (!str) {
          return [];
      }
      const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
      if (paths === null) {
          return [];
      }
      let currCommandData;
      let coordsStrArr;
      const result = [];
      for (let i = 0, len = paths.length; i < len; i++) {
          currPath = paths[i];
          coordsStr = currPath.slice(1);
          commandChar = currPath[0];
          currCommandData = [commandChar];
          coordsStrArr = coordsStr.match(rePathCommand);
          if (coordsStrArr === null) {
              result.push(currCommandData);
              continue;
          }
          for (let i = 0, len = coordsStrArr.length; i < len; i++) {
              coordStr = coordsStrArr[i];
              coordNumber = parseFloat(coordStr);
              if (!Number.isNaN(coordNumber)) {
                  currCommandData.push(coordNumber);
              }
          }
          standardCommandLen = commandLengths[commandChar];
          if (currCommandData.length - 1 > standardCommandLen) {
              let subCommand;
              for (let i = 1, len = currCommandData.length; i < len; i += standardCommandLen) {
                  subCommand = [commandChar];
                  for (let j = i, subLen = i + standardCommandLen; j < subLen; j++) {
                      subCommand.push(currCommandData[j]);
                  }
                  result.push(subCommand);
              }
          }
          else {
              result.push(currCommandData);
          }
      }
      return result;
  }

  exports.UpdateTag = void 0;
  (function (UpdateTag) {
      UpdateTag[UpdateTag["NONE"] = 0] = "NONE";
      UpdateTag[UpdateTag["UPDATE_BOUNDS"] = 1] = "UPDATE_BOUNDS";
      UpdateTag[UpdateTag["UPDATE_SHAPE"] = 2] = "UPDATE_SHAPE";
      UpdateTag[UpdateTag["CLEAR_SHAPE"] = 253] = "CLEAR_SHAPE";
      UpdateTag[UpdateTag["UPDATE_SHAPE_AND_BOUNDS"] = 3] = "UPDATE_SHAPE_AND_BOUNDS";
      UpdateTag[UpdateTag["INIT"] = 51] = "INIT";
      UpdateTag[UpdateTag["CLEAR_BOUNDS"] = 254] = "CLEAR_BOUNDS";
      UpdateTag[UpdateTag["UPDATE_GLOBAL_MATRIX"] = 32] = "UPDATE_GLOBAL_MATRIX";
      UpdateTag[UpdateTag["CLEAR_GLOBAL_MATRIX"] = 223] = "CLEAR_GLOBAL_MATRIX";
      UpdateTag[UpdateTag["UPDATE_LOCAL_MATRIX"] = 16] = "UPDATE_LOCAL_MATRIX";
      UpdateTag[UpdateTag["CLEAR_LOCAL_MATRIX"] = 239] = "CLEAR_LOCAL_MATRIX";
      UpdateTag[UpdateTag["UPDATE_GLOBAL_LOCAL_MATRIX"] = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX";
  })(exports.UpdateTag || (exports.UpdateTag = {}));
  exports.IContainPointMode = void 0;
  (function (IContainPointMode) {
      IContainPointMode[IContainPointMode["GLOBAL"] = 1] = "GLOBAL";
      IContainPointMode[IContainPointMode["LOCAL"] = 16] = "LOCAL";
      IContainPointMode[IContainPointMode["GLOBAL_ACCURATE"] = 3] = "GLOBAL_ACCURATE";
      IContainPointMode[IContainPointMode["LOCAL_ACCURATE"] = 48] = "LOCAL_ACCURATE";
  })(exports.IContainPointMode || (exports.IContainPointMode = {}));
  exports.AttributeUpdateType = void 0;
  (function (AttributeUpdateType) {
      AttributeUpdateType[AttributeUpdateType["INIT"] = 0] = "INIT";
      AttributeUpdateType[AttributeUpdateType["DEFAULT"] = 1] = "DEFAULT";
      AttributeUpdateType[AttributeUpdateType["STATE"] = 2] = "STATE";
      AttributeUpdateType[AttributeUpdateType["ANIMATE_BIND"] = 10] = "ANIMATE_BIND";
      AttributeUpdateType[AttributeUpdateType["ANIMATE_PLAY"] = 11] = "ANIMATE_PLAY";
      AttributeUpdateType[AttributeUpdateType["ANIMATE_START"] = 12] = "ANIMATE_START";
      AttributeUpdateType[AttributeUpdateType["ANIMATE_UPDATE"] = 13] = "ANIMATE_UPDATE";
      AttributeUpdateType[AttributeUpdateType["ANIMATE_END"] = 14] = "ANIMATE_END";
      AttributeUpdateType[AttributeUpdateType["TRANSLATE"] = 20] = "TRANSLATE";
      AttributeUpdateType[AttributeUpdateType["TRANSLATE_TO"] = 21] = "TRANSLATE_TO";
      AttributeUpdateType[AttributeUpdateType["SCALE"] = 22] = "SCALE";
      AttributeUpdateType[AttributeUpdateType["SCALE_TO"] = 23] = "SCALE_TO";
      AttributeUpdateType[AttributeUpdateType["ROTATE"] = 24] = "ROTATE";
      AttributeUpdateType[AttributeUpdateType["ROTATE_TO"] = 25] = "ROTATE_TO";
  })(exports.AttributeUpdateType || (exports.AttributeUpdateType = {}));
  exports.AnimateStatus = void 0;
  (function (AnimateStatus) {
      AnimateStatus[AnimateStatus["INITIAL"] = 0] = "INITIAL";
      AnimateStatus[AnimateStatus["RUNNING"] = 1] = "RUNNING";
      AnimateStatus[AnimateStatus["PAUSED"] = 2] = "PAUSED";
      AnimateStatus[AnimateStatus["END"] = 3] = "END";
  })(exports.AnimateStatus || (exports.AnimateStatus = {}));
  exports.AnimateMode = void 0;
  (function (AnimateMode) {
      AnimateMode[AnimateMode["NORMAL"] = 0] = "NORMAL";
      AnimateMode[AnimateMode["SET_ATTR_IMMEDIATELY"] = 1] = "SET_ATTR_IMMEDIATELY";
  })(exports.AnimateMode || (exports.AnimateMode = {}));
  exports.AnimateStepType = void 0;
  (function (AnimateStepType) {
      AnimateStepType["wait"] = "wait";
      AnimateStepType["from"] = "from";
      AnimateStepType["to"] = "to";
      AnimateStepType["customAnimate"] = "customAnimate";
  })(exports.AnimateStepType || (exports.AnimateStepType = {}));
  exports.Direction = void 0;
  (function (Direction) {
      Direction[Direction["ROW"] = 1] = "ROW";
      Direction[Direction["COLUMN"] = 2] = "COLUMN";
  })(exports.Direction || (exports.Direction = {}));
  exports.CurveTypeEnum = void 0;
  (function (CurveTypeEnum) {
      CurveTypeEnum[CurveTypeEnum["CubicBezierCurve"] = 0] = "CubicBezierCurve";
      CurveTypeEnum[CurveTypeEnum["QuadraticBezierCurve"] = 1] = "QuadraticBezierCurve";
      CurveTypeEnum[CurveTypeEnum["ArcCurve"] = 2] = "ArcCurve";
      CurveTypeEnum[CurveTypeEnum["LineCurve"] = 3] = "LineCurve";
      CurveTypeEnum[CurveTypeEnum["EllipseCurve"] = 4] = "EllipseCurve";
      CurveTypeEnum[CurveTypeEnum["MoveCurve"] = 5] = "MoveCurve";
  })(exports.CurveTypeEnum || (exports.CurveTypeEnum = {}));
  exports.BaseRenderContributionTime = void 0;
  (function (BaseRenderContributionTime) {
      BaseRenderContributionTime[BaseRenderContributionTime["beforeFillStroke"] = 0] = "beforeFillStroke";
      BaseRenderContributionTime[BaseRenderContributionTime["afterFillStroke"] = 1] = "afterFillStroke";
  })(exports.BaseRenderContributionTime || (exports.BaseRenderContributionTime = {}));

  function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
      const th = degreeToRadian(rotateX);
      const sin_th = Math.sin(th);
      const cos_th = Math.cos(th);
      rx = Math.abs(rx);
      ry = Math.abs(ry);
      const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
      const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
      let pl = (px * px) / (rx * rx) + (py * py) / (ry * ry);
      if (pl > 1) {
          pl = Math.sqrt(pl);
          rx *= pl;
          ry *= pl;
      }
      const a00 = cos_th / rx;
      const a01 = sin_th / rx;
      const a10 = -sin_th / ry;
      const a11 = cos_th / ry;
      const x0 = a00 * ox + a01 * oy;
      const y0 = a10 * ox + a11 * oy;
      const x1 = a00 * x + a01 * y;
      const y1 = a10 * x + a11 * y;
      const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
      let sfactor_sq = 1 / d - 0.25;
      if (sfactor_sq < 0) {
          sfactor_sq = 0;
      }
      let sfactor = Math.sqrt(sfactor_sq);
      if (sweep === large) {
          sfactor = -sfactor;
      }
      const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
      const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
      const th0 = Math.atan2(y0 - yc, x0 - xc);
      const th1 = Math.atan2(y1 - yc, x1 - xc);
      let th_arc = th1 - th0;
      if (th_arc < 0 && sweep === 1) {
          th_arc += tau;
      }
      else if (th_arc > 0 && sweep === 0) {
          th_arc -= tau;
      }
      const segs = Math.ceil(Math.abs(th_arc / (halfPi$1 + 0.001)));
      const result = [];
      for (let i = 0; i < segs; ++i) {
          const th2 = th0 + (i * th_arc) / segs;
          const th3 = th0 + ((i + 1) * th_arc) / segs;
          result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
      }
      return result;
  }
  function bezier(params) {
      const cx = params[0];
      const cy = params[1];
      const th0 = params[2];
      const th1 = params[3];
      const rx = params[4];
      const ry = params[5];
      const sin_th = params[6];
      const cos_th = params[7];
      const a00 = cos_th * rx;
      const a01 = -sin_th * ry;
      const a10 = sin_th * rx;
      const a11 = cos_th * ry;
      const cos_th0 = Math.cos(th0);
      const sin_th0 = Math.sin(th0);
      const cos_th1 = Math.cos(th1);
      const sin_th1 = Math.sin(th1);
      const th_half = 0.5 * (th1 - th0);
      const sin_th_h2 = Math.sin(th_half * 0.5);
      const t = ((8 / 3) * sin_th_h2 * sin_th_h2) / Math.sin(th_half);
      const x1 = cx + cos_th0 - t * sin_th0;
      const y1 = cy + sin_th0 + t * cos_th0;
      const x3 = cx + cos_th1;
      const y3 = cy + sin_th1;
      const x2 = x3 + t * sin_th1;
      const y2 = y3 - t * cos_th1;
      return [
          a00 * x1 + a01 * y1,
          a10 * x1 + a11 * y1,
          a00 * x2 + a01 * y2,
          a10 * x2 + a11 * y2,
          a00 * x3 + a01 * y3,
          a10 * x3 + a11 * y3
      ];
  }
  function drawArc(context, x, y, coords) {
      const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
      for (let i = 0; i < seg.length; ++i) {
          const bez = bezier(seg[i]);
          context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
      }
  }
  const addArcToBezierPath$1 = (bezierPath, startAngle, endAngle, cx, cy, rx, ry) => {
      const delta = Math.abs(endAngle - startAngle);
      const len = (Math.tan(delta / 4) * 4) / 3;
      const dir = endAngle < startAngle ? -1 : 1;
      const c1 = Math.cos(startAngle);
      const s1 = Math.sin(startAngle);
      const c2 = Math.cos(endAngle);
      const s2 = Math.sin(endAngle);
      const x1 = c1 * rx + cx;
      const y1 = s1 * ry + cy;
      const x4 = c2 * rx + cx;
      const y4 = s2 * ry + cy;
      const hx = rx * len * dir;
      const hy = ry * len * dir;
      bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  };

  const commandFuncs = [
      (command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, (command[3] * (sx + sy)) / 2, command[4], command[5], command[6], z),
      (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, (command[5] * (sx + sy)) / 2, z),
      (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z),
      (command, context, x, y) => context.closePath(),
      (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]),
      (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z),
      (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z),
      (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z),
      (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z)
  ];
  function renderCommandList(commandList, context, x = 0, y = 0, sx = 1, sy = 1, z) {
      for (let i = 0; i < commandList.length; i++) {
          const command = commandList[i];
          commandFuncs[command[0]](command, context, x, y, sx, sy, z);
      }
  }

  class Curve {
      type;
      p0;
      defined;
      length;
      getLength(direction) {
          if (direction != null) {
              return this.calcProjLength(direction);
          }
          if (Number.isFinite(this.length)) {
              return this.length;
          }
          this.length = this.calcLength();
          return this.length;
      }
  }

  function snapLength(xArr, yArr) {
      let totalLength = 0;
      const count = xArr.length;
      for (let i = 0; i < count; i++) {
          const x = xArr[i];
          const y = yArr[i];
          const nextX = xArr[(i + 1) % count];
          const nextY = yArr[(i + 1) % count];
          totalLength += PointService.distanceNN(x, y, nextX, nextY);
      }
      return totalLength / 2;
  }
  function cubicLength(p0, p1, p2, p3, iterationCount) {
      return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
  }
  function cubicCalc(p0, p1, p2, p3, t) {
      const one = 1 - t;
      return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
  }
  function cubicPointAt(p0, p1, p2, p3, t) {
      const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t);
      const y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
      return new Point(x, y);
  }

  function divideCubic(curve, t) {
      const { p0, p1, p2, p3 } = curve;
      const pt = cubicPointAt(p0, p1, p2, p3, t);
      const c1 = PointService.pointAtPP(p0, p1, t);
      const c2 = PointService.pointAtPP(p1, p2, t);
      const c3 = PointService.pointAtPP(p2, p3, t);
      const c12 = PointService.pointAtPP(c1, c2, t);
      const c23 = PointService.pointAtPP(c2, c3, t);
      const curve1 = new CubicBezierCurve(p0, c1, c12, pt);
      const curve2 = new CubicBezierCurve(pt, c23, c3, p3);
      return [curve1, curve2];
  }
  class CubicBezierCurve extends Curve {
      type = exports.CurveTypeEnum.CubicBezierCurve;
      constructor(p0, p1, p2, p3) {
          super();
          this.p0 = p0;
          this.p1 = p1;
          this.p2 = p2;
          this.p3 = p3;
      }
      _validPoint() {
          return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
      }
      getPointAt(t) {
          if (this.defined !== false) {
              return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
          }
          throw new Error('definedfalsegetPointAt');
      }
      calcLength() {
          if (this._validPoint()) {
              return cubicLength(this.p0, this.p1, this.p2, this.p3);
          }
          return 60;
      }
      calcProjLength(direction) {
          if (direction === exports.Direction.ROW) {
              return abs(this.p0.x - this.p3.x);
          }
          else if (direction === exports.Direction.COLUMN) {
              return abs(this.p0.y - this.p3.y);
          }
          return 0;
      }
      getAngleAt(t) {
          const minT = max(t - 0.01, 0);
          const maxT = min(t + 0.01, 1);
          const minP = this.getPointAt(minT);
          const maxP = this.getPointAt(maxT);
          return atan2(maxP.y - minP.y, maxP.x - minP.x);
      }
  }

  function divideLinear(curve, t) {
      const { p0, p1 } = curve;
      const c1 = PointService.pointAtPP(p0, p1, t);
      const curve1 = new LineCurve(p0, c1);
      const curve2 = new LineCurve(c1, p1);
      return [curve1, curve2];
  }
  class LineCurve extends Curve {
      type = exports.CurveTypeEnum.LineCurve;
      constructor(p0, p1) {
          super();
          this.p0 = p0;
          this.p1 = p1;
      }
      getPointAt(t) {
          if (this.defined !== false) {
              return PointService.pointAtPP(this.p0, this.p1, t);
          }
          throw new Error('definedfalsegetPointAt');
      }
      getAngleAt(t) {
          if (this.angle == null) {
              this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
          }
          return this.angle;
      }
      _validPoint() {
          return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
      }
      calcLength() {
          if (this._validPoint()) {
              return PointService.distancePP(this.p0, this.p1);
          }
          return 60;
      }
      calcProjLength(direction) {
          if (direction === exports.Direction.ROW) {
              return abs(this.p0.x - this.p1.x);
          }
          else if (direction === exports.Direction.COLUMN) {
              return abs(this.p0.y - this.p1.y);
          }
          return 0;
      }
  }

  class SegContext {
      _lastX;
      _lastY;
      _startX;
      _startY;
      get endX() {
          return this._lastX;
      }
      get endY() {
          return this._lastY;
      }
      curves;
      direction;
      curveType;
      length;
      constructor(curveType, direction) {
          this.init(curveType, direction);
      }
      init(curveType, direction) {
          this._lastX = this._lastY = this._startX = this._startY = 0;
          this.curveType = curveType;
          this.direction = direction;
          this.curves = [];
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined) {
          const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
          curve.defined = defined;
          this.curves.push(curve);
          this._lastX = x;
          this._lastY = y;
      }
      closePath() {
          if (this.curves.length < 2) {
              return;
          }
          const lastCurve = this.curves[this.curves.length - 1];
          this.lineTo(this._startX, this._startY, lastCurve.defined);
      }
      ellipse() {
          throw new Error('SegContextellipse');
      }
      lineTo(x, y, defined) {
          const curve = this.addLinearCurve(x, y, defined);
          this.curves.push(curve);
          this._lastX = x;
          this._lastY = y;
      }
      moveTo(x, y) {
          this._lastX = this._startX = x;
          this._lastY = this._startY = y;
          return this;
      }
      quadraticCurveTo(cpx, cpy, x, y) {
          throw new Error('SegContextquadraticCurveTo');
      }
      clear() {
          this.curves = [];
          this.length = NaN;
      }
      tryUpdateLength(direction) {
          return this.getLength(direction);
      }
      addLinearCurve(x, y, defined) {
          const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
          curve.defined = defined;
          return curve;
      }
      getPointAt(t) {
          throw new Error('');
      }
      getCurveLengths() {
          return [];
      }
      getLength(direction) {
          if (direction === exports.Direction.COLUMN) {
              if (!this.curves.length) {
                  return 0;
              }
              const sc = this.curves[0];
              const ec = this.curves[this.curves.length - 1];
              return abs(sc.p0.y - ec.p1.y);
          }
          else if (direction === exports.Direction.ROW) {
              if (!this.curves.length) {
                  return 0;
              }
              const sc = this.curves[0];
              const ec = this.curves[this.curves.length - 1];
              return abs(sc.p0.x - ec.p1.x);
          }
          if (Number.isFinite(this.length)) {
              return this.length;
          }
          this.length = this.curves.reduce((l, c) => l + c.getLength(), 0);
          return this.length;
      }
  }
  class ReflectSegContext extends SegContext {
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined) {
          return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined);
      }
      lineTo(x, y, defined) {
          return super.lineTo(y, x, defined);
      }
      moveTo(x, y) {
          return super.moveTo(y, x);
      }
      clear() {
          return super.clear();
      }
  }

  function genCurveSegments(path, points, step = 1) {
      let defined0 = false;
      for (let i = 0, n = points.length; i <= n; i++) {
          if (i >= n === defined0) {
              if ((defined0 = !defined0)) {
                  path.lineStart();
              }
              else {
                  path.lineEnd();
              }
          }
          if (defined0) {
              path.point(points[i]);
          }
      }
  }

  class Linear {
      _lastDefined;
      startPoint;
      constructor(context, startPoint) {
          this.context = context;
          startPoint && (this.startPoint = startPoint);
      }
      _x;
      _y;
      _x0;
      _x1;
      _y0;
      _y1;
      _line;
      _point;
      areaStart() {
          this._line = 0;
      }
      areaEnd() {
          this._line = NaN;
      }
      lineStart() {
          this._point = 0;
          this.startPoint && this.point(this.startPoint);
      }
      lineEnd() {
          if (this._line || (this._line !== 0 && this._point === 1)) {
              this.context.closePath();
          }
          this._line = 1 - this._line;
      }
      point(p) {
          const x = p.x;
          const y = p.y;
          switch (this._point) {
              case 0:
                  this._point = 1;
                  this._line
                      ? this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false)
                      : this.context.moveTo(x, y);
                  break;
              case 1:
                  this._point = 2;
              default:
                  this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false);
                  break;
          }
          this._lastDefined = p.defined;
      }
      tryUpdateLength() {
          return this.context.tryUpdateLength();
      }
  }
  function genLinearSegments(points, params = {}) {
      const { direction, startPoint } = params;
      if (points.length < 2 - Number(!!startPoint)) {
          return null;
      }
      const segContext = new SegContext('linear', direction ??
          (abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y)
              ? exports.Direction.ROW
              : exports.Direction.COLUMN));
      const linear = new Linear(segContext, startPoint);
      genLinearTypeSegments(linear, points);
      return segContext;
  }
  function genLinearTypeSegments(path, points) {
      return genCurveSegments(path, points, 1);
  }

  function point$2(curveClass, x, y, defined) {
      curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined);
  }
  class Basis {
      _lastDefined1;
      _lastDefined2;
      startPoint;
      constructor(context, startPoint) {
          this.context = context;
          this.startPoint = startPoint;
      }
      _x;
      _y;
      _x0;
      _x1;
      _y0;
      _y1;
      _line;
      _point;
      areaStart() {
          this._line = 0;
      }
      areaEnd() {
          this._line = NaN;
      }
      lineStart() {
          this._x0 = this._x1 = this._y0 = this._y1 = NaN;
          this._point = 0;
          this.startPoint && this.point(this.startPoint);
      }
      lineEnd() {
          switch (this._point) {
              case 2:
                  point$2(this, this._x1 * 6 - (this._x0 + 4 * this._x1), this._y1 * 6 - (this._y0 + 4 * this._y1), this._lastDefined1 !== false && this._lastDefined2 !== false);
          }
          if (this._line || (this._line !== 0 && this._point === 1)) {
              this.context.closePath();
          }
          this._line = 1 - this._line;
      }
      point(p) {
          const x = p.x;
          const y = p.y;
          switch (this._point) {
              case 0:
                  this._point = 1;
                  this._line
                      ? this.context.lineTo(x, y, this._lastDefined1 !== false && this._lastDefined2 !== false)
                      : this.context.moveTo(x, y);
                  break;
              case 1:
                  this._point = 2;
                  break;
              default:
                  point$2(this, x, y, this._lastDefined1 !== false && this._lastDefined2 !== false);
                  break;
          }
          (this._x0 = this._x1), (this._x1 = x);
          (this._y0 = this._y1), (this._y1 = y);
          this._lastDefined1 = this._lastDefined2;
          this._lastDefined2 = p.defined;
      }
      tryUpdateLength() {
          return this.context.tryUpdateLength();
      }
  }
  function genBasisTypeSegments(path, points) {
      return genCurveSegments(path, points, 2);
  }
  function genBasisSegments(points, params = {}) {
      const { direction, startPoint } = params;
      if (points.length < 2 - Number(!!startPoint)) {
          return null;
      }
      if (points.length < 3 - Number(!!startPoint)) {
          return genLinearSegments(points, params);
      }
      const segContext = new SegContext('basis', direction ??
          (abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y)
              ? exports.Direction.ROW
              : exports.Direction.COLUMN));
      const basis = new Basis(segContext, startPoint);
      genBasisTypeSegments(basis, points);
      return segContext;
  }

  function sign(x) {
      return x < 0 ? -1 : 1;
  }
  function slope3(curveClass, x2, y2) {
      const h0 = curveClass._x1 - curveClass._x0;
      const h1 = x2 - curveClass._x1;
      const s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0));
      const s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0));
      const p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }
  function slope2(curveClass, t) {
      const h = curveClass._x1 - curveClass._x0;
      return h ? ((3 * (curveClass._y1 - curveClass._y0)) / h - t) / 2 : t;
  }
  function point$1(curveClass, t0, t1, defined) {
      const x0 = curveClass._x0;
      const y0 = curveClass._y0;
      const x1 = curveClass._x1;
      const y1 = curveClass._y1;
      const dx = (x1 - x0) / 3;
      curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined);
  }
  class MonotoneX {
      _lastDefined1;
      _lastDefined2;
      startPoint;
      constructor(context, startPoint) {
          this.context = context;
          this.startPoint = startPoint;
      }
      _x;
      _y;
      _x0;
      _x1;
      _y0;
      _y1;
      _line;
      _point;
      areaStart() {
          this._line = 0;
      }
      areaEnd() {
          this._line = NaN;
      }
      lineStart() {
          this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
          this._point = 0;
          this.startPoint && this.point(this.startPoint);
      }
      lineEnd() {
          switch (this._point) {
              case 2:
                  this.context.lineTo(this._x1, this._y1, this._lastDefined2 !== false);
                  break;
              case 3:
                  point$1(this, this._t0, slope2(this, this._t0), this._lastDefined2 !== false);
                  break;
          }
          if (this._line || (this._line !== 0 && this._point === 1)) {
              this.context.closePath();
          }
          this._line = 1 - this._line;
      }
      point(p) {
          let t1 = NaN;
          const x = p.x;
          const y = p.y;
          if (x === this._x1 && y === this._y1) {
              return;
          }
          switch (this._point) {
              case 0:
                  this._point = 1;
                  this._line
                      ? this.context.lineTo(x, y, this._lastDefined1 !== false && this._lastDefined2 !== false)
                      : this.context.moveTo(x, y);
                  break;
              case 1:
                  this._point = 2;
                  break;
              case 2:
                  this._point = 3;
                  point$1(this, slope2(this, (t1 = slope3(this, x, y))), t1, this._lastDefined1 !== false && this._lastDefined2 !== false);
                  break;
              default:
                  point$1(this, this._t0, (t1 = slope3(this, x, y)), this._lastDefined1 !== false && this._lastDefined2 !== false);
                  break;
          }
          (this._x0 = this._x1), (this._x1 = x);
          (this._y0 = this._y1), (this._y1 = y);
          this._t0 = t1;
          this._lastDefined1 = this._lastDefined2;
          this._lastDefined2 = p.defined !== false;
      }
      tryUpdateLength() {
          return this.context.tryUpdateLength();
      }
  }
  class MonotoneY extends MonotoneX {
      constructor(context, startPoint) {
          super(context, startPoint);
      }
      point(p) {
          return super.point({ y: p.x, x: p.y, defined: p.defined });
      }
  }
  function genMonotpneXTypeSegments(path, points) {
      return genCurveSegments(path, points, 2);
  }
  function genMonotoneXSegments(points, params = {}) {
      const { direction, startPoint } = params;
      if (points.length < 2 - Number(!!startPoint)) {
          return null;
      }
      if (points.length < 3 - Number(!!startPoint)) {
          return genLinearSegments(points, params);
      }
      const segContext = new SegContext('monotoneX', direction ??
          (abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y)
              ? exports.Direction.ROW
              : exports.Direction.COLUMN));
      const monotoneX = new MonotoneX(segContext, startPoint);
      genMonotpneXTypeSegments(monotoneX, points);
      return segContext;
  }
  function genMonotpneYTypeSegments(path, points) {
      return genCurveSegments(path, points, 2);
  }
  function genMonotoneYSegments(points, params = {}) {
      const { direction, startPoint } = params;
      if (points.length < 2 - Number(!!startPoint)) {
          return null;
      }
      if (points.length < 3 - Number(!!startPoint)) {
          return genLinearSegments(points, params);
      }
      const segContext = new ReflectSegContext('monotoneY', direction ??
          (abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y)
              ? exports.Direction.ROW
              : exports.Direction.COLUMN));
      const monotoneY = new MonotoneY(segContext, startPoint);
      genMonotpneYTypeSegments(monotoneY, points);
      return segContext;
  }

  let Step$1 = class Step {
      _lastDefined;
      startPoint;
      constructor(context, t = 0.5, startPoint) {
          this.context = context;
          this._t = t;
          this.startPoint = startPoint;
      }
      _x;
      _y;
      _x0;
      _x1;
      _y0;
      _y1;
      _line;
      _point;
      areaStart() {
          this._line = 0;
      }
      areaEnd() {
          this._line = NaN;
      }
      lineStart() {
          this._x = this._y = NaN;
          this._point = 0;
          this.startPoint && this.point(this.startPoint);
      }
      lineEnd() {
          if (0 < this._t && this._t < 1 && this._point === 2) {
              this.context.lineTo(this._x, this._y, this._lastDefined !== false);
          }
          if (this._line || (this._line !== 0 && this._point === 1)) {
              this.context.closePath();
          }
          if (this._line >= 0) {
              (this._t = 1 - this._t), (this._line = 1 - this._line);
          }
      }
      point(p) {
          const x = p.x;
          const y = p.y;
          switch (this._point) {
              case 0:
                  this._point = 1;
                  this._line
                      ? this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false)
                      : this.context.moveTo(x, y);
                  break;
              case 1:
                  this._point = 2;
              default: {
                  if (this._t <= 0) {
                      this.context.lineTo(this._x, y, this._lastDefined !== false && p.defined !== false);
                      this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false);
                  }
                  else {
                      const x1 = this._x * (1 - this._t) + x * this._t;
                      this.context.lineTo(x1, this._y, this._lastDefined !== false && p.defined !== false);
                      this.context.lineTo(x1, y, this._lastDefined !== false && p.defined !== false);
                  }
                  break;
              }
          }
          this._lastDefined = p.defined;
          (this._x = x), (this._y = y);
      }
      tryUpdateLength() {
          return this.context.tryUpdateLength();
      }
  };
  function genStepSegments(points, t, params = {}) {
      const { direction, startPoint } = params;
      if (points.length < 2 - Number(!!startPoint)) {
          return null;
      }
      const segContext = new SegContext('step', direction ??
          (abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y)
              ? exports.Direction.ROW
              : exports.Direction.COLUMN));
      const step = new Step$1(segContext, t, startPoint);
      genStepTypeSegments(step, points);
      return segContext;
  }
  function genStepTypeSegments(path, points) {
      return genCurveSegments(path, points, 1);
  }

  class LinearClosed {
      _lastDefined;
      startPoint;
      constructor(context, startPoint) {
          this.context = context;
          startPoint && (this.startPoint = startPoint);
      }
      _x;
      _y;
      _x0;
      _x1;
      _y0;
      _y1;
      _line;
      _point;
      areaStart() {
          this._line = 0;
      }
      areaEnd() {
          this._line = NaN;
      }
      lineStart() {
          this._point = 0;
          this.startPoint && this.point(this.startPoint);
      }
      lineEnd() {
          this.context.closePath();
      }
      point(p) {
          const x = p.x;
          const y = p.y;
          switch (this._point) {
              case 0:
                  this._point = 1;
                  this._line
                      ? this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false)
                      : this.context.moveTo(x, y);
                  break;
              case 1:
                  this._point = 2;
              default:
                  this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false);
                  break;
          }
          this._lastDefined = p.defined;
      }
      tryUpdateLength() {
          return this.context.tryUpdateLength();
      }
  }
  function genLinearClosedSegments(points, params = {}) {
      const { direction, startPoint } = params;
      if (points.length < 2 - Number(!!startPoint)) {
          return null;
      }
      const segContext = new SegContext('linear', direction ??
          (abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y)
              ? exports.Direction.ROW
              : exports.Direction.COLUMN));
      const linear = new LinearClosed(segContext, startPoint);
      genLinearClosedTypeSegments(linear, points);
      return segContext;
  }
  function genLinearClosedTypeSegments(path, points) {
      return genCurveSegments(path, points, 1);
  }

  class CurveContext {
      _lastX;
      _lastY;
      _startX;
      _startY;
      constructor(path) {
          this.path = path;
          this._lastX = this._lastY = this._startX = this._startY = 0;
      }
      moveTo(x, y) {
          this._lastX = this._startX = x;
          this._lastY = this._startY = y;
          return this;
      }
      lineTo(x, y) {
          const curve = this.addLinearCurve(x, y);
          this.path.curves.push(curve);
          this._lastX = x;
          this._lastY = y;
      }
      addLinearCurve(x, y) {
          const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
          return curve;
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
          throw new Error('CurveContextquadraticCurveTo');
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
          const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
          this.path.curves.push(curve);
          this._lastX = x;
          this._lastY = y;
      }
      arcTo(aX1, aY1, aX2, aY2, aRadius) {
          throw new Error('CurveContextarcTo');
      }
      ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
          throw new Error('CurveContextellipse');
      }
      rect(x, y, w, h) {
          throw new Error('CurveContextrect');
      }
      arc(x, y, radius, startAngle, endAngle, counterclockwise) {
          throw new Error('CurveContextarc');
      }
      closePath() {
          if (this.path.curves.length < 2) {
              return;
          }
          this.lineTo(this._startX, this._startY);
      }
  }

  function calcLineCache$1(points, curveType, params) {
      switch (curveType) {
          case 'linear':
              return genLinearSegments(points, params);
          case 'basis':
              return genBasisSegments(points, params);
          case 'monotoneX':
              return genMonotoneXSegments(points, params);
          case 'monotoneY':
              return genMonotoneYSegments(points, params);
          case 'step':
              return genStepSegments(points, 0.5, params);
          case 'stepBefore':
              return genStepSegments(points, 0, params);
          case 'stepAfter':
              return genStepSegments(points, 1, params);
          case 'linearClosed':
              return genLinearClosedSegments(points, params);
          default:
              return genLinearSegments(points, params);
      }
  }

  class CustomPath2D extends CurvePath {
      commandList = [];
      _boundsContext;
      _ctx;
      direction;
      transformCbList;
      toStringCbList;
      constructor(ctx) {
          super();
          if (ctx) {
              this._ctx = ctx;
          }
          this._boundsContext = new BoundsContext(this.bounds);
      }
      setCtx(ctx) {
          this._ctx = ctx;
      }
      moveTo(x, y) {
          this.commandList.push([enumCommandMap.M, x, y]);
          this._ctx && this._ctx.moveTo(x, y);
          return this;
      }
      lineTo(x, y) {
          this.commandList.push([enumCommandMap.L, x, y]);
          this._ctx && this._ctx.lineTo(x, y);
          return this;
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
          this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]);
          this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY);
          return this;
      }
      bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
          this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]);
          this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
          return this;
      }
      arcTo(aX1, aY1, aX2, aY2, aRadius) {
          this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]);
          this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius);
          return this;
      }
      ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
          this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]);
          this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise);
          return this;
      }
      rect(x, y, w, h) {
          this.commandList.push([enumCommandMap.R, x, y, w, h]);
          this._ctx && this._ctx.rect(x, y, w, h);
          return this;
      }
      arc(x, y, radius, startAngle, endAngle, counterclockwise) {
          this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]);
          this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise);
          return this;
      }
      closePath() {
          this.commandList.push([enumCommandMap.Z]);
          this._ctx && this._ctx.closePath();
          return this;
      }
      addCurve(curve) {
          this.curves.push(curve);
      }
      clear() {
          this.transformCbList = null;
          this.commandList.length = 0;
          this.curves.length = 0;
      }
      toString() {
          if (!this.toStringCbList) {
              const list = [];
              list[enumCommandMap.M] = (cmd) => `M${cmd[1]} ${cmd[2]}`;
              list[enumCommandMap.L] = (cmd) => `L${cmd[1]} ${cmd[2]}`;
              list[enumCommandMap.Q] = (cmd) => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`;
              list[enumCommandMap.C] = (cmd) => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`;
              list[enumCommandMap.A] = (cmd) => {
                  const bezierPathList = [];
                  addArcToBezierPath$1(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);
                  let path = '';
                  for (let i = 0; i < bezierPathList.length; i += 6) {
                      path += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
                  }
                  return path;
              };
              list[enumCommandMap.Z] = (cmd) => `Z`;
              this.toStringCbList = list;
          }
          const list = this.toStringCbList;
          let path = '';
          this.commandList.forEach(c => {
              path += list[c[0]](c);
          });
          return path;
      }
      fromString(str, x, y, sX, sY) {
          this.clear();
          const commandStrList = parseSvgPath(str);
          this._runCommandStrList(commandStrList, x, y, sX, sY);
          this._updateBounds();
          return this;
      }
      fromLine(line) {
          const { points, curveType, clipRangeByDimension } = line.attribute;
          if (!points) {
              return;
          }
          const cache = calcLineCache$1(points, curveType);
          if (clipRangeByDimension === 'x') {
              this.direction = exports.Direction.ROW;
          }
          else if (clipRangeByDimension === 'y') {
              this.direction = exports.Direction.COLUMN;
          }
          else if (clipRangeByDimension === 'auto') {
              this.direction = cache.direction;
          }
          this.curves = cache.curves;
      }
      fromCustomPath2D(path, x, y, sX, sY) {
          this.clear();
          this._runCommandList(path.commandList, x, y, sX, sY);
          this._updateBounds();
          return this;
      }
      transform(x, y, sx, sy) {
          const commandList = this.commandList;
          if (!this.transformCbList) {
              const list = [];
              list[enumCommandMap.M] = this.moveToTransform;
              list[enumCommandMap.L] = this.lineToTransform;
              list[enumCommandMap.Q] = this.quadraticCurveToTransform;
              list[enumCommandMap.C] = this.bezierCurveToTransform;
              list[enumCommandMap.AT] = this.arcToTransform;
              list[enumCommandMap.E] = this.ellipseTransform;
              list[enumCommandMap.R] = this.rectTransform;
              list[enumCommandMap.A] = this.arcTransform;
              list[enumCommandMap.Z] = this.closePathTransform;
              this.transformCbList = list;
          }
          commandList.forEach(cmd => {
              this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
          });
          this._updateBounds();
      }
      moveToTransform(cmd, x, y, sx, sy) {
          cmd[1] = cmd[1] * sx + x;
          cmd[2] = cmd[2] * sy + y;
      }
      lineToTransform(cmd, x, y, sx, sy) {
          cmd[1] = cmd[1] * sx + x;
          cmd[2] = cmd[2] * sy + y;
      }
      quadraticCurveToTransform(cmd, x, y, sx, sy) {
          cmd[1] = cmd[1] * sx + x;
          cmd[2] = cmd[2] * sy + y;
          cmd[3] = cmd[3] * sx + x;
          cmd[4] = cmd[4] * sy + y;
      }
      bezierCurveToTransform(cmd, x, y, sx, sy) {
          cmd[1] = cmd[1] * sx + x;
          cmd[2] = cmd[2] * sy + y;
          cmd[3] = cmd[3] * sx + x;
          cmd[4] = cmd[4] * sy + y;
          cmd[5] = cmd[5] * sx + x;
          cmd[6] = cmd[6] * sy + y;
      }
      arcToTransform(cmd, x, y, sx, sy) {
          cmd[1] = cmd[1] * sx + x;
          cmd[2] = cmd[2] * sy + y;
          cmd[3] = cmd[3] * sx + x;
          cmd[4] = cmd[4] * sy + y;
          cmd[5] = (cmd[5] * (sx + sy)) / 2;
      }
      ellipseTransform(cmd, x, y, sx, sy) {
          cmd[1] = cmd[1] * sx + x;
          cmd[2] = cmd[2] * sy + y;
          cmd[3] = cmd[3] * sx;
          cmd[4] = cmd[4] * sy;
      }
      rectTransform(cmd, x, y, sx, sy) {
          cmd[1] = cmd[1] * sx + x;
          cmd[2] = cmd[2] * sy + y;
          cmd[3] = cmd[3] * sx;
          cmd[4] = cmd[4] * sy;
      }
      arcTransform(cmd, x, y, sx, sy) {
          cmd[1] = cmd[1] * sx + x;
          cmd[2] = cmd[2] * sy + y;
          cmd[3] = (cmd[3] * (sx + sy)) / 2;
      }
      closePathTransform() {
          return;
      }
      _runCommandStrList(commandStrList, l = 0, t = 0, sX = 1, sY = 1) {
          let current;
          let previous = null;
          let x = 0;
          let y = 0;
          let controlX = 0;
          let controlY = 0;
          let tempX;
          let tempY;
          let tempControlX;
          let tempControlY;
          for (let i = 0, len = commandStrList.length; i < len; ++i) {
              current = commandStrList[i];
              if (sX !== 1 || sY !== 1) {
                  current = scale$1(current, sX, sY);
              }
              switch (current[0]) {
                  case 'l':
                      x += current[1];
                      y += current[2];
                      this.lineTo(x + l, y + t);
                      break;
                  case 'L':
                      x = current[1];
                      y = current[2];
                      this.lineTo(x + l, y + t);
                      break;
                  case 'h':
                      x += current[1];
                      this.lineTo(x + l, y + t);
                      break;
                  case 'H':
                      x = current[1];
                      this.lineTo(x + l, y + t);
                      break;
                  case 'v':
                      y += current[1];
                      this.lineTo(x + l, y + t);
                      break;
                  case 'V':
                      y = current[1];
                      this.lineTo(x + l, y + t);
                      break;
                  case 'm':
                      x += current[1];
                      y += current[2];
                      this.moveTo(x + l, y + t);
                      break;
                  case 'M':
                      x = current[1];
                      y = current[2];
                      this.moveTo(x + l, y + t);
                      break;
                  case 'c':
                      tempX = x + current[5];
                      tempY = y + current[6];
                      controlX = x + current[3];
                      controlY = y + current[4];
                      this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t);
                      x = tempX;
                      y = tempY;
                      break;
                  case 'C':
                      x = current[5];
                      y = current[6];
                      controlX = current[3];
                      controlY = current[4];
                      this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
                      break;
                  case 's':
                      tempX = x + current[3];
                      tempY = y + current[4];
                      controlX = 2 * x - controlX;
                      controlY = 2 * y - controlY;
                      this.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t);
                      controlX = x + current[1];
                      controlY = y + current[2];
                      x = tempX;
                      y = tempY;
                      break;
                  case 'S':
                      tempX = current[3];
                      tempY = current[4];
                      controlX = 2 * x - controlX;
                      controlY = 2 * y - controlY;
                      this.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
                      x = tempX;
                      y = tempY;
                      controlX = current[1];
                      controlY = current[2];
                      break;
                  case 'q':
                      tempX = x + current[3];
                      tempY = y + current[4];
                      controlX = x + current[1];
                      controlY = y + current[2];
                      this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                      x = tempX;
                      y = tempY;
                      break;
                  case 'Q':
                      tempX = current[3];
                      tempY = current[4];
                      this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
                      x = tempX;
                      y = tempY;
                      controlX = current[1];
                      controlY = current[2];
                      break;
                  case 't':
                      tempX = x + current[1];
                      tempY = y + current[2];
                      if (previous[0].match(/[QqTt]/) === null) {
                          controlX = x;
                          controlY = y;
                      }
                      else if (previous[0] === 't') {
                          controlX = 2 * x - tempControlX;
                          controlY = 2 * y - tempControlY;
                      }
                      else if (previous[0] === 'q') {
                          controlX = 2 * x - controlX;
                          controlY = 2 * y - controlY;
                      }
                      tempControlX = controlX;
                      tempControlY = controlY;
                      this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                      x = tempX;
                      y = tempY;
                      controlX = x + current[1];
                      controlY = y + current[2];
                      break;
                  case 'T':
                      tempX = current[1];
                      tempY = current[2];
                      controlX = 2 * x - controlX;
                      controlY = 2 * y - controlY;
                      this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                      x = tempX;
                      y = tempY;
                      break;
                  case 'a':
                      drawArc(this, x + l, y + t, [
                          current[1],
                          current[2],
                          current[3],
                          current[4],
                          current[5],
                          current[6] + x + l,
                          current[7] + y + t
                      ]);
                      x += current[6];
                      y += current[7];
                      break;
                  case 'A':
                      drawArc(this, x + l, y + t, [
                          current[1],
                          current[2],
                          current[3],
                          current[4],
                          current[5],
                          current[6] + l,
                          current[7] + t
                      ]);
                      x = current[6];
                      y = current[7];
                      break;
                  case 'z':
                  case 'Z':
                      this.closePath();
                      break;
              }
              previous = current;
          }
      }
      _runCommandList(commandList, l = 0, t = 0, sX = 1, sY = 1) {
          if (l === 0 && t === 0 && sX === 1 && sY === 1) {
              this.commandList = commandList.map(entry => entry.slice());
              return;
          }
          for (let i = 0, len = commandList.length; i < len; ++i) {
              const current = commandList[i].slice();
              switch (current[0]) {
                  case enumCommandMap.L:
                      this.lineToTransform(current, l, t, sX, sY);
                      break;
                  case enumCommandMap.M:
                      this.moveToTransform(current, l, t, sX, sY);
                      break;
                  case enumCommandMap.C:
                      this.bezierCurveToTransform(current, l, t, sX, sY);
                      break;
                  case enumCommandMap.Q:
                      this.quadraticCurveToTransform(current, l, t, sX, sY);
                      break;
                  case enumCommandMap.A:
                      this.arcToTransform(current, l, t, sX, sY);
                      break;
                  case enumCommandMap.E:
                      this.ellipseTransform(current, l, t, sX, sY);
                      break;
                  case enumCommandMap.R:
                      this.rectTransform(current, l, t, sX, sY);
                      break;
                  case enumCommandMap.AT:
                      this.arcToTransform(current, l, t, sX, sY);
                      break;
                  case enumCommandMap.Z:
                      this.closePath();
                      break;
              }
          }
      }
      _updateBounds() {
          this.bounds.clear();
          renderCommandList(this.commandList, this._boundsContext);
      }
      release() {
          this.commandList = [];
          this._boundsContext = null;
          this._ctx = null;
      }
      getLength() {
          if (this.direction === exports.Direction.COLUMN) {
              if (!this.curves.length) {
                  return 0;
              }
              const sc = this.curves[0];
              const ec = this.curves[this.curves.length - 1];
              return abs(sc.p0.y - ec.p1.y);
          }
          else if (this.direction === exports.Direction.ROW) {
              if (!this.curves.length) {
                  return 0;
              }
              const sc = this.curves[0];
              const ec = this.curves[this.curves.length - 1];
              return abs(sc.p0.x - ec.p1.x);
          }
          return this.curves.reduce((l, c) => l + c.getLength(), 0);
      }
      getAttrAt(distance) {
          if (!this.curves) {
              return { pos: { x: 0, y: 0 }, angle: 0 };
          }
          let _dis = 0;
          let curve;
          for (let i = 0; i < this.curves.length; i++) {
              curve = this.curves[i];
              const cl = curve.getLength(this.direction);
              if (_dis + cl >= distance) {
                  break;
              }
              else {
                  _dis += cl;
              }
          }
          const t = (distance - _dis) / curve.getLength(this.direction);
          const pos = curve.getPointAt(t);
          const angle = curve.getAngleAt(t);
          return { pos, angle };
      }
  }
  const temp = ['l', 0, 0, 0, 0, 0, 0, 0];
  function scale$1(current, sX, sY) {
      const c = (temp[0] = current[0]);
      if (c === 'a' || c === 'A') {
          temp[1] = sX * current[1];
          temp[2] = sY * current[2];
          temp[3] = current[3];
          temp[4] = current[4];
          temp[5] = current[5];
          temp[6] = sX * current[6];
          temp[7] = sY * current[7];
      }
      else if (c === 'h' || c === 'H') {
          temp[1] = sX * current[1];
      }
      else if (c === 'v' || c === 'V') {
          temp[1] = sY * current[1];
      }
      else {
          for (let i = 1, n = current.length; i < n; ++i) {
              temp[i] = (i % 2 === 1 ? sX : sY) * current[i];
          }
      }
      return temp;
  }

  const DefaultTransform = {
      x: 0,
      y: 0,
      z: 0,
      dx: 0,
      dy: 0,
      dz: 0,
      scrollX: 0,
      scrollY: 0,
      scaleX: 1,
      scaleY: 1,
      scaleZ: 1,
      angle: 0,
      alpha: 0,
      beta: 0,
      anchor: [0, 0],
      anchor3d: [0, 0],
      postMatrix: new Matrix()
  };
  const DefaultFillStyle = {
      fillOpacity: 1,
      fill: false,
      shadowBlur: 0,
      shadowColor: 'black',
      shadowOffsetX: 0,
      shadowOffsetY: 0
  };
  const commonStroke = {
      strokeOpacity: 1,
      lineDash: [],
      lineDashOffset: 0,
      lineWidth: 1,
      lineCap: 'butt',
      lineJoin: 'miter',
      miterLimit: 10,
      strokeBoundsBuffer: 2,
      stroke: false
  };
  const DefaultStrokeStyle = {
      outerBorder: { ...commonStroke, distance: 0 },
      innerBorder: { ...commonStroke, distance: 0 },
      ...commonStroke
  };
  const DefaultTextStyle = {
      text: '',
      maxLineWidth: Infinity,
      textAlign: 'left',
      textBaseline: 'alphabetic',
      fontSize: 16,
      fontFamily: `PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,
    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol`,
      fontWeight: '',
      ellipsis: '',
      fontVariant: '',
      fontStyle: '',
      lineHeight: undefined,
      underline: 0,
      lineThrough: 0,
      scaleIn3d: false
  };
  const DefaultStyle = {
      opacity: 1,
      background: null,
      texture: null,
      textureColor: 'black',
      textureSize: 10,
      texturePadding: 2,
      backgroundMode: 0,
      blur: 0,
      cursor: null,
      ...DefaultFillStyle,
      ...DefaultStrokeStyle
  };
  const DefaultAttribute = {
      strokeSeg: null,
      pickable: true,
      childrenPickable: true,
      visible: true,
      zIndex: 0,
      layout: null,
      boundsPadding: 0,
      pickMode: 'accurate',
      customPickShape: null,
      boundsMode: 'accurate',
      keepDirIn3d: true,
      ...DefaultStyle,
      ...DefaultTransform
  };
  function addAttributeToPrototype(obj, c, keys) {
      keys.forEach(key => {
          c.prototype[key] = obj[key];
      });
  }
  function rewriteProto(obj, c) {
      Object.setPrototypeOf(obj, c);
  }
  const DefaultArcAttribute = {
      ...DefaultAttribute,
      startAngle: 0,
      endAngle: pi2,
      innerRadius: 0,
      outerRadius: 1,
      cornerRadius: 0,
      padRadius: 0,
      padAngle: 0,
      cap: false,
      forceShowCap: false
  };
  const DefaultAreaAttribute = {
      ...DefaultAttribute,
      points: [],
      segments: [],
      curveType: 'linear',
      clipRange: 1
  };
  const DefaultCircleAttribute = {
      ...DefaultAttribute,
      radius: 1,
      startAngle: 0,
      endAngle: pi2
  };
  const DefaultGroupAttribute = {
      ...DefaultAttribute,
      width: 0,
      height: 0,
      cornerRadius: 0,
      path: [],
      clip: false,
      visibleAll: true
  };
  const DefaultGlyphAttribute = {
      ...DefaultAttribute,
      path: '',
      width: 0,
      height: 0,
      cornerRadius: 0,
      clip: false
  };
  const DefaultLineAttribute = {
      ...DefaultAttribute,
      points: [],
      segments: [],
      curveType: 'linear',
      clipRange: 1,
      clipRangeByDimension: 'default'
  };
  const DefaultPathAttribute = {
      ...DefaultAttribute,
      path: new CustomPath2D(),
      customPath: () => {
          console.warn('');
      }
  };
  const DefaultPolygonAttribute = {
      ...DefaultAttribute,
      points: [],
      cornerRadius: 0
  };
  const DefaultRectAttribute = {
      ...DefaultAttribute,
      width: 0,
      height: 0,
      strokeBoundsBuffer: 0,
      cornerRadius: 0
  };
  const DefaultRect3dAttribute = {
      ...DefaultAttribute,
      width: 0,
      height: 0,
      cornerRadius: 0,
      length: 0
  };
  const DefaultSymbolAttribute = {
      ...DefaultAttribute,
      symbolType: 'circle',
      size: 10,
      keepDirIn3d: true
  };
  const DefaultTextAttribute = {
      ...DefaultAttribute,
      ...DefaultTextStyle,
      strokeBoundsBuffer: 0,
      keepDirIn3d: true
  };
  const DefaultRichTextAttribute = {
      ...DefaultAttribute,
      width: 300,
      height: 300,
      ellipsis: true,
      wordBreak: 'break-word',
      verticalDirection: 'top',
      textAlign: 'left',
      textBaseline: 'top',
      layoutDirection: 'horizontal',
      textConfig: [],
      maxHeight: undefined,
      maxWidth: undefined,
      singleLine: false
  };
  const DefaultImageAttribute = {
      repeatX: 'no-repeat',
      repeatY: 'no-repeat',
      image: '',
      width: 0,
      height: 0,
      ...DefaultAttribute,
      fill: true
  };
  const DefaultRichTextIconAttribute = {
      ...DefaultImageAttribute,
      backgroundShowMode: 'never',
      backgroundWidth: 0,
      backgroundHeight: 0,
      textAlign: 'left',
      textBaseline: 'middle',
      direction: 'horizontal',
      margin: 0,
      id: '',
      width: 20,
      height: 20,
      backgroundFill: 'rgba(101, 117, 168, 0.1)',
      backgroundFillOpacity: 1,
      backgroundStroke: false,
      backgroundStrokeOpacity: 1,
      backgroundRadius: 4,
      opacity: 1
  };

  let ATextMeasure = class ATextMeasure {
      release;
      canvas;
      context;
      configure(service, env) {
          this.canvas = service.canvas;
          this.context = service.context;
          service.bindTextMeasure(this);
      }
      measureTextWidth(text, options) {
          if (!this.context) {
              return this.estimate(text, options).width;
          }
          this.context.setTextStyleWithoutAlignBaseline(options);
          const textMeasure = this.context.measureText(text);
          return textMeasure.width;
      }
      estimate(text, { fontSize = DefaultTextAttribute.fontSize }) {
          let eCharLen = 0;
          let cCharLen = 0;
          for (let i = 0; i < text.length; i++) {
              text.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
          }
          return {
              width: ~~(0.8 * eCharLen * fontSize + cCharLen * fontSize),
              height: fontSize
          };
      }
      measureTextPixelHeight(text, options) {
          if (!this.context) {
              return options.fontSize ?? DefaultTextStyle.fontSize;
          }
          this.context.setTextStyleWithoutAlignBaseline(options);
          const textMeasure = this.context.measureText(text);
          return Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent);
      }
      measureTextBoundHieght(text, options) {
          if (!this.context) {
              return options.fontSize ?? DefaultTextStyle.fontSize;
          }
          this.context.setTextStyleWithoutAlignBaseline(options);
          const textMeasure = this.context.measureText(text);
          return Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent);
      }
      measureText(text, options) {
          if (!this.context) {
              return this.estimate(text, options);
          }
          this.context.setTextStyleWithoutAlignBaseline(options);
          return this.context.measureText(text);
      }
      clipText(text, options, width) {
          if (text.length === 0) {
              return { str: '', width: 0 };
          }
          let length = this.measureTextWidth(text, options);
          if (length <= width) {
              return { str: text, width: length };
          }
          length = this.measureTextWidth(text[0], options);
          if (length > width) {
              return { str: '', width: 0 };
          }
          return this._clipText(text, options, width, 0, text.length - 1);
      }
      _clipText(text, options, width, leftIdx, rightIdx) {
          const middleIdx = Math.floor((leftIdx + rightIdx) / 2);
          const subText = text.substring(0, middleIdx + 1);
          const strWidth = this.measureTextWidth(subText, options);
          let length;
          if (strWidth > width) {
              if (subText.length <= 1) {
                  return { str: '', width: 0 };
              }
              const str = text.substring(0, middleIdx);
              length = this.measureTextWidth(str, options);
              if (length <= width) {
                  return { str, width: length };
              }
              return this._clipText(text, options, width, leftIdx, middleIdx);
          }
          else if (strWidth < width) {
              if (middleIdx >= text.length - 1) {
                  return { str: text, width: this.measureTextWidth(text, options) };
              }
              const str = text.substring(0, middleIdx + 2);
              length = this.measureTextWidth(str, options);
              if (length >= width) {
                  return { str: subText, width: strWidth };
              }
              return this._clipText(text, options, width, middleIdx, rightIdx);
          }
          return { str: subText, width: strWidth };
      }
      clipTextWithSuffix(text, options, width, suffix) {
          if (suffix === '') {
              return this.clipText(text, options, width);
          }
          if (text.length === 0) {
              return { str: '', width: 0 };
          }
          const length = this.measureTextWidth(text, options);
          if (length <= width) {
              return { str: text, width: length };
          }
          const suffixWidth = this.measureTextWidth(suffix, options);
          if (suffixWidth > width) {
              return { str: '', width: 0 };
          }
          width -= suffixWidth;
          const data = this._clipText(text, options, width, 0, text.length - 1);
          data.str += suffix;
          data.width += suffixWidth;
          return data;
      }
  };
  ATextMeasure = __decorate([
      injectable()
  ], ATextMeasure);

  const TextMeasureContribution = Symbol.for('TextMeasureContribution');
  let DefaultTextMeasureContribution = class DefaultTextMeasureContribution extends ATextMeasure {
  };
  DefaultTextMeasureContribution = __decorate([
      injectable()
  ], DefaultTextMeasureContribution);

  const container = new Container();

  class Application {
      global;
      graphicUtil;
      graphicService;
      transformUtil;
      layerService;
  }
  const application = new Application();

  const CanvasFactory = Symbol.for('CanvasFactory');
  const Context2dFactory = Symbol.for('Context2dFactory');

  function wrapCanvas(params) {
      return container.getNamed(CanvasFactory, application.global.env)(params);
  }
  const EPSILON_NUMERIC = 1e-4;
  const THREE_SQRT = Math.sqrt(3);
  const ONE_THIRD = 1 / 3;
  function isAroundZero(val) {
      return val > -EPSILON && val < EPSILON;
  }
  function isNotAroundZero(val) {
      return val > EPSILON || val < -EPSILON;
  }
  const _v0 = [0, 0];
  const _v1 = [0, 0];
  const _v2 = [0, 0];
  function distanceSquare(v1, v2) {
      return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
  }
  function quadraticAt(p0, p1, p2, t) {
      const onet = 1 - t;
      return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
  }
  function cubicAt(p0, p1, p2, p3, t) {
      const onet = 1 - t;
      return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
  }
  function quadraticRootAt(p0, p1, p2, val, roots) {
      const a = p0 - 2 * p1 + p2;
      const b = 2 * (p1 - p0);
      const c = p0 - val;
      let n = 0;
      if (isAroundZero(a)) {
          if (isNotAroundZero(b)) {
              const t1 = -c / b;
              if (t1 >= 0 && t1 <= 1) {
                  roots[n++] = t1;
              }
          }
      }
      else {
          const disc = b * b - 4 * a * c;
          if (isAroundZero(disc)) {
              const t1 = -b / (2 * a);
              if (t1 >= 0 && t1 <= 1) {
                  roots[n++] = t1;
              }
          }
          else if (disc > 0) {
              const discSqrt = Math.sqrt(disc);
              const t1 = (-b + discSqrt) / (2 * a);
              const t2 = (-b - discSqrt) / (2 * a);
              if (t1 >= 0 && t1 <= 1) {
                  roots[n++] = t1;
              }
              if (t2 >= 0 && t2 <= 1) {
                  roots[n++] = t2;
              }
          }
      }
      return n;
  }
  function quadraticExtremum(p0, p1, p2) {
      const divider = p0 + p2 - 2 * p1;
      if (divider === 0) {
          return 0.5;
      }
      return (p0 - p1) / divider;
  }
  function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
      let t = 0;
      let interval = 0.005;
      let d = Infinity;
      _v0[0] = x;
      _v0[1] = y;
      for (let _t = 0; _t < 1; _t += 0.05) {
          _v1[0] = quadraticAt(x0, x1, x2, _t);
          _v1[1] = quadraticAt(y0, y1, y2, _t);
          const d1 = distanceSquare(_v0, _v1);
          if (d1 < d) {
              t = _t;
              d = d1;
          }
      }
      d = Infinity;
      for (let i = 0; i < 32; i++) {
          if (interval < EPSILON_NUMERIC) {
              break;
          }
          const prev = t - interval;
          const next = t + interval;
          _v1[0] = quadraticAt(x0, x1, x2, prev);
          _v1[1] = quadraticAt(y0, y1, y2, prev);
          const d1 = distanceSquare(_v1, _v0);
          if (prev >= 0 && d1 < d) {
              t = prev;
              d = d1;
          }
          else {
              _v2[0] = quadraticAt(x0, x1, x2, next);
              _v2[1] = quadraticAt(y0, y1, y2, next);
              const d2 = distanceSquare(_v2, _v0);
              if (next <= 1 && d2 < d) {
                  t = next;
                  d = d2;
              }
              else {
                  interval *= 0.5;
              }
          }
      }
      if (out) {
          out[0] = quadraticAt(x0, x1, x2, t);
          out[1] = quadraticAt(y0, y1, y2, t);
      }
      return Math.sqrt(d);
  }
  function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
      let t = 0;
      let interval = 0.005;
      let d = Infinity;
      let prev;
      let next;
      let d1;
      let d2;
      _v0[0] = x;
      _v0[1] = y;
      for (let _t = 0; _t < 1; _t += 0.05) {
          _v1[0] = cubicAt(x0, x1, x2, x3, _t);
          _v1[1] = cubicAt(y0, y1, y2, y3, _t);
          d1 = distanceSquare(_v0, _v1);
          if (d1 < d) {
              t = _t;
              d = d1;
          }
      }
      d = Infinity;
      for (let i = 0; i < 32; i++) {
          if (interval < EPSILON_NUMERIC) {
              break;
          }
          prev = t - interval;
          next = t + interval;
          _v1[0] = cubicAt(x0, x1, x2, x3, prev);
          _v1[1] = cubicAt(y0, y1, y2, y3, prev);
          d1 = distanceSquare(_v1, _v0);
          if (prev >= 0 && d1 < d) {
              t = prev;
              d = d1;
          }
          else {
              _v2[0] = cubicAt(x0, x1, x2, x3, next);
              _v2[1] = cubicAt(y0, y1, y2, y3, next);
              d2 = distanceSquare(_v2, _v0);
              if (next <= 1 && d2 < d) {
                  t = next;
                  d = d2;
              }
              else {
                  interval *= 0.5;
              }
          }
      }
      if (out) {
          out[0] = cubicAt(x0, x1, x2, x3, t);
          out[1] = cubicAt(y0, y1, y2, y3, t);
      }
      return Math.sqrt(d);
  }
  function normalizeRadian(angle) {
      angle %= pi2;
      if (angle < 0) {
          angle += pi2;
      }
      return angle;
  }
  function windingLine(x0, y0, x1, y1, x, y) {
      if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
          return 0;
      }
      if (y1 === y0) {
          return 0;
      }
      const t = (y - y0) / (y1 - y0);
      let dir = y1 < y0 ? 1 : -1;
      if (t === 1 || t === 0) {
          dir = y1 < y0 ? 0.5 : -0.5;
      }
      const x_ = t * (x1 - x0) + x0;
      return x_ === x ? Infinity : x_ > x ? dir : 0;
  }
  function containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
      if (lineWidth === 0) {
          return false;
      }
      const _l = lineWidth;
      if ((y > y0 + _l && y > y1 + _l && y > y2 + _l) ||
          (y < y0 - _l && y < y1 - _l && y < y2 - _l) ||
          (x > x0 + _l && x > x1 + _l && x > x2 + _l) ||
          (x < x0 - _l && x < x1 - _l && x < x2 - _l)) {
          return false;
      }
      const d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
      return d <= _l / 2;
  }
  function containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
      if (lineWidth === 0) {
          return false;
      }
      const _l = lineWidth;
      if ((y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l) ||
          (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l) ||
          (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l) ||
          (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)) {
          return false;
      }
      const d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
      return d <= _l / 2;
  }
  function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
      if (lineWidth === 0) {
          return false;
      }
      const _l = lineWidth;
      x -= cx;
      y -= cy;
      const d = Math.sqrt(x * x + y * y);
      if (d - _l > r || d + _l < r) {
          return false;
      }
      if (Math.abs(startAngle - endAngle) % pi2 < 1e-4) {
          return true;
      }
      if (anticlockwise) {
          const tmp = startAngle;
          startAngle = normalizeRadian(endAngle);
          endAngle = normalizeRadian(tmp);
      }
      else {
          startAngle = normalizeRadian(startAngle);
          endAngle = normalizeRadian(endAngle);
      }
      if (startAngle > endAngle) {
          endAngle += pi2;
      }
      let angle = Math.atan2(y, x);
      if (angle < 0) {
          angle += pi2;
      }
      return (angle >= startAngle && angle <= endAngle) || (angle + pi2 >= startAngle && angle + pi2 <= endAngle);
  }
  function containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {
      if (lineWidth === 0) {
          return false;
      }
      const _l = lineWidth;
      const _halfL = lineWidth / 2;
      let _a = 0;
      let _b = x0;
      if ((y > y0 + _halfL && y > y1 + _halfL) ||
          (y < y0 - _halfL && y < y1 - _halfL) ||
          (x > x0 + _halfL && x > x1 + _halfL) ||
          (x < x0 - _halfL && x < x1 - _halfL)) {
          return false;
      }
      if (x0 !== x1) {
          _a = (y0 - y1) / (x0 - x1);
          _b = (x0 * y1 - x1 * y0) / (x0 - x1);
      }
      else {
          return Math.abs(x - x0) <= _l / 2;
      }
      const tmp = _a * x - y + _b;
      const _s = (tmp * tmp) / (_a * _a + 1);
      return _s <= ((_l / 2) * _l) / 2;
  }
  const EPSILON = 1e-4;
  function cubicRootAt(p0, p1, p2, p3, val, roots) {
      const a = p3 + 3 * (p1 - p2) - p0;
      const b = 3 * (p2 - p1 * 2 + p0);
      const c = 3 * (p1 - p0);
      const d = p0 - val;
      const A = b * b - 3 * a * c;
      const B = b * c - 9 * a * d;
      const C = c * c - 3 * b * d;
      let n = 0;
      if (isAroundZero(A) && isAroundZero(B)) {
          if (isAroundZero(b)) {
              roots[0] = 0;
          }
          else {
              const t1 = -c / b;
              if (t1 >= 0 && t1 <= 1) {
                  roots[n++] = t1;
              }
          }
      }
      else {
          const disc = B * B - 4 * A * C;
          if (isAroundZero(disc)) {
              const K = B / A;
              const t1 = -b / a + K;
              const t2 = -K / 2;
              if (t1 >= 0 && t1 <= 1) {
                  roots[n++] = t1;
              }
              if (t2 >= 0 && t2 <= 1) {
                  roots[n++] = t2;
              }
          }
          else if (disc > 0) {
              const discSqrt = Math.sqrt(disc);
              let Y1 = A * b + 1.5 * a * (-B + discSqrt);
              let Y2 = A * b + 1.5 * a * (-B - discSqrt);
              if (Y1 < 0) {
                  Y1 = -Math.pow(-Y1, ONE_THIRD);
              }
              else {
                  Y1 = Math.pow(Y1, ONE_THIRD);
              }
              if (Y2 < 0) {
                  Y2 = -Math.pow(-Y2, ONE_THIRD);
              }
              else {
                  Y2 = Math.pow(Y2, ONE_THIRD);
              }
              const t1 = (-b - (Y1 + Y2)) / (3 * a);
              if (t1 >= 0 && t1 <= 1) {
                  roots[n++] = t1;
              }
          }
          else {
              const T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));
              const theta = Math.acos(T) / 3;
              const ASqrt = Math.sqrt(A);
              const tmp = Math.cos(theta);
              const t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
              const t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
              const t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
              if (t1 >= 0 && t1 <= 1) {
                  roots[n++] = t1;
              }
              if (t2 >= 0 && t2 <= 1) {
                  roots[n++] = t2;
              }
              if (t3 >= 0 && t3 <= 1) {
                  roots[n++] = t3;
              }
          }
      }
      return n;
  }
  function cubicExtrema(p0, p1, p2, p3, extrema) {
      const b = 6 * p2 - 12 * p1 + 6 * p0;
      const a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
      const c = 3 * p1 - 3 * p0;
      let n = 0;
      if (isAroundZero(a)) {
          if (isNotAroundZero(b)) {
              const t1 = -c / b;
              if (t1 >= 0 && t1 <= 1) {
                  extrema[n++] = t1;
              }
          }
      }
      else {
          const disc = b * b - 4 * a * c;
          if (isAroundZero(disc)) {
              extrema[0] = -b / (2 * a);
          }
          else if (disc > 0) {
              const discSqrt = Math.sqrt(disc);
              const t1 = (-b + discSqrt) / (2 * a);
              const t2 = (-b - discSqrt) / (2 * a);
              if (t1 >= 0 && t1 <= 1) {
                  extrema[n++] = t1;
              }
              if (t2 >= 0 && t2 <= 1) {
                  extrema[n++] = t2;
              }
          }
      }
      return n;
  }
  function isAroundEqual(a, b) {
      return Math.abs(a - b) < EPSILON;
  }
  const roots = [-1, -1, -1];
  const extrema = [-1, -1];
  function swapExtrema() {
      const tmp = extrema[0];
      extrema[0] = extrema[1];
      extrema[1] = tmp;
  }
  function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
      if ((y > y0 && y > y1 && y > y2 && y > y3) || (y < y0 && y < y1 && y < y2 && y < y3)) {
          return 0;
      }
      const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
      if (nRoots === 0) {
          return 0;
      }
      let w = 0;
      let nExtrema = -1;
      let y0_ = 0;
      let y1_ = 0;
      for (let i = 0; i < nRoots; i++) {
          const t = roots[i];
          const unit = t === 0 || t === 1 ? 0.5 : 1;
          const x_ = cubicAt(x0, x1, x2, x3, t);
          if (x_ < x) {
              continue;
          }
          if (nExtrema < 0) {
              nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
              if (extrema[1] < extrema[0] && nExtrema > 1) {
                  swapExtrema();
              }
              y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
              if (nExtrema > 1) {
                  y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
              }
          }
          if (nExtrema === 2) {
              if (t < extrema[0]) {
                  w += y0_ < y0 ? unit : -unit;
              }
              else if (t < extrema[1]) {
                  w += y1_ < y0_ ? unit : -unit;
              }
              else {
                  w += y3 < y1_ ? unit : -unit;
              }
          }
          else {
              if (t < extrema[0]) {
                  w += y0_ < y0 ? unit : -unit;
              }
              else {
                  w += y3 < y0_ ? unit : -unit;
              }
          }
      }
      return w;
  }
  function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
      if ((y > y0 && y > y1 && y > y2) || (y < y0 && y < y1 && y < y2)) {
          return 0;
      }
      const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
      if (nRoots === 0) {
          return 0;
      }
      const t = quadraticExtremum(y0, y1, y2);
      if (t >= 0 && t <= 1) {
          let w = 0;
          const y_ = quadraticAt(y0, y1, y2, t);
          for (let i = 0; i < nRoots; i++) {
              const unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
              const x_ = quadraticAt(x0, x1, x2, roots[i]);
              if (x_ < x) {
                  continue;
              }
              if (roots[i] < t) {
                  w += y_ < y0 ? unit : -unit;
              }
              else {
                  w += y2 < y_ ? unit : -unit;
              }
          }
          return w;
      }
      const unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      const x_ = quadraticAt(x0, x1, x2, roots[0]);
      if (x_ < x) {
          return 0;
      }
      return y2 < y0 ? unit : -unit;
  }
  function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
      y -= cy;
      if (y > r || y < -r) {
          return 0;
      }
      const tmp = Math.sqrt(r * r - y * y);
      roots[0] = -tmp;
      roots[1] = tmp;
      const dTheta = Math.abs(startAngle - endAngle);
      if (dTheta < 1e-4) {
          return 0;
      }
      if (dTheta >= pi2 - 1e-4) {
          startAngle = 0;
          endAngle = pi2;
          const dir = anticlockwise ? 1 : -1;
          if (x >= roots[0] + cx && x <= roots[1] + cx) {
              return dir;
          }
          return 0;
      }
      if (startAngle > endAngle) {
          const tmp = startAngle;
          startAngle = endAngle;
          endAngle = tmp;
      }
      if (startAngle < 0) {
          startAngle += pi2;
          endAngle += pi2;
      }
      let w = 0;
      for (let i = 0; i < 2; i++) {
          const x_ = roots[i];
          if (x_ + cx > x) {
              let angle = Math.atan2(y, x_);
              let dir = anticlockwise ? 1 : -1;
              if (angle < 0) {
                  angle = pi2 + angle;
              }
              if ((angle >= startAngle && angle <= endAngle) || (angle + pi2 >= startAngle && angle + pi2 <= endAngle)) {
                  if (angle > pi / 2 && angle < pi * 1.5) {
                      dir = -dir;
                  }
                  w += dir;
              }
          }
      }
      return w;
  }
  function modpi2(radian) {
      const n = Math.round((radian / pi) * 1e8) / 1e8;
      return (n % 2) * pi;
  }
  function normalizeArcAngles(angles, anticlockwise) {
      let newStartAngle = modpi2(angles[0]);
      if (newStartAngle < 0) {
          newStartAngle += pi2;
      }
      const delta = newStartAngle - angles[0];
      let newEndAngle = angles[1];
      newEndAngle += delta;
      if (!anticlockwise && newEndAngle - newStartAngle >= pi2) {
          newEndAngle = newStartAngle + pi2;
      }
      else if (anticlockwise && newStartAngle - newEndAngle >= pi2) {
          newEndAngle = newStartAngle - pi2;
      }
      else if (!anticlockwise && newStartAngle > newEndAngle) {
          newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle));
      }
      else if (anticlockwise && newStartAngle < newEndAngle) {
          newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle));
      }
      angles[0] = newStartAngle;
      angles[1] = newEndAngle;
  }
  const tmpAngles = [0, 0];
  function containPath(commands, lineWidth, isStroke, x, y) {
      const data = commands;
      const len = commands.length;
      let w = 0;
      let xi = 0;
      let yi = 0;
      let x0 = 0;
      let y0 = 0;
      let x1;
      let y1;
      for (let i = 0; i < len; i++) {
          const command = data[i];
          const isFirst = i === 0;
          if (command[0] === enumCommandMap.M && i > 1) {
              if (!isStroke) {
                  w += windingLine(xi, yi, x0, y0, x, y);
              }
          }
          if (isFirst) {
              xi = command[1];
              yi = command[2];
              x0 = xi;
              y0 = yi;
          }
          const c0 = command[0];
          const c1 = command[1];
          const c2 = command[2];
          const c3 = command[3];
          const c4 = command[4];
          const c5 = command[5];
          const c6 = command[6];
          let startAngle = c4;
          let endAngle = c5;
          tmpAngles[0] = startAngle;
          tmpAngles[1] = endAngle;
          normalizeArcAngles(tmpAngles, Boolean(command[6]));
          startAngle = tmpAngles[0];
          endAngle = tmpAngles[1];
          const theta = startAngle;
          const dTheta = endAngle - startAngle;
          const anticlockwise = !!(1 - (command[6] ? 0 : 1));
          const _x = ((x - c1) * c3) / c3 + c1;
          switch (c0) {
              case enumCommandMap.M:
                  x0 = c1;
                  y0 = c2;
                  xi = x0;
                  yi = y0;
                  break;
              case enumCommandMap.L:
                  if (isStroke) {
                      if (containLineStroke(xi, yi, c1, c2, lineWidth, x, y)) {
                          return true;
                      }
                  }
                  else {
                      w += windingLine(xi, yi, c1, c2, x, y) || 0;
                  }
                  xi = c1;
                  yi = c2;
                  break;
              case enumCommandMap.C:
                  if (isStroke) {
                      if (containCubicStroke(xi, yi, c1, c2, c3, c4, c5, c6, lineWidth, x, y)) {
                          return true;
                      }
                  }
                  else {
                      w += windingCubic(xi, yi, c1, c2, c3, c4, c5, c6, x, y) || 0;
                  }
                  xi = c5;
                  yi = c6;
                  break;
              case enumCommandMap.Q:
                  if (isStroke) {
                      if (containQuadStroke(xi, yi, c1, c2, c3, c4, lineWidth, x, y)) {
                          return true;
                      }
                  }
                  else {
                      w += windingQuadratic(xi, yi, c1, c2, c3, c4, x, y) || 0;
                  }
                  xi = c3;
                  yi = c4;
                  break;
              case enumCommandMap.A:
                  x1 = Math.cos(theta) * c3 + c1;
                  y1 = Math.sin(theta) * c3 + c2;
                  if (!isFirst) {
                      w += windingLine(xi, yi, x1, y1, x, y);
                  }
                  else {
                      x0 = x1;
                      y0 = y1;
                  }
                  if (isStroke) {
                      if (containArcStroke(c1, c2, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
                          return true;
                      }
                  }
                  else {
                      w += windingArc(c1, c2, c3, theta, theta + dTheta, anticlockwise, _x, y);
                  }
                  xi = Math.cos(theta + dTheta) * c3 + c1;
                  yi = Math.sin(theta + dTheta) * c3 + c2;
                  break;
              case enumCommandMap.R:
                  x0 = xi = c1;
                  y0 = yi = c2;
                  x1 = x0 + c3;
                  y1 = y0 + c4;
                  if (isStroke) {
                      if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) ||
                          containLineStroke(x1, y0, x1, y1, lineWidth, x, y) ||
                          containLineStroke(x1, y1, x0, y1, lineWidth, x, y) ||
                          containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) {
                          return true;
                      }
                  }
                  else {
                      w += windingLine(x1, y0, x1, y1, x, y);
                      w += windingLine(x0, y1, x0, y0, x, y);
                  }
                  break;
              case enumCommandMap.Z:
                  if (isStroke) {
                      if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) {
                          return true;
                      }
                  }
                  else {
                      w += windingLine(xi, yi, x0, y0, x, y);
                  }
                  xi = x0;
                  yi = y0;
                  break;
          }
      }
      if (!isStroke && !isAroundEqual(yi, y0)) {
          w += windingLine(xi, yi, x0, y0, x, y) || 0;
      }
      return w !== 0;
  }
  function contain(commands, x, y) {
      return containPath(commands, 0, false, x, y);
  }
  function containStroke(commands, lineWidth, x, y) {
      return containPath(commands, lineWidth, true, x, y);
  }

  exports.DefaultGraphicUtil = class DefaultGraphicUtil {
      contributions;
      global;
      canvas;
      context;
      _textMeasure;
      configured;
      constructor(contributions, global) {
          this.contributions = contributions;
          this.global = global;
          this.configured = false;
          this.global.hooks.onSetEnv.tap('graphic-util', (lastEnv, env, global) => {
              this.configured = false;
              this.configure(global, env);
          });
      }
      get textMeasure() {
          if (!this._textMeasure) {
              this.configure(this.global, this.global.env);
          }
          return this._textMeasure;
      }
      configure(global, env) {
          if (this.configured) {
              return;
          }
          const canvas = wrapCanvas({
              nativeCanvas: global.createCanvas({ width: 100, height: 100 })
          });
          this.canvas = canvas;
          this.context = canvas.getContext('2d');
          this.contributions.getContributions().forEach(contribution => {
              contribution.configure(this, env);
          });
          this.configured = true;
      }
      bindTextMeasure(tm) {
          this._textMeasure = tm;
      }
      measureText(text, tc, method = 'native') {
          this.configure(this.global, this.global.env);
          const m = this.global.measureTextMethod;
          this.global.measureTextMethod = method;
          const data = {
              width: this._textMeasure.measureTextWidth(text, tc),
              height: tc.fontSize ?? DefaultTextStyle.fontSize
          };
          this.global.measureTextMethod = m;
          return data;
      }
      createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
          this.configure(this.global, this.global.env);
          return new TextMeasure({
              defaultFontParams: {
                  fontFamily: DefaultTextStyle.fontFamily,
                  fontSize: DefaultTextStyle.fontSize
              },
              getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
              getTextBounds: undefined,
              specialCharSet: '-/: .,@%\'"~' + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase(),
              ...(option ?? {})
          }, textSpec);
      }
  };
  exports.DefaultGraphicUtil = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(TextMeasureContribution)),
      __param(1, inject(Global)),
      __metadata("design:paramtypes", [Object, Object])
  ], exports.DefaultGraphicUtil);
  var TransformMode;
  (function (TransformMode) {
      TransformMode[TransformMode["transform"] = 0] = "transform";
      TransformMode[TransformMode["matrix"] = 1] = "matrix";
  })(TransformMode || (TransformMode = {}));
  const _matrix = new Matrix();
  exports.DefaultTransformUtil = class DefaultTransformUtil {
      matrix;
      originTransform;
      outSourceMatrix;
      outTargetMatrix;
      mode;
      constructor() {
          this.matrix = new Matrix();
      }
      init(origin) {
          this.mode = TransformMode.transform;
          this.originTransform = origin;
          this.matrix.reset();
          return this;
      }
      fromMatrix(source, target) {
          this.mode = TransformMode.matrix;
          this.outSourceMatrix = source;
          this.outTargetMatrix = target;
          return this;
      }
      scaleMatrix(sx, sy, center) {
          const sMatrix = this.outSourceMatrix;
          _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f);
          this.outTargetMatrix.reset();
          if (center) {
              const { x, y } = center;
              this.outTargetMatrix.translate(x, y);
              this.outTargetMatrix.scale(sx, sy);
              this.outTargetMatrix.translate(-x, -y);
          }
          else {
              this.outTargetMatrix.scale(sx, sy);
          }
          this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f);
          return this;
      }
      scale(sx, sy, center) {
          if (this.mode === TransformMode.matrix) {
              return this.scaleMatrix(sx, sy, center);
          }
          return this;
      }
      translateMatrix(dx, dy) {
          const sMatrix = this.outSourceMatrix;
          _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f);
          this.outTargetMatrix.reset();
          this.outTargetMatrix.translate(dx, dy);
          this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f);
          return this;
      }
      translate(dx, dy) {
          if (this.mode === TransformMode.matrix) {
              return this.translateMatrix(dx, dy);
          }
          return this;
      }
      simplify(target) {
          if (this.mode === TransformMode.matrix) {
              return this.simplifyMatrix(target);
          }
          return this;
      }
      simplifyMatrix(target) {
          return this;
      }
  };
  exports.DefaultTransformUtil = __decorate([
      injectable(),
      __metadata("design:paramtypes", [])
  ], exports.DefaultTransformUtil);

  const defaultThemeObj = {
      arc: DefaultArcAttribute,
      area: DefaultAreaAttribute,
      circle: DefaultCircleAttribute,
      line: DefaultLineAttribute,
      path: DefaultPathAttribute,
      symbol: DefaultSymbolAttribute,
      text: DefaultTextAttribute,
      rect: DefaultRectAttribute,
      rect3d: DefaultRect3dAttribute,
      polygon: DefaultPolygonAttribute,
      richtext: DefaultRichTextAttribute,
      richtextIcon: DefaultRichTextIconAttribute,
      image: DefaultImageAttribute,
      group: DefaultGroupAttribute,
      glyph: DefaultGlyphAttribute
  };
  const themeKeys = Object.keys(defaultThemeObj);
  function newThemeObj() {
      return {
          arc: Object.assign({}, defaultThemeObj.arc),
          area: Object.assign({}, defaultThemeObj.area),
          circle: Object.assign({}, defaultThemeObj.circle),
          line: Object.assign({}, defaultThemeObj.line),
          path: Object.assign({}, defaultThemeObj.path),
          symbol: Object.assign({}, defaultThemeObj.symbol),
          text: Object.assign({}, defaultThemeObj.text),
          rect: Object.assign({}, defaultThemeObj.rect),
          rect3d: Object.assign({}, defaultThemeObj.rect3d),
          polygon: Object.assign({}, defaultThemeObj.polygon),
          richtext: Object.assign({}, defaultThemeObj.richtext),
          richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
          image: Object.assign({}, defaultThemeObj.image),
          group: Object.assign({}, defaultThemeObj.group),
          glyph: Object.assign({}, defaultThemeObj.glyph)
      };
  }
  function combineTheme(out, t, rewrite = true) {
      if (!t) {
          return;
      }
      if (rewrite) {
          Object.keys(t).forEach(k => {
              if (out[k]) {
                  Object.assign(out[k], t[k]);
              }
              else {
                  out[k] = t[k];
              }
          });
      }
      else {
          Object.keys(t).forEach(k => {
              if (out[k]) {
                  const outItem = out[k];
                  const tItem = t[k];
                  Object.keys(t[k]).forEach(kItem => {
                      if (outItem[kItem] === undefined) {
                          outItem[kItem] = tItem[kItem];
                      }
                  });
              }
              else {
                  out[k] = t[k];
              }
          });
      }
  }
  const staticThemePools = new Array(60).fill(0).map(() => newThemeObj());
  class Theme {
      combinedTheme;
      userTheme;
      commonTheme;
      _defaultTheme;
      dirty;
      constructor() {
          this._defaultTheme = staticThemePools.pop() || newThemeObj();
          this.combinedTheme = this._defaultTheme;
          this.dirty = false;
      }
      getTheme(group) {
          if (!group) {
              return this.combinedTheme;
          }
          if (!this.dirty) {
              return this.combinedTheme;
          }
          let parentTheme = {};
          const parentGroup = this.getParentWithTheme(group);
          if (parentGroup) {
              parentTheme = parentGroup.theme;
          }
          this.applyTheme(group, parentTheme);
          return this.combinedTheme;
      }
      getParentWithTheme(group) {
          while (group.parent) {
              group = group.parent;
              if (group.theme) {
                  return group;
              }
          }
          return null;
      }
      applyTheme(group, pt, force = false) {
          if (this.dirty) {
              const parentGroup = this.getParentWithTheme(group);
              if (parentGroup) {
                  const parentTheme = parentGroup.theme;
                  if (parentTheme.dirty || force) {
                      parentTheme.applyTheme(parentGroup, pt, true);
                  }
                  if (!this.userTheme) {
                      this.userTheme = clone(parentTheme.userTheme);
                  }
                  else {
                      combineTheme(this.userTheme, parentTheme.userTheme, false);
                  }
                  combineTheme(pt, parentTheme.userTheme);
              }
              if (!this.userTheme) {
                  if (parentGroup) {
                      this.combinedTheme = parentGroup.theme.combinedTheme;
                  }
                  else {
                      this.combinedTheme = this._defaultTheme;
                      console.warn('');
                  }
                  this.dirty = false;
              }
              else {
                  this.doCombine(pt);
              }
          }
          return this.combinedTheme;
      }
      doCombine(parentTheme) {
          const userTheme = this.userTheme;
          const defaultTheme = this._defaultTheme;
          const combinedTheme = this.combinedTheme;
          const parentCommonTheme = parentTheme.common || {};
          const commonTheme = Object.assign(parentCommonTheme, this.commonTheme);
          themeKeys.forEach(k => {
              if (userTheme[k] || commonTheme || parentTheme[k]) {
                  combinedTheme[k] = Object.assign({}, defaultTheme[k], commonTheme ?? {}, parentTheme[k] ?? {}, userTheme[k] ?? {});
              }
              else {
                  combinedTheme[k] = defaultTheme[k];
              }
          });
          this.dirty = false;
      }
      resetTheme(t, g) {
          this.userTheme = t;
          this.dirty = true;
          this.dirtyChildren(g);
      }
      setTheme(t, g) {
          let userTheme = this.userTheme;
          if (userTheme) {
              Object.keys(t).forEach(k => {
                  if (userTheme[k]) {
                      Object.assign(userTheme[k], t[k]);
                  }
                  else {
                      userTheme[k] = Object.assign({}, t[k]);
                  }
              });
          }
          else {
              userTheme = t;
          }
          if (t.common) {
              if (!this.commonTheme) {
                  this.commonTheme = t.common;
              }
              else {
                  Object.assign(this.commonTheme, t.common);
              }
          }
          this.userTheme = userTheme;
          this.dirty = true;
          this.dirtyChildren(g);
      }
      dirtyChildren(g) {
          g.forEachChildren(item => {
              if (item.isContainer) {
                  if (item.theme) {
                      item.theme.dirty = true;
                  }
                  this.dirtyChildren(item);
              }
          });
      }
  }
  const globalTheme = new Theme();
  function getTheme(graphic, theme) {
      if (graphic.glyphHost) {
          return getTheme(graphic.glyphHost);
      }
      if (theme) {
          if (graphic.isContainer) {
              return theme;
          }
          return theme;
      }
      return getThemeFromGroup(graphic) || globalTheme.getTheme();
  }
  function getThemeFromGroup(graphic) {
      let g;
      if (graphic.isContainer) {
          g = graphic;
      }
      else {
          g = graphic.parent;
      }
      if (g) {
          while (g) {
              if (g.theme) {
                  break;
              }
              g = g.parent;
          }
          if (!g) {
              return globalTheme.getTheme();
          }
          if (!g.theme) {
              g.createTheme();
          }
          return g.theme.getTheme(g);
      }
      return null;
  }

  class Generator {
      static auto_increment_id = 0;
      static GenAutoIncrementId() {
          return Generator.auto_increment_id++;
      }
  }

  class Node extends EventEmitter {
      parent;
      _prev;
      _next;
      _firstChild;
      _lastChild;
      _idMap;
      _count;
      _structEdit;
      _nodeList;
      get previousSibling() {
          return this._prev;
      }
      get nextSibling() {
          return this._next;
      }
      get children() {
          return this.getChildren();
      }
      get firstChild() {
          return this._firstChild;
      }
      get lastChild() {
          return this._lastChild;
      }
      get count() {
          return this._count;
      }
      get childrenCount() {
          if (!this._idMap) {
              return 0;
          }
          return this._idMap.size;
      }
      constructor() {
          super();
          this._uid = Generator.GenAutoIncrementId();
          this._firstChild = null;
          this._lastChild = null;
          this.parent = null;
          this._count = 1;
      }
      forEachChildren(cb, reverse = false) {
          if (reverse) {
              let child = this._lastChild;
              let i = 0;
              while (child) {
                  const breakTag = cb(child, i++);
                  if (breakTag) {
                      return;
                  }
                  child = child._prev;
              }
          }
          else {
              let child = this._firstChild;
              let i = 0;
              while (child) {
                  const breakTag = cb(child, i++);
                  if (breakTag) {
                      return;
                  }
                  child = child._next;
              }
          }
      }
      async forEachChildrenAsync(cb, reverse = false) {
          if (reverse) {
              let child = this._lastChild;
              let i = 0;
              while (child) {
                  let breakTag = cb(child, i++);
                  if (breakTag.then) {
                      breakTag = await breakTag;
                  }
                  if (breakTag) {
                      return;
                  }
                  child = child._prev;
              }
          }
          else {
              let child = this._firstChild;
              let i = 0;
              while (child) {
                  let breakTag = cb(child, i++);
                  if (breakTag.then) {
                      breakTag = await breakTag;
                  }
                  if (breakTag) {
                      return;
                  }
                  child = child._next;
              }
          }
      }
      forEach(cb) {
          return this.forEachChildren(cb);
      }
      appendChild(node) {
          if (this._uid === node._uid) {
              return null;
          }
          if (node.isAncestorsOf(this)) {
              throw new Error('Node::appendChildappend');
          }
          node.parent && node.parent.removeChild(node);
          node.parent = this;
          if (!this._lastChild) {
              this._firstChild = this._lastChild = node;
              node._prev = node._next = null;
          }
          else {
              this._lastChild._next = node;
              node._prev = this._lastChild;
              this._lastChild = node;
          }
          if (!this._idMap) {
              this._idMap = new Map();
          }
          this._idMap.set(node._uid, node);
          this.setCount(node.count);
          this._structEdit = true;
          return node;
      }
      appendChildArrHighPerformance(nodes, replace = false) {
          console.error('');
          return nodes;
      }
      insertBefore(newNode, referenceNode) {
          if (this._uid === newNode._uid) {
              return null;
          }
          if (newNode.isAncestorsOf(this)) {
              throw new Error('Node::insertBeforeinsert');
          }
          if (referenceNode.parent !== this) {
              return null;
          }
          newNode.parent && newNode.parent.removeChild(newNode);
          newNode.parent = this;
          newNode._prev = referenceNode._prev;
          if (!referenceNode._prev) {
              this._firstChild = newNode;
          }
          else {
              referenceNode._prev._next = newNode;
          }
          referenceNode._prev = newNode;
          newNode._next = referenceNode;
          if (!this._idMap) {
              this._idMap = new Map();
          }
          this._idMap.set(newNode._uid, newNode);
          this._structEdit = true;
          this.setCount(newNode.count);
          return newNode;
      }
      insertAfter(newNode, referenceNode) {
          if (this._uid === newNode._uid) {
              return null;
          }
          if (newNode.isAncestorsOf(this)) {
              throw new Error('Node::insertAfterinsert');
          }
          if (referenceNode.parent !== this) {
              return null;
          }
          newNode.parent && newNode.parent.removeChild(newNode);
          newNode.parent = this;
          if (!referenceNode._next) {
              this._lastChild = newNode;
          }
          else {
              referenceNode._next._prev = newNode;
              newNode._next = referenceNode._next;
          }
          referenceNode._next = newNode;
          newNode._prev = referenceNode;
          if (!this._idMap) {
              this._idMap = new Map();
          }
          this._idMap.set(newNode._uid, newNode);
          this._structEdit = true;
          this.setCount(newNode.count);
          return newNode;
      }
      insertInto(newNode, idx) {
          if (!this._ignoreWarn && this._nodeList) {
              console.warn('insertIntoKeepIdxinsertInto');
          }
          if (idx >= this.childrenCount) {
              return this.appendChild(newNode);
          }
          if (this._uid === newNode._uid) {
              return null;
          }
          if (newNode.isAncestorsOf(this)) {
              throw new Error('Node::insertBeforeinsert');
          }
          newNode.parent && newNode.parent.removeChild(newNode);
          newNode.parent = this;
          if (idx === 0) {
              newNode._next = this._firstChild;
              this._firstChild && (this._firstChild._prev = newNode);
              newNode._prev = null;
              this._firstChild = newNode;
          }
          else {
              let child = this._firstChild;
              for (let i = 0; i < idx; i++) {
                  if (!child) {
                      return null;
                  }
                  if (i > 0) {
                      child = child._next;
                  }
              }
              if (!child) {
                  return null;
              }
              newNode._next = child._next;
              newNode._prev = child;
              child._next = newNode;
              if (newNode._next) {
                  newNode._next._prev = newNode;
              }
          }
          if (!this._idMap) {
              this._idMap = new Map();
          }
          this._idMap.set(newNode._uid, newNode);
          this._structEdit = true;
          this.setCount(newNode.count);
          return newNode;
      }
      insertIntoKeepIdx(newNode, idx) {
          if (!this._nodeList) {
              this._nodeList = this.children;
          }
          if (this._nodeList[idx]) {
              const node = this._nodeList[idx];
              this._nodeList.splice(idx, 0, newNode);
              return this.insertBefore(newNode, node);
          }
          this._nodeList[idx] = newNode;
          let node;
          for (let i = idx - 1; i >= 0; i--) {
              node = this._nodeList[i];
              if (node) {
                  break;
              }
          }
          if (node) {
              return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
          }
          this._ignoreWarn = true;
          const data = this.insertInto(newNode, 0);
          this._ignoreWarn = false;
          return data;
      }
      removeChild(child) {
          if (!this._idMap) {
              return null;
          }
          if (!this._idMap.has(child._uid)) {
              return null;
          }
          this._idMap.delete(child._uid);
          if (this._nodeList) {
              const idx = this._nodeList.findIndex(n => n === child);
              if (idx > 0) {
                  this._nodeList.splice(idx, 1);
              }
          }
          if (!child._prev) {
              this._firstChild = child._next;
          }
          else {
              child._prev._next = child._next;
          }
          if (child._next) {
              child._next._prev = child._prev;
          }
          else {
              this._lastChild = child._prev;
          }
          child.parent = null;
          child._prev = null;
          child._next = null;
          this._structEdit = true;
          this.setCount(-child.count);
          return child;
      }
      delete() {
          if (this.parent) {
              this.parent.removeChild(this);
          }
      }
      removeAllChild() {
          if (!this._idMap) {
              return;
          }
          let child = this._firstChild;
          while (child) {
              child.parent = null;
              child._prev = null;
              child._next = null;
              child = child._next;
          }
          this._firstChild = null;
          this._lastChild = null;
          this._idMap.clear();
          this._structEdit = true;
          this.setCount(-this._count + 1);
      }
      replaceChild(newChild, oldChild) {
          throw new Error('');
      }
      find(callback, deep = false) {
          let target = null;
          this.forEachChildren((node, index) => {
              if (node !== this && callback(node, index)) {
                  target = node;
                  return true;
              }
              return false;
          });
          if (deep) {
              this.forEachChildren(child => {
                  if (child.isContainer) {
                      const node = child.find(callback, true);
                      if (node) {
                          target = node;
                          return true;
                      }
                  }
                  return false;
              });
          }
          return target;
      }
      findAll(callback, deep = false) {
          let nodes = [];
          this.forEachChildren((node, index) => {
              if (node !== this && callback(node, index)) {
                  nodes.push(node);
              }
          });
          if (deep) {
              this.forEachChildren(child => {
                  if (child.isContainer) {
                      const targets = child.findAll(callback, true);
                      if (targets.length) {
                          nodes = nodes.concat(targets);
                      }
                  }
              });
          }
          return nodes;
      }
      getElementById(id) {
          return this.find(node => node.id === id, true);
      }
      findChildById(id) {
          return this.getElementById(id);
      }
      findChildByUid(uid) {
          if (!this._idMap) {
              return null;
          }
          return this._idMap.get(uid) || null;
      }
      getElementsByName(name) {
          return this.findAll(node => node.name === name, true);
      }
      findChildrenByName(name) {
          return this.getElementsByName(name);
      }
      getElementsByType(type) {
          return this.findAll(node => node.type === type, true);
      }
      getChildByName(name, deep = false) {
          return this.find(node => node.name === name, deep);
      }
      getChildAt(idx) {
          let c = this._firstChild;
          if (!c) {
              return null;
          }
          for (let i = 0; i < idx; i++) {
              if (!c._next) {
                  return null;
              }
              c = c._next;
          }
          return c;
      }
      at(idx) {
          return this.getChildAt(idx);
      }
      containNode(node) {
          if (!this._idMap) {
              return false;
          }
          if (this._idMap.has(node._uid)) {
              return true;
          }
          let child = this._firstChild;
          while (child) {
              if (child.containNode(node)) {
                  return true;
              }
              child = child._next;
          }
          return false;
      }
      getRootNode() {
          let parent = this.parent;
          while (parent?.parent) {
              parent = parent.parent;
          }
          return parent || this;
      }
      hasChildNodes() {
          return this._firstChild !== null;
      }
      addChild(node) {
          return this.appendChild(node);
      }
      add(node) {
          return this.appendChild(node);
      }
      getChildren() {
          const nodes = [];
          let child = this._firstChild;
          while (child) {
              nodes.push(child);
              child = child._next;
          }
          return nodes;
      }
      isChildOf(node) {
          if (!this.parent) {
              return false;
          }
          return this.parent._uid === node._uid;
      }
      isParentOf(node) {
          return node.isChildOf(this);
      }
      isDescendantsOf(node) {
          let parent = this.parent;
          if (!parent) {
              return false;
          }
          do {
              if (parent._uid === node._uid) {
                  return true;
              }
              parent = parent.parent;
          } while (parent !== null);
          return false;
      }
      isAncestorsOf(node) {
          return node.isDescendantsOf(this);
      }
      getAncestor(idx) {
          throw new Error('');
      }
      setAllDescendantsProps(propsName, propsValue) {
          let child = this._firstChild;
          while (child) {
              child[propsName] = propsValue;
              child.setAllDescendantsProps(propsName, propsValue);
              child = child._next;
          }
      }
      setCount(deltaCount) {
          this._count += deltaCount;
          let parent = this.parent;
          if (!parent) {
              return;
          }
          do {
              parent._count += deltaCount;
              parent = parent.parent;
          } while (parent !== null);
      }
      clone() {
          throw new Error('');
      }
      cloneTo(node) {
          throw new Error('');
      }
      getParent() {
          return this.parent;
      }
      del(child) {
          return this.removeChild(child);
      }
      addEventListener(type, listener, options) {
          const capture = (isBoolean(options, true) && options) || (isObject(options) && options.capture);
          const once = isObject(options) && options.once;
          const context = isFunction(listener) ? undefined : listener;
          type = capture ? `${type}capture` : type;
          listener = isFunction(listener) ? listener : listener.handleEvent;
          if (once) {
              super.once(type, listener, context);
          }
          else {
              super.on(type, listener, context);
          }
          return this;
      }
      on(type, listener, options) {
          return this.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
          const capture = (isBoolean(options, true) && options) || (isObject(options) && options.capture);
          const context = isFunction(listener) ? undefined : listener;
          type = capture ? `${type}capture` : type;
          listener = isFunction(listener) ? listener : listener.handleEvent;
          const once = isObject(options) && options.once;
          super.off(type, listener, context, once);
          return this;
      }
      off(type, listener, options) {
          return this.removeEventListener(type, listener, options);
      }
      once(type, listener, options) {
          if (isObject(options)) {
              options.once = true;
              return this.addEventListener(type, listener, options);
          }
          return this.addEventListener(type, listener, { once: true });
      }
      removeAllEventListeners() {
          super.removeAllListeners();
          return this;
      }
      removeAllListeners() {
          return this.removeAllEventListeners();
      }
      dispatchEvent(event, ...args) {
          super.emit(event.type, event, ...args);
          return !event.defaultPrevented;
      }
      emit(event, data) {
          return this.dispatchEvent(event, data);
      }
      release() {
          this.removeAllListeners();
      }
  }

  class FederatedEvent {
      bubbles = true;
      cancelBubble = true;
      cancelable = false;
      composed = false;
      currentTarget;
      defaultPrevented = false;
      eventPhase = FederatedEvent.prototype.NONE;
      isTrusted;
      returnValue;
      srcElement;
      target;
      timeStamp;
      type;
      nativeEvent;
      originalEvent;
      propagationStopped = false;
      propagationImmediatelyStopped = false;
      path;
      manager;
      detail;
      view;
      layer = new Point();
      get layerX() {
          return this.layer.x;
      }
      get layerY() {
          return this.layer.y;
      }
      page = new Point();
      get pageX() {
          return this.page.x;
      }
      get pageY() {
          return this.page.y;
      }
      canvas = new Point();
      get x() {
          return this.canvas.x;
      }
      get y() {
          return this.canvas.y;
      }
      get canvasX() {
          return this.canvas.x;
      }
      get canvasY() {
          return this.canvas.y;
      }
      viewport = new Point();
      get viewX() {
          return this.viewport.x;
      }
      get viewY() {
          return this.viewport.y;
      }
      constructor(manager) {
          this.manager = manager;
      }
      composedPath() {
          if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
              this.path = this.target ? this.manager.propagationPath(this.target) : [];
          }
          return this.path;
      }
      preventDefault() {
          if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
              this.nativeEvent.preventDefault();
          }
          this.defaultPrevented = true;
      }
      stopImmediatePropagation() {
          this.propagationImmediatelyStopped = true;
      }
      stopPropagation() {
          this.propagationStopped = true;
      }
      initEvent() {
          return;
      }
      initUIEvent() {
          return;
      }
      clone() {
          throw new Error('Method not implemented.');
      }
      which;
      NONE = 0;
      CAPTURING_PHASE = 1;
      AT_TARGET = 2;
      BUBBLING_PHASE = 3;
  }

  class FederatedMouseEvent extends FederatedEvent {
      altKey;
      button;
      buttons;
      ctrlKey;
      metaKey;
      relatedTarget;
      shiftKey;
      client = new Point();
      get clientX() {
          return this.client.x;
      }
      get clientY() {
          return this.client.y;
      }
      movement = new Point();
      get movementX() {
          return this.movement.x;
      }
      get movementY() {
          return this.movement.y;
      }
      offset = new Point();
      get offsetX() {
          return this.offset.x;
      }
      get offsetY() {
          return this.offset.y;
      }
      global = new Point();
      get globalX() {
          return this.global.x;
      }
      get globalY() {
          return this.global.y;
      }
      screen = new Point();
      get screenX() {
          return this.screen.x;
      }
      get screenY() {
          return this.screen.y;
      }
      getModifierState(key) {
          return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
      initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
          throw new Error('Method not implemented.');
      }
  }

  class FederatedPointerEvent extends FederatedMouseEvent {
      pointerId;
      width = 0;
      height = 0;
      isPrimary = false;
      pointerType;
      pressure;
      tangentialPressure;
      tiltX;
      tiltY;
      twist;
      getCoalescedEvents() {
          if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove') {
              return [this];
          }
          return [];
      }
      getPredictedEvents() {
          throw new Error('getPredictedEvents is not supported!');
      }
      clone() {
          const event = new FederatedPointerEvent(this.manager);
          event.eventPhase = event.NONE;
          event.currentTarget = null;
          event.path = [];
          event.target = null;
          event.nativeEvent = this.nativeEvent;
          event.originalEvent = this.originalEvent;
          this.manager?.copyPointerData(this, event);
          this.manager?.copyMouseData(this, event);
          this.manager?.copyData(this, event);
          event.target = this.target;
          event.path = this.composedPath().slice();
          event.type = this.type;
          return event;
      }
  }

  class FederatedWheelEvent extends FederatedMouseEvent {
      deltaMode;
      deltaX;
      deltaY;
      deltaZ;
      static DOM_DELTA_PIXEL = 0;
      DOM_DELTA_PIXEL = 0;
      static DOM_DELTA_LINE = 1;
      DOM_DELTA_LINE = 1;
      static DOM_DELTA_PAGE = 2;
      DOM_DELTA_PAGE = 2;
      clone() {
          const event = new FederatedWheelEvent(this.manager);
          event.eventPhase = event.NONE;
          event.currentTarget = null;
          event.path = [];
          event.target = null;
          event.nativeEvent = this.nativeEvent;
          event.originalEvent = this.originalEvent;
          this.manager?.copyWheelData(this, event);
          this.manager?.copyMouseData(this, event);
          this.manager?.copyData(this, event);
          event.target = this.target;
          event.path = this.composedPath().slice();
          event.type = this.type;
          return event;
      }
  }

  class CustomEvent extends FederatedEvent {
      constructor(eventName, object) {
          super();
          this.type = eventName;
          this.detail = object;
      }
  }

  const WILDCARD = '*';

  const clock = typeof performance === 'object' && performance.now ? performance : Date;

  const PROPAGATION_LIMIT = 2048;
  function isMouseLike(pointerType) {
      return pointerType === 'mouse' || pointerType === 'pen';
  }
  class EventManager {
      rootTarget;
      dispatch = new EventEmitter();
      cursor;
      mappingTable;
      mappingState = {
          trackingData: {}
      };
      eventPool = new Map();
      _prePointTargetCache;
      constructor(root) {
          this.rootTarget = root;
          this.mappingTable = {};
          this.addEventMapping('pointerdown', this.onPointerDown);
          this.addEventMapping('pointermove', this.onPointerMove);
          this.addEventMapping('pointerout', this.onPointerOut);
          this.addEventMapping('pointerleave', this.onPointerOut);
          this.addEventMapping('pointerover', this.onPointerOver);
          this.addEventMapping('pointerup', this.onPointerUp);
          this.addEventMapping('pointerupoutside', this.onPointerUpOutside);
          this.addEventMapping('wheel', this.onWheel);
      }
      addEventMapping(type, fn) {
          if (!this.mappingTable[type]) {
              this.mappingTable[type] = [];
          }
          this.mappingTable[type].push({
              fn,
              priority: 0
          });
          this.mappingTable[type].sort((a, b) => a.priority - b.priority);
      }
      dispatchEvent(e, type) {
          e.propagationStopped = false;
          e.propagationImmediatelyStopped = false;
          this.propagate(e, type);
          this.dispatch.emit(type || e.type, e);
      }
      mapEvent(e) {
          if (!this.rootTarget) {
              return;
          }
          const mappers = this.mappingTable[e.type];
          let target;
          const cacheKey = `${e.canvasX}-${e.canvasY}`;
          if (this._prePointTargetCache?.[cacheKey]) {
              target = this._prePointTargetCache[cacheKey];
          }
          else {
              target = this.pickTarget(e.canvasX, e.canvasY);
              this._prePointTargetCache = {
                  [cacheKey]: target
              };
          }
          if (mappers) {
              for (let i = 0, j = mappers.length; i < j; i++) {
                  mappers[i].fn(e, target);
              }
          }
          else {
              console.warn(`[EventManager]: Event mapping not defined for ${e.type}`);
          }
      }
      propagate(e, type) {
          if (!e.target) {
              return;
          }
          const composedPath = e.composedPath();
          e.eventPhase = e.CAPTURING_PHASE;
          for (let i = 0, j = composedPath.length - 1; i < j; i++) {
              e.currentTarget = composedPath[i];
              this.notifyTarget(e, type);
              if (e.propagationStopped || e.propagationImmediatelyStopped) {
                  return;
              }
          }
          e.eventPhase = e.AT_TARGET;
          e.currentTarget = e.target;
          this.notifyTarget(e, type);
          if (e.propagationStopped || e.propagationImmediatelyStopped) {
              return;
          }
          e.eventPhase = e.BUBBLING_PHASE;
          for (let i = composedPath.length - 2; i >= 0; i--) {
              e.currentTarget = composedPath[i];
              this.notifyTarget(e, type);
              if (e.propagationStopped || e.propagationImmediatelyStopped) {
                  return;
              }
          }
      }
      propagationPath(target) {
          const propagationPath = [target];
          for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget && target.parent; i++) {
              if (!target.parent) {
                  throw new Error('Cannot find propagation path to disconnected target');
              }
              propagationPath.push(target.parent);
              target = target.parent;
          }
          propagationPath.reverse();
          return propagationPath;
      }
      notifyTarget(e, type) {
          type = type ?? e.type;
          const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
          this.notifyListeners(e, key);
          if (e.eventPhase === e.AT_TARGET) {
              this.notifyListeners(e, type);
          }
      }
      onPointerDown = (from, target) => {
          if (!(from instanceof FederatedPointerEvent)) {
              console.warn('EventManager cannot map a non-pointer event as a pointer event');
              return;
          }
          const e = this.createPointerEvent(from, from.type, target);
          this.dispatchEvent(e, 'pointerdown');
          if (e.pointerType === 'touch') {
              this.dispatchEvent(e, 'touchstart');
          }
          else if (isMouseLike(e.pointerType)) {
              const isRightButton = e.button === 2;
              this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');
          }
          const trackingData = this.trackingData(from.pointerId);
          trackingData.pressTargetsByButton[from.button] = e.composedPath();
          this.freeEvent(e);
      };
      onPointerMove = (from, target) => {
          if (!(from instanceof FederatedPointerEvent)) {
              console.warn('EventManager cannot map a non-pointer event as a pointer event');
              return;
          }
          const e = this.createPointerEvent(from, from.type, target);
          const isMouse = isMouseLike(e.pointerType);
          const trackingData = this.trackingData(from.pointerId);
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e.target) {
              const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';
              const outEvent = this.createPointerEvent(from, outType, outTarget || undefined);
              this.dispatchEvent(outEvent, 'pointerout');
              if (isMouse) {
                  this.dispatchEvent(outEvent, 'mouseout');
              }
              if (!e.composedPath().includes(outTarget)) {
                  const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
                  leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                  while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
                      leaveEvent.currentTarget = leaveEvent.target;
                      this.notifyTarget(leaveEvent);
                      if (isMouse) {
                          this.notifyTarget(leaveEvent, 'mouseleave');
                      }
                      leaveEvent.target = leaveEvent.target.parent;
                  }
                  this.freeEvent(leaveEvent);
              }
              this.freeEvent(outEvent);
          }
          if (outTarget !== e.target) {
              const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';
              const overEvent = this.clonePointerEvent(e, overType);
              this.dispatchEvent(overEvent, 'pointerover');
              if (isMouse) {
                  this.dispatchEvent(overEvent, 'mouseover');
              }
              let overTargetAncestor = outTarget?.parent;
              while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
                  if (overTargetAncestor === e.target) {
                      break;
                  }
                  overTargetAncestor = overTargetAncestor.parent;
              }
              const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
              if (didPointerEnter) {
                  const enterEvent = this.clonePointerEvent(e, 'pointerenter');
                  enterEvent.eventPhase = enterEvent.AT_TARGET;
                  while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
                      enterEvent.currentTarget = enterEvent.target;
                      this.notifyTarget(enterEvent);
                      if (isMouse) {
                          this.notifyTarget(enterEvent, 'mouseenter');
                      }
                      enterEvent.target = enterEvent.target.parent;
                  }
                  this.freeEvent(enterEvent);
              }
              this.freeEvent(overEvent);
          }
          const propagationMethod = 'dispatchEvent';
          this[propagationMethod](e, 'pointermove');
          if (e.pointerType === 'touch') {
              this[propagationMethod](e, 'touchmove');
          }
          if (isMouse) {
              this[propagationMethod](e, 'mousemove');
              this.cursor = e.target?.attribute?.cursor || this.rootTarget.getCursor();
          }
          trackingData.overTargets = e.composedPath();
          this.freeEvent(e);
      };
      onPointerOver = (from, target) => {
          if (!(from instanceof FederatedPointerEvent)) {
              console.warn('EventManager cannot map a non-pointer event as a pointer event');
              return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const e = this.createPointerEvent(from, from.type, target);
          const isMouse = isMouseLike(e.pointerType);
          this.dispatchEvent(e, 'pointerover');
          if (isMouse) {
              this.dispatchEvent(e, 'mouseover');
          }
          if (e.pointerType === 'mouse') {
              this.cursor = e.target?.attribute?.cursor || this.rootTarget.getCursor();
          }
          const enterEvent = this.clonePointerEvent(e, 'pointerenter');
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
              enterEvent.currentTarget = enterEvent.target;
              this.notifyTarget(enterEvent);
              if (isMouse) {
                  this.notifyTarget(enterEvent, 'mouseenter');
              }
              enterEvent.target = enterEvent.target.parent;
          }
          trackingData.overTargets = e.composedPath();
          this.freeEvent(e);
          this.freeEvent(enterEvent);
      };
      onPointerOut = (from, target) => {
          if (!(from instanceof FederatedPointerEvent)) {
              console.warn('EventManager cannot map a non-pointer event as a pointer event');
              return;
          }
          const trackingData = this.trackingData(from.pointerId);
          if (trackingData.overTargets) {
              const isMouse = isMouseLike(from.pointerType);
              const outTarget = this.findMountedTarget(trackingData.overTargets);
              const outEvent = this.createPointerEvent(from, 'pointerout', outTarget || undefined);
              this.dispatchEvent(outEvent);
              if (isMouse) {
                  this.dispatchEvent(outEvent, 'mouseout');
              }
              const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;
              while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
                  leaveEvent.currentTarget = leaveEvent.target;
                  this.notifyTarget(leaveEvent);
                  if (isMouse) {
                      this.notifyTarget(leaveEvent, 'mouseleave');
                  }
                  leaveEvent.target = leaveEvent.target.parent;
              }
              trackingData.overTargets = [];
              this.freeEvent(outEvent);
              this.freeEvent(leaveEvent);
          }
          this.cursor = '';
      };
      onPointerUp = (from, target) => {
          if (!(from instanceof FederatedPointerEvent)) {
              console.warn('EventManager cannot map a non-pointer event as a pointer event');
              return;
          }
          const now = clock.now();
          const e = this.createPointerEvent(from, from.type, target);
          this.dispatchEvent(e, 'pointerup');
          if (e.pointerType === 'touch') {
              this.dispatchEvent(e, 'touchend');
          }
          else if (isMouseLike(e.pointerType)) {
              const isRightButton = e.button === 2;
              this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          let clickTarget = pressTarget;
          if (pressTarget && !e.composedPath().includes(pressTarget)) {
              let currentTarget = pressTarget;
              while (currentTarget && !e.composedPath().includes(currentTarget)) {
                  e.currentTarget = currentTarget;
                  this.notifyTarget(e, 'pointerupoutside');
                  if (e.pointerType === 'touch') {
                      this.notifyTarget(e, 'touchendoutside');
                  }
                  else if (isMouseLike(e.pointerType)) {
                      const isRightButton = e.button === 2;
                      this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');
                  }
                  currentTarget = currentTarget.parent;
              }
              delete trackingData.pressTargetsByButton[from.button];
              clickTarget = currentTarget;
          }
          if (clickTarget) {
              const clickEvent = this.clonePointerEvent(e, 'click');
              clickEvent.target = clickTarget;
              clickEvent.path = [];
              if (!trackingData.clicksByButton[from.button]) {
                  trackingData.clicksByButton[from.button] = {
                      clickCount: 0,
                      target: clickEvent.target,
                      timeStamp: now
                  };
              }
              const clickHistory = trackingData.clicksByButton[from.button];
              if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
                  ++clickHistory.clickCount;
              }
              else {
                  clickHistory.clickCount = 1;
              }
              clickHistory.target = clickEvent.target;
              clickHistory.timeStamp = now;
              clickEvent.detail = clickHistory.clickCount;
              if (isMouseLike(clickEvent.pointerType)) {
                  this.dispatchEvent(clickEvent, 'click');
                  if (clickHistory.clickCount === 2) {
                      this.dispatchEvent(clickEvent, 'dblclick');
                  }
              }
              else if (clickEvent.pointerType === 'touch') {
                  this.dispatchEvent(clickEvent, 'tap');
              }
              this.dispatchEvent(clickEvent, 'pointertap');
              this.freeEvent(clickEvent);
          }
          this.freeEvent(e);
      };
      onPointerUpOutside = (from, target) => {
          if (!(from instanceof FederatedPointerEvent)) {
              console.warn('EventManager cannot map a non-pointer event as a pointer event');
              return;
          }
          const trackingData = this.trackingData(from.pointerId);
          const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          const e = this.createPointerEvent(from, from.type, target);
          if (pressTarget) {
              let currentTarget = pressTarget;
              while (currentTarget) {
                  e.currentTarget = currentTarget;
                  this.notifyTarget(e, 'pointerupoutside');
                  if (e.pointerType === 'touch') {
                      this.notifyTarget(e, 'touchendoutside');
                  }
                  else if (isMouseLike(e.pointerType)) {
                      this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');
                  }
                  currentTarget = currentTarget.parent;
              }
              delete trackingData.pressTargetsByButton[from.button];
          }
          this.freeEvent(e);
      };
      onWheel = (from, target) => {
          if (!(from instanceof FederatedWheelEvent)) {
              console.warn('EventManager cannot map a non-wheel event as a wheel event');
              return;
          }
          const wheelEvent = this.createWheelEvent(from, target);
          this.dispatchEvent(wheelEvent);
          this.freeEvent(wheelEvent);
      };
      findMountedTarget(propagationPath) {
          if (!propagationPath) {
              return null;
          }
          let currentTarget = propagationPath[0];
          for (let i = 1; i < propagationPath.length; i++) {
              if (propagationPath[i].parent === currentTarget) {
                  currentTarget = propagationPath[i];
              }
              else {
                  break;
              }
          }
          return currentTarget;
      }
      createPointerEvent(from, type, target) {
          const event = this.allocateEvent(FederatedPointerEvent);
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          if (target) {
              event.target = target;
          }
          else {
              event.target = this.pickTarget(event.global.x, event.global.y);
          }
          if (typeof type === 'string') {
              event.type = type;
          }
          return event;
      }
      createWheelEvent(from, target) {
          const event = this.allocateEvent(FederatedWheelEvent);
          this.copyWheelData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from;
          event.target = target || this.pickTarget(event.global.x, event.global.y);
          return event;
      }
      clonePointerEvent(from, type) {
          const event = this.allocateEvent(FederatedPointerEvent);
          event.nativeEvent = from.nativeEvent;
          event.originalEvent = from.originalEvent;
          this.copyPointerData(from, event);
          this.copyMouseData(from, event);
          this.copyData(from, event);
          event.target = from.target;
          event.path = from.composedPath().slice();
          event.type = type ?? event.type;
          return event;
      }
      copyWheelData(from, to) {
          to.deltaMode = from.deltaMode;
          to.deltaX = from.deltaX;
          to.deltaY = from.deltaY;
          to.deltaZ = from.deltaZ;
      }
      copyPointerData(from, to) {
          if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) {
              return;
          }
          to.pointerId = from.pointerId;
          to.width = from.width;
          to.height = from.height;
          to.isPrimary = from.isPrimary;
          to.pointerType = from.pointerType;
          to.pressure = from.pressure;
          to.tangentialPressure = from.tangentialPressure;
          to.tiltX = from.tiltX;
          to.tiltY = from.tiltY;
          to.twist = from.twist;
      }
      copyMouseData(from, to) {
          if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) {
              return;
          }
          to.altKey = from.altKey;
          to.button = from.button;
          to.buttons = from.buttons;
          to.client.copyFrom(from.client);
          to.ctrlKey = from.ctrlKey;
          to.shiftKey = from.shiftKey;
          to.metaKey = from.metaKey;
          to.movement.copyFrom(from.movement);
          to.canvas.copyFrom(from.canvas);
          to.screen.copyFrom(from.screen);
          to.global.copyFrom(from.global);
          to.offset.copyFrom(from.offset);
          to.viewport.copyFrom(from.viewport);
      }
      copyData(from, to) {
          to.isTrusted = from.isTrusted;
          to.srcElement = from.srcElement;
          to.timeStamp = clock.now();
          to.type = from.type;
          to.detail = from.detail;
          to.view = from.view;
          to.which = from.which;
          to.layer.copyFrom(from.layer);
          to.page.copyFrom(from.page);
      }
      trackingData(id) {
          if (!this.mappingState.trackingData[id]) {
              this.mappingState.trackingData[id] = {
                  pressTargetsByButton: {},
                  clicksByButton: {},
                  overTarget: null
              };
          }
          return this.mappingState.trackingData[id];
      }
      allocateEvent(constructor) {
          if (!this.eventPool.has(constructor)) {
              this.eventPool.set(constructor, []);
          }
          const event = this.eventPool.get(constructor)?.pop() || new constructor(this);
          event.eventPhase = event.NONE;
          event.currentTarget = null;
          event.path = [];
          event.target = null;
          return event;
      }
      freeEvent(event) {
          if (event.manager !== this) {
              throw new Error('It is illegal to free an event not managed by this EventManager!');
          }
          const constructor = event.constructor;
          if (!this.eventPool.has(constructor)) {
              this.eventPool.set(constructor, []);
          }
          this.eventPool.get(constructor)?.push(event);
      }
      notifyListeners(e, type) {
          const events = e.currentTarget._events;
          const listeners = events[type];
          if (listeners) {
              if ('fn' in listeners) {
                  if (listeners.once) {
                      e.currentTarget.removeEventListener(type, listeners.fn, { once: true });
                  }
                  listeners.fn.call(listeners.context, e);
              }
              else {
                  for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
                      if (listeners[i].once) {
                          e.currentTarget.removeEventListener(type, listeners[i].fn, { once: true });
                      }
                      listeners[i].fn.call(listeners[i].context, e);
                  }
              }
          }
          else {
              this.emitDelegation(e, type);
          }
      }
      emitDelegation(e, type) {
          const events = e.currentTarget._events;
          const listeners = events[WILDCARD];
          if (listeners) {
              if ('fn' in listeners) {
                  listeners.fn.call(listeners.context, e, type);
              }
              else {
                  for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
                      listeners[i].fn.call(listeners[i].context, e, type);
                  }
              }
          }
      }
      pickTarget(x, y) {
          let target;
          const pickResult = this.rootTarget.pick(x, y);
          if (pickResult && pickResult.graphic) {
              target = pickResult.graphic;
          }
          else if (pickResult && pickResult.group) {
              target = pickResult.group;
          }
          else if (x >= 0 && x <= get(this.rootTarget, 'width') && y >= 0 && y <= get(this.rootTarget, 'height')) {
              target = this.rootTarget;
          }
          else {
              target = null;
          }
          return target;
      }
  }

  const EventTarget = {
      pickable: true,
      visible: true,
      dispatchEvent(e) {
          if (!(e instanceof FederatedEvent)) {
              throw new Error('DisplayObject cannot propagate events outside of the Federated Events API');
          }
          e.defaultPrevented = false;
          e.path = [];
          e.target = this;
          e?.manager?.dispatchEvent(e);
          return !e.defaultPrevented;
      },
      emit(eventName, object) {
          return this.dispatchEvent(new CustomEvent(eventName, object));
      }
  };

  const MOUSE_POINTER_ID = 1;
  const TOUCH_TO_POINTER = {
      touchstart: 'pointerdown',
      touchend: 'pointerup',
      touchendoutside: 'pointerupoutside',
      touchmove: 'pointermove',
      touchcancel: 'pointercancel'
  };
  class EventSystem {
      globalObj;
      manager;
      supportsTouchEvents;
      supportsPointerEvents;
      supportsMouseEvents;
      applyStyles;
      viewport;
      autoPreventDefault;
      cursorStyles;
      domElement;
      resolution = 1;
      currentCursor;
      rootPointerEvent;
      rootWheelEvent;
      eventsAdded;
      constructor(params) {
          const { targetElement, resolution, rootNode, global, viewport, autoPreventDefault = false } = params;
          this.manager = new EventManager(rootNode);
          this.globalObj = global;
          this.supportsPointerEvents = global.supportsPointerEvents;
          this.supportsTouchEvents = global.supportsTouchEvents;
          this.supportsMouseEvents = global.supportsMouseEvents;
          this.applyStyles = global.applyStyles;
          this.autoPreventDefault = autoPreventDefault;
          this.eventsAdded = false;
          this.viewport = viewport;
          this.rootPointerEvent = new FederatedPointerEvent();
          this.rootWheelEvent = new FederatedWheelEvent();
          this.cursorStyles = {
              default: 'inherit',
              pointer: 'pointer'
          };
          this.resolution = resolution;
          this.setTargetElement(targetElement);
      }
      release() {
          this.setTargetElement(null);
      }
      setCursor(mode = 'default') {
          const { applyStyles, domElement } = this;
          if (this.currentCursor === mode) {
              return;
          }
          this.currentCursor = mode;
          const style = this.cursorStyles[mode];
          if (style) {
              if (typeof style === 'string' && applyStyles) {
                  domElement.style.cursor = style;
              }
              else if (typeof style === 'function') {
                  style(mode);
              }
              else if (typeof style === 'object' && applyStyles) {
                  Object.assign(domElement.style, style);
              }
          }
          else if (applyStyles && isString(mode) && !has(this.cursorStyles, mode)) {
              domElement.style.cursor = mode;
          }
      }
      onPointerDown = (nativeEvent) => {
          if (this.supportsTouchEvents && nativeEvent.pointerType === 'touch') {
              return;
          }
          const events = this.normalizeToPointerData(nativeEvent);
          if (this.autoPreventDefault && events[0].isNormalized) {
              const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);
              if (cancelable) {
                  nativeEvent.preventDefault();
              }
          }
          for (let i = 0, j = events.length; i < j; i++) {
              const nativeEvent = events[i];
              const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);
              this.manager.mapEvent(federatedEvent);
          }
          this.setCursor(this.manager.cursor);
      };
      onPointerMove = (nativeEvent) => {
          if (this.supportsTouchEvents && nativeEvent.pointerType === 'touch') {
              return;
          }
          if (this.isEventOutsideOfTargetElement(nativeEvent)) {
              return;
          }
          const normalizedEvents = this.normalizeToPointerData(nativeEvent);
          for (let i = 0, j = normalizedEvents.length; i < j; i++) {
              const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
              this.manager.mapEvent(event);
          }
          this.setCursor(this.manager.cursor);
      };
      onPointerUp = (nativeEvent) => {
          if (this.supportsTouchEvents && nativeEvent.pointerType === 'touch') {
              return;
          }
          const outside = this.isEventOutsideOfTargetElement(nativeEvent) ? 'outside' : '';
          const normalizedEvents = this.normalizeToPointerData(nativeEvent);
          for (let i = 0, j = normalizedEvents.length; i < j; i++) {
              const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
              event.type += outside;
              this.manager.mapEvent(event);
          }
          this.setCursor(this.manager.cursor);
      };
      onPointerOverOut = (nativeEvent) => {
          if (this.supportsTouchEvents && nativeEvent.pointerType === 'touch') {
              return;
          }
          const normalizedEvents = this.normalizeToPointerData(nativeEvent);
          for (let i = 0, j = normalizedEvents.length; i < j; i++) {
              const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
              this.manager.mapEvent(event);
          }
          this.setCursor(this.manager.cursor);
      };
      onWheel = (nativeEvent) => {
          const wheelEvent = this.normalizeWheelEvent(nativeEvent);
          this.manager.mapEvent(wheelEvent);
      };
      setTargetElement(element) {
          this.removeEvents();
          this.domElement = element;
          this.addEvents();
      }
      addEvents() {
          if (this.eventsAdded || !this.domElement) {
              return;
          }
          const { globalObj, domElement } = this;
          if (this.supportsPointerEvents) {
              if (globalObj.getDocument()) {
                  globalObj.getDocument().addEventListener('pointermove', this.onPointerMove, true);
                  globalObj.getDocument().addEventListener('pointerup', this.onPointerUp, true);
              }
              else {
                  domElement.addEventListener('pointermove', this.onPointerMove, true);
                  domElement.addEventListener('pointerup', this.onPointerUp, true);
              }
              domElement.addEventListener('pointerdown', this.onPointerDown, true);
              domElement.addEventListener('pointerleave', this.onPointerOverOut, true);
              domElement.addEventListener('pointerover', this.onPointerOverOut, true);
          }
          else {
              if (globalObj.getDocument()) {
                  globalObj.getDocument().addEventListener('mousemove', this.onPointerMove, true);
                  globalObj.getDocument().addEventListener('mouseup', this.onPointerUp, true);
              }
              else {
                  domElement.addEventListener('mousemove', this.onPointerMove, true);
                  domElement.addEventListener('mouseup', this.onPointerUp, true);
              }
              domElement.addEventListener('mousedown', this.onPointerDown, true);
              domElement.addEventListener('mouseout', this.onPointerOverOut, true);
              domElement.addEventListener('mouseover', this.onPointerOverOut, true);
          }
          if (this.supportsTouchEvents) {
              domElement.addEventListener('touchstart', this.onPointerDown, true);
              domElement.addEventListener('touchend', this.onPointerUp, true);
              domElement.addEventListener('touchmove', this.onPointerMove, true);
          }
          domElement.addEventListener('wheel', this.onWheel, {
              capture: true
          });
          this.eventsAdded = true;
      }
      removeEvents() {
          if (!this.eventsAdded || !this.domElement) {
              return;
          }
          const { globalObj, domElement } = this;
          if (this.supportsPointerEvents) {
              if (globalObj.getDocument()) {
                  globalObj.getDocument().removeEventListener('pointermove', this.onPointerMove, true);
                  globalObj.getDocument().removeEventListener('pointerup', this.onPointerUp, true);
              }
              else {
                  domElement.removeEventListener('pointermove', this.onPointerMove, true);
                  domElement.removeEventListener('pointerup', this.onPointerUp, true);
              }
              domElement.removeEventListener('pointerdown', this.onPointerDown, true);
              domElement.removeEventListener('pointerleave', this.onPointerOverOut, true);
              domElement.removeEventListener('pointerover', this.onPointerOverOut, true);
          }
          else {
              if (globalObj.getDocument()) {
                  globalObj.getDocument().removeEventListener('mousemove', this.onPointerMove, true);
                  globalObj.getDocument().removeEventListener('mouseup', this.onPointerUp, true);
              }
              else {
                  domElement.removeEventListener('mousemove', this.onPointerMove, true);
                  domElement.removeEventListener('mouseup', this.onPointerUp, true);
              }
              domElement.removeEventListener('mousedown', this.onPointerDown, true);
              domElement.removeEventListener('mouseout', this.onPointerOverOut, true);
              domElement.removeEventListener('mouseover', this.onPointerOverOut, true);
          }
          if (this.supportsTouchEvents) {
              domElement.removeEventListener('touchstart', this.onPointerDown, true);
              domElement.removeEventListener('touchend', this.onPointerUp, true);
              domElement.removeEventListener('touchmove', this.onPointerMove, true);
          }
          domElement.removeEventListener('wheel', this.onWheel, true);
          this.domElement = null;
          this.eventsAdded = false;
      }
      mapToViewportPoint(event) {
          const viewport = this.viewport;
          const { x, y } = event;
          return {
              x: x - viewport.x,
              y: y - viewport.y
          };
      }
      mapToCanvasPoint(nativeEvent) {
          const point = this.globalObj?.mapToCanvasPoint(nativeEvent, this.domElement);
          if (point) {
              return point;
          }
          const { clientX: x, clientY: y } = nativeEvent;
          const rect = this.domElement.getBoundingClientRect();
          return {
              x: x - rect.left,
              y: y - rect.top
          };
      }
      normalizeToPointerData(event) {
          const normalizedEvents = [];
          if (this.supportsTouchEvents &&
              event.changedTouches &&
              event.changedTouches.length) {
              for (let i = 0, li = event.changedTouches.length; i < li; i++) {
                  const touch = event.changedTouches[i];
                  if (isUndefined(touch.button)) {
                      touch.button = 0;
                  }
                  if (isUndefined(touch.buttons)) {
                      touch.buttons = 1;
                  }
                  if (isUndefined(touch.isPrimary)) {
                      touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                  }
                  if (isUndefined(touch.width)) {
                      touch.width = touch.radiusX || 1;
                  }
                  if (isUndefined(touch.height)) {
                      touch.height = touch.radiusY || 1;
                  }
                  if (isUndefined(touch.tiltX)) {
                      touch.tiltX = 0;
                  }
                  if (isUndefined(touch.tiltY)) {
                      touch.tiltY = 0;
                  }
                  if (isUndefined(touch.pointerType)) {
                      touch.pointerType = 'touch';
                  }
                  if (isUndefined(touch.pointerId)) {
                      touch.pointerId = touch.identifier || 0;
                  }
                  if (isUndefined(touch.pressure)) {
                      touch.pressure = touch.force || 0.5;
                  }
                  if (isUndefined(touch.twist)) {
                      touch.twist = 0;
                  }
                  if (isUndefined(touch.tangentialPressure)) {
                      touch.tangentialPressure = 0;
                  }
                  if (isUndefined(touch.layerX)) {
                      touch.layerX = touch.offsetX = touch.clientX;
                  }
                  if (isUndefined(touch.layerY)) {
                      touch.layerY = touch.offsetY = touch.clientY;
                  }
                  touch.isNormalized = true;
                  touch.type = event.type;
                  normalizedEvents.push(touch);
              }
          }
          else if (!this.globalObj.supportsMouseEvents ||
              (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof PointerEvent)))) {
              const tempEvent = event;
              if (isUndefined(tempEvent.isPrimary)) {
                  tempEvent.isPrimary = true;
              }
              if (isUndefined(tempEvent.width)) {
                  tempEvent.width = 1;
              }
              if (isUndefined(tempEvent.height)) {
                  tempEvent.height = 1;
              }
              if (isUndefined(tempEvent.tiltX)) {
                  tempEvent.tiltX = 0;
              }
              if (isUndefined(tempEvent.tiltY)) {
                  tempEvent.tiltY = 0;
              }
              if (isUndefined(tempEvent.pointerType)) {
                  tempEvent.pointerType = 'mouse';
              }
              if (isUndefined(tempEvent.pointerId)) {
                  tempEvent.pointerId = MOUSE_POINTER_ID;
              }
              if (isUndefined(tempEvent.pressure)) {
                  tempEvent.pressure = 0.5;
              }
              if (isUndefined(tempEvent.twist)) {
                  tempEvent.twist = 0;
              }
              if (isUndefined(tempEvent.tangentialPressure)) {
                  tempEvent.tangentialPressure = 0;
              }
              tempEvent.isNormalized = true;
              normalizedEvents.push(tempEvent);
          }
          else {
              normalizedEvents.push(event);
          }
          return normalizedEvents;
      }
      normalizeWheelEvent(nativeEvent) {
          const event = this.rootWheelEvent;
          this.transferMouseData(event, nativeEvent);
          event.deltaMode = nativeEvent.deltaMode;
          event.deltaX = nativeEvent.deltaX;
          event.deltaY = nativeEvent.deltaY;
          event.deltaZ = nativeEvent.deltaZ;
          const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
          event.canvas.x = canvasX;
          event.canvas.y = canvasY;
          event.global.copyFrom(event.canvas);
          event.offset.copyFrom(event.canvas);
          const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
          event.viewport.x = viewX;
          event.viewport.y = viewY;
          event.nativeEvent = nativeEvent;
          event.type = nativeEvent.type;
          return event;
      }
      bootstrapEvent(event, nativeEvent) {
          event.originalEvent = null;
          event.nativeEvent = nativeEvent;
          event.pointerId = nativeEvent.pointerId;
          event.width = nativeEvent.width;
          event.height = nativeEvent.height;
          event.isPrimary = nativeEvent.isPrimary;
          event.pointerType = nativeEvent.pointerType;
          event.pressure = nativeEvent.pressure;
          event.tangentialPressure = nativeEvent.tangentialPressure;
          event.tiltX = nativeEvent.tiltX;
          event.tiltY = nativeEvent.tiltY;
          event.twist = nativeEvent.twist;
          this.transferMouseData(event, nativeEvent);
          const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
          event.canvas.x = canvasX;
          event.canvas.y = canvasY;
          event.global.copyFrom(event.canvas);
          event.offset.copyFrom(event.canvas);
          const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
          event.viewport.x = viewX;
          event.viewport.y = viewY;
          event.isTrusted = nativeEvent.isTrusted;
          if (event.type === 'pointerleave') {
              event.type = 'pointerout';
          }
          if (event.type.startsWith('mouse')) {
              event.type = event.type.replace('mouse', 'pointer');
          }
          if (event.type.startsWith('touch')) {
              event.type = TOUCH_TO_POINTER[event.type] || event.type;
          }
          return event;
      }
      transferMouseData(event, nativeEvent) {
          event.isTrusted = nativeEvent.isTrusted;
          event.srcElement = nativeEvent.srcElement;
          event.timeStamp = clock.now();
          event.type = nativeEvent.type;
          event.altKey = nativeEvent.altKey;
          event.button = nativeEvent.button;
          event.buttons = nativeEvent.buttons;
          event.client.x = nativeEvent.clientX;
          event.client.y = nativeEvent.clientY;
          event.ctrlKey = nativeEvent.ctrlKey;
          event.shiftKey = nativeEvent.shiftKey;
          event.metaKey = nativeEvent.metaKey;
          event.movement.x = nativeEvent.movementX;
          event.movement.y = nativeEvent.movementY;
          event.page.x = nativeEvent.pageX;
          event.page.y = nativeEvent.pageY;
          event.relatedTarget = null;
      }
      isEventOutsideOfTargetElement(nativeEvent) {
          let target = nativeEvent.target;
          if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
              target = nativeEvent.composedPath()[0];
          }
          const nativeElement = this.domElement.getNativeHandler
              ? this.domElement.getNativeHandler().nativeCanvas
              : this.domElement;
          return target !== nativeElement;
      }
  }

  class DragNDrop {
      rootNode;
      constructor(rootNode) {
          this.rootNode = rootNode;
          this.initEvents();
      }
      initEvents() {
          this.rootNode?.addEventListener('pointerdown', this.onPointerDown);
      }
      removeEvents() {
          this.rootNode?.removeEventListener('pointerdown', this.onPointerDown);
      }
      release() {
          this.removeEvents();
          this.rootNode = null;
      }
      onPointerDown = (event) => {
          const target = event.target;
          const rootNode = this.rootNode;
          const isRoot = target === rootNode;
          if (target && !isRoot) {
              let dragstartTriggered = false;
              let currentDroppable;
              function handlePointerMove(moveEvent) {
                  if (!dragstartTriggered) {
                      moveEvent.type = 'dragstart';
                      target?.dispatchEvent(moveEvent);
                      dragstartTriggered = true;
                  }
                  moveEvent.type = 'drag';
                  target?.dispatchEvent(moveEvent);
                  if (!isRoot) {
                      target.pickable = false;
                      const clickResult = rootNode?.pick(moveEvent.global.x, moveEvent.global.y);
                      const elemBelow = clickResult.graphic;
                      target.pickable = true;
                      if (currentDroppable !== elemBelow) {
                          if (currentDroppable) {
                              moveEvent.type = 'dragleave';
                              moveEvent.target = currentDroppable;
                              currentDroppable.dispatchEvent(moveEvent);
                          }
                          if (elemBelow) {
                              moveEvent.type = 'dragenter';
                              moveEvent.target = elemBelow;
                              elemBelow.dispatchEvent(moveEvent);
                          }
                          currentDroppable = elemBelow;
                          if (currentDroppable) {
                              moveEvent.type = 'dragover';
                              moveEvent.target = currentDroppable;
                              currentDroppable.dispatchEvent(moveEvent);
                          }
                      }
                  }
              }
              rootNode?.addEventListener('pointermove', handlePointerMove);
              const stopDragging = function () {
                  if (dragstartTriggered) {
                      if (currentDroppable) {
                          event.type = 'drop';
                          event.target = currentDroppable;
                          currentDroppable.dispatchEvent(event);
                      }
                      event.type = 'dragend';
                      target.dispatchEvent(event);
                      dragstartTriggered = false;
                  }
                  rootNode?.removeEventListener('pointermove', handlePointerMove);
              };
              target.addEventListener('pointerup', stopDragging, { once: true });
              target.addEventListener('pointerupoutside', stopDragging, { once: true });
          }
      };
  }

  const PRESS_TIME = 251;
  const PRESS_THRESHOLD = 9;
  const SWIPE_VELOCITY = 0.3;
  const SWIPE_THRESHOLD = 10;
  const calcDirection = (start, end) => {
      const xDistance = end.x - start.x;
      const yDistance = end.y - start.y;
      if (Math.abs(xDistance) > Math.abs(yDistance)) {
          return xDistance > 0 ? 'right' : 'left';
      }
      return yDistance > 0 ? 'down' : 'up';
  };
  const calcDistance = (point1, point2) => {
      const xDistance = Math.abs(point2.x - point1.x);
      const yDistance = Math.abs(point2.y - point1.y);
      return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
  };
  const getCenter = (points) => {
      const pointersLength = points.length;
      if (pointersLength === 1) {
          return {
              x: Math.round(points[0].x),
              y: Math.round(points[0].y)
          };
      }
      let x = 0;
      let y = 0;
      let i = 0;
      while (i < pointersLength) {
          x += points[i].x;
          y += points[i].y;
          i++;
      }
      return {
          x: Math.round(x / pointersLength),
          y: Math.round(y / pointersLength)
      };
  };
  class Gesture extends EventEmitter {
      element;
      cachedEvents = [];
      startTime;
      pressTimeout;
      startPoints = [];
      processEvent = {};
      startDistance;
      center;
      eventType;
      direction;
      lastMoveTime;
      prevMoveTime;
      prevMovePoint;
      lastMovePoint;
      throttleTimer = 0;
      emitThrottles = [];
      config;
      constructor(element, config = {}) {
          super();
          this.element = element;
          this.config = {
              press: {
                  time: config?.press?.time ?? PRESS_TIME,
                  threshold: config?.press?.threshold ?? PRESS_THRESHOLD
              },
              swipe: {
                  threshold: config?.swipe?.threshold ?? SWIPE_THRESHOLD,
                  velocity: config?.swipe?.velocity ?? SWIPE_VELOCITY
              }
          };
          this.initEvents();
      }
      initEvents() {
          const { element } = this;
          if (!element) {
              return;
          }
          element.addEventListener('pointerdown', this.onStart);
          element.addEventListener('pointermove', this.onMove);
          element.addEventListener('pointerup', this.onEnd);
          element.addEventListener('pointerupoutside', this.onEnd);
      }
      removeEvents() {
          const { element } = this;
          if (!element) {
              return;
          }
          element.removeEventListener('pointerdown', this.onStart);
          element.removeEventListener('pointermove', this.onMove);
          element.removeEventListener('pointerup', this.onEnd);
          element.removeEventListener('pointerupoutside', this.onEnd);
      }
      release() {
          this.removeEvents();
          this.element = null;
      }
      onStart = (ev) => {
          this.reset();
          this.startTime = clock.now();
          const { cachedEvents, startPoints } = this;
          if (ev) {
              cachedEvents.push(ev.clone());
          }
          startPoints.length = cachedEvents.length;
          for (let i = 0; i < cachedEvents.length; i++) {
              const { x, y } = cachedEvents[i];
              const point = { x, y };
              startPoints[i] = point;
          }
          if (startPoints.length === 1) {
              const event = cachedEvents[0];
              this.pressTimeout = setTimeout(() => {
                  const eventType = 'press';
                  const direction = 'none';
                  event.direction = direction;
                  event.deltaX = 0;
                  event.deltaY = 0;
                  event.points = startPoints;
                  this.triggerStartEvent(eventType, event);
                  this.triggerEvent(eventType, event);
                  this.eventType = eventType;
                  this.direction = direction;
              }, this.config.press.time);
              return;
          }
          this.startDistance = calcDistance(startPoints[0], startPoints[1]);
          this.center = getCenter([startPoints[0], startPoints[1]]);
      };
      onMove = (ev) => {
          this.clearPressTimeout();
          const { startPoints, cachedEvents } = this;
          if (!startPoints.length) {
              return;
          }
          const moveEvent = ev.clone();
          const { x, y, pointerId } = moveEvent;
          for (let i = 0, len = cachedEvents.length; i < len; i++) {
              if (pointerId === cachedEvents[i].pointerId) {
                  cachedEvents[i] = moveEvent;
                  break;
              }
          }
          const point = { x, y };
          const points = cachedEvents.map(cachedEvent => ({ x: cachedEvent.x, y: cachedEvent.y }));
          const now = clock.now();
          this.prevMoveTime = this.lastMoveTime;
          this.prevMovePoint = this.lastMovePoint;
          this.lastMoveTime = now;
          this.lastMovePoint = point;
          if (startPoints.length === 1) {
              const startPoint = startPoints[0];
              const deltaX = x - startPoint.x;
              const deltaY = y - startPoint.y;
              const direction = this.direction || calcDirection(startPoint, point);
              this.direction = direction;
              const eventType = this.getEventType(point);
              moveEvent.direction = direction;
              moveEvent.deltaX = deltaX;
              moveEvent.deltaY = deltaY;
              moveEvent.points = points;
              this.triggerStartEvent(eventType, moveEvent);
              this.triggerEvent(eventType, moveEvent);
              return;
          }
          const { startDistance } = this;
          const currentDistance = calcDistance(points[0], points[1]);
          moveEvent.scale = currentDistance / startDistance;
          moveEvent.center = this.center;
          moveEvent.points = points;
          this.triggerStartEvent('pinch', moveEvent);
          this.triggerEvent('pinch', moveEvent);
      };
      onEnd = (ev) => {
          const endEvent = ev.clone();
          const { cachedEvents, startPoints } = this;
          const points = cachedEvents.map(ev => {
              return { x: ev.x, y: ev.y };
          });
          endEvent.points = points;
          this.triggerEndEvent(endEvent);
          if (cachedEvents.length === 1) {
              const now = clock.now();
              const lastMoveTime = this.lastMoveTime;
              if (now - lastMoveTime < 100) {
                  const prevMoveTime = this.prevMoveTime || this.startTime;
                  const intervalTime = lastMoveTime - prevMoveTime;
                  if (intervalTime > 0) {
                      const prevMovePoint = this.prevMovePoint || startPoints[0];
                      const lastMovePoint = this.lastMovePoint || startPoints[0];
                      const distance = calcDistance(prevMovePoint, lastMovePoint);
                      const velocity = distance / intervalTime;
                      if (velocity > this.config.swipe.velocity && distance > this.config.swipe.threshold) {
                          endEvent.velocity = velocity;
                          endEvent.direction = calcDirection(prevMovePoint, lastMovePoint);
                          this.triggerEvent('swipe', endEvent);
                      }
                  }
              }
          }
          for (let i = 0, len = cachedEvents.length; i < len; i++) {
              if (cachedEvents[i].pointerId === endEvent.pointerId) {
                  cachedEvents.splice(i, 1);
                  startPoints.splice(i, 1);
                  break;
              }
          }
          this.reset();
          if (cachedEvents.length > 0) {
              this.onStart();
          }
      };
      getEventType(point) {
          const { eventType, startTime, startPoints } = this;
          if (eventType) {
              return eventType;
          }
          let type;
          const now = clock.now();
          if (now - startTime > this.config.press.time && calcDistance(startPoints[0], point) < this.config.press.threshold) {
              type = 'press';
          }
          else {
              type = 'pan';
          }
          this.eventType = type;
          return type;
      }
      enable(eventType) {
          this.processEvent[eventType] = true;
      }
      isProcess(eventType) {
          return this.processEvent[eventType];
      }
      pushEvent(type, ev) {
          const { emitThrottles } = this;
          const newEvent = { type, ev };
          for (let i = 0, len = emitThrottles.length; i < len; i++) {
              if (emitThrottles[i].type === type) {
                  emitThrottles.splice(i, 1, newEvent);
                  return;
              }
          }
          emitThrottles.push(newEvent);
      }
      clearPressTimeout() {
          if (this.pressTimeout) {
              clearTimeout(this.pressTimeout);
              this.pressTimeout = null;
          }
      }
      reset() {
          this.clearPressTimeout();
          this.startTime = 0;
          this.startDistance = 0;
          this.direction = null;
          this.eventType = null;
          this.prevMoveTime = 0;
          this.prevMovePoint = null;
          this.lastMoveTime = 0;
          this.lastMovePoint = null;
      }
      triggerEvent(type, ev) {
          this.pushEvent(type, ev);
          const { throttleTimer, emitThrottles } = this;
          if (throttleTimer) {
              return;
          }
          this.throttleTimer = application.global.getRequestAnimationFrame()(() => {
              for (let i = 0, len = emitThrottles.length; i < len; i++) {
                  const { type, ev } = emitThrottles[i];
                  this.emitEvent(type, ev);
              }
              this.throttleTimer = 0;
              this.emitThrottles.length = 0;
          });
      }
      triggerStartEvent(type, ev) {
          if (this.isProcess(type)) {
              return;
          }
          this.enable(type);
          this.triggerEvent(`${type}start`, ev);
      }
      triggerEndEvent(ev) {
          const processEvent = this.processEvent;
          Object.keys(processEvent).forEach(type => {
              this.triggerEvent(`${type}end`, ev);
              if (type === 'press') {
                  this.triggerEvent(`${type}up`, ev);
              }
              delete processEvent[type];
          });
      }
      emitEvent(type, e) {
          const events = this.element._events;
          const listeners = events[WILDCARD];
          if (listeners) {
              if ('fn' in listeners) {
                  listeners.fn.call(listeners.context, e, type);
              }
              else {
                  for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
                      listeners[i].fn.call(listeners[i].context, e, type);
                  }
              }
          }
          this.emit(type, e);
      }
  }

  class ManualTickHandler {
      timerId;
      time = 0;
      static Avaliable() {
          return true;
      }
      avaliable() {
          return ManualTickHandler.Avaliable();
      }
      tick(interval, cb) {
          this.time = Math.max(0, interval + this.time);
          cb(this, { once: true });
      }
      tickTo(t, cb) {
          this.time = Math.max(0, t);
          cb(this, { once: true });
      }
      release() {
          if (this.timerId > 0) {
              this.timerId = -1;
          }
      }
      getTime() {
          return this.time;
      }
  }
  class TimeOutTickHandler {
      timerId;
      static Avaliable() {
          return true;
      }
      avaliable() {
          return TimeOutTickHandler.Avaliable();
      }
      tick(interval, cb) {
          this.timerId = setTimeout(() => {
              cb(this);
          }, interval);
      }
      release() {
          if (this.timerId > 0) {
              clearTimeout(this.timerId);
              this.timerId = -1;
          }
      }
      getTime() {
          return Date.now();
      }
  }
  class RAFTickHandler {
      released;
      static Avaliable() {
          return !!application.global.getRequestAnimationFrame();
      }
      avaliable() {
          return RAFTickHandler.Avaliable();
      }
      tick(interval, cb) {
          const raf = application.global.getRequestAnimationFrame();
          raf(() => {
              if (this.released) {
                  return;
              }
              cb(this);
          });
      }
      release() {
          this.released = true;
      }
      getTime() {
          return Date.now();
      }
  }
  var STATUS$1;
  (function (STATUS) {
      STATUS[STATUS["INITIAL"] = 0] = "INITIAL";
      STATUS[STATUS["RUNNING"] = 1] = "RUNNING";
      STATUS[STATUS["PAUSE"] = 2] = "PAUSE";
  })(STATUS$1 || (STATUS$1 = {}));
  class DefaultTicker {
      interval;
      tickerHandler;
      _mode;
      status;
      lastFrameTime;
      tickCounts;
      timelines;
      autoStop;
      set mode(m) {
          if (this._mode === m) {
              return;
          }
          this._mode = m;
          this.setupTickHandler();
      }
      get mode() {
          return this._mode;
      }
      constructor(timelines = []) {
          this.init();
          this.lastFrameTime = -1;
          this.tickCounts = 0;
          this.timelines = timelines;
          this.autoStop = true;
      }
      init() {
          this.interval = NaN;
          this.status = STATUS$1.INITIAL;
          application.global.hooks.onSetEnv.tap('window', () => {
              this.initHandler();
          });
          if (application.global.env) {
              this.initHandler();
          }
      }
      addTimeline(timeline) {
          this.timelines.push(timeline);
      }
      remTimeline(timeline) {
          this.timelines = this.timelines.filter(t => t !== timeline);
      }
      initHandler() {
          if (this._mode) {
              return null;
          }
          const ticks = [
              { mode: 'raf', cons: RAFTickHandler },
              { mode: 'timeout', cons: TimeOutTickHandler },
              { mode: 'manual', cons: ManualTickHandler }
          ];
          for (let i = 0; i < ticks.length; i++) {
              if (ticks[i].cons.Avaliable()) {
                  this.mode = ticks[i].mode;
                  break;
              }
          }
          return null;
      }
      setupTickHandler() {
          let handler;
          switch (this._mode) {
              case 'raf':
                  handler = new RAFTickHandler();
                  break;
              case 'timeout':
                  handler = new TimeOutTickHandler();
                  break;
              case 'manual':
                  handler = new ManualTickHandler();
                  break;
              default:
                  console.warn('');
                  handler = new RAFTickHandler();
                  break;
          }
          if (!handler.avaliable()) {
              return false;
          }
          if (this.tickerHandler) {
              this.tickerHandler.release();
          }
          this.tickerHandler = handler;
          return true;
      }
      setInterval(interval) {
          this.interval = interval;
      }
      getInterval() {
          return this.interval;
      }
      setFPS(fps) {
          this.setInterval(1000 / fps);
      }
      getFPS() {
          return 1000 / this.interval;
      }
      tick(interval) {
          this.tickerHandler.tick(interval, (handler) => {
              this.handleTick(handler, { once: true });
          });
      }
      tickTo(t) {
          if (!this.tickerHandler.tickTo) {
              return;
          }
          this.tickerHandler.tickTo(t, (handler) => {
              this.handleTick(handler, { once: true });
          });
      }
      pause() {
          if (this.status === STATUS$1.INITIAL) {
              return false;
          }
          this.status = STATUS$1.PAUSE;
          return true;
      }
      resume() {
          if (this.status === STATUS$1.INITIAL) {
              return false;
          }
          this.status = STATUS$1.RUNNING;
          return true;
      }
      ifCanStop() {
          if (this.autoStop) {
              if (!this.timelines.length) {
                  return true;
              }
              if (this.timelines.reduce((a, b) => a + b.animateCount, 0) === 0) {
                  return true;
              }
          }
          return false;
      }
      start(force = false) {
          if (this.status === STATUS$1.RUNNING) {
              return false;
          }
          if (!this.tickerHandler) {
              return false;
          }
          if (!force) {
              if (this.status === STATUS$1.PAUSE) {
                  return false;
              }
              if (!this.timelines.length) {
                  return false;
              }
              if (this.timelines.reduce((a, b) => a + b.animateCount, 0) === 0) {
                  return false;
              }
          }
          this.status = STATUS$1.RUNNING;
          this.tickerHandler.tick(0, this.handleTick);
          return true;
      }
      stop() {
          this.status = STATUS$1.INITIAL;
          this.setupTickHandler();
          this.lastFrameTime = -1;
      }
      handleTick = (handler, params) => {
          const { once = false } = params ?? {};
          if (this.ifCanStop()) {
              this.stop();
              return;
          }
          this._handlerTick(handler);
          if (!once) {
              handler.tick(this.interval, this.handleTick);
          }
      };
      _handlerTick = (handler) => {
          const tickerHandler = this.tickerHandler;
          const time = tickerHandler.getTime();
          let delta = 0;
          if (this.lastFrameTime >= 0) {
              delta = time - this.lastFrameTime;
          }
          this.lastFrameTime = time;
          if (this.status !== STATUS$1.RUNNING) {
              return;
          }
          this.tickCounts++;
          this.timelines.forEach(t => {
              t.tick(delta);
          });
      };
  }
  class ManualTicker extends DefaultTicker {
      set mode(m) {
          this.setupTickHandler();
      }
      get mode() {
          return this._mode;
      }
      initHandler() {
          this.mode = 'manual';
          return null;
      }
      setupTickHandler() {
          const handler = new ManualTickHandler();
          this._mode = 'manual';
          if (this.tickerHandler) {
              this.tickerHandler.release();
          }
          this.tickerHandler = handler;
          return true;
      }
      tickAt(time) {
          this.tickerHandler.tick(time - this.lastFrameTime, (handler) => {
              this.handleTick(handler, { once: true });
          });
      }
      ifCanStop() {
          return false;
      }
  }

  class Easing {
      constructor() {
      }
      static linear(t) {
          return t;
      }
      static none() {
          return this.linear;
      }
      static get(amount) {
          if (amount < -1) {
              amount = -1;
          }
          else if (amount > 1) {
              amount = 1;
          }
          return function (t) {
              if (amount === 0) {
                  return t;
              }
              if (amount < 0) {
                  return t * (t * -amount + 1 + amount);
              }
              return t * ((2 - t) * amount + (1 - amount));
          };
      }
      static getPowIn(pow) {
          return function (t) {
              return Math.pow(t, pow);
          };
      }
      static getPowOut(pow) {
          return function (t) {
              return 1 - Math.pow(1 - t, pow);
          };
      }
      static getPowInOut(pow) {
          return function (t) {
              if ((t *= 2) < 1) {
                  return 0.5 * Math.pow(t, pow);
              }
              return 1 - 0.5 * Math.abs(Math.pow(2 - t, pow));
          };
      }
      static quadIn = Easing.getPowIn(2);
      static quadOut = Easing.getPowOut(2);
      static quadInOut = Easing.getPowInOut(2);
      static cubicIn = Easing.getPowIn(3);
      static cubicOut = Easing.getPowOut(3);
      static cubicInOut = Easing.getPowInOut(3);
      static quartIn = Easing.getPowIn(4);
      static quartOut = Easing.getPowOut(4);
      static quartInOut = Easing.getPowInOut(4);
      static quintIn = Easing.getPowIn(5);
      static quintOut = Easing.getPowOut(5);
      static quintInOut = Easing.getPowInOut(5);
      static getBackIn(amount) {
          return function (t) {
              return t * t * ((amount + 1) * t - amount);
          };
      }
      static getBackOut(amount) {
          return function (t) {
              return --t * t * ((amount + 1) * t + amount) + 1;
          };
      }
      static getBackInOut(amount) {
          amount *= 1.525;
          return function (t) {
              if ((t *= 2) < 1) {
                  return 0.5 * (t * t * ((amount + 1) * t - amount));
              }
              return 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
          };
      }
      static backIn = Easing.getBackIn(1.7);
      static backOut = Easing.getBackOut(1.7);
      static backInOut = Easing.getBackInOut(1.7);
      static sineIn(t) {
          return 1 - Math.cos((t * Math.PI) / 2);
      }
      static sineOut(t) {
          return Math.sin((t * Math.PI) / 2);
      }
      static sineInOut(t) {
          return -(Math.cos(Math.PI * t) - 1) / 2;
      }
      static expoIn(t) {
          return t === 0 ? 0 : Math.pow(2, 10 * t - 10);
      }
      static expoOut(t) {
          return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
      }
      static expoInOut(t) {
          return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
      }
      static circIn(t) {
          return -(Math.sqrt(1 - t * t) - 1);
      }
      static circOut(t) {
          return Math.sqrt(1 - --t * t);
      }
      static circInOut(t) {
          if ((t *= 2) < 1) {
              return -0.5 * (Math.sqrt(1 - t * t) - 1);
          }
          return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      }
      static bounceOut(t) {
          if (t < 1 / 2.75) {
              return 7.5625 * t * t;
          }
          else if (t < 2 / 2.75) {
              return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
          }
          else if (t < 2.5 / 2.75) {
              return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
          }
          return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      }
      static bounceIn(t) {
          return 1 - Easing.bounceOut(1 - t);
      }
      static bounceInOut(t) {
          if (t < 0.5) {
              return Easing.bounceIn(t * 2) * 0.5;
          }
          return Easing.bounceOut(t * 2 - 1) * 0.5 + 0.5;
      }
      static getElasticIn(amplitude, period) {
          return function (t) {
              if (t === 0 || t === 1) {
                  return t;
              }
              const s = (period / pi2) * Math.asin(1 / amplitude);
              return -(amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * pi2) / period));
          };
      }
      static getElasticOut(amplitude, period) {
          return function (t) {
              if (t === 0 || t === 1) {
                  return t;
              }
              const s = (period / pi2) * Math.asin(1 / amplitude);
              return amplitude * Math.pow(2, -10 * t) * Math.sin(((t - s) * pi2) / period) + 1;
          };
      }
      static getElasticInOut(amplitude, period) {
          return function (t) {
              const s = (period / pi2) * Math.asin(1 / amplitude);
              if ((t *= 2) < 1) {
                  return -0.5 * (amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * pi2) / period));
              }
              return amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin(((t - s) * pi2) / period) * 0.5 + 1;
          };
      }
      static elasticIn = Easing.getElasticIn(1, 0.3);
      static elasticOut = Easing.getElasticOut(1, 0.3);
      static elasticInOut = Easing.getElasticInOut(1, 0.3 * 1.5);
  }

  class DefaultTimeline {
      constructor() {
          this.id = Generator.GenAutoIncrementId();
          this.animateHead = null;
          this.animateTail = null;
          this.animateCount = 0;
          this.paused = false;
      }
      addAnimate(animate) {
          if (!this.animateTail) {
              this.animateHead = animate;
              this.animateTail = animate;
          }
          else {
              this.animateTail.nextAnimate = animate;
              animate.prevAnimate = this.animateTail;
              this.animateTail = animate;
              animate.nextAnimate = null;
          }
          this.animateCount++;
      }
      pause() {
          this.paused = true;
      }
      resume() {
          this.paused = false;
      }
      tick(delta) {
          if (this.paused) {
              return;
          }
          let animate = this.animateHead;
          this.animateCount = 0;
          while (animate) {
              if (animate.status === exports.AnimateStatus.END) {
                  this.removeAnimate(animate);
              }
              else if (animate.status === exports.AnimateStatus.RUNNING || animate.status === exports.AnimateStatus.INITIAL) {
                  this.animateCount++;
                  animate.advance(delta);
              }
              else if (animate.status === exports.AnimateStatus.PAUSED) {
                  this.animateCount++;
              }
              animate = animate.nextAnimate;
          }
      }
      clear() {
          let animate = this.animateHead;
          while (animate) {
              animate.release();
              animate = animate.nextAnimate;
          }
          this.animateHead = null;
          this.animateTail = null;
          this.animateCount = 0;
      }
      removeAnimate(animate) {
          animate._onRemove && animate._onRemove.forEach(cb => cb());
          if (animate === this.animateHead) {
              this.animateHead = animate.nextAnimate;
              if (animate === this.animateTail) {
                  this.animateTail = null;
              }
              else {
                  this.animateHead.prevAnimate = null;
              }
          }
          else if (animate === this.animateTail) {
              this.animateTail = animate.prevAnimate;
              this.animateTail.nextAnimate = null;
          }
          else {
              animate.prevAnimate.nextAnimate = animate.nextAnimate;
              animate.nextAnimate.prevAnimate = animate.prevAnimate;
          }
          animate.release();
          return;
      }
  }
  const defaultTimeline = new DefaultTimeline();

  class ACustomAnimate {
      constructor(from, to, duration, easing, params) {
          this.from = from;
          this.to = to;
          this.duration = duration;
          this.easing = easing;
          this.params = params;
          this.updateCount = 0;
      }
      bind(target, subAni) {
          this.target = target;
          this.subAnimate = subAni;
          this.onBind();
      }
      onBind() {
          return;
      }
      onFirstRun() {
          return;
      }
      onStart() {
          return;
      }
      onEnd() {
          return;
      }
      getEndProps() {
          return;
      }
      getFromProps() {
          return this.from;
      }
      getMergedEndProps() {
          const thisEndProps = this.getEndProps();
          if (thisEndProps) {
              if (this._endProps === thisEndProps) {
                  return this._mergedEndProps;
              }
              this._endProps = thisEndProps;
              this._mergedEndProps = Object.assign({}, this.step.prev.getLastProps() ?? {}, thisEndProps);
              return;
          }
          return this.step.prev ? this.step.prev.getLastProps() : thisEndProps;
      }
      update(end, ratio, out) {
          if (this.updateCount === 0) {
              this.onFirstRun();
          }
          this.updateCount += 1;
          Object.assign(out, this.step.getLastProps());
          this.onUpdate(end, ratio, out);
          if (end) {
              this.onEnd();
          }
      }
  }
  class CbAnimate extends ACustomAnimate {
      cb;
      constructor(cb) {
          super(null, null, 0, 'linear');
          this.cb = cb;
      }
      onUpdate(end, ratio, out) {
          return;
      }
      onStart() {
          this.cb();
      }
  }
  class Animate {
      static mode = exports.AnimateMode.NORMAL;
      static interpolateMap = new Map();
      constructor(id = Generator.GenAutoIncrementId(), timeline = defaultTimeline) {
          this.id = id;
          this.timeline = timeline;
          this.status = exports.AnimateStatus.INITIAL;
          this.tailAnimate = new SubAnimate(this);
          this.subAnimates = [this.tailAnimate];
          this.timeScale = 1;
          this.rawPosition = -1;
          this._startTime = 0;
          this._duringTime = 0;
          this.timeline.addAnimate(this);
      }
      getStartTime() {
          return this._startTime;
      }
      getDuration() {
          return this.subAnimates.reduce((t, subAnimate) => t + subAnimate.totalDuration, 0);
      }
      after(animate) {
          const t = animate.getDuration();
          this._startTime = t;
          return this;
      }
      afterAll(list) {
          let maxT = -Infinity;
          list.forEach(a => {
              maxT = max(a.getDuration(), maxT);
          });
          this._startTime = maxT;
          return this;
      }
      parallel(animate) {
          this._startTime = animate.getStartTime();
          return this;
      }
      static AddInterpolate(name, cb) {
          Animate.interpolateMap.set(name, cb);
      }
      play(customAnimate) {
          this.tailAnimate.play(customAnimate);
          if (this.target) {
              const stage = this.target.stage;
              stage && stage.renderNextFrame();
          }
          if (this.subAnimates.length === 1 && this.tailAnimate.duration === customAnimate.duration) {
              this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode);
          }
          return this;
      }
      trySetAttribute(attr, mode = Animate.mode) {
          if (attr && mode & exports.AnimateMode.SET_ATTR_IMMEDIATELY) {
              this.target.setAttributes &&
                  this.target.setAttributes(attr, false, { type: exports.AttributeUpdateType.ANIMATE_PLAY });
          }
      }
      runCb(cb) {
          const customAnimate = new CbAnimate(() => {
              cb(this, customAnimate.step.prev);
          });
          this.tailAnimate.play(customAnimate);
          return this;
      }
      customInterpolate(key, ratio, from, to, target, ret) {
          const func = Animate.interpolateMap.get(key) || Animate.interpolateMap.get('');
          if (!func) {
              return false;
          }
          return func(key, ratio, from, to, target, ret);
      }
      pause() {
          if (this.status === exports.AnimateStatus.RUNNING) {
              this.status = exports.AnimateStatus.PAUSED;
          }
      }
      resume() {
          if (this.status === exports.AnimateStatus.PAUSED) {
              this.status = exports.AnimateStatus.RUNNING;
          }
      }
      to(props, duration, easing, params) {
          this.tailAnimate.to(props, duration, easing, params);
          if (this.target) {
              const stage = this.target.stage;
              stage && stage.renderNextFrame();
          }
          return this;
      }
      from(props, duration, easing, params) {
          this.tailAnimate.from(props, duration, easing, params);
          if (this.target) {
              const stage = this.target.stage;
              stage && stage.renderNextFrame();
          }
          return this;
      }
      wait(duration) {
          this.tailAnimate.wait(duration);
          if (this.target) {
              const stage = this.target.stage;
              stage && stage.renderNextFrame();
          }
          return this;
      }
      startAt(t) {
          this.tailAnimate.startAt(t);
          if (this.target) {
              const stage = this.target.stage;
              stage && stage.renderNextFrame();
          }
          return this;
      }
      loop(l) {
          this.tailAnimate.loop = l;
          if (this.target) {
              const stage = this.target.stage;
              stage && stage.renderNextFrame();
          }
          return this;
      }
      reversed(r) {
          this.tailAnimate.reversed = r;
          if (this.target) {
              const stage = this.target.stage;
              stage && stage.renderNextFrame();
          }
          return this;
      }
      bounce(b) {
          this.tailAnimate.bounce = b;
          if (this.target) {
              const stage = this.target.stage;
              stage && stage.renderNextFrame();
          }
          return this;
      }
      subAnimate() {
          const sa = new SubAnimate(this, this.tailAnimate);
          this.tailAnimate = sa;
          this.subAnimates.push(sa);
          sa.bind(this.target);
          return this;
      }
      getStartProps() {
          return this.subAnimates[0].getStartProps();
      }
      getEndProps() {
          return this.tailAnimate.getEndProps();
      }
      depreventAttr(key) {
          if (!this._preventAttrs) {
              return;
          }
          this._preventAttrs.delete(key);
      }
      preventAttr(key) {
          if (!this._preventAttrs) {
              this._preventAttrs = new Set();
          }
          this._preventAttrs.add(key);
      }
      preventAttrs(keys) {
          keys.forEach(key => this.preventAttr(key));
      }
      validAttr(key) {
          if (!this._preventAttrs) {
              return true;
          }
          return !this._preventAttrs.has(key);
      }
      bind(target) {
          this.target = target;
          if (this.target.onAnimateBind) {
              this.target.onAnimateBind(this);
          }
          this.subAnimates.forEach(sa => {
              sa.bind(target);
          });
          return this;
      }
      advance(delta) {
          if (this._duringTime < this._startTime) {
              if (this._duringTime + delta * this.timeScale < this._startTime) {
                  this._duringTime += delta * this.timeScale;
                  return;
              }
              delta = this._duringTime + delta * this.timeScale - this._startTime;
              this._duringTime = this._startTime;
          }
          if (this.status === exports.AnimateStatus.INITIAL) {
              this.status = exports.AnimateStatus.RUNNING;
              this._onStart && this._onStart.forEach(cb => cb());
          }
          const end = this.setPosition(this.rawPosition + delta * this.timeScale);
          if (end && this.status === exports.AnimateStatus.RUNNING) {
              this.status = exports.AnimateStatus.END;
              this._onEnd && this._onEnd.forEach(cb => cb());
          }
      }
      setPosition(rawPosition) {
          let d = 0;
          let sa;
          const prevRawPos = this.rawPosition;
          const maxRawPos = this.subAnimates.reduce((a, b) => a + b.totalDuration, 0);
          if (rawPosition < 0) {
              rawPosition = 0;
          }
          const end = rawPosition >= maxRawPos;
          if (end) {
              rawPosition = maxRawPos;
          }
          if (rawPosition === prevRawPos) {
              return end;
          }
          for (let i = 0; i < this.subAnimates.length; i++) {
              sa = this.subAnimates[i];
              if (d + sa.totalDuration >= rawPosition) {
                  break;
              }
              else {
                  d += sa.totalDuration;
                  sa = undefined;
              }
          }
          this.rawPosition = rawPosition;
          sa.setPosition(rawPosition - d);
          return end;
      }
      onStart(cb) {
          if (!this._onStart) {
              this._onStart = [];
          }
          this._onStart.push(cb);
      }
      onEnd(cb) {
          if (!this._onEnd) {
              this._onEnd = [];
          }
          this._onEnd.push(cb);
      }
      onRemove(cb) {
          if (!this._onRemove) {
              this._onRemove = [];
          }
          this._onRemove.push(cb);
      }
      onFrame(cb) {
          if (!this._onFrame) {
              this._onFrame = [];
          }
          this._onFrame.push(cb);
      }
      release() {
          this.status = exports.AnimateStatus.END;
          return;
      }
      stop(nextVal) {
          if (!nextVal) {
              this.target.onStop();
          }
          if (nextVal === 'start') {
              this.target.onStop(this.getStartProps());
          }
          else if (nextVal === 'end') {
              this.target.onStop(this.getEndProps());
          }
          else {
              this.target.onStop(nextVal);
          }
          this.release();
      }
  }
  class SubAnimate {
      get totalDuration() {
          this.calcAttr();
          return this._totalDuration + this._startAt;
      }
      constructor(animate, lastSubAnimate) {
          this.rawPosition = -1;
          this.position = 0;
          this.loop = 0;
          this.duration = 0;
          this.animate = animate;
          if (lastSubAnimate) {
              this.stepHead = new Step(0, 0, Object.assign({}, lastSubAnimate.stepTail.props));
          }
          else {
              this.stepHead = new Step(0, 0, {});
          }
          this.stepTail = this.stepHead;
          this.dirty = true;
          this._startAt = 0;
      }
      calcAttr() {
          if (!this.dirty) {
              return;
          }
          this._totalDuration = this.duration * (this.loop + 1);
      }
      bind(target) {
          this.target = target;
          return this;
      }
      play(customAnimate) {
          let duration = customAnimate.duration;
          if (duration == null || duration < 0) {
              duration = 0;
          }
          const easing = customAnimate.easing;
          const easingFunc = typeof easing === 'string' ? Easing[easing] : easing;
          const step = this._addStep(duration, null, easingFunc);
          step.type = exports.AnimateStepType.customAnimate;
          this._appendProps(customAnimate.getEndProps(), step, false);
          this._appendCustomAnimate(customAnimate, step);
          return this;
      }
      to(props, duration, easing, params) {
          if (duration == null || duration < 0) {
              duration = 0;
          }
          const easingFunc = typeof easing === 'string' ? Easing[easing] : easing;
          const step = this._addStep(duration, null, easingFunc);
          step.type = exports.AnimateStepType.to;
          this._appendProps(props, step, params ? params.tempProps : false);
          if (!step.propKeys) {
              step.propKeys = Object.keys(step.props);
          }
          if (!(params && params.noPreventAttrs)) {
              this.target.animates.forEach(a => {
                  if (a.id !== this.animate.id) {
                      a.preventAttrs(step.propKeys);
                  }
              });
          }
          return this;
      }
      from(props, duration, easing, params) {
          this.to(props, 0, easing, params);
          const toProps = {};
          if (!this.stepTail.propKeys) {
              this.stepTail.propKeys = Object.keys(this.stepTail.props);
          }
          this.stepTail.propKeys.forEach(k => {
              toProps[k] = this.getLastPropByName(k, this.stepTail);
          });
          this.to(toProps, duration, easing, params);
          this.stepTail.type = exports.AnimateStepType.from;
      }
      startAt(t) {
          if (t < 0) {
              t = 0;
          }
          this._startAt = t;
          return this;
      }
      getStartProps() {
          return this.stepHead?.props;
      }
      getEndProps() {
          return this.stepTail.props;
      }
      getLastStep() {
          return this._lastStep;
      }
      wait(duration) {
          if (duration > 0) {
              const step = this._addStep(+duration, null);
              step.type = exports.AnimateStepType.wait;
              if (step.prev.customAnimate) {
                  step.props = step.prev.customAnimate.getEndProps();
              }
              else {
                  step.props = step.prev.props;
              }
              if (this.target.onAddStep) {
                  this.target.onAddStep(step);
              }
          }
          return this;
      }
      _addStep(duration, props, easingFunc) {
          const step = new Step(this.duration, duration, props, easingFunc);
          this.duration += duration;
          this.stepTail.append(step);
          this.stepTail = step;
          return step;
      }
      _appendProps(props, step, tempProps) {
          if (tempProps) {
              step.props = props;
          }
          else {
              step.props = Object.assign({}, props);
          }
          let lastStep = step.prev;
          const _props = step.props;
          if (!step.propKeys) {
              step.propKeys = Object.keys(step.props);
          }
          step.propKeys.forEach(k => {
              if (step.props[k] === undefined) {
                  step.props[k] = this.target.getDefaultAttribute(k);
              }
          });
          while (lastStep.prev) {
              if (lastStep.props) {
                  if (!lastStep.propKeys) {
                      lastStep.propKeys = Object.keys(lastStep.props);
                  }
                  lastStep.propKeys.forEach(key => {
                      if (_props[key] === undefined) {
                          _props[key] = lastStep.props[key];
                      }
                  });
              }
              lastStep = lastStep.prev;
          }
          const initProps = this.stepHead.props;
          if (!step.propKeys) {
              step.propKeys = Object.keys(_props);
          }
          step.propKeys.forEach(key => {
              if (initProps[key] === undefined) {
                  const parentAnimateInitProps = this.animate.getStartProps();
                  initProps[key] = parentAnimateInitProps[key] = this.target.getComputedAttribute(key);
              }
          });
          if (this.target.onAddStep) {
              this.target.onAddStep(step);
          }
      }
      _appendCustomAnimate(customAnimate, step) {
          step.customAnimate = customAnimate;
          customAnimate.step = step;
          customAnimate.bind(this.target, this);
      }
      setPosition(rawPosition) {
          const d = this.duration;
          const loopCount = this.loop;
          const prevRawPos = this.rawPosition;
          let end = false;
          let loop;
          let position;
          const startAt = this._startAt ?? 0;
          if (rawPosition < 0) {
              rawPosition = 0;
          }
          if (rawPosition < startAt) {
              this.rawPosition = rawPosition;
              return false;
          }
          rawPosition = rawPosition - startAt;
          if (d <= 0) {
              end = true;
              return end;
          }
          loop = Math.floor(rawPosition / d);
          position = rawPosition - loop * d;
          end = rawPosition >= loopCount * d + d;
          if (end) {
              position = d;
              loop = loopCount;
              rawPosition = position * loop + d;
          }
          if (rawPosition === prevRawPos) {
              return end;
          }
          const rev = !this.reversed !== !(this.bounce && loop % 2);
          if (rev) {
              position = d - position;
          }
          this._deltaPosition = position - this.position;
          this.position = position;
          this.rawPosition = rawPosition + startAt;
          this.updatePosition(end, rev);
          return end;
      }
      updatePosition(end, rev) {
          if (!this.stepHead) {
              return;
          }
          let step = this.stepHead.next;
          const position = this.position;
          const duration = this.duration;
          if (this.target && step) {
              let stepNext = step.next;
              while (stepNext && stepNext.position <= position) {
                  step = stepNext;
                  stepNext = step.next;
              }
              let ratio = end ? (duration === 0 ? 1 : position / duration) : (position - step.position) / step.duration;
              if (step.easing) {
                  ratio = step.easing(ratio);
              }
              this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev);
              this.updateTarget(step, ratio, end);
              this._lastStep = step;
              this.animate._onFrame && this.animate._onFrame.forEach(cb => cb(step, ratio));
          }
      }
      tryCallCustomAnimateLifeCycle(step, lastStep, rev) {
          if (step === lastStep) {
              return;
          }
          if (rev) {
              let _step = lastStep.prev;
              while (_step && _step !== step) {
                  if (_step.customAnimate) {
                      _step.customAnimate.onStart && _step.customAnimate.onStart();
                      _step.customAnimate.onEnd && _step.customAnimate.onEnd();
                  }
                  _step = step.prev;
              }
              if (lastStep && lastStep.customAnimate) {
                  lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd();
              }
              if (step && step.customAnimate) {
                  step.customAnimate.onStart && step.customAnimate.onStart();
              }
          }
          else {
              let _step = lastStep.next;
              while (_step && _step !== step) {
                  if (_step.customAnimate) {
                      _step.customAnimate.onStart && _step.customAnimate.onStart();
                      _step.customAnimate.onEnd && _step.customAnimate.onEnd();
                  }
                  _step = _step.next;
              }
              if (lastStep && lastStep.customAnimate) {
                  lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd();
              }
              if (step && step.customAnimate) {
                  step.customAnimate.onStart && step.customAnimate.onStart();
              }
          }
      }
      getLastPropByName(name, step) {
          let lastStep = step.prev;
          while (lastStep) {
              if (lastStep.props && lastStep.props[name] !== undefined) {
                  return lastStep.props[name];
              }
              else if (lastStep.customAnimate) {
                  const val = lastStep.customAnimate.getEndProps()[name];
                  if (val !== undefined) {
                      return val;
                  }
              }
              lastStep = lastStep.prev;
          }
          console.warn('step');
          return step.props[name];
      }
      updateTarget(step, ratio, end) {
          if (step.props == null && step.customAnimate == null) {
              return;
          }
          this.target.onStep(this, this.animate, step, ratio, end);
      }
  }
  class Step {
      type;
      constructor(position, duration, props, easing) {
          this.duration = duration;
          this.position = position;
          this.props = props;
          this.easing = easing;
      }
      append(step) {
          step.prev = this;
          step.next = this.next;
          this.next = step;
      }
      getLastProps() {
          let step = this.prev;
          while (step) {
              if (step.props) {
                  return step.props;
              }
              else if (step.customAnimate) {
                  return step.customAnimate.getMergedEndProps();
              }
              step = step.prev;
          }
          return null;
      }
  }

  const DefaultStateAnimateConfig = {
      duration: 200,
      easing: 'cubicOut'
  };
  const DefaultMorphingAnimateConfig = {
      duration: 1000,
      easing: 'quadInOut'
  };

  exports.Edge = void 0;
  (function (Edge) {
      Edge[Edge["Top"] = 1] = "Top";
      Edge[Edge["Right"] = 2] = "Right";
      Edge[Edge["Bottom"] = 4] = "Bottom";
      Edge[Edge["Left"] = 8] = "Left";
      Edge[Edge["ALL"] = 15] = "ALL";
  })(exports.Edge || (exports.Edge = {}));
  const _strokeVec4 = [
      false,
      false,
      false,
      false
  ];
  const parseStroke = (stroke) => {
      let isFullStroke = true;
      if (isBoolean(stroke, true)) {
          for (let i = 0; i < 4; i++) {
              _strokeVec4[i] = stroke;
              isFullStroke &&= !!(_strokeVec4[i] ?? true);
          }
          isFullStroke = stroke;
      }
      else if (Array.isArray(stroke)) {
          for (let i = 0; i < 4; i++) {
              _strokeVec4[i] = !!stroke[i];
              isFullStroke &&= !!_strokeVec4[i];
          }
      }
      else {
          _strokeVec4[0] = false;
          _strokeVec4[1] = false;
          _strokeVec4[2] = false;
          _strokeVec4[3] = false;
      }
      return {
          isFullStroke,
          stroke: _strokeVec4
      };
  };
  const _paddingVec4 = [0, 0, 0, 0];
  const parsePadding = (padding) => {
      if (!padding) {
          return 0;
      }
      if (isArray(padding)) {
          if (padding.length === 0) {
              return 0;
          }
          else if (padding.length === 1) {
              return padding[0];
          }
          else if (padding.length === 2) {
              _paddingVec4[0] = padding[0];
              _paddingVec4[2] = padding[0];
              _paddingVec4[1] = padding[1];
              _paddingVec4[3] = padding[1];
              return _paddingVec4;
          }
          return padding;
      }
      return padding;
  };
  const _coords = [
      { x: 0, y: 0 },
      { x: 0, y: 0 },
      { x: 0, y: 0 },
      { x: 0, y: 0 }
  ];
  const indexList = [1, 2, 3, 0, 1, 2, 3, 0];
  function circleBounds(startAngle, endAngle, radius, bounds) {
      while (startAngle >= pi2) {
          startAngle -= pi2;
      }
      while (startAngle < 0) {
          startAngle += pi2;
      }
      while (startAngle > endAngle) {
          endAngle += pi2;
      }
      _coords[0].x = radius;
      _coords[1].y = radius;
      _coords[2].x = -radius;
      _coords[3].y = -radius;
      const startIdx = Math.ceil(startAngle / halfPi$1) % 4;
      const endIdx = Math.ceil(endAngle / halfPi$1) % 4;
      bounds.add(cos(startAngle) * radius, sin(startAngle) * radius);
      bounds.add(cos(endAngle) * radius, sin(endAngle) * radius);
      if (startIdx !== endIdx || endAngle - startAngle > pi) {
          let match = false;
          for (let i = 0; i < indexList.length; i++) {
              if (!match && startIdx === indexList[i]) {
                  match = true;
                  const p = _coords[startIdx];
                  bounds.add(p.x, p.y);
                  continue;
              }
              else if (match && endIdx === indexList[i]) {
                  break;
              }
              if (match) {
                  const p = _coords[indexList[i]];
                  bounds.add(p.x, p.y);
              }
          }
      }
  }
  function pointsEqual(pointsA, pointsB) {
      if (!pointsA || !pointsB) {
          return false;
      }
      if (Array.isArray(pointsA) && Array.isArray(pointsB)) {
          if (pointsA.length !== pointsB.length) {
              return false;
          }
          return pointsA.every((point, index) => pointEqual(point, pointsB[index]));
      }
      if (!Number.isNaN(pointsA.x + pointsA.y)) {
          return pointEqual(pointsA, pointsB);
      }
      return false;
  }
  function pointEqual(pointA, pointB) {
      return (pointA.x === pointB.x &&
          pointA.y === pointB.y &&
          pointA.x1 === pointB.x1 &&
          pointA.y1 === pointB.y1 &&
          pointA.defined === pointB.defined);
  }
  function pointInterpolation(pointA, pointB, ratio) {
      const { x, y } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio);
      const { x: x1, y: y1 } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio);
      const point = new Point(x, y, x1, y1);
      point.defined = pointB.defined;
      return point;
  }
  function pointInterpolationHighPerformance(pointA, pointB, ratio, point) {
      const { x, y } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio);
      const { x: x1, y: y1 } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio);
      point.x = x;
      point.y = y;
      point.x1 = x1;
      point.y1 = y1;
      point.defined = pointB.defined;
      return point;
  }
  function pointsInterpolation(pointsA, pointsB, ratio) {
      if (!pointsA || !pointsB) {
          return [];
      }
      if (!Array.isArray(pointsA)) {
          pointsA = [pointsA];
      }
      if (!Array.isArray(pointsB)) {
          pointsB = [pointsB];
      }
      let points = [];
      if (pointsA.length > pointsB.length) {
          points = pointsB.map(point => {
              const p = new Point(point.x, point.y, point.x1, point.y1);
              p.defined = point.defined;
              return p;
          });
          for (let i = 0; i < pointsB.length; i++) {
              points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
          }
      }
      else {
          points = pointsB.map(point => {
              const p = new Point(point.x, point.y, point.x1, point.y1);
              p.defined = point.defined;
              return p;
          });
          for (let i = 0; i < pointsA.length; i++) {
              points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
          }
      }
      return points;
  }
  const transformKeys = [
      'x',
      'y',
      'dx',
      'dy',
      'scaleX',
      'scaleY',
      'angle',
      'anchor',
      'postMatrix',
      'scrollX',
      'scrollY'
  ];
  const isTransformKey = (key) => {
      return transformKeys.includes(key);
  };
  function getAttributeFromDefaultAttrList(attr, key) {
      if (isArray(attr)) {
          let val;
          for (let i = 0; i < attr.length && val === undefined; i++) {
              val = attr[i][key];
          }
          return val;
      }
      return attr[key];
  }

  class IncreaseCount extends ACustomAnimate {
      fromNumber;
      toNumber;
      constructor(from, to, duration, easing, params) {
          super(from, to, duration, easing, params);
      }
      getEndProps() {
          if (this.valid === false) {
              return {};
          }
          return {
              text: this.to
          };
      }
      onBind() {
          this.fromNumber = isNumber(this.from?.text) ? this.from?.text : Number.parseFloat(this.from?.text);
          this.toNumber = isNumber(this.to?.text) ? this.to?.text : Number.parseFloat(this.to?.text);
          if (!Number.isFinite(this.toNumber)) {
              this.fromNumber = 0;
          }
          if (!Number.isFinite(this.toNumber)) {
              this.valid = false;
          }
      }
      onEnd() {
          return;
      }
      onUpdate(end, ratio, out) {
          if (this.valid === false) {
              return;
          }
          if (end) {
              out.text = this.toNumber.toFixed();
          }
          else {
              out.text = (this.fromNumber + (this.toNumber - this.fromNumber) * ratio).toFixed(this.params?.fixed ?? 0);
          }
      }
  }
  var Direction;
  (function (Direction) {
      Direction[Direction["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
      Direction[Direction["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
      Direction[Direction["TOP_TO_BOTTOM"] = 2] = "TOP_TO_BOTTOM";
      Direction[Direction["BOTTOM_TO_TOP"] = 3] = "BOTTOM_TO_TOP";
      Direction[Direction["STROKE"] = 4] = "STROKE";
  })(Direction || (Direction = {}));
  class FadeInPlus extends ACustomAnimate {
      constructor(from, to, duration, easing, params) {
          super(from, to, duration, easing, params);
          const { direction = Direction.LEFT_TO_RIGHT, fill = true, stroke = true } = params || {};
          this.direction = direction;
          this.fill = fill;
          this.stroke = stroke;
          this.fillGradient = {
              gradient: 'linear',
              stops: []
          };
          this.strokeGradient = {
              gradient: 'linear',
              stops: []
          };
      }
      getEndProps() {
          return {
              fill: this.toFill,
              stroke: this.toStroke
          };
      }
      onBind() {
          this.toFill = this.target.getComputedAttribute('fill');
          this.toStroke = this.target.getComputedAttribute('stroke');
      }
      onEnd() {
          return;
      }
      onUpdate(end, ratio, out) {
          if (!this.toFill) {
              return;
          }
          if (!this.toStroke) {
              return;
          }
          switch (this.direction) {
              case Direction.RIGHT_TO_LEFT:
                  this.rightToLeft(end, ratio, out);
                  break;
              case Direction.TOP_TO_BOTTOM:
                  this.topToBottom(end, ratio, out);
                  break;
              case Direction.BOTTOM_TO_TOP:
                  this.bottomToTop(end, ratio, out);
                  break;
              case Direction.STROKE:
                  this.strokePath(end, ratio, out);
                  break;
              default:
                  this.leftToRight(end, ratio, out);
                  break;
          }
      }
      leftToRight(end, ratio, out) {
          if (this.fill) {
              const toFillColor = this.toFill;
              this.fillGradient.x0 = 0;
              this.fillGradient.y0 = 0;
              this.fillGradient.x1 = 1;
              this.fillGradient.y1 = 0;
              this.fillGradient.stops = [
                  { offset: 0, color: toFillColor },
                  { offset: ratio, color: toFillColor },
                  { offset: Math.min(1, ratio * 2), color: 'transparent' }
              ];
              out.fill = this.fillGradient;
          }
          if (this.stroke) {
              const toStrokeColor = this.toStroke;
              this.strokeGradient.x0 = 0;
              this.strokeGradient.y0 = 0;
              this.strokeGradient.x1 = 1;
              this.strokeGradient.y1 = 0;
              this.strokeGradient.stops = [
                  { offset: 0, color: toStrokeColor },
                  { offset: ratio, color: toStrokeColor },
                  { offset: Math.min(1, ratio * 6), color: 'transparent' }
              ];
              out.stroke = this.strokeGradient;
          }
          return;
      }
      strokePath(end, ratio, out) {
          if (this.fill) {
              const toFillColor = this.toFill;
              this.fillGradient.x0 = 0;
              this.fillGradient.y0 = 0;
              this.fillGradient.x1 = 1;
              this.fillGradient.y1 = 0;
              this.fillGradient.stops = [
                  { offset: 0, color: toFillColor },
                  { offset: ratio, color: toFillColor },
                  { offset: Math.min(1, ratio * 2), color: 'transparent' }
              ];
              out.fill = this.fillGradient;
          }
          if (this.stroke) {
              const dashLen = 300;
              const offset = ratio * dashLen;
              out.lineDash = [offset, dashLen - offset];
          }
          return;
      }
      rightToLeft(end, ratio, out) {
          return;
      }
      topToBottom(end, ratio, out) {
          return;
      }
      bottomToTop(end, ratio, out) {
          return;
      }
  }
  class InputText extends ACustomAnimate {
      fromText = '';
      toText = '';
      getEndProps() {
          if (this.valid === false) {
              return {};
          }
          return {
              text: this.to
          };
      }
      onBind() {
          this.fromText = this.from?.text ?? '';
          this.toText = this.to?.text ?? '';
          if (!this.toText || isArray(this.toText)) {
              this.valid = false;
          }
          else {
              this.toText = this.toText.toString();
              const root = this.target.attachShadow();
              const line = application.graphicService.creator.line({
                  x: 0,
                  y: 0,
                  points: [
                      { x: 0, y: 0 },
                      { x: 0, y: this.target.getComputedAttribute('fontSize') }
                  ],
                  stroke: 'black',
                  lineWidth: 1
              });
              root.add(line);
          }
      }
      onEnd() {
          this.target.detachShadow();
          return;
      }
      onUpdate(end, ratio, out) {
          if (this.valid === false) {
              return;
          }
          const fromCount = this.fromText.length;
          const toCount = this.toText.length;
          const count = Math.ceil(fromCount + (toCount - fromCount) * ratio);
          out.text = this.toText.substr(0, count);
          const line = this.target.shadowRoot?.at(0);
          const endX = this.target.clipedWidth + 2;
          line.setAttribute('x', endX);
      }
  }
  class StreamLight extends ACustomAnimate {
      constructor(from, to, duration, easing, params) {
          super(from, to, duration, easing, params);
      }
      getEndProps() {
          return {};
      }
      onStart() {
          const root = this.target.attachShadow();
          const height = this.target.AABBBounds.height();
          const rect = application.graphicService.creator.rect({
              height: height,
              fill: '#bcdeff',
              shadowBlur: 30,
              shadowColor: '#bcdeff',
              ...this.params?.attribute,
              x: 0,
              y: 0,
              width: 0
          });
          this.rect = rect;
          root.add(rect);
      }
      onBind() {
          return;
      }
      onEnd() {
          this.target.detachShadow();
      }
      onUpdate(end, ratio, out) {
          const parentWidth = this.target.attribute.width ?? 250;
          const streamLength = this.params?.streamLength ?? parentWidth;
          const maxLength = this.params?.attribute?.width ?? 60;
          const startX = -maxLength;
          const currentX = startX + (streamLength - startX) * ratio;
          const x = Math.max(currentX, 0);
          const w = Math.min(Math.min(currentX + maxLength, maxLength), streamLength - currentX);
          const width = w + x > parentWidth ? Math.max(parentWidth - x, 0) : w;
          this.rect.setAttributes({
              x,
              width
          }, false, {
              type: exports.AttributeUpdateType.ANIMATE_PLAY,
              animationState: {
                  ratio,
                  end
              }
          });
      }
  }
  class Meteor extends ACustomAnimate {
      get lastPos() {
          return this.posList[this.posList.length - 1];
      }
      constructor(size, duration, easing, params) {
          super(null, null, duration, easing, params);
          this.size = size;
          this.posList = [];
      }
      onBind() {
          const root = this.target.attachShadow();
          this.root = root;
          for (let i = 0; i < this.size; i++) {
              const g = this.target.clone();
              const scale = Math.min(((this.size - i) / this.size) * 3, 1);
              const opacity = Math.min(0.2 + 0.7 / this.size);
              g.setAttributes({ x: 0, y: 0, dx: 0, dy: 0, scaleX: scale, scaleY: scale, opacity }, false, {
                  type: exports.AttributeUpdateType.ANIMATE_BIND
              });
              root.add(g);
          }
      }
      onUpdate(end, ratio, out) {
          if (end) {
              this.target.detachShadow();
              this.posList.length = 0;
              return;
          }
          const x = this.target.getComputedAttribute('x');
          const y = this.target.getComputedAttribute('y');
          const nextPos = new Point(x, y);
          if (!this.posList.length) {
              this.posList.push(nextPos);
              return;
          }
          this.target.shadowRoot.forEachChildren((g, i) => {
              const pos = this.posList[Math.max(this.posList.length - i - 1, 0)];
              g.setAttributes({
                  x: pos.x - x,
                  y: pos.y - y
              }, false);
          });
          this.posList.push(nextPos);
      }
  }
  class MotionPath extends ACustomAnimate {
      constructor(from, to, duration, easing, params) {
          super(from, to, duration, easing, params);
          if (params) {
              this.pathLength = params.path.getLength();
              this.path = params.path;
              this.distance = params.distance;
              this.to = params.distance * this.pathLength;
              this.initAngle = params.initAngle ?? 0;
              this.changeAngle = !!params.changeAngle;
              this.cb = params.cb;
          }
      }
      onUpdate(end, ratio, out) {
          const at = this.to * ratio;
          const { pos, angle } = this.path.getAttrAt(at);
          out.x = pos.x;
          out.y = pos.y;
          if (this.changeAngle) {
              out.angle = angle + this.initAngle;
          }
          this.cb && this.cb(this.from, this.to, ratio, this.target);
      }
  }
  class TagPointsUpdate extends ACustomAnimate {
      fromPoints;
      toPoints;
      points;
      interpolatePoints;
      newPointAnimateType;
      constructor(from, to, duration, easing, params) {
          super(from, to, duration, easing, params);
          this.newPointAnimateType = params?.newPointAnimateType === 'appear' ? 'appear' : 'grow';
      }
      onBind() {
          const originFromPoints = this.from?.points;
          const originToPoints = this.to?.points;
          this.fromPoints = !originFromPoints ? [] : !Array.isArray(originFromPoints) ? [originFromPoints] : originFromPoints;
          this.toPoints = !originToPoints ? [] : !Array.isArray(originToPoints) ? [originToPoints] : originToPoints;
          const tagMap = new Map();
          this.fromPoints.forEach(point => {
              if (point.context) {
                  tagMap.set(point.context, point);
              }
          });
          let firstMatchedIndex = Infinity;
          let lastMatchedIndex = -Infinity;
          let firstMatchedPoint;
          let lastMatchedPoint;
          for (let i = 0; i < this.toPoints.length; i += 1) {
              if (tagMap.has(this.toPoints[i].context)) {
                  firstMatchedIndex = i;
                  firstMatchedPoint = tagMap.get(this.toPoints[i].context);
                  break;
              }
          }
          for (let i = this.toPoints.length - 1; i >= 0; i -= 1) {
              if (tagMap.has(this.toPoints[i].context)) {
                  lastMatchedIndex = i;
                  lastMatchedPoint = tagMap.get(this.toPoints[i].context);
                  break;
              }
          }
          let prevMatchedPoint = this.toPoints[0];
          this.interpolatePoints = this.toPoints.map((point, index) => {
              const matchedPoint = tagMap.get(point.context);
              if (matchedPoint) {
                  prevMatchedPoint = matchedPoint;
                  return [matchedPoint, point];
              }
              if (this.newPointAnimateType === 'appear') {
                  return [point, point];
              }
              if (index < firstMatchedIndex && firstMatchedPoint) {
                  return [firstMatchedPoint, point];
              }
              else if (index > lastMatchedIndex && lastMatchedPoint) {
                  return [lastMatchedPoint, point];
              }
              return [prevMatchedPoint, point];
          });
          this.points = this.interpolatePoints.map(interpolate => {
              const fromPoint = interpolate[0];
              const toPoint = interpolate[1];
              const newPoint = new Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
              newPoint.defined = toPoint.defined;
              newPoint.context = toPoint.context;
              return newPoint;
          });
      }
      onUpdate(end, ratio, out) {
          this.points = this.points.map((point, index) => {
              const newPoint = pointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
              newPoint.context = point.context;
              return newPoint;
          });
          out.points = this.points;
      }
  }
  class GraphicAnimate extends ACustomAnimate {
      graphic;
      constructor(from, to, duration, easing, params) {
          super(from, to, duration, easing, params);
          this.graphic = params?.graphic;
      }
      onUpdate(end, ratio, out) {
          if (!this.graphic) {
              return;
          }
          Object.keys(this.from).forEach(k => {
              out[k] = this.from[k] + (this.to[k] - this.from[k]) * ratio;
          });
      }
  }
  class ClipGraphicAnimate extends ACustomAnimate {
      _group;
      _clipGraphic;
      clipFromAttribute;
      clipToAttribute;
      _lastClip;
      _lastPath;
      constructor(from, to, duration, easing, params) {
          super(null, null, duration, easing, params);
          this.clipFromAttribute = from;
          this.clipToAttribute = to;
          this._group = params?.group;
          this._clipGraphic = params?.clipGraphic;
      }
      onBind() {
          if (this._group && this._clipGraphic) {
              this._lastClip = this._group.attribute.clip;
              this._lastPath = this._group.attribute.path;
              this._group.setAttributes({
                  clip: true,
                  path: [this._clipGraphic]
              }, false, { type: exports.AttributeUpdateType.ANIMATE_BIND });
          }
      }
      onEnd() {
          if (this._group) {
              this._group.setAttributes({
                  clip: this._lastClip,
                  path: this._lastPath
              }, false, { type: exports.AttributeUpdateType.ANIMATE_END });
          }
          return;
      }
      onUpdate(end, ratio, out) {
          if (!this._clipGraphic) {
              return;
          }
          const res = {};
          Object.keys(this.clipFromAttribute).forEach(k => {
              res[k] = this.clipFromAttribute[k] + (this.clipToAttribute[k] - this.clipFromAttribute[k]) * ratio;
          });
          this._clipGraphic.setAttributes(res, false, {
              type: exports.AttributeUpdateType.ANIMATE_UPDATE,
              animationState: { ratio, end }
          });
      }
  }
  class ClipAngleAnimate extends ClipGraphicAnimate {
      constructor(from, to, duration, easing, params) {
          const groupAttribute = params?.group?.attribute ?? {};
          const width = groupAttribute.width ?? 0;
          const height = groupAttribute.height ?? 0;
          const animationType = params?.animationType ?? 'in';
          const startAngle = params?.startAngle ?? 0;
          const orient = params?.orient ?? 'clockwise';
          let arcStartAngle = 0;
          let arcEndAngle = 0;
          if (orient === 'anticlockwise') {
              arcEndAngle = animationType === 'in' ? startAngle + Math.PI * 2 : startAngle;
              arcEndAngle = startAngle + Math.PI * 2;
          }
          else {
              arcStartAngle = startAngle;
              arcEndAngle = animationType === 'out' ? startAngle + Math.PI * 2 : startAngle;
          }
          const arc = application.graphicService.creator.arc({
              x: params?.center?.x ?? width / 2,
              y: params?.center?.y ?? height / 2,
              outerRadius: params?.radius ?? (width + height) / 2,
              innerRadius: 0,
              startAngle: arcStartAngle,
              endAngle: arcEndAngle,
              fill: true
          });
          let fromAttributes;
          let toAttributes;
          if (orient === 'anticlockwise') {
              fromAttributes = { startAngle: startAngle + Math.PI * 2 };
              toAttributes = { startAngle: startAngle };
          }
          else {
              fromAttributes = { endAngle: startAngle };
              toAttributes = { endAngle: startAngle + Math.PI * 2 };
          }
          super(animationType === 'in' ? fromAttributes : toAttributes, animationType === 'in' ? toAttributes : fromAttributes, duration, easing, { group: params?.group, clipGraphic: arc });
      }
  }
  class ClipRadiusAnimate extends ClipGraphicAnimate {
      constructor(from, to, duration, easing, params) {
          const groupAttribute = params?.group?.attribute ?? {};
          const width = groupAttribute.width ?? 0;
          const height = groupAttribute.height ?? 0;
          const animationType = params?.animationType ?? 'in';
          const startRadius = params?.startRadius ?? 0;
          const endRadius = params?.endRadius ?? Math.sqrt((width / 2) ** 2 + (height / 2) ** 2);
          const arc = application.graphicService.creator.arc({
              x: params?.center?.x ?? width / 2,
              y: params?.center?.y ?? height / 2,
              outerRadius: animationType === 'out' ? endRadius : startRadius,
              innerRadius: 0,
              startAngle: 0,
              endAngle: Math.PI * 2,
              fill: true
          });
          const fromAttributes = { outerRadius: startRadius };
          const toAttributes = { outerRadius: endRadius };
          super(animationType === 'in' ? fromAttributes : toAttributes, animationType === 'in' ? toAttributes : fromAttributes, duration, easing, { group: params?.group, clipGraphic: arc });
      }
  }
  class ClipDirectionAnimate extends ClipGraphicAnimate {
      constructor(from, to, duration, easing, params) {
          const groupAttribute = params?.group?.attribute ?? {};
          const width = params?.width ?? groupAttribute.width ?? 0;
          const height = params?.height ?? groupAttribute.height ?? 0;
          const animationType = params?.animationType ?? 'in';
          const direction = params?.direction ?? 'x';
          const orient = params?.orient ?? 'positive';
          const rect = application.graphicService.creator.rect({
              x: 0,
              y: 0,
              width: animationType === 'in' && direction === 'x' ? 0 : width,
              height: animationType === 'in' && direction === 'y' ? 0 : height,
              fill: true
          });
          let fromAttributes = {};
          let toAttributes = {};
          if (direction === 'y') {
              if (orient === 'negative') {
                  fromAttributes = { y: height, height: 0 };
                  toAttributes = { y: 0, height: height };
              }
              else {
                  fromAttributes = { height: 0 };
                  toAttributes = { height: height };
              }
          }
          else {
              if (orient === 'negative') {
                  fromAttributes = { x: width, width: 0 };
                  toAttributes = { x: 0, width: width };
              }
              else {
                  fromAttributes = { width: 0 };
                  toAttributes = { width: width };
              }
          }
          super(animationType === 'in' ? fromAttributes : toAttributes, animationType === 'in' ? toAttributes : fromAttributes, duration, easing, { group: params?.group, clipGraphic: rect });
      }
  }
  class RotateBySphereAnimate extends ACustomAnimate {
      onStart() {
          const { center, r } = typeof this.params === 'function' ? this.params() : this.params;
          const startX = this.target.getComputedAttribute('x');
          const startY = this.target.getComputedAttribute('y');
          const startZ = this.target.getComputedAttribute('z');
          const phi = Math.acos((startY - center.y) / r);
          let theta = Math.acos((startX - center.x) / r / Math.sin(phi));
          if (startZ - center.z < 0) {
              theta = pi2 - theta;
          }
          this.theta = theta;
          this.phi = phi;
      }
      onBind() {
          return;
      }
      onEnd() {
          return;
      }
      onUpdate(end, ratio, out) {
          if (this.phi == null || this.theta == null) {
              return;
          }
          const { center, r } = typeof this.params === 'function' ? this.params() : this.params;
          const deltaAngle = Math.PI * 2 * ratio;
          const theta = this.theta + deltaAngle;
          const phi = this.phi;
          const x = r * Math.sin(phi) * Math.cos(theta) + center.x;
          const y = r * Math.cos(phi) + center.y;
          const z = r * Math.sin(phi) * Math.sin(theta) + center.z;
          out.x = x;
          out.y = y;
          out.z = z;
          out.alpha = theta + pi / 2;
          while (out.alpha > pi2) {
              out.alpha -= pi2;
          }
          out.alpha = pi2 - out.alpha;
          out.zIndex = out.z * -10000;
      }
  }
  class GroupFadeIn extends ACustomAnimate {
      getEndProps() {
          return {};
      }
      onBind() {
          this.target.setTheme({
              common: {
                  opacity: 0
              }
          });
          return;
      }
      onEnd() {
          this.target.setTheme({
              common: {
                  opacity: 1
              }
          });
          return;
      }
      onUpdate(end, ratio, out) {
          this.target.setTheme({
              common: {
                  opacity: ratio
              }
          });
      }
  }
  class GroupFadeOut extends ACustomAnimate {
      getEndProps() {
          return {};
      }
      onBind() {
          this.target.setTheme({
              common: {
                  opacity: 1
              }
          });
          return;
      }
      onEnd() {
          this.target.setTheme({
              common: {
                  opacity: 0
              }
          });
          return;
      }
      onUpdate(end, ratio, out) {
          this.target.setTheme({
              common: {
                  opacity: 1 - ratio
              }
          });
      }
  }
  class AttributeAnimate extends ACustomAnimate {
      constructor(to, duration, easing) {
          super({}, to, duration, easing);
      }
      getEndProps() {
          return this.to;
      }
      onBind() {
          Object.keys(this.to).forEach(k => {
              this.from[k] = this.target.getComputedAttribute(k);
          });
          return;
      }
      onEnd() {
          return;
      }
      onUpdate(end, ratio, out) {
          this.target.stepInterpolate(this.subAnimate, this.subAnimate.animate, out, this.step, ratio, end, this.to, this.from);
      }
  }
  class AnimateGroup extends ACustomAnimate {
      constructor(duration, customAnimates) {
          super(null, null, duration, 'linear');
          this.customAnimates = customAnimates;
      }
      initAnimates() {
          this.customAnimates.forEach(a => {
              a.step = this.step;
              a.subAnimate = this.subAnimate;
              a.target = this.target;
          });
      }
      getEndProps() {
          const props = {};
          this.customAnimates.forEach(a => {
              Object.assign(props, a.getEndProps());
          });
          return props;
      }
      onBind() {
          this.initAnimates();
          this.customAnimates.forEach(a => {
              a.onBind();
          });
          return;
      }
      onEnd() {
          this.customAnimates.forEach(a => {
              a.onEnd();
          });
          return;
      }
      onUpdate(end, ratio, out) {
          if (this.updating) {
              return;
          }
          this.updating = true;
          this.customAnimates.forEach(a => {
              const easing = a.easing;
              const easingFunc = typeof easing === 'string' ? Easing[easing] : easing;
              ratio = easingFunc(ratio);
              a.onUpdate(end, ratio, out);
          });
          this.updating = false;
          return;
      }
  }
  class AnimateGroup1 extends ACustomAnimate {
      constructor(duration, customAnimates) {
          super(null, null, duration, 'linear');
          this.customAnimates = customAnimates;
      }
      initAnimates() {
          this.customAnimates.forEach(a => {
              a.step = this.step;
              a.subAnimate = this.subAnimate;
              a.target = this.target;
          });
      }
      getEndProps() {
          const props = {};
          this.customAnimates.forEach(a => {
              Object.assign(props, a.getEndProps());
          });
          return props;
      }
      onBind() {
          this.initAnimates();
          this.customAnimates.forEach(a => {
              a.onBind();
          });
          return;
      }
      onEnd() {
          this.customAnimates.forEach(a => {
              a.onEnd();
          });
          return;
      }
      onUpdate(end, ratio, out) {
          if (this.updating) {
              return;
          }
          this.updating = true;
          this.customAnimates.forEach(a => {
              const easing = a.easing;
              const easingFunc = typeof easing === 'string' ? Easing[easing] : easing;
              ratio = easingFunc(ratio);
              a.onUpdate(end, ratio, out);
          });
          this.updating = false;
          return;
      }
  }

  function cubicSubdivide(p0, p1, p2, p3, t, out) {
      const p01 = (p1 - p0) * t + p0;
      const p12 = (p2 - p1) * t + p1;
      const p23 = (p3 - p2) * t + p2;
      const p012 = (p12 - p01) * t + p01;
      const p123 = (p23 - p12) * t + p12;
      const p0123 = (p123 - p012) * t + p012;
      out[0] = p0;
      out[1] = p01;
      out[2] = p012;
      out[3] = p0123;
      out[4] = p0123;
      out[5] = p123;
      out[6] = p23;
      out[7] = p3;
  }
  function alignSubpath(subpath1, subpath2) {
      const len1 = subpath1.length;
      const len2 = subpath2.length;
      if (len1 === len2) {
          return [subpath1, subpath2];
      }
      const tmpSegX = [];
      const tmpSegY = [];
      const shorterPath = len1 < len2 ? subpath1 : subpath2;
      const shorterLen = Math.min(len1, len2);
      const diff = Math.abs(len2 - len1) / 6;
      const shorterBezierCount = (shorterLen - 2) / 6;
      const eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount);
      const newSubpath = [shorterPath[0], shorterPath[1]];
      let remained = diff;
      for (let i = 2; i < shorterLen; i += 6) {
          let x0 = shorterPath[i - 2];
          let y0 = shorterPath[i - 1];
          let x1 = shorterPath[i];
          let y1 = shorterPath[i + 1];
          let x2 = shorterPath[i + 2];
          let y2 = shorterPath[i + 3];
          const x3 = shorterPath[i + 4];
          const y3 = shorterPath[i + 5];
          if (remained <= 0) {
              newSubpath.push(x1, y1, x2, y2, x3, y3);
              continue;
          }
          const actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;
          for (let k = 1; k <= actualSubDivCount; k++) {
              const p = k / actualSubDivCount;
              cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);
              cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);
              x0 = tmpSegX[3];
              y0 = tmpSegY[3];
              newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
              x1 = tmpSegX[5];
              y1 = tmpSegY[5];
              x2 = tmpSegX[6];
              y2 = tmpSegY[6];
          }
          remained -= actualSubDivCount - 1;
      }
      return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
  }
  function createSubpath(lastSubpath, otherSubpath) {
      const prevSubPath = lastSubpath || otherSubpath;
      const len = prevSubPath.length;
      const lastX = prevSubPath[len - 2];
      const lastY = prevSubPath[len - 1];
      const newSubpath = [];
      for (let i = 0; i < otherSubpath.length; i += 2) {
          newSubpath[i] = lastX;
          newSubpath[i + 1] = lastY;
      }
      return newSubpath;
  }
  function reverseSubpath(array) {
      const newArr = [];
      const len = array.length;
      for (let i = 0; i < len; i += 2) {
          newArr[i] = array[len - i - 2];
          newArr[i + 1] = array[len - i - 1];
      }
      return newArr;
  }
  function centroidOfSubpath(array) {
      let signedArea = 0;
      let cx = 0;
      let cy = 0;
      const len = array.length;
      for (let i = 0, j = len - 2; i < len; j = i, i += 2) {
          const x0 = array[j];
          const y0 = array[j + 1];
          const x1 = array[i];
          const y1 = array[i + 1];
          const a = x0 * y1 - x1 * y0;
          signedArea += a;
          cx += (x0 + x1) * a;
          cy += (y0 + y1) * a;
      }
      if (signedArea === 0) {
          return [array[0] || 0, array[1] || 0, 0];
      }
      return [cx / signedArea / 3, cy / signedArea / 3, signedArea];
  }
  function findBestRotationOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
      const bezierCount = (fromSubBeziers.length - 2) / 6;
      let bestScore = Infinity;
      let bestOffset = 0;
      const len = fromSubBeziers.length;
      const len2 = len - 2;
      for (let offset = 0; offset < bezierCount; offset++) {
          const cursorOffset = offset * 6;
          let score = 0;
          for (let k = 0; k < len; k += 2) {
              const idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2) + 2;
              const x0 = fromSubBeziers[idx] - fromCp[0];
              const y0 = fromSubBeziers[idx + 1] - fromCp[1];
              const x1 = toSubBeziers[k] - toCp[0];
              const y1 = toSubBeziers[k + 1] - toCp[1];
              const dx = x1 - x0;
              const dy = y1 - y0;
              score += dx * dx + dy * dy;
          }
          if (score < bestScore) {
              bestScore = score;
              bestOffset = offset;
          }
      }
      return bestOffset;
  }
  function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
      const result = [];
      let fromNeedsReverse;
      for (let i = 0; i < fromArr.length; i++) {
          let fromSubpathBezier = fromArr[i];
          const toSubpathBezier = toArr[i];
          const fromCp = centroidOfSubpath(fromSubpathBezier);
          const toCp = centroidOfSubpath(toSubpathBezier);
          if (fromNeedsReverse == null) {
              fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
          }
          const newFromSubpathBezier = [];
          const newToSubpathBezier = [];
          let bestAngle = 0;
          let bestScore = Infinity;
          const tmpArr = [];
          const len = fromSubpathBezier.length;
          if (fromNeedsReverse) {
              fromSubpathBezier = reverseSubpath(fromSubpathBezier);
          }
          const offset = findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
          const len2 = len - 2;
          for (let k = 0; k < len2; k += 2) {
              const idx = ((offset + k) % len2) + 2;
              newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];
              newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
          }
          newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
          newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
          if (searchAngleIteration > 0) {
              const step = searchAngleRange / searchAngleIteration;
              for (let angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
                  const sa = Math.sin(angle);
                  const ca = Math.cos(angle);
                  let score = 0;
                  for (let k = 0; k < fromSubpathBezier.length; k += 2) {
                      const x0 = newFromSubpathBezier[k];
                      const y0 = newFromSubpathBezier[k + 1];
                      const x1 = toSubpathBezier[k] - toCp[0];
                      const y1 = toSubpathBezier[k + 1] - toCp[1];
                      const newX1 = x1 * ca - y1 * sa;
                      const newY1 = x1 * sa + y1 * ca;
                      tmpArr[k] = newX1;
                      tmpArr[k + 1] = newY1;
                      const dx = newX1 - x0;
                      const dy = newY1 - y0;
                      score += dx * dx + dy * dy;
                  }
                  if (score < bestScore) {
                      bestScore = score;
                      bestAngle = angle;
                      for (let m = 0; m < tmpArr.length; m++) {
                          newToSubpathBezier[m] = tmpArr[m];
                      }
                  }
              }
          }
          else {
              for (let i = 0; i < len; i += 2) {
                  newToSubpathBezier[i] = toSubpathBezier[i] - toCp[0];
                  newToSubpathBezier[i + 1] = toSubpathBezier[i + 1] - toCp[1];
              }
          }
          result.push({
              from: newFromSubpathBezier,
              to: newToSubpathBezier,
              fromCp,
              toCp,
              rotation: -bestAngle
          });
      }
      return result;
  }
  function alignBezierCurves(array1, array2) {
      let lastSubpath1;
      let lastSubpath2;
      const newArray1 = [];
      const newArray2 = [];
      for (let i = 0; i < Math.max(array1.length, array2.length); i++) {
          const subpath1 = array1[i];
          const subpath2 = array2[i];
          let newSubpath1;
          let newSubpath2;
          if (!subpath1) {
              newSubpath1 = createSubpath(lastSubpath1, subpath2);
              newSubpath2 = subpath2;
          }
          else if (!subpath2) {
              newSubpath2 = createSubpath(lastSubpath2, subpath1);
              newSubpath1 = subpath1;
          }
          else {
              [newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2);
              lastSubpath1 = newSubpath1;
              lastSubpath2 = newSubpath2;
          }
          newArray1.push(newSubpath1);
          newArray2.push(newSubpath2);
      }
      return [newArray1, newArray2];
  }
  const addLineToBezierPath = (bezierPath, x0, y0, x1, y1) => {
      if (!(isNumberClose(x0, x1) && isNumberClose(y0, y1))) {
          bezierPath.push(x0, y0, x1, y1, x1, y1);
      }
  };
  function pathToBezierCurves(path) {
      const commandList = path.commandList;
      const bezierArrayGroups = [];
      let currentSubpath;
      let xi = 0;
      let yi = 0;
      let x0 = 0;
      let y0 = 0;
      const createNewSubpath = (x, y) => {
          if (currentSubpath && currentSubpath.length > 2) {
              bezierArrayGroups.push(currentSubpath);
          }
          currentSubpath = [x, y];
      };
      let x1;
      let y1;
      let x2;
      let y2;
      for (let i = 0, len = commandList.length; i < len; i++) {
          const cmd = commandList[i];
          const isFirst = i === 0;
          if (isFirst) {
              x0 = xi = cmd[1];
              y0 = yi = cmd[2];
              if ([enumCommandMap.L, enumCommandMap.C, enumCommandMap.Q].includes(cmd[0])) {
                  currentSubpath = [x0, y0];
              }
          }
          switch (cmd[0]) {
              case enumCommandMap.M:
                  xi = x0 = cmd[1];
                  yi = y0 = cmd[2];
                  createNewSubpath(x0, y0);
                  break;
              case enumCommandMap.L:
                  x1 = cmd[1];
                  y1 = cmd[2];
                  addLineToBezierPath(currentSubpath, xi, yi, x1, y1);
                  xi = x1;
                  yi = y1;
                  break;
              case enumCommandMap.C:
                  currentSubpath.push(cmd[1], cmd[2], cmd[3], cmd[4], (xi = cmd[5]), (yi = cmd[6]));
                  break;
              case enumCommandMap.Q:
                  x1 = cmd[1];
                  y1 = cmd[2];
                  x2 = cmd[3];
                  y2 = cmd[4];
                  currentSubpath.push(xi + (2 / 3) * (x1 - xi), yi + (2 / 3) * (y1 - yi), x2 + (2 / 3) * (x1 - x2), y2 + (2 / 3) * (y1 - y2), x2, y2);
                  xi = x2;
                  yi = y2;
                  break;
              case enumCommandMap.A: {
                  const cx = cmd[1];
                  const cy = cmd[2];
                  const rx = cmd[3];
                  const ry = rx;
                  const startAngle = cmd[4];
                  const endAngle = cmd[5];
                  const counterClockwise = !!cmd[6];
                  x1 = Math.cos(startAngle) * rx + cx;
                  y1 = Math.sin(startAngle) * rx + cy;
                  if (isFirst) {
                      x0 = x1;
                      y0 = y1;
                      createNewSubpath(x0, y0);
                  }
                  else {
                      addLineToBezierPath(currentSubpath, xi, yi, x1, y1);
                  }
                  xi = Math.cos(endAngle) * rx + cx;
                  yi = Math.sin(endAngle) * rx + cy;
                  const step = ((counterClockwise ? -1 : 1) * Math.PI) / 2;
                  for (let angle = startAngle; counterClockwise ? angle > endAngle : angle < endAngle; angle += step) {
                      const nextAngle = counterClockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
                      addArcToBezierPath$1(currentSubpath, angle, nextAngle, cx, cy, rx, ry);
                  }
                  break;
              }
              case enumCommandMap.E: {
                  const cx = cmd[1];
                  const cy = cmd[2];
                  const rx = cmd[3];
                  const ry = cmd[4];
                  const rotate = cmd[5];
                  const startAngle = cmd[6];
                  const endAngle = cmd[7] + startAngle;
                  const anticlockwise = !!cmd[8];
                  const hasRotate = !isNumberClose(rotate, 0);
                  const rc = Math.cos(rotate);
                  const rs = Math.sin(rotate);
                  let xTemp = Math.cos(startAngle) * rx;
                  let yTemp = Math.sin(startAngle) * ry;
                  if (hasRotate) {
                      x1 = xTemp * rc - yTemp * rs + cx;
                      y1 = xTemp * rs + yTemp * rc + cy;
                  }
                  else {
                      x1 = xTemp + cx;
                      y1 = yTemp + cy;
                  }
                  if (isFirst) {
                      x0 = x1;
                      y0 = y1;
                      createNewSubpath(x0, y0);
                  }
                  else {
                      addLineToBezierPath(currentSubpath, xi, yi, x1, y1);
                  }
                  xTemp = Math.cos(endAngle) * rx;
                  yTemp = Math.sin(endAngle) * ry;
                  if (hasRotate) {
                      xi = xTemp * rc - yTemp * rs + cx;
                      yi = xTemp * rs + yTemp * rc + cy;
                  }
                  else {
                      xi = xTemp + cx;
                      yi = yTemp + cy;
                  }
                  const step = ((anticlockwise ? -1 : 1) * Math.PI) / 2;
                  for (let angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
                      const nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
                      addArcToBezierPath$1(currentSubpath, angle, nextAngle, cx, cy, rx, ry);
                      if (hasRotate) {
                          const curLen = currentSubpath.length;
                          for (let j = curLen - 6; j <= curLen - 1; j += 2) {
                              xTemp = currentSubpath[j];
                              yTemp = currentSubpath[j + 1];
                              currentSubpath[j] = (xTemp - cx) * rc - (yTemp - cy) * rs + cx;
                              currentSubpath[j + 1] = (xTemp - cx) * rs + (yTemp - cy) * rc + cy;
                          }
                      }
                  }
                  break;
              }
              case enumCommandMap.R: {
                  x0 = xi = cmd[1];
                  y0 = yi = cmd[2];
                  x1 = x0 + cmd[3];
                  y1 = y0 + cmd[4];
                  createNewSubpath(x1, y0);
                  addLineToBezierPath(currentSubpath, x1, y0, x1, y1);
                  addLineToBezierPath(currentSubpath, x1, y1, x0, y1);
                  addLineToBezierPath(currentSubpath, x0, y1, x0, y0);
                  addLineToBezierPath(currentSubpath, x0, y0, x1, y0);
                  break;
              }
              case enumCommandMap.AT: {
                  const tx1 = cmd[1];
                  const ty1 = cmd[2];
                  const tx2 = cmd[3];
                  const ty2 = cmd[4];
                  const r = cmd[5];
                  const dis1 = PointService.distancePP({ x: xi, y: yi }, { x: tx1, y: ty1 });
                  const dis2 = PointService.distancePP({ x: tx2, y: ty2 }, { x: tx1, y: ty1 });
                  const theta = ((xi - tx1) * (tx2 - tx1) + (yi - ty1) * (ty2 - ty1)) / (dis1 * dis2);
                  const dis = r / Math.sin(theta / 2);
                  const midX = (xi + tx2 - 2 * tx1) / 2;
                  const midY = (yi + ty2 - 2 * ty1) / 2;
                  const midLen = PointService.distancePP({ x: midX, y: midY }, { x: 0, y: 0 });
                  const cx = tx1 + (dis * midX) / midLen;
                  const cy = tx2 + (dis * midY) / midLen;
                  const disP = Math.sqrt(dis * dis - r * r);
                  x0 = tx1 + (disP * (xi - tx1)) / dis1;
                  y0 = ty1 + (disP * (yi - ty1)) / dis1;
                  addLineToBezierPath(currentSubpath, xi, yi, x0, y0);
                  xi = tx1 + (disP * (tx2 - tx1)) / dis2;
                  yi = ty1 + (disP * (ty2 - ty1)) / dis2;
                  const startAngle = getAngleByPoint({ x: cx, y: cy }, { x: x0, y: y0 });
                  const endAngle = getAngleByPoint({ x: cx, y: cy }, { x: xi, y: yi });
                  addArcToBezierPath$1(currentSubpath, startAngle, endAngle, cx, cy, r, r);
                  break;
              }
              case enumCommandMap.Z: {
                  currentSubpath && addLineToBezierPath(currentSubpath, xi, yi, x0, y0);
                  xi = x0;
                  yi = y0;
                  break;
              }
          }
      }
      if (currentSubpath && currentSubpath.length > 2) {
          bezierArrayGroups.push(currentSubpath);
      }
      return bezierArrayGroups;
  }
  function applyTransformOnBezierCurves(bezierCurves, martrix) {
      for (let i = 0; i < bezierCurves.length; i++) {
          const subPath = bezierCurves[i];
          for (let k = 0; k < subPath.length; k += 2) {
              const x = subPath[k];
              const y = subPath[k + 1];
              const res = { x, y };
              martrix.transformPoint({ x, y }, res);
              subPath[k] = res.x;
              subPath[k + 1] = res.y;
          }
      }
  }
  function bezierCurversToPath(bezierCurves) {
      const path = new CustomPath2D();
      for (let i = 0; i < bezierCurves.length; i++) {
          const subPath = bezierCurves[i];
          if (subPath.length > 2) {
              path.moveTo(subPath[0], subPath[1]);
              for (let k = 2; k < subPath.length; k += 6) {
                  path.bezierCurveTo(subPath[k], subPath[k + 1], subPath[k + 2], subPath[k + 3], subPath[k + 4], subPath[k + 5]);
              }
          }
      }
      return path;
  }

  function splitToGrids(width, height, count) {
      const ratio = width / height;
      let rowCount;
      let columnCount;
      if (width >= height) {
          columnCount = Math.ceil(Math.sqrt(count * ratio));
          rowCount = Math.floor(count / columnCount);
          if (rowCount === 0) {
              rowCount = 1;
              columnCount = count;
          }
      }
      else {
          rowCount = Math.ceil(Math.sqrt(count / ratio));
          columnCount = Math.floor(count / rowCount);
          if (columnCount === 0) {
              columnCount = 1;
              rowCount = count;
          }
      }
      const grids = [];
      for (let i = 0; i < rowCount; i++) {
          grids.push(columnCount);
      }
      const sumCount = rowCount * columnCount;
      const remained = count - sumCount;
      if (remained > 0) {
          for (let i = 0; i < remained; i += columnCount) {
              if (i + columnCount < remained) {
                  grids.push(columnCount);
              }
              else {
                  grids.push(remained - i);
              }
          }
      }
      return grids;
  }
  const splitRect = (rect, count) => {
      const x = 0;
      const y = 0;
      const width = rect.getComputedAttribute('width');
      const height = rect.getComputedAttribute('height');
      const grids = splitToGrids(width, height, count);
      const res = [];
      const gridHeight = height / grids.length;
      for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
          const columnCount = grids[i];
          const gridWidth = width / columnCount;
          for (let j = 0; j < columnCount; j++) {
              res.push({
                  x: x + j * gridWidth,
                  y: y + i * gridHeight,
                  width: gridWidth,
                  height: gridHeight
              });
          }
      }
      return res;
  };
  const splitArc = (arc, count) => {
      const angles = arc.getParsedAngle();
      const startAngle = angles.startAngle;
      const endAngle = angles.endAngle;
      const innerRadius = arc.getComputedAttribute('innerRadius');
      const outerRadius = arc.getComputedAttribute('outerRadius');
      const angleDelta = Math.abs(startAngle - endAngle);
      const radiusDelta = Math.abs(outerRadius - innerRadius);
      const grids = splitToGrids((angleDelta * (innerRadius + outerRadius)) / 2, radiusDelta, count);
      const res = [];
      const gridRadius = radiusDelta / grids.length;
      const radiusSign = outerRadius >= innerRadius ? 1 : -1;
      const angleSign = endAngle >= startAngle ? 1 : -1;
      for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
          const columnCount = grids[i];
          const gridAngle = angleDelta / columnCount;
          for (let j = 0; j < columnCount; j++) {
              res.push({
                  innerRadius: outerRadius - gridRadius * i * radiusSign,
                  outerRadius: outerRadius - gridRadius * (i + 1) * radiusSign,
                  startAngle: startAngle + gridAngle * j * angleSign,
                  endAngle: startAngle + gridAngle * (j + 1) * angleSign
              });
          }
      }
      return res;
  };
  const splitCircle = (arc, count) => {
      const startAngle = arc.getComputedAttribute('startAngle');
      const endAngle = arc.getComputedAttribute('endAngle');
      const radius = arc.getComputedAttribute('radius');
      const angleDelta = Math.abs(startAngle - endAngle);
      const grids = splitToGrids(angleDelta * radius, radius, count);
      const res = [];
      const gridAngle = angleDelta / grids[0];
      const gridRadius = radius / grids.length;
      const angleSign = endAngle >= startAngle ? 1 : -1;
      for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
          for (let j = 0, columnCount = grids[i]; j < columnCount; j++) {
              res.push({
                  innerRadius: gridRadius * i,
                  outerRadius: gridRadius * (i + 1),
                  startAngle: startAngle + gridAngle * j * angleSign,
                  endAngle: startAngle + gridAngle * (j + 1) * angleSign
              });
          }
      }
      return res;
  };
  const samplingPoints = (points, count) => {
      const validatePoints = points.filter(point => point.defined !== false && isNumber(point.x) && isNumber(point.y));
      if (validatePoints.length === 0) {
          return [];
      }
      if (validatePoints.length === 1) {
          return new Array(count).fill(0).map(i => validatePoints[0]);
      }
      const res = [];
      if (count <= validatePoints.length) {
          const step = validatePoints.length / count;
          let i = 0;
          let cur = 0;
          while (i < count) {
              res.push(validatePoints[Math.floor(cur)]);
              cur += step;
              i++;
          }
          return res;
      }
      const insertCount = count - validatePoints.length;
      const insertStep = insertCount / (validatePoints.length - 1);
      const insetRatio = 1 / (insertStep + 1);
      let curCount = 0;
      for (let i = 0, len = points.length; i < len; i++) {
          res.push(points[i]);
          if (i < len - 1) {
              let cur = insetRatio;
              const xCur = points[i].x;
              const yCur = points[i].y;
              const xNext = points[i + 1].x;
              const yNext = points[i + 1].y;
              while (cur < 1 && curCount < insertCount) {
                  res.push({
                      x: xCur + (xNext - xCur) * cur,
                      y: yCur + (yNext - yCur) * cur
                  });
                  cur += insetRatio;
                  curCount += 1;
              }
          }
      }
      return res;
  };
  const splitArea = (area, count) => {
      const attribute = area.attribute;
      let points = attribute.points;
      const segements = attribute.segments;
      if (!points) {
          points = segements.reduce((res, seg) => {
              return res.concat(seg.points ?? []);
          }, []);
      }
      const validatePoints = points.filter(point => point.defined !== false && isNumber(point.x) && isNumber(point.y));
      if (!validatePoints.length) {
          return [];
      }
      const allPoints = [];
      validatePoints.forEach(point => {
          allPoints.push({ x: point.x, y: point.y });
      });
      for (let i = validatePoints.length - 1; i >= 0; i--) {
          const point = validatePoints[i];
          allPoints.push({ x: point.x1 ?? point.x, y: point.y1 ?? point.y });
      }
      const res = [];
      recursiveCallBinarySplit(points, count, res);
      return res;
  };
  const splitLine = (line, count) => {
      const attribute = line.attribute;
      const points = attribute.points;
      if (points) {
          return samplingPoints(points, count);
      }
      else if (attribute.segments) {
          const segs = attribute.segments;
          const allPoints = segs.reduce((res, seg) => {
              return res.concat(seg.points ?? []);
          }, []);
          return samplingPoints(allPoints, count);
      }
      return [];
  };
  function crossProduct(dir1, dir2) {
      return dir1[0] * dir2[1] - dir1[1] * dir2[0];
  }
  const clonePoints = (points) => {
      return points.map(p => ({ x: p.x, y: p.y }));
  };
  const splitPolygonByLine = (points, p0, p1) => {
      const len = points.length;
      const intersections = [];
      for (let i = 0; i < len; i++) {
          const cur = points[i];
          const next = i === len - 1 ? points[0] : points[i + 1];
          const res = getIntersectPoint([p0.x, p0.y], [p1.x, p1.y], [cur.x, cur.y], [next.x, next.y]);
          if (res && typeof res !== 'boolean') {
              intersections.push({
                  dot: crossProduct([res[0] - p0.x, res[1] - p0.x], [p1.x - p0.x, p1.y - p0.x]),
                  point: { x: res[0], y: res[1] },
                  edgeIndex: i
              });
          }
      }
      if (intersections.length < 2) {
          return [clonePoints(points), clonePoints(points)];
      }
      intersections.sort((a, b) => a.dot - b.dot);
      let is0 = intersections[0];
      let is1 = intersections[intersections.length - 1];
      if (is0.edgeIndex > is1.edgeIndex) {
          [is0, is1] = [is1, is0];
      }
      const newP0 = is0.point;
      const newP1 = is1.point;
      const newPointsA = [{ x: newP0.x, y: newP0.y }];
      for (let i = is0.edgeIndex + 1; i <= is1.edgeIndex; i++) {
          newPointsA.push({ x: points[i].x, y: points[i].y });
      }
      newPointsA.push({ x: newP1.x, y: newP1.y });
      const newPointsB = [{ x: newP1.x, y: newP1.y }];
      for (let i = is1.edgeIndex + 1, maxIndex = is0.edgeIndex + len; i <= maxIndex; i++) {
          const p = points[i % len];
          newPointsB.push({ x: p.x, y: p.y });
      }
      newPointsB.push({ x: newP0.x, y: newP0.y });
      return [newPointsA, newPointsB];
  };
  const binarySplitPolygon = (points) => {
      const box = new Bounds();
      points.forEach(point => {
          box.add(point.x, point.y);
      });
      const width = box.width();
      const height = box.height();
      if (width >= height) {
          const midX = box.x1 + width / 2;
          return splitPolygonByLine(points, {
              x: midX,
              y: box.y1
          }, {
              x: midX,
              y: box.y2
          });
      }
      const midY = box.y1 + height / 2;
      return splitPolygonByLine(points, {
          x: box.x1,
          y: midY
      }, {
          x: box.x2,
          y: midY
      });
  };
  const recursiveCallBinarySplit = (points, count, out) => {
      if (count === 1) {
          out.push({ points });
      }
      else {
          const half = Math.floor(count / 2);
          const res = binarySplitPolygon(points);
          recursiveCallBinarySplit(res[0], half, out);
          recursiveCallBinarySplit(res[1], count - half, out);
      }
  };
  const splitPolygon = (polygon, count) => {
      const points = polygon.attribute.points;
      if (!points || !points.length) {
          return [];
      }
      if (count === 1) {
          return [{ points: clonePoints(points) }];
      }
      const res = [];
      recursiveCallBinarySplit(points, count, res);
      return res;
  };
  const splitPath = (path, count) => {
      const pathShape = path.getParsedPathShape();
      const bezierCurves = pathToBezierCurves(pathShape);
      if (!bezierCurves.length || count < 0) {
          return [];
      }
      const subPathCnt = bezierCurves.length;
      if (bezierCurves.length >= count) {
          const res = [];
          const stepCount = Math.floor(bezierCurves.length / count);
          for (let i = 0; i < count; i++) {
              const curves = bezierCurves.slice(i * stepCount, i === count - 1 ? subPathCnt : (i + 1) * stepCount);
              res.push({ path: bezierCurversToPath(curves) });
          }
          return res;
      }
      const res = [];
      const stepCount = Math.floor(count / subPathCnt);
      let remain = count;
      for (let c = 0; c < subPathCnt; c++) {
          const points = [];
          for (let i = 2, len = bezierCurves[c].length; i < len; i += 2) {
              points.push({ x: bezierCurves[0][i], y: bezierCurves[0][i + 1] });
          }
          recursiveCallBinarySplit(points, c === subPathCnt - 1 ? remain : stepCount, res);
          remain -= stepCount;
      }
      return res;
  };

  var colorNames = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
  };

  const reverseNames = {};
  for (const name in colorNames) {
      if (has(colorNames, name)) {
          reverseNames[colorNames[name]] = name;
      }
  }
  const cs = {
      to: {},
      get: {}
  };
  cs.get = function (str, arr = [0, 0, 0, 1]) {
      const prefix = str.substring(0, 3).toLowerCase();
      let val;
      let model;
      switch (prefix) {
          case 'hsl':
              val = cs.get.hsl(str, arr);
              model = 'hsl';
              break;
          case 'hwb':
              val = cs.get.hwb(str, arr);
              model = 'hwb';
              break;
          default:
              val = cs.get.rgb(str, arr);
              model = 'rgb';
              break;
      }
      if (!val) {
          return null;
      }
      return { model: model, value: val };
  };
  cs.get.rgb = function (str, arr = [0, 0, 0, 1]) {
      if (!str) {
          return null;
      }
      const abbr = /^#([a-f0-9]{3,4})$/i;
      const hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      const rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/;
      const per = /^rgba?\(\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/;
      const keyword = /(\D+)/;
      const rgb = arr;
      let match;
      let i;
      let hexAlpha;
      if ((match = str.match(hex))) {
          hexAlpha = match[2];
          match = match[1];
          for (i = 0; i < 3; i++) {
              const i2 = i * 2;
              rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
          }
          if (hexAlpha) {
              rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
          }
      }
      else if ((match = str.match(abbr))) {
          match = match[1];
          hexAlpha = match[3];
          for (i = 0; i < 3; i++) {
              rgb[i] = parseInt(match[i] + match[i], 16);
          }
          if (hexAlpha) {
              rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
          }
      }
      else if ((match = str.match(rgba))) {
          for (i = 0; i < 3; i++) {
              rgb[i] = parseInt(match[i + 1], 10);
          }
          if (match[4]) {
              rgb[3] = parseFloat(match[4]);
          }
      }
      else if ((match = str.match(per))) {
          for (i = 0; i < 3; i++) {
              rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
          }
          if (match[4]) {
              rgb[3] = parseFloat(match[4]);
          }
      }
      else if ((match = str.match(keyword))) {
          if (match[1] === 'transparent') {
              return [0, 0, 0, 0];
          }
          const _color = colorNames[match[1]];
          rgb[0] = _color[0];
          rgb[1] = _color[1];
          rgb[2] = _color[2];
          rgb[3] = _color[3];
          if (!rgb) {
              return null;
          }
          rgb[3] = 1;
          return rgb;
      }
      else {
          return null;
      }
      for (i = 0; i < 3; i++) {
          rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
  };
  cs.get.hsl = function (str, arr = [0, 0, 0, 1]) {
      if (!str) {
          return null;
      }
      const hsl = /^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/;
      const match = str.match(hsl);
      if (match) {
          const alpha = parseFloat(match[4]);
          arr[0] = (parseFloat(match[1]) + 360) % 360;
          arr[1] = clamp(parseFloat(match[2]), 0, 100);
          arr[2] = clamp(parseFloat(match[3]), 0, 100);
          arr[3] = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
          return arr;
      }
      return null;
  };
  cs.get.hwb = function (str, arr = [0, 0, 0, 1]) {
      if (!str) {
          return null;
      }
      const hwb = /^hwb\(\s*([+-]?\d*[.]?\d+)(?:deg)?\s*,\s*([+-]?[\d.]+)%\s*,\s*([+-]?[\d.]+)%\s*(?:,\s*([+-]?[\d.]+)\s*)?\)$/;
      const match = str.match(hwb);
      if (match) {
          const alpha = parseFloat(match[4]);
          arr[0] = ((parseFloat(match[1]) % 360) + 360) % 360;
          arr[1] = clamp(parseFloat(match[2]), 0, 100);
          arr[2] = clamp(parseFloat(match[3]), 0, 100);
          arr[3] = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
          return arr;
      }
      return null;
  };
  cs.to.hex = function (...args) {
      const rgba = args;
      return ('#' +
          hexDouble(rgba[0]) +
          hexDouble(rgba[1]) +
          hexDouble(rgba[2]) +
          (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : ''));
  };
  cs.to.rgb = function (...args) {
      const rgba = args;
      return rgba.length < 4 || rgba[3] === 1
          ? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
          : 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
  };
  cs.to.rgb.percent = function (...args) {
      const rgba = args;
      const r = Math.round((rgba[0] / 255) * 100);
      const g = Math.round((rgba[1] / 255) * 100);
      const b = Math.round((rgba[2] / 255) * 100);
      return rgba.length < 4 || rgba[3] === 1
          ? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
          : 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
  };
  cs.to.hsl = function (...args) {
      const hsla = args;
      return hsla.length < 4 || hsla[3] === 1
          ? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
          : 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
  };
  cs.to.hwb = function (...args) {
      const hwba = args;
      let a = '';
      if (hwba.length >= 4 && hwba[3] !== 1) {
          a = ', ' + hwba[3];
      }
      return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
  };
  cs.to.keyword = function (rgb) {
      return reverseNames[rgb.slice(0, 3)];
  };
  function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
  }
  function hexDouble(num) {
      const str = num.toString(16).toUpperCase();
      return str.length < 2 ? '0' + str : str;
  }
  const colorString = cs;
  var ColorType;
  (function (ColorType) {
      ColorType[ColorType["Color255"] = 0] = "Color255";
      ColorType[ColorType["Color1"] = 1] = "Color1";
  })(ColorType || (ColorType = {}));
  class ColorStore {
      static store255 = {};
      static store1 = {};
      static Get(str, size = ColorType.Color1, arr = [0, 0, 0, 1]) {
          if (size === ColorType.Color1) {
              let color = ColorStore.store1[str];
              if (color) {
                  arr[0] = color[0];
                  arr[1] = color[1];
                  arr[2] = color[2];
                  arr[3] = color[3];
                  return arr;
              }
              color = cs.get(str);
              if (color && color.value) {
                  const value = color.value;
                  const data = [value[0] / 255, value[1] / 255, value[2] / 255, value[3]];
                  ColorStore.store1[str] = data;
                  ColorStore.store255[str] = value;
                  arr[0] = data[0];
                  arr[1] = data[1];
                  arr[2] = data[2];
                  arr[3] = data[3];
              }
              return arr;
          }
          let color = ColorStore.store255[str];
          if (color) {
              arr[0] = color[0];
              arr[1] = color[1];
              arr[2] = color[2];
              arr[3] = color[3];
              return arr;
          }
          color = cs.get(str);
          if (color && color.value) {
              const value = color.value;
              ColorStore.store1[str] = [value[0] / 255, value[1] / 255, value[2] / 255, value[3]];
              ColorStore.store255[str] = value;
              arr[0] = value[0];
              arr[1] = value[1];
              arr[2] = value[2];
              arr[3] = value[3];
          }
          return arr;
      }
      static Set(str, size, arr) {
          if (size === ColorType.Color1) {
              if (ColorStore.store1[str]) {
                  return;
              }
              ColorStore.store1[str] = arr;
              ColorStore.store255[str] = [
                  Math.floor(arr[0] * 255),
                  Math.floor(arr[1] * 255),
                  Math.floor(arr[2] * 255),
                  Math.floor(arr[3] * 255)
              ];
          }
          else {
              if (ColorStore.store255[str]) {
                  return;
              }
              ColorStore.store255[str] = arr;
              ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
          }
      }
  }

  function colorArrayToString(color, alphaChannel = false) {
      if (Array.isArray(color)) {
          return alphaChannel
              ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})`
              : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})`;
      }
      return color;
  }
  function interpolateColor(from, to, ratio, alphaChannel, cb) {
      if (!(from && to)) {
          return (from && colorArrayToString(from)) || (to && colorArrayToString(to)) || false;
      }
      let fromArray;
      let toArray;
      let fromGradient = false;
      let toGradient = false;
      if (Array.isArray(from)) {
          fromArray = from;
      }
      else if (typeof from === 'string') {
          fromArray = ColorStore.Get(from, ColorType.Color255);
      }
      else {
          fromGradient = true;
      }
      if (Array.isArray(to)) {
          toArray = to;
      }
      else if (typeof to === 'string') {
          toArray = ColorStore.Get(to, ColorType.Color255);
      }
      else {
          toGradient = true;
      }
      if (fromGradient !== toGradient) {
          const gradient = (fromGradient ? from : to);
          const pure = (fromGradient ? to : from);
          const gradientFromPure = {
              ...gradient,
              stops: gradient.stops.map(v => ({ ...v, color: colorArrayToString(pure) }))
          };
          return fromGradient
              ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb)
              : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
      }
      if (fromGradient) {
          if (from.gradient === to.gradient) {
              const fc = from;
              const tc = to;
              const fromStops = fc.stops;
              const toStops = tc.stops;
              if (fromStops.length !== toStops.length) {
                  return false;
              }
              if (fc.gradient === 'linear') {
                  return interpolateGradientLinearColor(fc, tc, ratio);
              }
              else if (fc.gradient === 'radial') {
                  return interpolateGradientRadialColor(fc, tc, ratio);
              }
              else if (fc.gradient === 'conical') {
                  return interpolateGradientConicalColor(fc, tc, ratio);
              }
          }
          return false;
      }
      cb && cb(fromArray, toArray);
      const result = interpolatePureColorArray(fromArray, toArray, ratio);
      return colorArrayToString(result, alphaChannel);
  }
  function interpolateGradientLinearColor(fc, tc, ratio) {
      const fStops = fc.stops;
      const tStops = tc.stops;
      const color = {
          gradient: 'linear',
          x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
          x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
          y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
          y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
          stops: new Array(fStops.length).fill(0).map((_, i) => {
              return {
                  color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
                  offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
              };
          })
      };
      return color;
  }
  function interpolateGradientRadialColor(fc, tc, ratio) {
      const fStops = fc.stops;
      const tStops = tc.stops;
      const color = {
          gradient: 'radial',
          x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
          x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
          y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
          y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
          r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
          r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
          stops: new Array(fStops.length).fill(0).map((_, i) => {
              return {
                  color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
                  offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
              };
          })
      };
      return color;
  }
  function interpolateGradientConicalColor(fc, tc, ratio) {
      const fStops = fc.stops;
      const tStops = tc.stops;
      const color = {
          gradient: 'conical',
          startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
          endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
          x: fc.x + (tc.x - fc.x) * ratio,
          y: fc.y + (tc.y - fc.y) * ratio,
          stops: new Array(fStops.length).fill(0).map((_, i) => {
              return {
                  color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
                  offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
              };
          })
      };
      return color;
  }
  function interpolatePureColorArray(from, to, ratio) {
      return [
          from[0] + (to[0] - from[0]) * ratio,
          from[1] + (to[1] - from[1]) * ratio,
          from[2] + (to[2] - from[2]) * ratio,
          from[3] + (to[3] - from[3]) * ratio
      ];
  }
  const _fromColorRGB = [0, 0, 0, 0];
  const _toColorRGB = [0, 0, 0, 0];
  function colorStringInterpolationToStr(fromColor, toColor, ratio) {
      ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB);
      ColorStore.Get(toColor, ColorType.Color255, _toColorRGB);
      return `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
  }

  const interpolateOtherAttrs = (attrs, out, ratio) => {
      attrs.forEach(entry => {
          if (Number.isFinite(entry.to)) {
              out[entry.key] = entry.from + (entry.to - entry.from) * ratio;
          }
          else if (entry.key === 'fill' || entry.key === 'stroke') {
              const color = interpolateColor(entry.from, entry.to, ratio, false);
              if (color) {
                  out[entry.key] = color;
              }
          }
      });
  };
  const interpolateMorphingData = (morphingData, path, ratio) => {
      const tmpArr = [];
      const newCp = [];
      path.clear();
      for (let i = 0; i < morphingData.length; i++) {
          const item = morphingData[i];
          const from = item.from;
          const to = item.to;
          const angle = item.rotation * ratio;
          const fromCp = item.fromCp;
          const toCp = item.toCp;
          const sa = Math.sin(angle);
          const ca = Math.cos(angle);
          newCp[0] = fromCp[0] + (toCp[0] - fromCp[0]) * ratio;
          newCp[1] = fromCp[1] + (toCp[1] - fromCp[1]) * ratio;
          for (let m = 0; m < from.length; m += 2) {
              const x0 = from[m];
              const y0 = from[m + 1];
              const x1 = to[m];
              const y1 = to[m + 1];
              const x = x0 * (1 - ratio) + x1 * ratio;
              const y = y0 * (1 - ratio) + y1 * ratio;
              tmpArr[m] = x * ca - y * sa + newCp[0];
              tmpArr[m + 1] = x * sa + y * ca + newCp[1];
          }
          let x0 = tmpArr[0];
          let y0 = tmpArr[1];
          path.moveTo(x0, y0);
          for (let m = 2; m < from.length; m += 6) {
              const x1 = tmpArr[m];
              const y1 = tmpArr[m + 1];
              const x2 = tmpArr[m + 2];
              const y2 = tmpArr[m + 3];
              const x3 = tmpArr[m + 4];
              const y3 = tmpArr[m + 5];
              if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {
                  path.lineTo(x3, y3);
              }
              else {
                  path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
              }
              x0 = x3;
              y0 = y3;
          }
      }
  };
  const parseMorphingData = (fromPath, toPath, config) => {
      const fromBezier = fromPath ? pathToBezierCurves(fromPath) : [];
      const toBezier = pathToBezierCurves(toPath);
      if (config && fromBezier) {
          config.fromTransform && applyTransformOnBezierCurves(fromBezier, config.fromTransform.clone().getInverse());
          applyTransformOnBezierCurves(fromBezier, config.toTransfrom);
      }
      const [fromBezierCurves, toBezierCurves] = alignBezierCurves(fromBezier, toBezier);
      return fromPath
          ? findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI)
          : toBezierCurves.map((to, index) => {
              return {
                  from: fromBezierCurves[index],
                  to,
                  fromCp: [0, 0],
                  toCp: [0, 0],
                  rotation: 0
              };
          });
  };
  const validateOtherAttrs = [
      'fill',
      'fillOpacity',
      'shadowBlur',
      'shadowColor',
      'shadowOffsetX',
      'shadowOffsetY',
      'stroke',
      'strokeOpacity',
      'lineDashOffset'
  ];
  const parseOtherAnimateAttrs = (fromAttrs, toAttrs) => {
      if (!fromAttrs || !toAttrs) {
          return null;
      }
      const res = [];
      let hasAttr = false;
      Object.keys(fromAttrs).forEach(fromKey => {
          if (!validateOtherAttrs.includes(fromKey)) {
              return;
          }
          const toValue = toAttrs[fromKey];
          if (!isNil(toValue) && !isNil(fromAttrs[fromKey]) && toValue !== fromAttrs[fromKey]) {
              if (fromKey === 'fill' || fromKey === 'stroke') {
                  res.push({
                      from: typeof fromAttrs[fromKey] === 'string'
                          ? ColorStore.Get(fromAttrs[fromKey], ColorType.Color255)
                          : fromAttrs[fromKey],
                      to: typeof toValue === 'string' ? ColorStore.Get(toValue, ColorType.Color255) : toValue,
                      key: fromKey
                  });
              }
              else {
                  res.push({ from: fromAttrs[fromKey], to: toValue, key: fromKey });
              }
              hasAttr = true;
          }
      });
      return hasAttr ? res : null;
  };
  class MorphingPath extends ACustomAnimate {
      saveOnEnd;
      otherAttrs;
      constructor(config, duration, easing) {
          super(0, 1, duration, easing);
          this.morphingData = config.morphingData;
          this.otherAttrs = config.otherAttrs;
          this.saveOnEnd = config.saveOnEnd;
      }
      morphingData;
      getEndProps() {
          return {};
      }
      onBind() {
          this.target.createPathProxy();
          this.onUpdate(false, 0, this.target.attribute);
      }
      onEnd() {
          return;
      }
      onUpdate(end, ratio, out) {
          const target = this.target;
          const pathProxy = typeof target.pathProxy === 'function' ? target.pathProxy(target.attribute) : target.pathProxy;
          interpolateMorphingData(this.morphingData, pathProxy, ratio);
          if (this.otherAttrs && this.otherAttrs.length) {
              interpolateOtherAttrs(this.otherAttrs, out, ratio);
          }
          if (end && !this.saveOnEnd) {
              this.target.pathProxy = null;
          }
      }
  }
  const morphPath = (fromGraphic, toGraphic, animationConfig, fromGraphicTransform) => {
      if (fromGraphic && (!fromGraphic.valid || !fromGraphic.toCustomPath)) {
          if (__DEV__) {
              console.error(fromGraphic, ' is not validate');
          }
          return null;
      }
      if (!toGraphic.valid || !toGraphic.toCustomPath) {
          if (__DEV__) {
              console.error(toGraphic, ' is not validate');
          }
          return null;
      }
      let fromTransform = fromGraphic?.globalTransMatrix;
      if (fromGraphicTransform && fromTransform) {
          fromTransform = fromGraphicTransform
              .clone()
              .multiply(fromTransform.a, fromTransform.b, fromTransform.c, fromTransform.d, fromTransform.e, fromTransform.f);
      }
      const morphingData = parseMorphingData(fromGraphic?.toCustomPath?.(), toGraphic.toCustomPath(), {
          fromTransform,
          toTransfrom: toGraphic.globalTransMatrix
      });
      const attrs = parseOtherAnimateAttrs(fromGraphic?.attribute, toGraphic.attribute);
      const animate = toGraphic.animate(animationConfig);
      if (animationConfig?.delay) {
          animate.wait(animationConfig.delay);
      }
      animate.play(new MorphingPath({ morphingData, otherAttrs: attrs }, animationConfig?.duration ?? DefaultMorphingAnimateConfig.duration, animationConfig?.easing ?? DefaultMorphingAnimateConfig.easing));
      return animate;
  };
  const oneToMultiMorph = (fromGraphic, toGraphics, animationConfig) => {
      const validateToGraphics = toGraphics.filter(graphic => graphic && graphic.toCustomPath && graphic.valid);
      if (!validateToGraphics.length) {
          if (__DEV__) {
              console.error(validateToGraphics, ' is not validate');
          }
      }
      if (!fromGraphic.valid || !fromGraphic.toCustomPath) {
          if (__DEV__) {
              console.error(fromGraphic, ' is not validate');
          }
      }
      const childGraphics = (animationConfig?.splitPath === 'clone' ? cloneGraphic : animationConfig?.splitPath ?? splitGraphic)(fromGraphic, validateToGraphics.length, false);
      const oldOnEnd = animationConfig?.onEnd;
      let count = validateToGraphics.length;
      const onEachEnd = () => {
          count--;
          if (count === 0 && oldOnEnd) {
              oldOnEnd();
          }
      };
      validateToGraphics.forEach((toChild, index) => {
          const fromChild = childGraphics[index];
          const delay = (animationConfig?.delay ?? 0) +
              (animationConfig?.individualDelay
                  ? animationConfig.individualDelay(index, validateToGraphics.length, fromChild, toChild)
                  : 0);
          morphPath(fromChild, toChild, Object.assign({}, animationConfig, { onEnd: onEachEnd, delay }), fromGraphic.globalTransMatrix);
      });
  };
  class MultiToOneMorphingPath extends ACustomAnimate {
      otherAttrs;
      constructor(config, duration, easing) {
          super(0, 1, duration, easing);
          this.morphingData = config.morphingData;
          this.otherAttrs = config.otherAttrs;
      }
      morphingData;
      getEndProps() {
          return {};
      }
      onBind() {
          this.addPathProxy();
      }
      addPathProxy() {
          const shadowRoot = this.target.shadowRoot;
          shadowRoot.forEachChildren(child => {
              child.createPathProxy();
          });
          this.onUpdate(false, 0, this.target.attribute);
      }
      clearPathProxy() {
          const shadowRoot = this.target.shadowRoot;
          shadowRoot.forEachChildren(child => {
              child.pathProxy = null;
          });
      }
      onEnd() {
          return;
      }
      onUpdate(end, ratio, out) {
          const shadowRoot = this.target.shadowRoot;
          shadowRoot.forEachChildren((child, index) => {
              interpolateMorphingData(this.morphingData[index], typeof child.pathProxy === 'function' ? child.pathProxy(child.attribute) : child.pathProxy, ratio);
              if (this.otherAttrs?.[index] && this.otherAttrs[index].length) {
                  interpolateOtherAttrs(this.otherAttrs[index], child.attribute, ratio);
              }
          });
          if (end) {
              this.clearPathProxy();
              this.morphingData = null;
          }
      }
  }
  const parseShadowChildAttrs = (graphicAttrs) => {
      const attrs = {};
      Object.keys(graphicAttrs).forEach(key => {
          if (!isTransformKey(key)) {
              attrs[key] = graphicAttrs[key];
          }
      });
      return attrs;
  };
  const appendShadowChildrenToGraphic = (graphic, children, count) => {
      const childAttrs = parseShadowChildAttrs(graphic.attribute);
      const shadowRoot = graphic.attachShadow();
      if (children.length) {
          shadowRoot.setTheme({
              [children[0].type]: childAttrs
          });
          children.forEach(element => {
              shadowRoot.appendChild(element);
          });
      }
      else {
          const box = graphic.AABBBounds;
          const width = box.width();
          const height = box.height();
          shadowRoot.setTheme({
              rect: childAttrs
          });
          new Array(count).fill(0).forEach(el => {
              const child = application.graphicService.creator.rect({
                  x: 0,
                  y: 0,
                  width,
                  height: height
              });
              shadowRoot.appendChild(child);
              children.push(child);
          });
      }
  };
  const cloneGraphic = (graphic, count, needAppend) => {
      const children = [];
      const childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
      const path = graphic.toCustomPath();
      for (let i = 0; i < count; i++) {
          const element = {
              path: new CustomPath2D().fromCustomPath2D(path)
          };
          children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
      }
      if (needAppend) {
          appendShadowChildrenToGraphic(graphic, children, count);
      }
      return children;
  };
  const splitGraphic = (graphic, count, needAppend) => {
      const children = [];
      const childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
      if (graphic.type === 'rect') {
          const childrenAttrs = splitRect(graphic, count);
          childrenAttrs.forEach(element => {
              children.push(application.graphicService.creator.rect(needAppend ? element : Object.assign({}, childAttrs, element)));
          });
      }
      else if (graphic.type === 'arc') {
          const childrenAttrs = splitArc(graphic, count);
          childrenAttrs.forEach(element => {
              children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
          });
      }
      else if (graphic.type === 'circle') {
          const childrenAttrs = splitCircle(graphic, count);
          childrenAttrs.forEach(element => {
              children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
          });
      }
      else if (graphic.type === 'line') {
          const childrenAttrs = splitLine(graphic, count);
          const defaultSymbol = { size: 10, symbolType: 'circle' };
          childrenAttrs.forEach(element => {
              children.push(application.graphicService.creator.symbol(needAppend ? Object.assign({}, element, defaultSymbol) : Object.assign({}, childAttrs, element, defaultSymbol)));
          });
      }
      else if (graphic.type === 'polygon') {
          const childrenAttrs = splitPolygon(graphic, count);
          childrenAttrs.forEach(element => {
              children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
          });
      }
      else if (graphic.type === 'area') {
          const childrenAttrs = splitArea(graphic, count);
          childrenAttrs.forEach(element => {
              children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
          });
      }
      else if (graphic.type === 'path') {
          const childrenAttrs = splitPath(graphic, count);
          childrenAttrs.forEach(element => {
              if ('path' in element) {
                  children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
              }
              else {
                  children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
              }
          });
      }
      if (needAppend) {
          appendShadowChildrenToGraphic(graphic, children, count);
      }
      return children;
  };
  const multiToOneMorph = (fromGraphics, toGraphic, animationConfig) => {
      const validateFromGraphics = fromGraphics.filter(graphic => graphic.toCustomPath && graphic.valid);
      if (!validateFromGraphics.length) {
          if (__DEV__) {
              console.error(fromGraphics, ' is not validate');
          }
      }
      if (!toGraphic.valid || !toGraphic.toCustomPath) {
          if (__DEV__) {
              console.error(toGraphic, ' is not validate');
          }
      }
      const childGraphics = (animationConfig?.splitPath === 'clone' ? cloneGraphic : animationConfig?.splitPath ?? splitGraphic)(toGraphic, validateFromGraphics.length, true);
      const toAttrs = toGraphic.attribute;
      toGraphic.setAttribute('visible', false);
      const morphingData = validateFromGraphics.map((graphic, index) => {
          return parseMorphingData(graphic.toCustomPath(), childGraphics[index].toCustomPath(), {
              fromTransform: graphic.globalTransMatrix,
              toTransfrom: childGraphics[index].globalTransMatrix
          });
      });
      const otherAttrs = validateFromGraphics.map((graphic, index) => {
          return parseOtherAnimateAttrs(graphic.attribute, toAttrs);
      });
      if (animationConfig?.individualDelay) {
          const oldOnEnd = animationConfig.onEnd;
          let count = validateFromGraphics.length;
          const onEachEnd = () => {
              count--;
              if (count === 0) {
                  toGraphic.setAttributes({ visible: true, ratio: null }, false, {
                      type: exports.AttributeUpdateType.ANIMATE_END
                  });
                  toGraphic.detachShadow();
                  if (oldOnEnd) {
                      oldOnEnd();
                  }
              }
          };
          childGraphics.forEach((to, index) => {
              const delay = (animationConfig.delay ?? 0) +
                  animationConfig.individualDelay(index, validateFromGraphics.length, fromGraphics[index], to);
              const animate = to.animate(Object.assign({}, animationConfig, { onEnd: onEachEnd }));
              animate.wait(delay);
              animate.play(new MorphingPath({
                  morphingData: morphingData[index],
                  saveOnEnd: true,
                  otherAttrs: otherAttrs[index]
              }, animationConfig.duration ?? DefaultMorphingAnimateConfig.duration, animationConfig.easing ?? DefaultMorphingAnimateConfig.easing));
          });
      }
      else {
          const oldOnEnd = animationConfig?.onEnd;
          const config = animationConfig ? Object.assign({}, animationConfig) : {};
          config.onEnd = () => {
              toGraphic.setAttribute('visible', true, false, { type: exports.AttributeUpdateType.ANIMATE_END });
              toGraphic.detachShadow();
              if (oldOnEnd) {
                  oldOnEnd();
              }
          };
          const animate = toGraphic.animate(config);
          if (animationConfig?.delay) {
              animate.wait(animationConfig.delay);
          }
          animate.play(new MultiToOneMorphingPath({ morphingData, otherAttrs }, animationConfig?.duration ?? DefaultMorphingAnimateConfig.duration, animationConfig?.easing ?? DefaultMorphingAnimateConfig.easing));
      }
  };

  class ResourceLoader {
      static cache = new Map();
      static GetImage(url, mark) {
          let data = ResourceLoader.cache.get(url);
          if (data) {
              if (data.loadState === 'fail') {
                  application.global.getRequestAnimationFrame()(() => {
                      mark.imageLoadFail(url);
                  });
              }
              else if (data.loadState === 'init' || data.loadState === 'loading') {
                  data.waitingMark?.push(mark);
              }
              else if (mark) {
                  application.global.getRequestAnimationFrame()(() => {
                      mark.imageLoadSuccess(url, data.data);
                  });
              }
          }
          else {
              data = { type: 'image', loadState: 'init' };
              ResourceLoader.cache.set(url, data);
              data.dataPromise = application.global.loadImage(url);
              if (!data.dataPromise) {
                  data.loadState = 'fail';
                  mark.imageLoadFail(url);
              }
              else {
                  data.waitingMark = [mark];
                  data.dataPromise.then(res => {
                      data.loadState = res?.data ? 'success' : 'fail';
                      data.data = res?.data;
                      data.waitingMark?.map((mark, index) => {
                          if (res?.data) {
                              data.loadState = 'success';
                              data.data = res.data;
                              mark.imageLoadSuccess(url, res.data);
                          }
                          else {
                              data.loadState = 'fail';
                              mark.imageLoadFail(url);
                          }
                      });
                  });
              }
          }
      }
      static GetSvg(svgStr, mark) {
          let data = ResourceLoader.cache.get(svgStr);
          if (data) {
              if (data.loadState === 'fail') {
                  application.global.getRequestAnimationFrame()(() => {
                      mark.imageLoadFail(svgStr);
                  });
              }
              else if (data.loadState === 'init' || data.loadState === 'loading') {
                  data.waitingMark?.push(mark);
              }
              else if (mark) {
                  application.global.getRequestAnimationFrame()(() => {
                      mark.imageLoadSuccess(svgStr, data.data);
                  });
              }
          }
          else {
              data = { type: 'image', loadState: 'init' };
              ResourceLoader.cache.set(svgStr, data);
              data.dataPromise = application.global.loadSvg(svgStr);
              if (!data.dataPromise) {
                  data.loadState = 'fail';
                  mark.imageLoadFail(svgStr);
              }
              else {
                  data.waitingMark = [mark];
                  data.dataPromise.then(res => {
                      data.loadState = res?.data ? 'success' : 'fail';
                      data.data = res?.data;
                      data.waitingMark?.map((mark, index) => {
                          if (res?.data) {
                              data.loadState = 'success';
                              data.data = res.data;
                              mark.imageLoadSuccess(svgStr, res.data);
                          }
                          else {
                              data.loadState = 'fail';
                              mark.imageLoadFail(svgStr);
                          }
                      });
                  });
              }
          }
      }
      static GetFile(url, type) {
          let data = ResourceLoader.cache.get(url);
          if (data) {
              if (data.loadState === 'init' || data.loadState === 'fail') {
                  return Promise.reject();
              }
              else if (data.loadState === 'loading') {
                  return data.dataPromise.then(data => data.data);
              }
              return Promise.resolve(data.data);
          }
          data = { type, loadState: 'init' };
          ResourceLoader.cache.set(url, data);
          if (type === 'arrayBuffer') {
              data.dataPromise = application.global.loadArrayBuffer(url);
          }
          else if (type === 'blob') {
              data.dataPromise = application.global.loadBlob(url);
          }
          else if (type === 'json') {
              data.dataPromise = application.global.loadJson(url);
          }
          return data.dataPromise.then(data => data.data);
      }
  }

  const tempMatrix = new Matrix();
  const PURE_STYLE_KEY = [
      'stroke',
      'opacity',
      'strokeOpacity',
      'lineDash',
      'lineDashOffset',
      'lineCap',
      'lineJoin',
      'miterLimit',
      'fill',
      'fillOpacity'
  ];
  const GRAPHIC_UPDATE_TAG_KEY = [
      'lineWidth',
      'lineCap',
      'lineJoin',
      'miterLimit',
      'scaleX',
      'scaleY',
      'angle',
      'anchor'
  ];
  const tempConstantXYKey = ['x', 'y'];
  const tempConstantScaleXYKey = ['scaleX', 'scaleY'];
  const tempConstantAngleKey = ['angle'];
  const point = new Point();
  class Graphic extends Node {
      static mixin(source) {
          const keys = Object.keys(source);
          for (let i = 0; i < keys.length; ++i) {
              const propertyName = keys[i];
              Object.defineProperty(Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
          }
      }
      get AABBBounds() {
          return this.tryUpdateAABBBounds(this.attribute.boundsMode === 'imprecise');
      }
      get OBBBounds() {
          return this.tryUpdateOBBBounds();
      }
      get globalAABBBounds() {
          return this.tryUpdateGlobalAABBBounds();
      }
      get transMatrix() {
          return this.tryUpdateLocalTransMatrix(true);
      }
      get globalTransMatrix() {
          return this.tryUpdateGlobalTransMatrix(true);
      }
      constructor(params = {}) {
          super();
          this._AABBBounds = new AABBBounds();
          this._updateTag = exports.UpdateTag.INIT;
          this.attribute = params;
          this.valid = this.isValid();
          if (params.background) {
              this.loadImage(params.background, true);
          }
      }
      setMode(mode) {
          mode === '3d' ? this.set3dMode() : this.set2dMode();
      }
      set3dMode() {
          this.in3dMode = true;
      }
      set2dMode() {
          this.in3dMode = false;
      }
      getOffsetXY(attr, includeScroll = false) {
          const { dx = attr.dx, dy = attr.dy } = this.attribute;
          if (includeScroll && this.parent) {
              const groupTheme = getTheme(this.parent).group;
              const { scrollX = groupTheme.scrollX, scrollY = groupTheme.scrollY } = this.parent.attribute;
              point.x = dx + scrollX;
              point.y = dy + scrollY;
          }
          else {
              point.x = dx;
              point.y = dy;
          }
          return point;
      }
      tryUpdateAABBBounds(full) {
          if (!this.shouldUpdateAABBBounds()) {
              return this._AABBBounds;
          }
          if (!this.valid) {
              this._AABBBounds.clear();
              return this._AABBBounds;
          }
          application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
          const bounds = this.doUpdateAABBBounds(full);
          application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, true);
          return bounds;
      }
      combindShadowAABBBounds(bounds) {
          if (this.shadowRoot) {
              const b = this.shadowRoot.AABBBounds.clone();
              bounds.union(b);
          }
      }
      tryUpdateGlobalAABBBounds() {
          if (!this._globalAABBBounds) {
              this._globalAABBBounds = this.AABBBounds.clone();
          }
          else {
              this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2);
          }
          if (this.parent) {
              this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix);
          }
          return this._globalAABBBounds;
      }
      tryUpdateGlobalTransMatrix(clearTag = true) {
          if (!this._globalTransMatrix) {
              this._globalTransMatrix = this.parent
                  ? this.parent.globalTransMatrix.clone()
                  : this.transMatrix.clone();
          }
          else if (this.parent) {
              const m = this.parent.globalTransMatrix;
              this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
          }
          if (this.shouldUpdateGlobalMatrix()) {
              this.doUpdateGlobalMatrix();
          }
          return this._globalTransMatrix;
      }
      shouldUpdateGlobalMatrix() {
          return true;
      }
      tryUpdateLocalTransMatrix(clearTag = true) {
          if (!this._transMatrix) {
              this._transMatrix = new Matrix();
          }
          if (this.shouldUpdateLocalMatrix()) {
              this.doUpdateLocalMatrix();
              clearTag && this.clearUpdateLocalPositionTag();
          }
          return this._transMatrix;
      }
      shouldUpdateAABBBounds() {
          if (this.shadowRoot) {
              return !!(this._updateTag & exports.UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds();
          }
          return !!(this._updateTag & exports.UpdateTag.UPDATE_BOUNDS);
      }
      shouldSelfChangeUpdateAABBBounds() {
          if (this.shadowRoot) {
              return !!(this._updateTag & exports.UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds();
          }
          return !!(this._updateTag & exports.UpdateTag.UPDATE_BOUNDS);
      }
      shouldUpdateLocalMatrix() {
          return !!(this._updateTag & exports.UpdateTag.UPDATE_LOCAL_MATRIX);
      }
      isValid() {
          const attribute = this.attribute;
          return Number.isFinite((attribute.x ?? 0) + (attribute.y ?? 0));
      }
      _validNumber(num) {
          return num == null || Number.isFinite(num);
      }
      shouldUpdateShape() {
          return !!(this._updateTag & exports.UpdateTag.UPDATE_SHAPE);
      }
      clearUpdateShapeTag() {
          this._updateTag &= exports.UpdateTag.CLEAR_SHAPE;
      }
      containsPoint(x, y, mode, picker) {
          if (!picker) {
              return false;
          }
          if (mode === exports.IContainPointMode.GLOBAL) {
              const point = new Point(x, y);
              if (this.parent) {
                  this.parent.globalTransMatrix.transformPoint(point, point);
              }
              x = point.x;
              y = point.y;
          }
          return picker.containsPoint(this, { x, y });
      }
      setAttributes(params, forceUpdateTag = false, context) {
          params =
              (this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context)) || params;
          if (params.background) {
              this.loadImage(params.background, true);
          }
          this._setAttributes(params, forceUpdateTag, context);
      }
      _setAttributes(params, forceUpdateTag = false, context) {
          const keys = Object.keys(params);
          for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              this.attribute[key] = params[key];
          }
          this.valid = this.isValid();
          if (!this.updateShapeAndBoundsTagSetted() && (forceUpdateTag || this.needUpdateTags(keys))) {
              this.addUpdateShapeAndBoundsTag();
          }
          else {
              this.addUpdateBoundTag();
          }
          this.addUpdatePositionTag();
          this.onAttributeUpdate(context);
      }
      setAttribute(key, value, forceUpdateTag, context) {
          const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({ [key]: value }, this.attribute, key, context);
          if (!params) {
              if (!isNil(this.normalAttrs?.[key])) {
                  this.normalAttrs[key] = value;
              }
              else {
                  this.attribute[key] = value;
                  this.valid = this.isValid();
                  if (!this.updateShapeAndBoundsTagSetted() && (forceUpdateTag || this.needUpdateTag(key))) {
                      this.addUpdateShapeAndBoundsTag();
                  }
                  else {
                      this.addUpdateBoundTag();
                  }
                  this.addUpdatePositionTag();
                  this.onAttributeUpdate(context);
              }
          }
          else {
              this._setAttributes(params, forceUpdateTag, context);
          }
          if (key === 'background') {
              this.loadImage(value, true);
          }
      }
      needUpdateTags(keys) {
          for (let i = 0; i < GRAPHIC_UPDATE_TAG_KEY.length; i++) {
              const attrKey = GRAPHIC_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < GRAPHIC_UPDATE_TAG_KEY.length; i++) {
              const attrKey = GRAPHIC_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      initAttributes(params) {
          const context = { type: exports.AttributeUpdateType.INIT };
          params =
              (this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context)) || params;
          this.attribute = params;
          if (params.background) {
              this.loadImage(params.background, true);
          }
          this._updateTag = exports.UpdateTag.INIT;
          this.onAttributeUpdate(context);
      }
      translate(x, y) {
          if (x === 0 && y === 0) {
              return this;
          }
          const context = {
              type: exports.AttributeUpdateType.TRANSLATE
          };
          const params = this.onBeforeAttributeUpdate &&
              this.onBeforeAttributeUpdate({ x, y }, this.attribute, tempConstantXYKey, context);
          if (params) {
              x = params.x;
              y = params.y;
              delete params.x;
              delete params.y;
              this._setAttributes(params);
          }
          const attribute = this.attribute;
          const postMatrix = attribute.postMatrix;
          if (!postMatrix) {
              attribute.x = (attribute.x ?? DefaultTransform.x) + x;
              attribute.y = (attribute.y ?? DefaultTransform.y) + y;
          }
          else {
              application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y);
          }
          this.addUpdatePositionTag();
          this.addUpdateBoundTag();
          this.onAttributeUpdate(context);
          return this;
      }
      translateTo(x, y) {
          const attribute = this.attribute;
          if (attribute.x === x && attribute.y === y) {
              return this;
          }
          const context = {
              type: exports.AttributeUpdateType.TRANSLATE_TO
          };
          const params = this.onBeforeAttributeUpdate &&
              this.onBeforeAttributeUpdate({ x, y }, this.attribute, tempConstantXYKey, context);
          if (params) {
              this._setAttributes(params, false, context);
              return this;
          }
          attribute.x = x;
          attribute.y = y;
          this.addUpdatePositionTag();
          this.addUpdateBoundTag();
          this.onAttributeUpdate(context);
          return this;
      }
      scale(scaleX, scaleY, scaleCenter) {
          if (scaleX === 1 && scaleY === 1) {
              return this;
          }
          const context = {
              type: exports.AttributeUpdateType.SCALE
          };
          const params = this.onBeforeAttributeUpdate &&
              this.onBeforeAttributeUpdate({ scaleX, scaleY, scaleCenter }, this.attribute, tempConstantScaleXYKey, context);
          if (params) {
              scaleX = params.scaleX;
              scaleY = params.scaleY;
              delete params.scaleX;
              delete params.scaleY;
              this._setAttributes(params);
          }
          const attribute = this.attribute;
          if (!scaleCenter) {
              attribute.scaleX = (attribute.scaleX ?? DefaultTransform.scaleX) * scaleX;
              attribute.scaleY = (attribute.scaleY ?? DefaultTransform.scaleY) * scaleY;
          }
          else {
              let { postMatrix } = this.attribute;
              if (!postMatrix) {
                  postMatrix = new Matrix();
                  attribute.postMatrix = postMatrix;
              }
              application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
          }
          this.addUpdatePositionTag();
          this.addUpdateBoundTag();
          this.onAttributeUpdate(context);
          return this;
      }
      scaleTo(scaleX, scaleY) {
          const attribute = this.attribute;
          if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) {
              return this;
          }
          const context = {
              type: exports.AttributeUpdateType.SCALE_TO
          };
          const params = this.onBeforeAttributeUpdate &&
              this.onBeforeAttributeUpdate({ scaleX, scaleY }, this.attribute, tempConstantScaleXYKey, context);
          if (params) {
              this._setAttributes(params, false, context);
              return this;
          }
          attribute.scaleX = scaleX;
          attribute.scaleY = scaleY;
          this.addUpdatePositionTag();
          this.addUpdateBoundTag();
          this.onAttributeUpdate(context);
          return this;
      }
      rotate(angle) {
          if (angle === 0) {
              return this;
          }
          const context = { type: exports.AttributeUpdateType.ROTATE };
          const params = this.onBeforeAttributeUpdate &&
              this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
          if (params) {
              this._setAttributes(params, false, context);
              return this;
          }
          const attribute = this.attribute;
          attribute.angle = (attribute.angle ?? DefaultTransform.angle) + angle;
          this.addUpdatePositionTag();
          this.addUpdateBoundTag();
          this.onAttributeUpdate(context);
          return this;
      }
      rotateTo(angle) {
          const attribute = this.attribute;
          if (attribute.angle === angle) {
              return this;
          }
          const context = {
              type: exports.AttributeUpdateType.ROTATE_TO
          };
          const params = this.onBeforeAttributeUpdate &&
              this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
          if (params) {
              this._setAttributes(params, false, context);
              return this;
          }
          attribute.angle = angle;
          this.addUpdatePositionTag();
          this.addUpdateBoundTag();
          this.onAttributeUpdate(context);
          return this;
      }
      skewTo(b, c) {
          return this;
      }
      animate(params) {
          if (!this.animates) {
              this.animates = new Map();
          }
          const animate = new Animate(params?.id).bind(this);
          if (params) {
              const { onStart, onFrame, onEnd, onRemove } = params;
              onStart != null && animate.onStart(onStart);
              onFrame != null && animate.onFrame(onFrame);
              onEnd != null && animate.onEnd(onEnd);
              onRemove != null && animate.onRemove(onRemove);
              animate.interpolateFunc = params.interpolate;
          }
          this.animates.set(animate.id, animate);
          animate.onRemove(() => {
              this.animates.delete(animate.id);
          });
          return animate;
      }
      onAttributeUpdate(context) {
          application.graphicService.onAttributeUpdate(this);
          this._emitCustomEvent('afterAttributeUpdate', context);
      }
      update(d) {
          if (d) {
              d.bounds && this.tryUpdateAABBBounds(this.attribute.boundsMode === 'imprecise');
              d.trans && this.tryUpdateLocalTransMatrix();
          }
          else {
              this.tryUpdateAABBBounds(this.attribute.boundsMode === 'imprecise');
              this.tryUpdateLocalTransMatrix();
          }
      }
      hasState(stateName) {
          if (!this.currentStates || !this.currentStates.length) {
              return false;
          }
          if (!isNil(stateName)) {
              return this.currentStates.includes(stateName);
          }
          return true;
      }
      getState(stateName) {
          return this.states?.[stateName];
      }
      applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
          if (hasAnimation) {
              const keys = Object.keys(attrs);
              const animateAttrs = isClear
                  ? keys.reduce((res, key) => {
                      res[key] = attrs[key] === undefined ? this.getDefaultAttribute(key) : attrs[key];
                      return res;
                  }, {})
                  : attrs;
              const animate = this.animate();
              animate.stateNames = stateNames;
              animate.to(animateAttrs, this.stateAnimateConfig?.duration ?? DefaultStateAnimateConfig.duration, this.stateAnimateConfig?.easing ?? DefaultStateAnimateConfig.easing);
          }
          else {
              this.setAttributes(attrs, false, { type: exports.AttributeUpdateType.STATE });
          }
      }
      updateNormalAttrs(stateAttrs) {
          const newNormalAttrs = {};
          if (this.normalAttrs) {
              Object.keys(stateAttrs).forEach(key => {
                  if (key in this.normalAttrs) {
                      newNormalAttrs[key] = this.normalAttrs[key];
                      delete this.normalAttrs[key];
                  }
                  else {
                      newNormalAttrs[key] = this.getNormalAttribute(key);
                  }
              });
              Object.keys(this.normalAttrs).forEach(key => {
                  stateAttrs[key] = this.normalAttrs[key];
              });
          }
          else {
              Object.keys(stateAttrs).forEach(key => {
                  newNormalAttrs[key] = this.getNormalAttribute(key);
              });
          }
          this.normalAttrs = newNormalAttrs;
      }
      getNormalAttribute(key) {
          let value = this.attribute[key];
          if (this.animates) {
              this.animates.forEach(animate => {
                  if (animate.stateNames) {
                      const endProps = animate.getEndProps();
                      if (has(endProps, key)) {
                          value = endProps[key];
                      }
                  }
              });
          }
          return value;
      }
      clearStates(hasAnimation) {
          if (this.hasState() && this.normalAttrs) {
              this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true);
          }
          this.normalAttrs = null;
          this.currentStates = [];
      }
      removeState(stateName, hasAnimation) {
          const index = this.currentStates ? this.currentStates.indexOf(stateName) : -1;
          if (index >= 0) {
              const currentStates = this.currentStates.filter(state => state !== stateName);
              this.useStates(currentStates, hasAnimation);
          }
      }
      toggleState(stateName, hasAnimation) {
          if (this.hasState(stateName)) {
              this.removeState(stateName, hasAnimation);
          }
          else {
              const index = this.currentStates ? this.currentStates.indexOf(stateName) : -1;
              if (index < 0) {
                  const nextStates = this.currentStates ? this.currentStates.slice() : [];
                  nextStates.push(stateName);
                  this.useStates(nextStates, hasAnimation);
              }
          }
      }
      addState(stateName, keepCurrentStates, hasAnimation) {
          if (this.currentStates &&
              this.currentStates.includes(stateName) &&
              (keepCurrentStates || this.currentStates.length === 1)) {
              return;
          }
          const newStates = keepCurrentStates && this.currentStates?.length ? this.currentStates.concat([stateName]) : [stateName];
          this.useStates(newStates, hasAnimation);
      }
      useStates(states, hasAnimation) {
          if (!states.length) {
              this.clearStates(hasAnimation);
              return;
          }
          const isChange = this.currentStates?.length !== states.length ||
              states.some((stateName, index) => this.currentStates[index] !== stateName);
          if (!isChange) {
              return;
          }
          const stateAttrs = {};
          states.forEach(stateName => {
              const attrs = this.stateProxy ? this.stateProxy(stateName, states) : this.states?.[stateName];
              if (attrs) {
                  Object.assign(stateAttrs, attrs);
              }
          });
          this.updateNormalAttrs(stateAttrs);
          this.currentStates = states;
          this.applyStateAttrs(stateAttrs, states, hasAnimation);
      }
      addUpdateBoundTag() {
          this._updateTag |= exports.UpdateTag.UPDATE_BOUNDS;
          if (this.parent) {
              this.parent.addChildUpdateBoundTag();
          }
          if (this.glyphHost) {
              this.glyphHost.addUpdateBoundTag();
          }
      }
      addUpdateShapeTag() {
          this._updateTag |= exports.UpdateTag.UPDATE_SHAPE;
      }
      addUpdateShapeAndBoundsTag() {
          this._updateTag |= exports.UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
          if (this.parent) {
              this.parent.addChildUpdateBoundTag();
          }
          if (this.glyphHost) {
              this.glyphHost.addUpdateBoundTag();
          }
      }
      updateShapeAndBoundsTagSetted() {
          return (this._updateTag & exports.UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === exports.UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
      }
      clearUpdateBoundTag() {
          this._updateTag &= exports.UpdateTag.CLEAR_BOUNDS;
      }
      addUpdatePositionTag() {
          this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag();
          this._updateTag |= exports.UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
      }
      addUpdateGlobalPositionTag() {
          this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag();
          this._updateTag |= exports.UpdateTag.UPDATE_GLOBAL_MATRIX;
      }
      clearUpdateLocalPositionTag() {
          this._updateTag &= exports.UpdateTag.CLEAR_LOCAL_MATRIX;
      }
      clearUpdateGlobalPositionTag() {
          this._updateTag &= exports.UpdateTag.CLEAR_GLOBAL_MATRIX;
      }
      doUpdateLocalMatrix() {
          const { x = DefaultTransform.x, y = DefaultTransform.y, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle = DefaultTransform.angle, anchor, postMatrix } = this.attribute;
          const _anchor = [0, 0];
          if (anchor) {
              if (typeof anchor[0] === 'string') {
                  const ratio = parseFloat(anchor[0]) / 100;
                  const bounds = this.AABBBounds;
                  _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
              }
              else {
                  _anchor[0] = anchor[0];
              }
              if (typeof anchor[1] === 'string') {
                  const ratio = parseFloat(anchor[1]) / 100;
                  const bounds = this.AABBBounds;
                  _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
              }
              else {
                  _anchor[1] = anchor[1];
              }
          }
          normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle, anchor && _anchor);
          const p = this.getOffsetXY(DefaultTransform);
          this._transMatrix.e += p.x;
          this._transMatrix.f += p.y;
          if (postMatrix) {
              const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f);
              const m2 = this._transMatrix;
              m1.multiply(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
              m2.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
          }
      }
      doUpdateGlobalMatrix() {
          if (this.parent) {
              this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
              const { scrollX = 0, scrollY = 0 } = this.parent.attribute;
              this._globalTransMatrix.translate(scrollX, scrollY);
          }
      }
      setStage(stage, layer) {
          if (this.stage !== stage) {
              this.stage = stage;
              this.layer = layer;
              this.setStageToShadowRoot(stage, layer);
              this._onSetStage && this._onSetStage(this, stage, layer);
              application.graphicService.onSetStage(this, stage);
          }
      }
      setStageToShadowRoot(stage, layer) {
          if (this.shadowRoot) {
              this.shadowRoot.setStage(stage, layer);
          }
      }
      onAddStep(step) {
          return;
      }
      onStop(props) {
          if (props) {
              this.setAttributes(props, false, { type: exports.AttributeUpdateType.ANIMATE_END });
          }
      }
      onStep(subAnimate, animate, step, ratio, end) {
          const nextAttributes = {};
          if (step.customAnimate) {
              step.customAnimate.update(end, ratio, nextAttributes);
          }
          else {
              const nextProps = step.props;
              const nextParsedProps = step.parsedProps;
              const propKeys = step.propKeys;
              this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, undefined, nextParsedProps, propKeys);
          }
          this.setAttributes(nextAttributes, false, {
              type: exports.AttributeUpdateType.ANIMATE_UPDATE,
              animationState: {
                  ratio,
                  end,
                  step,
                  isFirstFrameOfStep: subAnimate.getLastStep() !== step
              }
          });
          this.stage && this.stage.renderNextFrame();
      }
      stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {
          if (!propKeys) {
              propKeys = Object.keys(nextProps);
              step.propKeys = propKeys;
          }
          if (end) {
              step.propKeys.forEach(key => {
                  if (!animate.validAttr(key)) {
                      return;
                  }
                  nextAttributes[key] = nextProps[key];
              });
          }
          else {
              propKeys.forEach(key => {
                  if (!animate.validAttr(key)) {
                      return;
                  }
                  const nextStepVal = nextProps[key];
                  const lastStepVal = (lastProps && lastProps[key]) ?? subAnimate.getLastPropByName(key, step);
                  let match;
                  match =
                      animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes);
                  if (match) {
                      return;
                  }
                  match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, this, nextAttributes);
                  if (match) {
                      return;
                  }
                  if (!this.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio)) {
                      this._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes);
                  }
              });
          }
          step.parsedProps = nextParsedProps;
      }
      defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {
          if (Number.isFinite(nextStepVal)) {
              nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio;
              return true;
          }
          else if (key === 'fill') {
              if (!nextParsedProps) {
                  nextParsedProps = {};
              }
              const fillColorArray = nextParsedProps.fillColorArray;
              const color = interpolateColor(lastStepVal, fillColorArray ?? nextStepVal, ratio, false, (fArray, tArray) => {
                  nextParsedProps.fillColorArray = tArray;
              });
              if (color) {
                  nextAttributes[key] = color;
              }
              return true;
          }
          else if (key === 'stroke') {
              if (!nextParsedProps) {
                  nextParsedProps = {};
              }
              const strokeColorArray = nextParsedProps.strokeColorArray;
              const color = interpolateColor(lastStepVal, strokeColorArray ?? nextStepVal, ratio, false, (fArray, tArray) => {
                  nextParsedProps.strokeColorArray = tArray;
              });
              if (color) {
                  nextAttributes[key] = color;
              }
              return true;
          }
          else if (key === 'shadowColor') {
              if (!nextParsedProps) {
                  nextParsedProps = {};
              }
              const shadowColorArray = nextParsedProps.shadowColorArray;
              const color = interpolateColor(lastStepVal, shadowColorArray ?? nextStepVal, ratio, true, (fArray, tArray) => {
                  nextParsedProps.shadowColorArray = tArray;
              });
              if (color) {
                  nextAttributes[key] = color;
              }
              return true;
          }
          return false;
      }
      _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
          return;
      }
      getDefaultAttribute(name) {
          return getTheme(this)[this.type][name];
      }
      getComputedAttribute(name) {
          return this.attribute[name] ?? this.getDefaultAttribute(name);
      }
      onSetStage(cb, immediate = false) {
          this._onSetStage = cb;
          if (immediate && this.stage) {
              cb(this, this.stage);
          }
      }
      attachShadow(shadowRoot) {
          if (shadowRoot) {
              shadowRoot.shadowHost = this;
          }
          this.shadowRoot = shadowRoot ?? application.graphicService.creator.shadowRoot(this);
          this.addUpdateBoundTag();
          this.shadowRoot.setStage(this.stage, this.layer);
          return this.shadowRoot;
      }
      detachShadow() {
          if (this.shadowRoot) {
              this.addUpdateBoundTag();
              this.shadowRoot = null;
          }
      }
      toJson() {
          return {
              attribute: this.attribute,
              _uid: this._uid,
              type: this.type,
              name: this.name,
              children: this.children.map((item) => item.toJson())
          };
      }
      createPathProxy(path) {
          if (isString(path, true)) {
              this.pathProxy = new CustomPath2D().fromString(path);
          }
          else {
              this.pathProxy = new CustomPath2D();
          }
          return this.pathProxy;
      }
      loadImage(image, background = false) {
          if (!image) {
              return;
          }
          const url = image;
          if (!this.resources) {
              this.resources = new Map();
          }
          const cache = {
              data: 'init',
              state: null
          };
          this.resources.set(url, cache);
          if (typeof image === 'string') {
              cache.state = 'loading';
              if (isValidUrl(image) || isBase64(image)) {
                  ResourceLoader.GetImage(image, this);
                  this.backgroundImg = this.backgroundImg || background;
              }
              else if (image.startsWith('<svg')) {
                  ResourceLoader.GetSvg(image, this);
                  this.backgroundImg = this.backgroundImg || background;
              }
          }
          else {
              (cache.state = 'success'), (cache.data = image);
              this.backgroundImg = this.backgroundImg || background;
          }
      }
      imageLoadSuccess(url, image, cb) {
          if (!this.resources) {
              return;
          }
          const res = this.resources.get(url);
          if (!res) {
              return;
          }
          res.state = 'success';
          res.data = image;
          cb && cb();
          this.addUpdateBoundTag();
          this.stage && this.stage.renderNextFrame();
      }
      imageLoadFail(url, cb) {
          if (!this.resources) {
              return;
          }
          const res = this.resources.get(url);
          if (!res) {
              return;
          }
          res.state = 'fail';
          cb && cb();
      }
      release() {
          this.releaseStatus = 'released';
      }
      _emitCustomEvent(type, context) {
          if (this._events && type in this._events) {
              const changeEvent = new CustomEvent(type, context);
              changeEvent.bubbles = false;
              changeEvent.manager = this.stage?.eventSystem?.manager;
              this.dispatchEvent(changeEvent);
          }
      }
  }
  Graphic.mixin(EventTarget);

  function incrementalAddTo(group, graphic) {
      group.incrementalAppendChild(graphic);
  }
  async function waitForAllSubLayers(stage) {
      const promiseList = [];
      const layers = stage.getChildren();
      await new Promise(resolve => {
          application.global.getRequestAnimationFrame()(() => {
              resolve(null);
          });
      });
      layers.forEach(l => {
          if (l.subLayers.size) {
              l.subLayers.forEach(sl => {
                  if (sl.drawContribution && sl.drawContribution.hooks && sl.drawContribution.rendering) {
                      promiseList.push(new Promise(resolve => {
                          sl.drawContribution.hooks.completeDraw.tap('outWait', () => {
                              sl.drawContribution.hooks.completeDraw.taps = sl.drawContribution.hooks.completeDraw.taps.filter(i => {
                                  return i.name !== 'outWait';
                              });
                              resolve(null);
                          });
                      }));
                  }
              });
          }
      });
      await Promise.all(promiseList);
  }
  function boundStroke(bounds, halfW, miter, pad = 0) {
      bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0)));
      return bounds;
  }
  function miterAdjustment(miter, strokeWidth) {
      return miter ? strokeWidth : 0;
  }
  let NUMBER_TYPE = 0;
  function genNumberType() {
      return NUMBER_TYPE++;
  }

  const ARC_NUMBER_TYPE = genNumberType();
  const ARC3D_NUMBER_TYPE = genNumberType();
  const AREA_NUMBER_TYPE = genNumberType();
  const CIRCLE_NUMBER_TYPE = genNumberType();
  const GLYPH_NUMBER_TYPE = genNumberType();
  const GROUP_NUMBER_TYPE = genNumberType();
  const IMAGE_NUMBER_TYPE = genNumberType();
  const LINE_NUMBER_TYPE = genNumberType();
  const PATH_NUMBER_TYPE = genNumberType();
  const POLYGON_NUMBER_TYPE = genNumberType();
  const PYRAMID3D_NUMBER_TYPE = genNumberType();
  const RECT_NUMBER_TYPE = genNumberType();
  const RECT3D_NUMBER_TYPE = genNumberType();
  const RICHTEXT_NUMBER_TYPE = genNumberType();
  const SYMBOL_NUMBER_TYPE = genNumberType();
  const TEXT_NUMBER_TYPE = genNumberType();
  const GraphicService = Symbol.for('GraphicService');
  const GraphicCreator = Symbol.for('GraphicCreator');

  exports.GroupUpdateAABBBoundsMode = void 0;
  (function (GroupUpdateAABBBoundsMode) {
      GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode["LESS_GROUP"] = 0] = "LESS_GROUP";
      GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode["MORE_GROUP"] = 1] = "MORE_GROUP";
  })(exports.GroupUpdateAABBBoundsMode || (exports.GroupUpdateAABBBoundsMode = {}));
  class Group extends Graphic {
      type = 'group';
      parent = null;
      isContainer = true;
      constructor(params) {
          super(params);
          this.numberType = GROUP_NUMBER_TYPE;
          this._childUpdateTag = exports.UpdateTag.UPDATE_BOUNDS;
      }
      setMode(mode) {
          mode === '3d' ? this.set3dMode() : this.set2dMode();
      }
      set3dMode() {
          this.in3dMode = true;
      }
      set2dMode() {
          this.in3dMode = false;
      }
      setTheme(t) {
          if (!this.theme) {
              this.theme = new Theme();
          }
          return this.theme.setTheme(t, this);
      }
      createTheme() {
          if (!this.theme) {
              this.theme = new Theme();
          }
      }
      hideAll() {
          this.setAttribute('visible', false);
          this.forEachChildren((item) => {
              if (item.isContainer && item.hideAll) {
                  item.hideAll();
              }
              else {
                  item.setAttribute('visible', false);
              }
          });
      }
      showAll() {
          this.setAttribute('visible', true);
          this.forEachChildren((item) => {
              if (item.isContainer && item.showAll) {
                  item.showAll();
              }
              else {
                  item.setAttribute('visible', true);
              }
          });
      }
      containsPoint(x, y, mode) {
          if (mode === exports.IContainPointMode.GLOBAL) {
              const point = new Point(x, y);
              if (this.parent) {
                  this.parent.globalTransMatrix.transformPoint(point, point);
              }
              return this.AABBBounds.contains(point.x, point.y);
          }
          return this.AABBBounds.contains(x, y);
      }
      shouldUpdateAABBBounds() {
          if (super.shouldUpdateAABBBounds()) {
              return true;
          }
          if (this._childUpdateTag & exports.UpdateTag.UPDATE_BOUNDS) {
              return true;
          }
          return false;
      }
      tryUpdateAABBBounds() {
          if (!this.shouldUpdateAABBBounds()) {
              return this._AABBBounds;
          }
          application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
          const selfChange = this.shouldSelfChangeUpdateAABBBounds();
          const bounds = this.doUpdateAABBBounds();
          application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange);
          return bounds;
      }
      doUpdateAABBBounds() {
          const attribute = this.attribute;
          const groupTheme = getTheme(this).group;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const bounds = application.graphicService.updateGroupAABBBounds(attribute, getTheme(this).group, this._AABBBounds, this);
          const { boundsPadding = groupTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.parent && this.parent.addChildUpdateBoundTag();
          this.clearUpdateBoundTag();
          this._emitCustomEvent('AAABBBoundsChange');
          return bounds;
      }
      clearUpdateBoundTag() {
          this._updateTag &= exports.UpdateTag.CLEAR_BOUNDS;
          this._childUpdateTag &= exports.UpdateTag.CLEAR_BOUNDS;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      addUpdateBoundTag() {
          this._updateTag |= exports.UpdateTag.UPDATE_BOUNDS;
          if (this.parent) {
              this.parent.addChildUpdateBoundTag();
          }
      }
      addChildUpdateBoundTag() {
          if (this._childUpdateTag & exports.UpdateTag.UPDATE_BOUNDS) {
              return;
          }
          this._childUpdateTag |= exports.UpdateTag.UPDATE_BOUNDS;
          this.parent && this.parent.addChildUpdateBoundTag();
      }
      getTheme() {
          return this.theme.getTheme(this);
      }
      incrementalAppendChild(node) {
          const data = super.appendChild(node);
          if (this.stage && data) {
              data.stage = this.stage;
              data.layer = this.layer;
          }
          this.addUpdateBoundTag();
          application.graphicService.onAddIncremental(node, this, this.stage);
          return data;
      }
      incrementalClearChild() {
          super.removeAllChild();
          this.addUpdateBoundTag();
          application.graphicService.onClearIncremental(this, this.stage);
          return;
      }
      appendChild(node, addStage = true) {
          const data = super.appendChild(node);
          if (addStage && this.stage && data) {
              data.setStage(this.stage, this.layer);
          }
          this.addUpdateBoundTag();
          return data;
      }
      insertBefore(newNode, referenceNode) {
          const data = super.insertBefore(newNode, referenceNode);
          if (this.stage && data) {
              data.setStage(this.stage, this.layer);
          }
          this.addUpdateBoundTag();
          return data;
      }
      insertAfter(newNode, referenceNode) {
          const data = super.insertAfter(newNode, referenceNode);
          if (this.stage && data) {
              data.setStage(this.stage, this.layer);
          }
          this.addUpdateBoundTag();
          return data;
      }
      insertInto(newNode, idx) {
          const data = super.insertInto(newNode, idx);
          if (this.stage && data) {
              data.setStage(this.stage, this.layer);
          }
          this.addUpdateBoundTag();
          return data;
      }
      removeChild(child) {
          const data = super.removeChild(child);
          child.stage = null;
          application.graphicService.onRemove(child);
          this.addUpdateBoundTag();
          return data;
      }
      removeAllChild() {
          this.forEachChildren((child) => {
              application.graphicService.onRemove(child);
          });
          super.removeAllChild();
          this.addUpdateBoundTag();
      }
      setStage(stage, layer) {
          if (this.stage !== stage) {
              this.stage = stage;
              this.layer = layer;
              this.setStageToShadowRoot(stage, layer);
              this._onSetStage && this._onSetStage(this, stage, layer);
              application.graphicService.onSetStage(this, stage);
              this.forEachChildren(item => {
                  item.setStage(stage, this.layer);
              });
          }
      }
      addUpdatePositionTag() {
          super.addUpdatePositionTag();
          this.forEachChildren((g) => {
              if (g.isContainer) {
                  g.addUpdateGlobalPositionTag();
              }
          });
      }
      addUpdateGlobalPositionTag() {
          super.addUpdateGlobalPositionTag();
          this.forEachChildren((g) => {
              if (g.isContainer) {
                  g.addUpdateGlobalPositionTag();
              }
          });
      }
      tryUpdateGlobalTransMatrix(clearTag = true) {
          if (this.shouldUpdateGlobalMatrix()) {
              if (!this._globalTransMatrix) {
                  this._globalTransMatrix = this.parent
                      ? this.parent.globalTransMatrix.clone()
                      : this.transMatrix.clone();
              }
              else if (this.parent) {
                  const m = this.parent.globalTransMatrix;
                  this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
              }
              this.doUpdateGlobalMatrix();
              clearTag && this.clearUpdateGlobalPositionTag();
          }
          return this._globalTransMatrix;
      }
      shouldUpdateGlobalMatrix() {
          const shouldUpdate = !!(this._updateTag & exports.UpdateTag.UPDATE_GLOBAL_MATRIX);
          return shouldUpdate;
      }
      _getChildByName(name, deep) {
          return this.find(node => node.name === name, deep);
      }
      createOrUpdateChild(graphicName, attributes, graphicType) {
          let graphic = this._getChildByName(graphicName);
          if (graphic) {
              graphic.setAttributes(attributes);
          }
          else {
              graphic = application.graphicService.creator[graphicType](attributes);
              graphic.name = graphicName;
              this.add(graphic);
          }
          return graphic;
      }
      clone() {
          return new Group({ ...this.attribute });
      }
  }

  const LayerHandlerContribution = Symbol.for('LayerHandlerContribution');
  class Layer extends Group {
      get offscreen() {
          return this.layerHandler.offscreen;
      }
      get width() {
          if (!this.stage) {
              return 0;
          }
          return this.stage.width;
      }
      get height() {
          if (!this.stage) {
              return 0;
          }
          return this.stage.height;
      }
      get viewWidth() {
          if (!this.stage) {
              return 0;
          }
          return this.stage.viewWidth;
      }
      get viewHeight() {
          if (!this.stage) {
              return 0;
          }
          return this.stage.viewHeight;
      }
      get dirtyBound() {
          throw new Error('');
      }
      get dpr() {
          return this._dpr;
      }
      constructor(stage, global, window, params) {
          super({});
          this.stage = stage;
          this.global = global;
          this.window = window;
          this.main = params.main;
          this.layerHandler = container.get(LayerHandlerContribution);
          this.layerHandler.init(this, window, {
              main: params.main,
              canvasId: params.canvasId,
              width: this.viewWidth,
              height: this.viewHeight,
              zIndex: params.zIndex ?? 0
          });
          this.layer = this;
          this.subLayers = new Map();
          this.theme = new Theme();
          this.background = 'rgba(0, 0, 0, 0)';
      }
      combineSubLayer(removeIncrementalKey = true) {
          const subLayers = Array.from(this.subLayers.values()).sort((a, b) => {
              return a.zIndex - b.zIndex;
          });
          this.layerHandler.merge(subLayers.map(l => {
              if (l.layer.subLayers.size) {
                  l.layer.combineSubLayer(removeIncrementalKey);
              }
              return l.layer.getNativeHandler();
          }));
          if (removeIncrementalKey) {
              subLayers.forEach(l => {
                  l.group && (l.group.incremental = 0);
              });
          }
          subLayers.forEach(l => {
              application.layerService.releaseLayer(this.stage, l.layer);
          });
          this.subLayers.clear();
      }
      getNativeHandler() {
          return this.layerHandler;
      }
      setStage(stage, layer) {
          super.setStage(stage, this);
      }
      pick(x, y) {
          throw new Error('');
      }
      render(params, userParams) {
          const stage = this.stage;
          this.layerHandler.render([this], {
              renderService: params.renderService,
              x: stage.x,
              y: stage.y,
              width: this.viewWidth,
              height: this.viewHeight,
              stage: this.stage,
              layer: this,
              background: params.background ?? this.background,
              updateBounds: params.updateBounds
          }, userParams);
      }
      resize(w, h) {
          this.layerHandler.resize(w, h);
      }
      resizeView(w, h) {
          this.layerHandler.resizeView(w, h);
      }
      setDpr(dpr) {
          throw new Error('');
      }
      afterDraw(cb) {
          throw new Error('');
      }
      startAnimate(t) {
          throw new Error('');
      }
      setToFrame(t) {
          throw new Error('');
      }
      prepare(dirtyBounds, params) {
          return;
      }
      combineTo(target, params) {
          if (this.offscreen) {
              this.layerHandler.drawTo(target, [this], {
                  background: params.background ?? this.background,
                  renderService: params.renderService,
                  x: this.stage.x,
                  y: this.stage.y,
                  width: this.viewWidth,
                  height: this.viewHeight,
                  stage: this.stage,
                  layer: this,
                  ...params
              });
          }
      }
      release() {
          super.release();
          this.layerHandler.release();
          if (this.subLayers) {
              this.subLayers.forEach(l => {
                  application.layerService.releaseLayer(this.stage, l.layer);
              });
          }
      }
      drawTo(target, params) {
          this.layerHandler.drawTo(target, [this], {
              background: params.background ?? this.background,
              renderService: params.renderService,
              x: this.stage.x,
              y: this.stage.y,
              width: this.viewWidth,
              height: this.viewHeight,
              stage: this.stage,
              layer: this,
              ...params
          });
      }
  }

  exports.DefaultLayerService = class DefaultLayerService {
      global;
      constructor(global) {
          this.global = global;
          this.layerMap = new Map();
      }
      getStageLayer(stage) {
          return this.layerMap.get(stage);
      }
      createLayer(stage) {
          const layer = new Layer(stage, this.global, stage.window, { main: false });
          const stageLayers = this.layerMap.get(stage) || [];
          stageLayers.push(layer);
          this.layerMap.set(stage, stageLayers);
          return layer;
      }
      releaseLayer(stage, layer) {
          layer.release();
          const stageLayers = this.layerMap.get(stage) || [];
          this.layerMap.set(stage, stageLayers.filter(l => l !== layer));
      }
      layerCount(stage) {
          return (this.layerMap.get(stage) || []).length;
      }
      restLayerCount(stage) {
          if (this.global.env === 'browser') {
              return 10;
          }
          return 0;
      }
  };
  exports.DefaultLayerService = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultLayerService);

  const Window = Symbol.for('Window');
  const WindowHandlerContribution = Symbol.for('WindowHandlerContribution');
  exports.DefaultWindow = class DefaultWindow {
      global;
      _width;
      _height;
      _handler;
      hooks = {
          onChange: new SyncHook(['x', 'y', 'width', 'height'])
      };
      get width() {
          if (this._handler) {
              const wh = this._handler.getWH();
              return (this._width = wh.width);
          }
          return this._width;
      }
      get height() {
          if (this._handler) {
              const wh = this._handler.getWH();
              return (this._height = wh.height);
          }
          return this._height;
      }
      get dpr() {
          return this._handler.getDpr();
      }
      constructor(global) {
          this.global = global;
          this._uid = Generator.GenAutoIncrementId();
      }
      postInit() {
          this.global.hooks.onSetEnv.tap('window', () => {
              this.active();
          });
          this.active();
      }
      active() {
          const global = this.global;
          if (!global.env || this.actived) {
              return;
          }
          const handler = container.getNamed(WindowHandlerContribution, global.env);
          handler.configure(this, global);
          this.actived = true;
      }
      get style() {
          return this._handler.getStyle();
      }
      set style(style) {
          this._handler.setStyle(style);
      }
      create(params) {
          this._handler.createWindow(params);
          const windowWH = this._handler.getWH();
          this._width = windowWH.width;
          this._height = windowWH.height;
          this.title = this._handler.getTitle();
          this.resizable = true;
      }
      setWindowHandler(handler) {
          this._handler = handler;
      }
      setDpr(dpr) {
          return this._handler.setDpr(dpr);
      }
      resize(w, h) {
          return this._handler.resizeWindow(w, h);
      }
      configure() {
          throw new Error('');
      }
      release() {
          return this._handler.releaseWindow();
      }
      getContext() {
          return this._handler.getContext();
      }
      getNativeHandler() {
          return this._handler.getNativeHandler();
      }
      getImageBuffer(type) {
          if (!this._handler.getImageBuffer) {
              return null;
          }
          return this._handler.getImageBuffer(type);
      }
      addEventListener(type, listener, options) {
          return this._handler.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
          return this._handler.removeEventListener(type, listener, options);
      }
      dispatchEvent(event) {
          return this._handler.dispatchEvent(event);
      }
      getBoundingClientRect() {
          return this._handler.getBoundingClientRect();
      }
      getContainer() {
          return this._handler.container;
      }
      clearViewBox(viewBox, color) {
          this._handler.clearViewBox(viewBox, color);
      }
  };
  __decorate([
      postConstruct(),
      __metadata("design:type", Function),
      __metadata("design:paramtypes", []),
      __metadata("design:returntype", void 0)
  ], exports.DefaultWindow.prototype, "postInit", null);
  exports.DefaultWindow = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultWindow);

  const TransformUtil = Symbol.for('TransformUtil');
  const GraphicUtil = Symbol.for('GraphicUtil');
  const LayerService = Symbol.for('LayerService');

  var coreModule = new ContainerModule(bind => {
      bind(exports.DefaultGlobal).toSelf().inSingletonScope();
      bind(Global).toService(exports.DefaultGlobal);
      bind(exports.DefaultWindow).to(exports.DefaultWindow);
      bind(Window).toService(exports.DefaultWindow);
      bind(exports.DefaultGraphicUtil).toSelf().inSingletonScope();
      bind(GraphicUtil).toService(exports.DefaultGraphicUtil);
      bind(exports.DefaultTransformUtil).toSelf().inSingletonScope();
      bind(TransformUtil).toService(exports.DefaultTransformUtil);
      bind(exports.DefaultLayerService).toSelf().inSingletonScope();
      bind(LayerService).toService(exports.DefaultLayerService);
  });

  function runFill(fill) {
      return !!fill;
  }
  function runStroke(stroke, lineWidth) {
      let s;
      if (isArray(stroke)) {
          s = stroke.some(item => item || item === undefined);
      }
      else {
          s = !!stroke;
      }
      return s && lineWidth > 0;
  }
  function fillVisible(opacity, fillOpacity) {
      return opacity * fillOpacity > 0;
  }
  function rectFillVisible(opacity, fillOpacity, width, height) {
      return opacity * fillOpacity > 0 && width > 0 && height > 0;
  }
  function strokeVisible(opacity, strokeOpacity) {
      return opacity * strokeOpacity > 0;
  }
  function rectStrokeVisible(opacity, strokeOpacity, width, height) {
      return opacity * strokeOpacity > 0 && width > 0 && height > 0;
  }
  function drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
      if (!graphic.pathProxy) {
          return false;
      }
      const themeAttributes = getTheme(graphic, params?.theme)[graphic.type];
      const { fill = themeAttributes.fill, stroke = themeAttributes.stroke, opacity = themeAttributes.opacity, fillOpacity = themeAttributes.fillOpacity, lineWidth = themeAttributes.lineWidth, strokeOpacity = themeAttributes.strokeOpacity, visible = themeAttributes.visible } = graphic.attribute;
      const fVisible = fillVisible(opacity, fillOpacity);
      const sVisible = strokeVisible(opacity, strokeOpacity);
      const doFill = runFill(fill);
      const doStroke = runStroke(stroke, lineWidth);
      if (!visible) {
          return true;
      }
      if (!(doFill || doStroke)) {
          return true;
      }
      if (!(fVisible || sVisible || fillCb || strokeCb)) {
          return true;
      }
      context.beginPath();
      const path = typeof graphic.pathProxy === 'function' ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
      renderCommandList(path.commandList, context, x, y);
      context.setShadowStyle && context.setShadowStyle(graphic, graphic.attribute, themeAttributes);
      if (doStroke) {
          if (strokeCb) {
              strokeCb(context, graphic.attribute, themeAttributes);
          }
          else if (sVisible) {
              context.setStrokeStyle(graphic, graphic.attribute, x, y, themeAttributes);
              context.stroke();
          }
      }
      if (doFill) {
          if (fillCb) {
              fillCb(context, graphic.attribute, themeAttributes);
          }
          else if (fVisible) {
              context.setCommonStyle(graphic, graphic.attribute, x, y, themeAttributes);
              context.fill();
          }
      }
      return true;
  }
  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      const x10 = x1 - x0;
      const y10 = y1 - y0;
      const x32 = x3 - x2;
      const y32 = y3 - y2;
      let t = y32 * x10 - x32 * y10;
      if (t * t < epsilon) {
          return [];
      }
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
  }
  function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
      const x01 = x0 - x1;
      const y01 = y0 - y1;
      const lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01);
      const ox = lo * y01;
      const oy = -lo * x01;
      const x11 = x0 + ox;
      const y11 = y0 + oy;
      const x10 = x1 + ox;
      const y10 = y1 + oy;
      const x00 = (x11 + x10) / 2;
      const y00 = (y11 + y10) / 2;
      const dx = x10 - x11;
      const dy = y10 - y11;
      const d2 = dx * dx + dy * dy;
      const r = r1 - rc;
      const D = x11 * y10 - x10 * y11;
      const d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
      let cx0 = (D * dy - dx * d) / d2;
      let cy0 = (-D * dx - dy * d) / d2;
      const cx1 = (D * dy + dx * d) / d2;
      const cy1 = (-D * dx + dy * d) / d2;
      const dx0 = cx0 - x00;
      const dy0 = cy0 - y00;
      const dx1 = cx1 - x00;
      const dy1 = cy1 - y00;
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
          (cx0 = cx1), (cy0 = cy1);
      }
      return {
          cx: cx0,
          cy: cy0,
          x01: -ox,
          y01: -oy,
          x11: cx0 * (r1 / r - 1),
          y11: cy0 * (r1 / r - 1)
      };
  }
  function drawArcPath$1(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
      const { startAngle, endAngle } = arc.getParsedAngle();
      const deltaAngle = abs(endAngle - startAngle);
      const clockwise = endAngle > startAngle;
      let collapsedToLine = false;
      if (outerRadius < innerRadius) {
          const temp = outerRadius;
          outerRadius = innerRadius;
          innerRadius = temp;
      }
      if (outerRadius <= epsilon) {
          context.moveTo(cx, cy);
      }
      else if (deltaAngle >= pi2 - epsilon) {
          context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle));
          context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise);
          if (innerRadius > epsilon) {
              context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle));
              context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
          }
      }
      else {
          const cornerRadius = arc.getParsedCornerRadius();
          const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
          const outerCornerRadiusStart = cornerRadius;
          const outerCornerRadiusEnd = cornerRadius;
          const innerCornerRadiusEnd = cornerRadius;
          const innerCornerRadiusStart = cornerRadius;
          const maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart);
          const maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
          let limitedOcr = maxOuterCornerRadius;
          let limitedIcr = maxInnerCornerRadius;
          const xors = outerRadius * cos(outerStartAngle);
          const yors = outerRadius * sin(outerStartAngle);
          const xire = innerRadius * cos(innerEndAngle);
          const yire = innerRadius * sin(innerEndAngle);
          let xore;
          let yore;
          let xirs;
          let yirs;
          if (maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) {
              xore = outerRadius * cos(outerEndAngle);
              yore = outerRadius * sin(outerEndAngle);
              xirs = innerRadius * cos(innerStartAngle);
              yirs = innerRadius * sin(innerStartAngle);
              if (deltaAngle < pi) {
                  const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
                  if (oc) {
                      const ax = xors - oc[0];
                      const ay = yors - oc[1];
                      const bx = xore - oc[0];
                      const by = yore - oc[1];
                      const kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2);
                      const lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                      limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1));
                      limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
                  }
              }
          }
          if (outerDeltaAngle < 0.001) {
              if (partStroke && (partStroke[3] || partStroke[1])) {
                  context.moveTo(cx + xors, cy + yors);
              }
              collapsedToLine = true;
          }
          else if (limitedOcr > epsilon) {
              const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr);
              const cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr);
              const t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise));
              const t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
              if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                  if (!partStroke || partStroke[0]) {
                      context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
                      context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);
                  }
                  else {
                      context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01)));
                  }
              }
              else {
                  if (!partStroke || partStroke[0]) {
                      context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
                      cornerRadiusStart > 0 &&
                          context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
                      context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise);
                      cornerRadiusEnd > 0 &&
                          context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
                  }
                  else {
                      if (cornerRadiusEnd > 0) {
                          context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01)));
                      }
                      else {
                          context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
                      }
                  }
              }
          }
          else {
              if (!partStroke || partStroke[0]) {
                  context.moveTo(cx + xors, cy + yors);
                  context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise);
              }
          }
          if (!(innerRadius > epsilon) || innerDeltaAngle < 0.001) {
              if (!partStroke || partStroke[1]) {
                  context.lineTo(cx + xire, cy + yire);
              }
              else {
                  context.moveTo(cx + xire, cy + yire);
              }
              collapsedToLine = true;
          }
          else if (limitedIcr > epsilon) {
              const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr);
              const cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr);
              const t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise));
              const t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
              if (!partStroke || partStroke[1]) {
                  context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
              }
              else {
                  context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
              }
              if (limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                  const arcEndAngle = atan2(t1.y01, t1.x01);
                  if (!partStroke || partStroke[2]) {
                      context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
                  }
                  else {
                      context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
                  }
              }
              else {
                  if (!partStroke || partStroke[2]) {
                      cornerRadiusEnd > 0 &&
                          context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
                      context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise);
                      cornerRadiusStart > 0 &&
                          context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
                  }
                  else {
                      if (cornerRadiusStart > 0) {
                          context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01)));
                      }
                      else {
                          context.moveTo(cx + xirs, cy + yirs);
                      }
                  }
              }
          }
          else {
              if (!partStroke || partStroke[1]) {
                  context.lineTo(cx + xire, cy + yire);
              }
              else {
                  context.moveTo(cx + xire, cy + yire);
              }
              if (!partStroke || partStroke[2]) {
                  context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise);
              }
              else {
                  context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
              }
          }
      }
      if (!partStroke) {
          context.closePath();
      }
      else if (partStroke[3]) {
          context.lineTo(cx + outerRadius * cos(endAngle), cy + outerRadius * cos(endAngle));
      }
      return collapsedToLine;
  }

  class ConicalCanvas {
      static canvas;
      static ctx;
      static GetCanvas() {
          try {
              if (!ConicalCanvas.canvas) {
                  ConicalCanvas.canvas = application.global.createCanvas({});
              }
              return ConicalCanvas.canvas;
          }
          catch (err) {
              return null;
          }
      }
      static GetCtx() {
          if (!ConicalCanvas.ctx) {
              const conicalCanvas = ConicalCanvas.GetCanvas();
              ConicalCanvas.ctx = conicalCanvas.getContext('2d');
          }
          return ConicalCanvas.ctx;
      }
  }
  class ColorInterpolate {
      rgbaSet;
      constructor(stops = [], precision = 100) {
          const canvas = ConicalCanvas.GetCanvas();
          const conicalCtx = ConicalCanvas.GetCtx();
          canvas.width = precision;
          canvas.height = 1;
          if (!conicalCtx) {
              return;
          }
          conicalCtx.translate(0, 0);
          if (!conicalCtx) {
              throw new Error('ctx');
          }
          const gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);
          stops.forEach(stop => {
              gradient.addColorStop(stop[0], stop[1]);
          });
          conicalCtx.fillStyle = gradient;
          conicalCtx.fillRect(0, 0, precision, 1);
          this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;
      }
      getColor(offset) {
          const rgba = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
          return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3] / 255})`;
      }
      static dataMap = new Map();
      static GetOrCreate(stops = [], precision = 100) {
          let str = '';
          stops.forEach(item => (str += item.join()));
          str += precision;
          let colorInter = ColorInterpolate.dataMap.get(str);
          if (!colorInter) {
              colorInter = new ColorInterpolate(stops, precision);
              ColorInterpolate.dataMap.set(str, colorInter);
          }
          return colorInter;
      }
      static SetColorInterpolateInstance(stops, ins) {
          ColorInterpolate.dataMap.set(stops, ins);
      }
      static GetColorInterpolateInstance(stops) {
          return ColorInterpolate.dataMap.get(stops);
      }
  }
  class ConicalPatternStore {
      static cache = {};
      static ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560];
      static GetSize(minSize) {
          for (let i = 0; i < ConicalPatternStore.ImageSize.length; i++) {
              if (ConicalPatternStore.ImageSize[i] >= minSize) {
                  return ConicalPatternStore.ImageSize[i];
              }
          }
          return minSize;
      }
      static Get(stops, x, y, startAngle, endAngle, w, h) {
          const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
          const data = ConicalPatternStore.cache[key];
          if (!data || data.length === 0) {
              return null;
          }
          for (let i = 0; i < data.length; i++) {
              if (data[i].width >= w && data[i].height >= h) {
                  return data[i].pattern;
              }
          }
          return null;
      }
      static Set(stops, x, y, startAngle, endAngle, pattern, w, h) {
          const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
          if (!ConicalPatternStore.cache[key]) {
              ConicalPatternStore.cache[key] = [
                  {
                      width: w,
                      height: h,
                      pattern
                  }
              ];
          }
          else {
              ConicalPatternStore.cache[key].push({
                  width: w,
                  height: h,
                  pattern
              });
          }
      }
      static GenKey(stops, x, y, startAngle, endAngle) {
          return `${x},${y},${startAngle},${endAngle},${stops.join()}`;
      }
  }
  function getConicGradientAt(x, y, angle, color) {
      const { stops, startAngle, endAngle } = color;
      while (angle < 0) {
          angle += pi2;
      }
      while (angle > pi2) {
          angle -= pi2;
      }
      if (angle < startAngle) {
          return stops[0].color;
      }
      if (angle > endAngle) {
          return stops[0].color;
      }
      let percent = (angle - startAngle) / (endAngle - startAngle);
      let startStop;
      let endStop;
      for (let i = 0; i < stops.length; i++) {
          if (stops[i].offset >= percent) {
              startStop = stops[i - 1];
              endStop = stops[i];
              break;
          }
      }
      percent = (percent - startStop.offset) / (endStop.offset - startStop.offset);
      return interpolateColor(startStop.color, endStop.color, percent, false);
  }
  function createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {
      const deltaDeg = Math.floor((deltaAngle * 180) / Math.PI);
      const conicalCanvas = ConicalCanvas.GetCanvas();
      const conicalCtx = ConicalCanvas.GetCtx();
      if (!conicalCtx) {
          return null;
      }
      const width = ConicalPatternStore.GetSize(minW);
      const height = ConicalPatternStore.GetSize(minH);
      let pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);
      if (pattern) {
          return pattern;
      }
      const r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2))));
      const stepNum = deltaDeg + 1;
      const step = deltaAngle / Math.max(1, stepNum - 1);
      const colorInter = ColorInterpolate.GetOrCreate(stops, stepNum);
      const lineWidth = (2 * Math.PI * r) / 360;
      conicalCanvas.width = width;
      conicalCanvas.height = height;
      conicalCtx.setTransform(1, 0, 0, 1, 0, 0);
      conicalCtx.clearRect(0, 0, width, height);
      conicalCtx.translate(x, y);
      conicalCtx.rotate(startAngle);
      for (let i = 0, len = stepNum - 1; i < len; i++) {
          if (startAngle + i * step > endAngle) {
              break;
          }
          const color = colorInter.getColor(i);
          conicalCtx.beginPath();
          conicalCtx.rotate(step);
          conicalCtx.moveTo(0, 0);
          conicalCtx.lineTo(r, -2 * lineWidth);
          conicalCtx.lineTo(r, 0);
          conicalCtx.fillStyle = color;
          conicalCtx.closePath();
          conicalCtx.fill();
      }
      const imageData = conicalCtx.getImageData(0, 0, width, height);
      conicalCanvas.width = imageData.width;
      conicalCanvas.height = imageData.height;
      conicalCtx.putImageData(imageData, 0, 0);
      pattern = context.createPattern(conicalCanvas, 'no-repeat');
      pattern && ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height);
      return pattern;
  }

  function getScaledStroke(context, width, dpr) {
      let strokeWidth = width;
      const { a, b, c, d } = context.currentMatrix;
      const scaleX = Math.sign(a) * Math.sqrt(a * a + b * b);
      const scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
      if (scaleX + scaleY === 0) {
          return 0;
      }
      strokeWidth = (strokeWidth / Math.abs(scaleX + scaleY)) * 2 * dpr;
      return strokeWidth;
  }
  function createColor(context, c, params, offsetX, offsetY) {
      if (!c || c === true) {
          return 'black';
      }
      let result;
      let color;
      if (isArray(c)) {
          for (let i = 0; i < c.length; i++) {
              color = c[i];
              if (color) {
                  break;
              }
          }
      }
      else {
          color = c;
      }
      if (typeof color === 'string') {
          return color;
      }
      if (color.gradient === 'linear') {
          result = createLinearGradient(context, color, params, offsetX, offsetY);
      }
      else if (color.gradient === 'conical') {
          result = createConicGradient(context, color, params, offsetX, offsetY);
      }
      else if (color.gradient === 'radial') {
          result = createRadialGradient(context, color, params, offsetX, offsetY);
      }
      return result || 'orange';
  }
  function createLinearGradient(context, color, params, offsetX = 0, offsetY = 0) {
      const bounds = params.AABBBounds;
      if (!bounds) {
          return;
      }
      let w = bounds.x2 - bounds.x1;
      let h = bounds.y2 - bounds.y1;
      let x = bounds.x1 - offsetX;
      let y = bounds.y1 - offsetY;
      if (params.attribute) {
          const { scaleX = 1, scaleY = 1 } = params.attribute;
          if (scaleX * scaleY === 0) {
              return;
          }
          w /= scaleX;
          h /= scaleY;
          x /= scaleX;
          y /= scaleY;
      }
      const canvasGradient = context.createLinearGradient(x + (color.x0 ?? 0) * w, y + (color.y0 ?? 0) * h, x + (color.x1 ?? 1) * w, y + (color.y1 ?? 0) * h);
      color.stops.forEach(stop => {
          canvasGradient.addColorStop(stop.offset, stop.color);
      });
      return canvasGradient;
  }
  function createRadialGradient(context, color, params, offsetX = 0, offsetY = 0) {
      const bounds = params.AABBBounds;
      if (!bounds) {
          return;
      }
      let w = bounds.x2 - bounds.x1;
      let h = bounds.y2 - bounds.y1;
      let x = bounds.x1 - offsetX;
      let y = bounds.y1 - offsetY;
      if (params.attribute) {
          const { scaleX = 1, scaleY = 1 } = params.attribute;
          if (scaleX * scaleY === 0) {
              return;
          }
          x /= scaleX;
          y /= scaleY;
          w /= scaleX;
          h /= scaleY;
      }
      const canvasGradient = context.createRadialGradient(x + (color.x0 ?? 0.5) * w, y + (color.y0 ?? 0.5) * h, Math.max(w, h) * (color.r0 ?? 0), x + (color.x1 ?? 0.5) * w, y + (color.y1 ?? 0.5) * h, Math.max(w, h) * (color.r1 ?? 0.5));
      color.stops.forEach(stop => {
          canvasGradient.addColorStop(stop.offset, stop.color);
      });
      return canvasGradient;
  }
  function createConicGradient(context, color, params, offsetX = 0, offsetY = 0) {
      const bounds = params.AABBBounds;
      if (!bounds) {
          return;
      }
      let w = bounds.x2 - bounds.x1;
      let h = bounds.y2 - bounds.y1;
      let x = bounds.x1 - offsetX;
      let y = bounds.y1 - offsetY;
      if (params.attribute) {
          const { scaleX = 1, scaleY = 1 } = params.attribute;
          if (scaleX * scaleY === 0) {
              return;
          }
          w /= scaleX;
          h /= scaleY;
          x /= scaleX;
          y /= scaleY;
      }
      const canvasGradient = context.createConicGradient(x + (color.x ?? 0) * w, y + (color.y ?? 0) * h, color.startAngle, color.endAngle);
      color.stops.forEach(stop => {
          canvasGradient.addColorStop(stop.offset, stop.color);
      });
      let deltaAngle;
      return canvasGradient.GetPattern(w + x, h + y, deltaAngle);
  }

  const CIRCLE_UPDATE_TAG_KEY = ['radius', 'startAngle', 'endAngle', ...GRAPHIC_UPDATE_TAG_KEY];
  class Circle extends Graphic {
      type = 'circle';
      constructor(params = { radius: 1 }) {
          super(params);
          this.numberType = CIRCLE_NUMBER_TYPE;
      }
      isValid() {
          return super.isValid() && this._isValid();
      }
      _isValid() {
          const { startAngle, endAngle, radius } = this.attribute;
          return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
      }
      doUpdateAABBBounds(full) {
          const circleTheme = getTheme(this).circle;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateCircleAABBBounds(attribute, getTheme(this).circle, this._AABBBounds, full, this);
          const { boundsPadding = circleTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      getDefaultAttribute(name) {
          const circleTheme = getTheme(this).circle;
          return circleTheme[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < CIRCLE_UPDATE_TAG_KEY.length; i++) {
              const attrKey = CIRCLE_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < CIRCLE_UPDATE_TAG_KEY.length; i++) {
              const attrKey = CIRCLE_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      toCustomPath() {
          const x = 0;
          const y = 0;
          const attribute = this.attribute;
          const radius = attribute.radius ?? this.getDefaultAttribute('radius');
          const startAngle = attribute.startAngle ?? this.getDefaultAttribute('startAngle');
          const endAngle = attribute.endAngle ?? this.getDefaultAttribute('endAngle');
          const path = new CustomPath2D();
          path.arc(x, y, radius, startAngle, endAngle);
          return path;
      }
      clone() {
          return new Circle({ ...this.attribute });
      }
  }

  function getContextFont(text, defaultAttr = {}, fontSizeScale) {
      if (!fontSizeScale) {
          fontSizeScale = 1;
      }
      const { fontStyle = defaultAttr.fontStyle, fontVariant = defaultAttr.fontVariant, fontWeight = defaultAttr.fontWeight, fontSize = defaultAttr.fontSize, fontFamily = defaultAttr.fontFamily } = text;
      return ('' +
          (fontStyle ? fontStyle + ' ' : '') +
          (fontVariant ? fontVariant + ' ' : '') +
          (fontWeight ? fontWeight + ' ' : '') +
          fontSize * fontSizeScale +
          'px ' +
          (fontFamily ? fontFamily : 'sans-serif'));
  }
  function textDrawOffsetY(baseline, h) {
      const offset = baseline === 'top'
          ? Math.ceil(0.79 * h)
          : baseline === 'middle'
              ? Math.round(0.3 * h)
              : baseline === 'bottom'
                  ? Math.round(-0.21 * h)
                  : 0;
      return offset;
  }
  function textDrawOffsetX(textAlign, width) {
      if (textAlign === 'end' || textAlign === 'right') {
          return -width;
      }
      else if (textAlign === 'center') {
          return -width / 2;
      }
      return 0;
  }
  function textLayoutOffsetY(baseline, lineHeight, fontSize) {
      if (baseline === 'middle') {
          return -lineHeight / 2;
      }
      if (baseline === 'top') {
          return 0;
      }
      if (baseline === 'bottom') {
          return -lineHeight;
      }
      if (!baseline || baseline === 'alphabetic') {
          if (!fontSize) {
              fontSize = lineHeight;
          }
          return -(lineHeight - fontSize) / 2 - 0.79 * fontSize;
      }
      return 0;
  }

  class CanvasTextLayout {
      fontFamily;
      textOptions;
      textMeasure;
      constructor(fontFamily, options, textMeasure) {
          this.fontFamily = fontFamily;
          this.textOptions = options;
          this.textMeasure = textMeasure;
      }
      LayoutBBox(bbox, textAlign, textBaseline) {
          if (textAlign === 'left' || textAlign === 'start') {
              bbox.xOffset = 0;
          }
          else if (textAlign === 'center') {
              bbox.xOffset = bbox.width / -2;
          }
          else if (textAlign === 'right' || textAlign === 'end') {
              bbox.xOffset = -bbox.width;
          }
          else {
              throw new Error('textAlign');
          }
          if (textBaseline === 'top') {
              bbox.yOffset = 0;
          }
          else if (textBaseline === 'middle') {
              bbox.yOffset = bbox.height / -2;
          }
          else if (textBaseline === 'alphabetic') {
              bbox.yOffset = bbox.height * -0.79;
          }
          else {
              bbox.yOffset = -bbox.height;
          }
          return bbox;
      }
      GetLayout(str, width, height, textAlign, textBaseline, lineHeight, suffix, miniApp) {
          const linesLayout = [];
          const bboxWH = [width, height];
          const bboxOffset = [0, 0];
          while (str.length > 0) {
              const { str: clipText } = this.textMeasure.clipTextWithSuffix(str, this.textOptions, width, suffix);
              linesLayout.push({
                  str: clipText,
                  width: this.textMeasure.measureTextWidth(clipText, this.textOptions)
              });
              str = str.substring(clipText.length);
          }
          if (textAlign === 'left' || textAlign === 'start') ;
          else if (textAlign === 'center') {
              bboxOffset[0] = bboxWH[0] / -2;
          }
          else if (textAlign === 'right' || textAlign === 'end') {
              bboxOffset[0] = -bboxWH[0];
          }
          if (textBaseline === 'top') ;
          else if (textBaseline === 'middle') {
              bboxOffset[1] = bboxWH[1] / -2;
          }
          else if (textBaseline === 'bottom') {
              bboxOffset[1] = -bboxWH[1];
          }
          const bbox = {
              xOffset: bboxOffset[0],
              yOffset: bboxOffset[1],
              width: bboxWH[0],
              height: bboxWH[1]
          };
          return this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
      }
      GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = '', lineWidth) {
          lines = lines.map(l => l.toString());
          const linesLayout = [];
          const bboxWH = [0, 0];
          if (typeof lineWidth === 'number' && lineWidth !== Infinity) {
              let width;
              for (let i = 0, len = lines.length; i < len; i++) {
                  width = Math.min(this.textMeasure.measureTextWidth(lines[i], this.textOptions), lineWidth);
                  linesLayout.push({
                      str: this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, width, suffix).str,
                      width
                  });
              }
              bboxWH[0] = lineWidth;
          }
          else {
              lineWidth = 0;
              let width;
              let text;
              for (let i = 0, len = lines.length; i < len; i++) {
                  text = lines[i];
                  width = this.textMeasure.measureTextWidth(text, this.textOptions);
                  lineWidth = Math.max(lineWidth, width);
                  linesLayout.push({ str: text, width });
              }
              bboxWH[0] = lineWidth;
          }
          bboxWH[1] = linesLayout.length * lineHeight;
          const bbox = {
              xOffset: 0,
              yOffset: 0,
              width: bboxWH[0],
              height: bboxWH[1]
          };
          this.LayoutBBox(bbox, textAlign, textBaseline);
          return this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
      }
      layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
          const origin = [0, 0];
          const totalLineHeight = lines.length * lineHeight;
          if (textBaseline === 'top') ;
          else if (textBaseline === 'middle') {
              origin[1] = (bbox.height - totalLineHeight) / 2;
          }
          else if (textBaseline === 'bottom') {
              origin[1] = bbox.height - totalLineHeight;
          }
          for (let i = 0; i < lines.length; i++) {
              this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
          }
          return {
              bbox,
              lines,
              fontFamily: this.fontFamily,
              fontSize: this.textOptions.fontSize,
              fontWeight: this.textOptions.fontWeight,
              lineHeight,
              textAlign,
              textBaseline
          };
      }
      lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
          if (textAlign === 'left' || textAlign === 'start') {
              line.leftOffset = 0;
          }
          else if (textAlign === 'center') {
              line.leftOffset = (bbox.width - line.width) / 2;
          }
          else if (textAlign === 'right' || textAlign === 'end') {
              line.leftOffset = bbox.width - line.width;
          }
          line.topOffset = (lineHeight - this.textOptions.fontSize) / 2 + this.textOptions.fontSize * 0.79 + origin[1];
          origin[1] += lineHeight;
          return line;
      }
  }

  const TEXT_UPDATE_TAG_KEY = [
      'text',
      'maxLineWidth',
      'fontSize',
      'fontFamily',
      'fontWeight',
      'ellipsis',
      'lineHeight',
      ...GRAPHIC_UPDATE_TAG_KEY
  ];
  class Text extends Graphic {
      type = 'text';
      cache;
      _font;
      get font() {
          const textTheme = getTheme(this).text;
          if (!this._font) {
              this._font = getContextFont(this.attribute, textTheme);
          }
          return this._font;
      }
      get clipedText() {
          const attribute = this.attribute;
          const textTheme = getTheme(this).text;
          if (Array.isArray(attribute.text)) {
              return undefined;
          }
          const { maxLineWidth = textTheme.maxLineWidth } = attribute;
          if (!Number.isFinite(maxLineWidth)) {
              return (attribute.text ?? textTheme.text).toString();
          }
          this.tryUpdateAABBBounds();
          return this.cache.clipedText;
      }
      get clipedWidth() {
          if (Array.isArray(this.attribute.text)) {
              return undefined;
          }
          this.tryUpdateAABBBounds();
          return this.cache.clipedWidth;
      }
      get cliped() {
          const textTheme = getTheme(this).text;
          const attribute = this.attribute;
          if (Array.isArray(attribute.text)) {
              return undefined;
          }
          const { maxLineWidth = textTheme.maxLineWidth } = attribute;
          if (!Number.isFinite(maxLineWidth)) {
              return false;
          }
          this.tryUpdateAABBBounds();
          return this.clipedText === attribute.text;
      }
      get multilineLayout() {
          if (!Array.isArray(this.attribute.text)) {
              return undefined;
          }
          this.tryUpdateAABBBounds();
          return this.cache.layoutData;
      }
      constructor(params = { text: '', fontSize: 16 }) {
          super(params);
          this.numberType = TEXT_NUMBER_TYPE;
          this.cache = {};
      }
      isValid() {
          return super.isValid() && this._isValid();
      }
      _isValid() {
          const { text } = this.attribute;
          return text != null && text !== '';
      }
      doUpdateAABBBounds() {
          const textTheme = getTheme(this).text;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateTextAABBBounds(attribute, textTheme, this._AABBBounds, this);
          const { boundsPadding = textTheme.boundsPadding } = this.attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      updateSingallineAABBBounds(text) {
          const textTheme = getTheme(this).text;
          const textMeasure = application.graphicUtil.textMeasure;
          let width;
          let str;
          const buf = 2;
          const attribute = this.attribute;
          const { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, stroke = textTheme.stroke, lineHeight = attribute.lineHeight ?? (attribute.fontSize || textTheme.fontSize) + buf, lineWidth = textTheme.lineWidth } = attribute;
          if (!this.shouldUpdateShape() && this.cache) {
              width = this.cache.clipedWidth;
              const dx = textDrawOffsetX(textAlign, width);
              const dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
              this._AABBBounds.set(dx, dy, dx + width, dy + lineHeight);
              if (stroke) {
                  this._AABBBounds.expand(lineWidth / 2);
              }
              return this._AABBBounds;
          }
          if (Number.isFinite(maxLineWidth)) {
              if (ellipsis) {
                  const strEllipsis = (ellipsis === true ? textTheme.ellipsis : ellipsis);
                  const data = textMeasure.clipTextWithSuffix(text.toString(), { fontSize }, maxLineWidth, strEllipsis);
                  str = data.str;
                  width = data.width;
              }
              else {
                  const data = textMeasure.clipText(text.toString(), { fontSize }, maxLineWidth);
                  str = data.str;
                  width = data.width;
              }
              this.cache.clipedText = str;
              this.cache.clipedWidth = width;
          }
          else {
              width = textMeasure.measureTextWidth(text.toString(), { fontSize });
              this.cache.clipedText = text.toString();
              this.cache.clipedWidth = width;
          }
          this.clearUpdateShapeTag();
          const dx = textDrawOffsetX(textAlign, width);
          const dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
          this._AABBBounds.set(dx, dy, dx + width, dy + lineHeight);
          if (stroke) {
              this._AABBBounds.expand(lineWidth / 2);
          }
          return this._AABBBounds;
      }
      updateMultilineAABBBounds(text) {
          const textTheme = getTheme(this).text;
          const attribute = this.attribute;
          const { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, lineHeight = attribute.lineHeight || attribute.fontSize || textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke = textTheme.stroke, lineWidth = textTheme.lineWidth } = attribute;
          if (!this.shouldUpdateShape() && this.cache?.layoutData) {
              const bbox = this.cache.layoutData.bbox;
              this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
              if (stroke) {
                  this._AABBBounds.expand(lineWidth / 2);
              }
              return this._AABBBounds;
          }
          const textMeasure = application.graphicUtil.textMeasure;
          const layoutObj = new CanvasTextLayout(fontFamily, { fontSize }, textMeasure);
          const layoutData = layoutObj.GetLayoutByLines(text, textAlign, textBaseline, lineHeight, ellipsis === true ? textTheme.ellipsis : ellipsis || undefined, maxLineWidth);
          const { bbox } = layoutData;
          this.cache.layoutData = layoutData;
          this.clearUpdateShapeTag();
          this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
          if (stroke) {
              this._AABBBounds.expand(lineWidth / 2);
          }
          return this._AABBBounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      getDefaultAttribute(name) {
          const textTheme = getTheme(this).text;
          return textTheme[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < TEXT_UPDATE_TAG_KEY.length; i++) {
              const attrKey = TEXT_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < TEXT_UPDATE_TAG_KEY.length; i++) {
              const attrKey = TEXT_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      clone() {
          return new Text({ ...this.attribute });
      }
  }

  function circle(ctx, r, x, y, z) {
      if (z) {
          ctx.arc(x, y, r, 0, tau, false, z);
      }
      else {
          ctx.arc(x, y, r, 0, tau);
      }
      return false;
  }
  class CircleSymbol {
      type = 'circle';
      pathStr = 'M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0';
      draw(ctx, size, x, y, z) {
          const r = size / 2;
          return circle(ctx, r, x, y, z);
      }
      drawOffset(ctx, size, x, y, offset, z) {
          const r = size / 2 + offset;
          return circle(ctx, r, x, y, z);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var circle$1 = new CircleSymbol();

  function cross(ctx, r, x, y, z) {
      ctx.moveTo(-3 * r + x, -r + y, z);
      ctx.lineTo(-r + x, -r + y, z);
      ctx.lineTo(-r + x, -3 * r + y, z);
      ctx.lineTo(r + x, -3 * r + y, z);
      ctx.lineTo(r + x, -r + y, z);
      ctx.lineTo(3 * r + x, -r + y, z);
      ctx.lineTo(3 * r + x, r + y, z);
      ctx.lineTo(r + x, r + y, z);
      ctx.lineTo(r + x, 3 * r + y, z);
      ctx.lineTo(-r + x, 3 * r + y, z);
      ctx.lineTo(-r + x, r + y, z);
      ctx.lineTo(-3 * r + x, r + y, z);
      ctx.closePath();
      return true;
  }
  function crossOffset(ctx, r, x, y, offset, z) {
      ctx.moveTo(-3 * r + x - offset, -r + y - offset, z);
      ctx.lineTo(-r + x - offset, -r + y - offset, z);
      ctx.lineTo(-r + x - offset, -3 * r + y - offset, z);
      ctx.lineTo(r + x + offset, -3 * r + y - offset, z);
      ctx.lineTo(r + x + offset, -r + y - offset, z);
      ctx.lineTo(3 * r + x + offset, -r + y - offset, z);
      ctx.lineTo(3 * r + x + offset, r + y + offset, z);
      ctx.lineTo(r + x + offset, r + y + offset, z);
      ctx.lineTo(r + x + offset, 3 * r + y + offset, z);
      ctx.lineTo(-r + x - offset, 3 * r + y + offset, z);
      ctx.lineTo(-r + x - offset, r + y + offset, z);
      ctx.lineTo(-3 * r + x - offset, r + y + offset, z);
      ctx.closePath();
      return true;
  }
  class CrossSymbol {
      type = 'cross';
      pathStr = 'M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z';
      draw(ctx, size, x, y, z) {
          const r = size / 6;
          return cross(ctx, r, x, y, z);
      }
      drawOffset(ctx, size, x, y, offset, z) {
          const r = size / 6;
          return crossOffset(ctx, r, x, y, offset, z);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var cross$1 = new CrossSymbol();

  function diamond(ctx, r, x, y, z) {
      ctx.moveTo(x, y - r, z);
      ctx.lineTo(r + x, y, z);
      ctx.lineTo(x, y + r, z);
      ctx.lineTo(x - r, y, z);
      ctx.closePath();
      return true;
  }
  class DiamondSymbol {
      type = 'diamond';
      pathStr = 'M-0.5,0L0,-0.5L0.5,0L0,0.5Z';
      draw(ctx, size, x, y, z) {
          const r = size / 2;
          return diamond(ctx, r, x, y, z);
      }
      drawFitDir(ctx, size, x, y, z) {
          const r = size / 2;
          return diamond(ctx, r, x, y, z);
      }
      drawOffset(ctx, size, x, y, offset, z) {
          const r = size / 2 + offset;
          return diamond(ctx, r, x, y, z);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var diamond$1 = new DiamondSymbol();

  function square(ctx, r, x, y) {
      const wh = r * 2;
      ctx.rect(x - r, y - r, wh, wh);
      return false;
  }
  class SquareSymbol {
      type = 'square';
      pathStr = 'M-0.5,-0.5h1v1h-1Z';
      draw(ctx, size, x, y) {
          const r = size / 2;
          return square(ctx, r, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
          const r = size / 2 + offset;
          return square(ctx, r, x, y);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var square$1 = new SquareSymbol();

  function trianglUp(ctx, r, x, y) {
      ctx.moveTo(x + r, r + y);
      ctx.lineTo(x - r, r + y);
      ctx.lineTo(x, y - r);
      ctx.closePath();
      return true;
  }
  function trianglUpOffset(ctx, r, x, y, offset) {
      ctx.moveTo(x + r + offset * 2, r + y + offset);
      ctx.lineTo(x - r - offset * 2, r + y + offset);
      ctx.lineTo(x, y - r - offset * 2);
      ctx.closePath();
      return true;
  }
  class TriangleUpSymbol {
      type = 'triangleUp';
      pathStr = 'M0.5,0.5 L-0.5,0.5 L0,-0.5 Z';
      draw(ctx, size, x, y) {
          const r = size / 2;
          return trianglUp(ctx, r, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
          const r = size / 2;
          return trianglUpOffset(ctx, r, x, y, offset);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var triangleUp = new TriangleUpSymbol();

  class TriangleSymbol extends TriangleUpSymbol {
      type = 'triangle';
  }
  var triangle = new TriangleSymbol();

  const kr = Math.sin(Math.PI / 10) / Math.sin((7 * Math.PI) / 10);
  const kx = Math.sin(tau / 10) * kr;
  const ky = -Math.cos(tau / 10) * kr;
  function star(ctx, r, transX, transY) {
      const x = kx * r;
      const y = ky * r;
      ctx.moveTo(transX, -r + transY);
      ctx.lineTo(x + transX, y + transY);
      for (let i = 1; i < 5; ++i) {
          const a = (tau * i) / 5;
          const c = Math.cos(a);
          const s = Math.sin(a);
          ctx.lineTo(s * r + transX, -c * r + transY);
          ctx.lineTo(c * x - s * y + transX, s * x + c * y + transY);
      }
      ctx.closePath();
      return true;
  }
  class StarSymbol {
      type = 'star';
      pathStr = 'M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0';
      draw(ctx, size, transX, transY) {
          const r = size / 2;
          return star(ctx, r, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
          const r = size / 2 + offset;
          return star(ctx, r, transX, transY);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var star$1 = new StarSymbol();

  const sqrt3$1 = sqrt(3);
  function arrow(ctx, r, transX, transY) {
      const triangleH = r;
      const trangleBottomSide = triangleH / sqrt3$1;
      const rectW = trangleBottomSide / 5;
      const rectH = r;
      ctx.moveTo(0 + transX, -triangleH + transY);
      ctx.lineTo(trangleBottomSide / 2 + transX, transY);
      ctx.lineTo(rectW / 2 + transX, transY);
      ctx.lineTo(rectW / 2 + transX, rectH + transY);
      ctx.lineTo(-rectW / 2 + transX, rectH + transY);
      ctx.lineTo(-rectW / 2 + transX, transY);
      ctx.lineTo(-trangleBottomSide / 2 + transX, transY);
      ctx.closePath();
      return true;
  }
  class ArrowSymbol {
      type = 'arrow';
      pathStr = 'M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z';
      draw(ctx, size, transX, transY) {
          const r = size / 2;
          return arrow(ctx, r, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
          const r = size / 2 + offset;
          return arrow(ctx, r, transX, transY);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var arrow$1 = new ArrowSymbol();

  function wedge(ctx, r, transX, transY) {
      const h = r * 2;
      ctx.moveTo(transX, -r + transY);
      ctx.lineTo(h / 3 / 2 + transX, r + transY);
      ctx.lineTo(-h / 3 / 2 + transX, r + transY);
      ctx.closePath();
      return true;
  }
  class WedgeSymbol {
      type = 'wedge';
      pathStr = 'M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z';
      draw(ctx, size, transX, transY) {
          const r = size / 2;
          return wedge(ctx, r, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
          const r = size / 2 + offset;
          return wedge(ctx, r, transX, transY);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var wedge$1 = new WedgeSymbol();

  function stroke(ctx, r, transX, transY) {
      ctx.moveTo(-r + transX, transY);
      ctx.lineTo(transX, r + transY);
      return false;
  }
  class StrokeSymbol {
      type = 'stroke';
      pathStr = '';
      draw(ctx, size, transX, transY) {
          const r = size / 2;
          return stroke(ctx, r, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
          const r = size / 2 + offset;
          return stroke(ctx, r, transX, transY);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var stroke$1 = new StrokeSymbol();

  const c = -0.5;
  const s = sqrt(3) / 2;
  const k = 1 / sqrt(12);
  function wye(ctx, r, transX, transY) {
      const x0 = r / 2;
      const y0 = r * k;
      const x1 = x0;
      const y1 = r * k + r;
      const x2 = -x1;
      const y2 = y1;
      ctx.moveTo(x0 + transX, y0 + transY);
      ctx.lineTo(x1 + transX, y1 + transY);
      ctx.lineTo(x2 + transX, y2 + transY);
      ctx.lineTo(c * x0 - s * y0 + transX, s * x0 + c * y0 + transY);
      ctx.lineTo(c * x1 - s * y1 + transX, s * x1 + c * y1 + transY);
      ctx.lineTo(c * x2 - s * y2 + transX, s * x2 + c * y2 + transY);
      ctx.lineTo(c * x0 + s * y0 + transX, c * y0 - s * x0 + transY);
      ctx.lineTo(c * x1 + s * y1 + transX, c * y1 - s * x1 + transY);
      ctx.lineTo(c * x2 + s * y2 + transX, c * y2 - s * x2 + transY);
      ctx.closePath();
      return false;
  }
  class WyeSymbol {
      type = 'wye';
      pathStr = 'M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0';
      draw(ctx, size, transX, transY) {
          const r = size / 2;
          return wye(ctx, r, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
          const r = size / 2 + offset;
          return wye(ctx, r, transX, transY);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var wye$1 = new WyeSymbol();

  function trianglLeft(ctx, r, x, y) {
      ctx.moveTo(-r + x, y);
      ctx.lineTo(r + x, r + y);
      ctx.lineTo(r + x, y - r);
      ctx.closePath();
      return true;
  }
  function trianglLeftOffset(ctx, r, x, y, offset) {
      ctx.moveTo(-r + x - 2 * offset, y);
      ctx.lineTo(r + x + offset, r + y + 2 * offset);
      ctx.lineTo(r + x + offset, y - r - 2 * offset);
      ctx.closePath();
      return true;
  }
  class TriangleLeftSymbol {
      type = 'triangleLeft';
      pathStr = 'M-0.5,0 L0.5,0.5 L0.5,-0.5 Z';
      draw(ctx, size, x, y) {
          const r = size / 2;
          return trianglLeft(ctx, r, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
          const r = size / 2;
          return trianglLeftOffset(ctx, r, x, y, offset);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var triangleLeft = new TriangleLeftSymbol();

  function trianglRight(ctx, r, x, y) {
      ctx.moveTo(x - r, r + y);
      ctx.lineTo(r + x, y);
      ctx.lineTo(x - r, y - r);
      ctx.closePath();
      return true;
  }
  function trianglRightOffset(ctx, r, x, y, offset) {
      ctx.moveTo(x - r - offset, r + y + 2 * offset);
      ctx.lineTo(r + x + 2 * offset, y);
      ctx.lineTo(x - r - offset, y - r - 2 * offset);
      ctx.closePath();
      return true;
  }
  class TriangleRightSymbol {
      type = 'triangleRight';
      pathStr = 'M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z';
      draw(ctx, size, x, y) {
          const r = size / 2;
          return trianglRight(ctx, r, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
          const r = size / 2;
          return trianglRightOffset(ctx, r, x, y, offset);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var triangleRight = new TriangleRightSymbol();

  function trianglDown(ctx, r, x, y) {
      ctx.moveTo(x - r, y - r);
      ctx.lineTo(x + r, y - r);
      ctx.lineTo(x, y + r);
      ctx.closePath();
      return true;
  }
  function trianglDownOffset(ctx, r, x, y, offset) {
      ctx.moveTo(x - r - offset * 2, y - r - offset);
      ctx.lineTo(x + r + offset * 2, y - r - offset);
      ctx.lineTo(x, y + r + offset * 2);
      ctx.closePath();
      return true;
  }
  class TriangleDownSymbol {
      type = 'triangleDown';
      pathStr = 'M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z';
      draw(ctx, size, x, y) {
          const r = size / 2;
          return trianglDown(ctx, r, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
          const r = size / 2;
          return trianglDownOffset(ctx, r, x, y, offset);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var triangleDown = new TriangleDownSymbol();

  const sqrt3 = sqrt(3);
  function thinTriangle(ctx, r, x, y) {
      const h = r * sqrt3;
      ctx.moveTo(x, y + (-h / 3) * 2);
      ctx.lineTo(r + x, y + h);
      ctx.lineTo(x - r, y + h);
      ctx.closePath();
      return true;
  }
  class ThinTriangleSymbol extends TriangleUpSymbol {
      type = 'thinTriangle';
      pathStr = 'M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z';
      draw(ctx, size, x, y) {
          const r = size / 2 / sqrt3;
          return thinTriangle(ctx, r, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
          const r = size / 2 / sqrt3 + offset;
          return thinTriangle(ctx, r, x, y);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var thinTriangle$1 = new ThinTriangleSymbol();

  function arrow2Left(ctx, r, transX, transY) {
      const r2 = r * 2;
      ctx.moveTo(r + transX, transY - r2);
      ctx.lineTo(transX - r, transY);
      ctx.lineTo(r + transX, r2 + transY);
      return true;
  }
  class Arrow2LeftSymbol {
      type = 'arrow2Left';
      pathStr = 'M 0.25 -0.5 L -0.25 0 l 0.5 0.5';
      draw(ctx, size, transX, transY) {
          const r = size / 4;
          return arrow2Left(ctx, r, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
          const r = size / 4 + offset;
          return arrow2Left(ctx, r, transX, transY);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var arrow2Left$1 = new Arrow2LeftSymbol();

  function arrow2Right(ctx, r, transX, transY) {
      const r2 = r * 2;
      ctx.moveTo(transX - r, transY - r2);
      ctx.lineTo(transX + r, transY);
      ctx.lineTo(transX - r, r2 + transY);
      return true;
  }
  class Arrow2RightSymbol {
      type = 'arrow2Right';
      pathStr = 'M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5';
      draw(ctx, size, transX, transY) {
          const r = size / 4;
          return arrow2Right(ctx, r, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
          const r = size / 4 + offset;
          return arrow2Right(ctx, r, transX, transY);
      }
      bounds(size, bounds) {
          const r = size / 2;
          bounds.x1 = -r;
          bounds.x2 = r;
          bounds.y1 = -r;
          bounds.y2 = r;
      }
  }
  var arrow2Right$1 = new Arrow2RightSymbol();

  function rect(ctx, size, x, y) {
      ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
      return false;
  }
  class RectSymbol {
      type = 'rect';
      pathStr = 'M-0.5,-0.5h1v1h-1Z';
      draw(ctx, size, x, y) {
          const rectSize = isNumber(size) ? [size, size] : size;
          return rect(ctx, rectSize, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
          const rectSize = isNumber(size)
              ? [size + 2 * offset, size + 2 * offset]
              : [size[0] + 2 * offset, size[1] + 2 * offset];
          return rect(ctx, rectSize, x, y);
      }
      bounds(size, bounds) {
          const rectSize = isNumber(size) ? [size, size] : size;
          bounds.x1 = -rectSize[0] / 2;
          bounds.x2 = rectSize[0] / 2;
          bounds.y1 = -rectSize[1] / 2;
          bounds.y2 = rectSize[1] / 2;
      }
  }
  var rect$1 = new RectSymbol();

  class CustomSymbolClass {
      type;
      path;
      pathStr = '';
      constructor(type, path) {
          this.type = type;
          this.path = path;
      }
      drawOffset(ctx, size, x, y, offset) {
          renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset);
          return false;
      }
      draw(ctx, size, x, y) {
          renderCommandList(this.path.commandList, ctx, x, y, size, size);
          return false;
      }
      bounds(size, bounds) {
          if (!this.path.bounds) {
              return;
          }
          bounds.x1 = this.path.bounds.x1 * size;
          bounds.y1 = this.path.bounds.y1 * size;
          bounds.x2 = this.path.bounds.x2 * size;
          bounds.y2 = this.path.bounds.y2 * size;
      }
  }

  const builtinSymbols = [
      circle$1,
      cross$1,
      diamond$1,
      square$1,
      thinTriangle$1,
      triangle,
      star$1,
      arrow$1,
      wedge$1,
      stroke$1,
      wye$1,
      triangleLeft,
      triangleRight,
      triangleUp,
      triangleDown,
      arrow2Left$1,
      arrow2Right$1,
      rect$1
  ];
  const builtinSymbolsMap = {};
  builtinSymbols.forEach(symbol => {
      builtinSymbolsMap[symbol.type] = symbol;
  });

  const SYMBOL_UPDATE_TAG_KEY = ['symbolType', 'size', ...GRAPHIC_UPDATE_TAG_KEY];
  let Symbol$1 = class Symbol extends Graphic {
      type = 'symbol';
      static userSymbolMap = {};
      constructor(params = { symbolType: 'circle' }) {
          super(params);
          this.numberType = SYMBOL_NUMBER_TYPE;
      }
      _parsedPath;
      getParsedPath() {
          if (this.shouldUpdateShape()) {
              this.doUpdateParsedPath();
              this.clearUpdateShapeTag();
          }
          return this._parsedPath;
      }
      isValid() {
          return super.isValid() && this._isValid();
      }
      _isValid() {
          const { size } = this.attribute;
          return isArray(size) ? size.length === 2 && size.every(this._validNumber) : this._validNumber(size);
      }
      doUpdateParsedPath() {
          const symbolTheme = getTheme(this).symbol;
          const { symbolType = symbolTheme.symbolType } = this.attribute;
          let path = builtinSymbolsMap[symbolType];
          if (path) {
              this._parsedPath = path;
              return path;
          }
          path = Symbol.userSymbolMap[symbolType];
          if (path) {
              this._parsedPath = path;
              return path;
          }
          const cache = new CustomPath2D().fromString(symbolType);
          const width = cache.bounds.width();
          const height = cache.bounds.height();
          const maxWH = max(width, height);
          const scale = 1 / maxWH;
          cache.transform(0, 0, scale, scale);
          this._parsedPath = new CustomSymbolClass(symbolType, cache);
          Symbol.userSymbolMap[symbolType] = this._parsedPath;
          return this._parsedPath;
      }
      doUpdateAABBBounds(full) {
          const symbolTheme = getTheme(this).symbol;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateSymbolAABBBounds(attribute, getTheme(this).symbol, this._AABBBounds, full, this);
          const { boundsPadding = symbolTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      getDefaultAttribute(name) {
          const symbolTheme = getTheme(this).symbol;
          return symbolTheme[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < SYMBOL_UPDATE_TAG_KEY.length; i++) {
              const attrKey = SYMBOL_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < SYMBOL_UPDATE_TAG_KEY.length; i++) {
              const attrKey = SYMBOL_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      toCustomPath() {
          const symbolInstance = this.getParsedPath();
          const size = this.attribute.size;
          const x = 0;
          const y = 0;
          const formattedSize = isArray(size) ? size : [size, size];
          return symbolInstance.path
              ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, x, y, formattedSize[0], formattedSize[1])
              : new CustomPath2D().fromString(symbolInstance.pathStr, x, y, formattedSize[0], formattedSize[1]);
      }
      clone() {
          return new Symbol({ ...this.attribute });
      }
  };

  const LINE_UPDATE_TAG_KEY = ['segments', 'points', 'curveType', ...GRAPHIC_UPDATE_TAG_KEY];
  let Line$1 = class Line extends Graphic {
      type = 'line';
      constructor(params = {}) {
          super(params);
          this.numberType = LINE_NUMBER_TYPE;
      }
      isValid() {
          return super.isValid() && this._isValid();
      }
      _isValid() {
          const { points, segments } = this.attribute;
          if (segments) {
              if (segments.length === 0) {
                  return false;
              }
              return true;
          }
          else if (points) {
              if (points.length <= 1) {
                  return false;
              }
              return true;
          }
          return false;
      }
      _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
          if (key === 'points') {
              nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio);
          }
      }
      doUpdateAABBBounds() {
          const lineTheme = getTheme(this).line;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateLineAABBBounds(attribute, getTheme(this).line, this._AABBBounds, this);
          const { boundsPadding = lineTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      getDefaultAttribute(name) {
          const lineTheme = getTheme(this).line;
          return lineTheme[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < LINE_UPDATE_TAG_KEY.length; i++) {
              const attrKey = LINE_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < LINE_UPDATE_TAG_KEY.length; i++) {
              const attrKey = LINE_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      toCustomPath() {
          const attribute = this.attribute;
          const path = new CustomPath2D();
          const segments = attribute.segments;
          const parsePoints = (points) => {
              if (points && points.length) {
                  let isFirst = true;
                  points.forEach(point => {
                      if (point.defined === false) {
                          return;
                      }
                      if (isFirst) {
                          path.moveTo(point.x, point.y);
                      }
                      else {
                          path.lineTo(point.x, point.y);
                      }
                      isFirst = false;
                  });
              }
          };
          if (segments && segments.length) {
              segments.forEach(seg => {
                  parsePoints(seg.points);
              });
          }
          else if (attribute.points) {
              parsePoints(attribute.points);
          }
          return path;
      }
      clone() {
          return new Line({ ...this.attribute });
      }
  };

  const RECT_UPDATE_TAG_KEY = ['width', 'height', 'cornerRadius', ...GRAPHIC_UPDATE_TAG_KEY];
  class Rect extends Graphic {
      type = 'rect';
      constructor(params) {
          super(params);
          this.numberType = RECT_NUMBER_TYPE;
      }
      isValid() {
          return super.isValid() && this._isValid();
      }
      _isValid() {
          const { width, height } = this.attribute;
          return this._validNumber(width) && this._validNumber(height);
      }
      doUpdateAABBBounds() {
          const rectTheme = getTheme(this).rect;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateRectAABBBounds(attribute, getTheme(this).rect, this._AABBBounds, this);
          const { boundsPadding = rectTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      getDefaultAttribute(name) {
          const rectTheme = getTheme(this).rect;
          return rectTheme[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < RECT_UPDATE_TAG_KEY.length; i++) {
              const attrKey = RECT_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < RECT_UPDATE_TAG_KEY.length; i++) {
              const attrKey = RECT_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      toCustomPath() {
          const attribute = this.attribute;
          const width = attribute.width;
          const height = attribute.height;
          const x = 0;
          const y = 0;
          const path = new CustomPath2D();
          path.moveTo(x, y);
          path.rect(x, y, width, height);
          return path;
      }
      clone() {
          return new Rect({ ...this.attribute });
      }
  }

  const CUBE_VERTICES = [
      [0, 0, 0],
      [1, 0, 0],
      [1, 1, 0],
      [0, 1, 0],
      [0, 0, 1],
      [1, 0, 1],
      [1, 1, 1],
      [0, 1, 1]
  ];
  class Rect3d extends Rect {
      type = 'rect3d';
      constructor(params) {
          super(params);
          this.numberType = RECT3D_NUMBER_TYPE;
      }
      findFace() {
          const faces = { polygons: [], vertices: [], edges: [] };
          const rectTheme = getTheme(this).rect3d;
          const { width = rectTheme.width, height = rectTheme.width, length = min(rectTheme.width, rectTheme.height) } = this.attribute;
          for (let i = 0; i < CUBE_VERTICES.length; i++) {
              const v = CUBE_VERTICES[i];
              faces.vertices.push([v[0] * width, v[1] * height, v[2] * length]);
          }
          faces.polygons.push({ polygon: [0, 1, 5, 4], normal: [0, -1, 0] });
          faces.polygons.push({ polygon: [2, 3, 7, 6], normal: [0, 1, 0] });
          faces.polygons.push({ polygon: [4, 7, 3, 0], normal: [-1, 0, 0] });
          faces.polygons.push({ polygon: [1, 2, 6, 5], normal: [1, 0, 0] });
          faces.polygons.push({ polygon: [0, 1, 2, 3], normal: [0, 0, -1] });
          faces.polygons.push({ polygon: [4, 5, 6, 7], normal: [0, 0, 1] });
          faces.edges = [
              [0, 1],
              [1, 2],
              [2, 3],
              [3, 0],
              [4, 5],
              [5, 6],
              [6, 7],
              [7, 4],
              [0, 4],
              [3, 7],
              [1, 5],
              [2, 6]
          ];
          return faces;
      }
  }

  class Glyph extends Graphic {
      type = 'glyph';
      constructor(params) {
          super(params);
          this.numberType = GLYPH_NUMBER_TYPE;
          this.subGraphic = [];
          this._onInit && this._onInit(this);
          this.valid = this.isValid();
      }
      setSubGraphic(subGraphic) {
          this.detachSubGraphic();
          this.subGraphic = subGraphic;
          subGraphic.forEach(g => {
              g.glyphHost = this;
              Object.setPrototypeOf(g.attribute, this.attribute);
          });
          this.valid = this.isValid();
          this.addUpdateBoundTag();
      }
      detachSubGraphic() {
          this.subGraphic.forEach(g => {
              g.glyphHost = null;
              Object.setPrototypeOf(g.attribute, {});
          });
      }
      getSubGraphic() {
          return this.subGraphic;
      }
      onInit(cb) {
          this._onInit = cb;
      }
      onUpdate(cb) {
          this._onUpdate = cb;
      }
      isValid() {
          return true;
      }
      setAttribute(key, value, forceUpdateTag, context) {
          super.setAttribute(key, value, forceUpdateTag, context);
          this.subGraphic.forEach(g => {
              g.addUpdateShapeAndBoundsTag();
              g.addUpdatePositionTag();
          });
      }
      setAttributes(params, forceUpdateTag = false, context) {
          super.setAttributes(params, forceUpdateTag, context);
          this.subGraphic.forEach(g => {
              g.addUpdateShapeAndBoundsTag();
              g.addUpdatePositionTag();
          });
      }
      translate(x, y) {
          super.translate(x, y);
          this.subGraphic.forEach(g => {
              g.addUpdatePositionTag();
              g.addUpdateBoundTag();
          });
          return this;
      }
      translateTo(x, y) {
          super.translateTo(x, y);
          this.subGraphic.forEach(g => {
              g.addUpdatePositionTag();
              g.addUpdateBoundTag();
          });
          return this;
      }
      scale(scaleX, scaleY, scaleCenter) {
          super.scale(scaleX, scaleY, scaleCenter);
          this.subGraphic.forEach(g => {
              g.addUpdatePositionTag();
              g.addUpdateBoundTag();
          });
          return this;
      }
      scaleTo(scaleX, scaleY) {
          super.scaleTo(scaleX, scaleY);
          this.subGraphic.forEach(g => {
              g.addUpdatePositionTag();
              g.addUpdateBoundTag();
          });
          return this;
      }
      rotate(angle) {
          super.rotate(angle);
          this.subGraphic.forEach(g => {
              g.addUpdatePositionTag();
              g.addUpdateBoundTag();
          });
          return this;
      }
      rotateTo(angle) {
          super.rotate(angle);
          this.subGraphic.forEach(g => {
              g.addUpdatePositionTag();
              g.addUpdateBoundTag();
          });
          return this;
      }
      doUpdateAABBBounds() {
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const bounds = application.graphicService.updateGlyphAABBBounds(this.attribute, getTheme(this).glyph, this._AABBBounds, this);
          this.clearUpdateBoundTag();
          return bounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      needUpdateTags(keys) {
          return false;
      }
      needUpdateTag(key) {
          return false;
      }
      useStates(states, hasAnimation) {
          if (!states.length) {
              this.clearStates(hasAnimation);
              return;
          }
          const isChange = this.currentStates?.length !== states.length ||
              states.some((stateName, index) => this.currentStates[index] !== stateName);
          if (!isChange) {
              return;
          }
          const stateAttrs = {};
          const subAttrs = this.subGraphic.map(() => ({}));
          states.forEach(stateName => {
              const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
              if (attrs) {
                  Object.assign(stateAttrs, attrs.attributes);
                  if (attrs.subAttributes?.length) {
                      subAttrs.forEach((subAttrs, index) => {
                          Object.assign(subAttrs, attrs.subAttributes[index]);
                      });
                  }
              }
          });
          this.subGraphic.forEach((graphic, index) => {
              graphic.updateNormalAttrs(subAttrs[index]);
              graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);
          });
          this.updateNormalAttrs(stateAttrs);
          this.currentStates = states;
          this.applyStateAttrs(stateAttrs, states, hasAnimation);
      }
      clearStates(hasAnimation) {
          if (!this.hasState() || !this.normalAttrs) {
              return;
          }
          this.subGraphic.forEach(graphic => {
              graphic.applyStateAttrs(graphic.normalAttrs, this.currentStates, hasAnimation, true);
              graphic.normalAttrs = null;
          });
          this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true);
          this.normalAttrs = null;
          this.currentStates = [];
      }
      clone() {
          const glyph = new Glyph({ ...this.attribute });
          glyph.setSubGraphic(this.subGraphic.map(g => g.clone()));
          return glyph;
      }
  }

  const DIRECTION_KEY = {
      horizontal: {
          width: 'width',
          height: 'height',
          left: 'left',
          top: 'top',
          x: 'x',
          y: 'y',
          bottom: 'bottom'
      },
      vertical: {
          width: 'height',
          height: 'width',
          left: 'top',
          top: 'left',
          x: 'y',
          y: 'x',
          bottom: 'right'
      }
  };
  const defaultFormatting = {
      fontSize: 16,
      fontFamily: 'sans-serif',
      fill: true,
      stroke: false,
      fontWeight: 'normal',
      lineHeight: 'normal',
      fontStyle: 'normal',
      textDecoration: 'none',
      textAlign: 'left',
      script: 'normal'
  };
  const regLetter = /\w|\(|\)/;
  const regPunctuation = /[.?!,;:/]/;
  const regFirstSpace = /\S/;
  function applyFillStyle(ctx, character) {
      const fillStyle = (character && character.fill) || defaultFormatting.fill;
      if (!fillStyle) {
          ctx.globalAlpha = 0;
          return;
      }
      ctx.globalAlpha = 1;
      ctx.fillStyle = fillStyle;
      let fontSize = character.fontSize || 16;
      switch (character.script) {
          case 'super':
          case 'sub':
              fontSize *= 0.8;
              break;
      }
      ctx.setTextStyle({
          textAlign: 'left',
          textBaseline: character.textBaseline || 'alphabetic',
          fontStyle: character.fontStyle || '',
          fontWeight: character.fontWeight || '',
          fontSize,
          fontFamily: character.fontFamily || 'sans-serif'
      });
  }
  function applyStrokeStyle(ctx, character) {
      const strokeStyle = (character && character.stroke) || defaultFormatting.stroke;
      if (!strokeStyle) {
          ctx.globalAlpha = 0;
          return;
      }
      ctx.globalAlpha = 1;
      ctx.lineWidth = 1;
      ctx.strokeStyle = strokeStyle;
      let fontSize = character.fontSize || 16;
      switch (character.script) {
          case 'super':
          case 'sub':
              fontSize *= 0.8;
              break;
      }
      ctx.setTextStyle({
          textAlign: 'left',
          textBaseline: character.textBaseline || 'alphabetic',
          fontStyle: character.fontStyle || '',
          fontWeight: character.fontWeight || '',
          fontSize,
          fontFamily: character.fontFamily || 'sans-serif'
      });
  }
  function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
      if (!width || width <= 0) {
          return 0;
      }
      const textMeasure = application.graphicUtil.textMeasure;
      let index = guessIndex;
      let temp = desc.slice(0, index);
      let tempWidth = Math.floor(textMeasure.measureText(temp, character).width);
      let tempNext = desc.slice(0, index + 1);
      let tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
      while (tempWidth > width || tempWidthNext <= width) {
          if (tempWidth > width) {
              index--;
          }
          else {
              index++;
          }
          if (index > desc.length) {
              index = desc.length;
              break;
          }
          else if (index < 0) {
              index = 0;
              break;
          }
          temp = desc.slice(0, index);
          tempWidth = Math.floor(textMeasure.measureText(temp, character).width);
          tempNext = desc.slice(0, index + 1);
          tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
      }
      if (needTestLetter) {
          index = testLetter(desc, index);
      }
      return index;
  }
  function testLetter(string, index) {
      let i = index;
      while ((regLetter.test(string[i - 1]) && regLetter.test(string[i])) ||
          regPunctuation.test(string[i])) {
          i--;
          if (i <= 0) {
              return index;
          }
      }
      return i;
  }
  function measureTextCanvas(text, character) {
      const textMeasure = application.graphicUtil.textMeasure;
      const measurement = textMeasure.measureText(text, character);
      const result = {
          ascent: 0,
          height: 0,
          descent: 0,
          width: 0
      };
      if (typeof measurement.actualBoundingBoxAscent !== 'number' ||
          typeof measurement.actualBoundingBoxDescent !== 'number') {
          result.width = Math.floor(measurement.width);
          result.height = character.fontSize || 0;
          result.ascent = result.height;
          result.descent = 0;
      }
      else {
          result.width = Math.floor(measurement.width);
          result.height = Math.floor(measurement.actualBoundingBoxAscent + measurement.actualBoundingBoxDescent);
          result.ascent = Math.floor(measurement.actualBoundingBoxAscent);
          result.descent = result.height - result.ascent;
      }
      return result;
  }

  class Frame {
      left;
      top;
      bottom;
      right;
      width;
      height;
      actualHeight;
      ellipsis;
      wordBreak;
      verticalDirection;
      lines;
      globalAlign;
      globalBaseline;
      layoutDirection;
      directionKey;
      isWidthMax;
      isHeightMax;
      singleLine;
      icons;
      constructor(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
          this.actualHeight = 0;
          this.bottom = top + height;
          this.right = left + width;
          this.ellipsis = ellipsis;
          this.wordBreak = wordBreak;
          this.verticalDirection = verticalDirection;
          this.lines = [];
          this.globalAlign = globalAlign;
          this.globalBaseline = globalBaseline;
          this.layoutDirection = layoutDirection;
          this.directionKey = DIRECTION_KEY[this.layoutDirection];
          this.isWidthMax = isWidthMax;
          this.isHeightMax = isHeightMax;
          this.singleLine = singleLine;
          if (icons) {
              icons.clear();
              this.icons = icons;
          }
          else {
              this.icons = new Map();
          }
      }
      draw(ctx, drawIcon) {
          const { width: actualWidth, height: actualHeight } = this.getActualSize();
          const width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
          let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
          height = Math.min(height, actualHeight);
          let deltaY = 0;
          switch (this.globalBaseline) {
              case 'top':
                  deltaY = 0;
                  break;
              case 'middle':
                  deltaY = -height / 2;
                  break;
              case 'bottom':
                  deltaY = -height;
                  break;
          }
          let deltaX = 0;
          switch (this.globalAlign) {
              case 'left':
                  deltaX = 0;
                  break;
              case 'center':
                  deltaX = -width / 2;
                  break;
              case 'right':
                  deltaX = -width;
                  break;
          }
          let frameHeight = this[this.directionKey.height];
          if (this.singleLine) {
              frameHeight = this.lines[0].height + 1;
          }
          let lastLineTag = false;
          if (this.verticalDirection === 'middle') {
              if (this.actualHeight >= frameHeight && frameHeight !== 0) {
                  for (let i = 0; i < this.lines.length; i++) {
                      const { top, height } = this.lines[i];
                      if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) {
                          return lastLineTag;
                      }
                      let lastLine = false;
                      if (this.ellipsis &&
                          this.lines[i + 1] &&
                          this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                          lastLine = true;
                          lastLineTag = true;
                      }
                      this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);
                  }
              }
              else {
                  const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
                  if (this.layoutDirection === 'vertical') {
                      deltaX += detalHeight;
                  }
                  else {
                      deltaY += detalHeight;
                  }
                  for (let i = 0; i < this.lines.length; i++) {
                      this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);
                  }
              }
          }
          else if (this.verticalDirection === 'bottom' && this.layoutDirection !== 'vertical') {
              for (let i = 0; i < this.lines.length; i++) {
                  const { top, height } = this.lines[i];
                  const y = frameHeight - this.lines[i].top - this.lines[i].height;
                  if (frameHeight === 0) {
                      this.lines[i].draw(ctx, false, deltaX, y + deltaY, drawIcon);
                  }
                  else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) {
                      return lastLineTag;
                  }
                  else {
                      let lastLine = false;
                      if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
                          lastLine = true;
                          lastLineTag = true;
                      }
                      this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, drawIcon);
                  }
              }
          }
          else {
              if (this.verticalDirection === 'bottom' &&
                  this.layoutDirection === 'vertical' &&
                  this.singleLine &&
                  this.isWidthMax) {
                  deltaX += this.lines[0].height + 1;
              }
              for (let i = 0; i < this.lines.length; i++) {
                  if (this.verticalDirection === 'bottom' && this.layoutDirection === 'vertical') {
                      deltaX -= this.lines[i].height + this.lines[i].top;
                  }
                  const { top, height } = this.lines[i];
                  if (frameHeight === 0) {
                      this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);
                  }
                  else if (top + height < this[this.directionKey.top] ||
                      top + height > this[this.directionKey.top] + frameHeight) {
                      return lastLineTag;
                  }
                  else {
                      let lastLine = false;
                      if (this.ellipsis &&
                          this.lines[i + 1] &&
                          this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                          lastLine = true;
                          lastLineTag = true;
                      }
                      this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);
                  }
              }
          }
          return lastLineTag;
      }
      getActualSize() {
          if (this.ellipsis) {
              return this.getActualSizeWidthEllipsis();
          }
          return this.getRawActualSize();
      }
      getRawActualSize() {
          let width = 0;
          let height = 0;
          for (let i = 0; i < this.lines.length; i++) {
              const line = this.lines[i];
              if (line.actualWidth > width) {
                  width = line.actualWidth;
              }
              height += line.height;
          }
          return {
              width: this.layoutDirection === 'vertical' ? height : width,
              height: this.layoutDirection === 'vertical' ? width : height
          };
      }
      getActualSizeWidthEllipsis() {
          let widthBound = 0;
          let heightBound = 0;
          const { width: actualWidth, height: actualHeight } = this.getRawActualSize();
          this.width || actualWidth || 0;
          this.height || actualHeight || 0;
          let frameHeight = this[this.directionKey.height];
          if (this.singleLine) {
              frameHeight = this.lines[0].height + 1;
          }
          if (this.verticalDirection === 'middle') {
              if (this.actualHeight >= frameHeight && frameHeight !== 0) {
                  for (let i = 0; i < this.lines.length; i++) {
                      const { top, height } = this.lines[i];
                      if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;
                      else {
                          if (this.ellipsis &&
                              this.lines[i + 1] &&
                              this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                              const lineWidth = this.lines[i].getWidthWithEllips();
                              if (lineWidth > widthBound) {
                                  widthBound = lineWidth;
                              }
                              heightBound += this.lines[i].height;
                          }
                          else {
                              if (this.lines[i].actualWidth > widthBound) {
                                  widthBound = this.lines[i].actualWidth;
                              }
                              heightBound += this.lines[i].height;
                          }
                      }
                  }
              }
              else {
                  Math.floor((frameHeight - this.actualHeight) / 2);
                  for (let i = 0; i < this.lines.length; i++) {
                      if (this.lines[i].actualWidth > widthBound) {
                          widthBound = this.lines[i].actualWidth;
                      }
                      heightBound += this.lines[i].height;
                  }
              }
          }
          else if (this.verticalDirection === 'bottom') {
              for (let i = 0; i < this.lines.length; i++) {
                  const { top, height } = this.lines[i];
                  const y = frameHeight - this.lines[i].top - this.lines[i].height;
                  if (frameHeight === 0) {
                      if (this.lines[i].actualWidth > widthBound) {
                          widthBound = this.lines[i].actualWidth;
                      }
                      heightBound += this.lines[i].height;
                  }
                  else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ;
                  else {
                      if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
                          const lineWidth = this.lines[i].getWidthWithEllips();
                          if (lineWidth > widthBound) {
                              widthBound = lineWidth;
                          }
                          heightBound += this.lines[i].height;
                      }
                      else {
                          if (this.lines[i].actualWidth > widthBound) {
                              widthBound = this.lines[i].actualWidth;
                          }
                          heightBound += this.lines[i].height;
                      }
                  }
              }
          }
          else {
              for (let i = 0; i < this.lines.length; i++) {
                  const { top, height } = this.lines[i];
                  if (frameHeight === 0) {
                      if (this.lines[i].actualWidth > widthBound) {
                          widthBound = this.lines[i].actualWidth;
                      }
                      heightBound += this.lines[i].height;
                  }
                  else if (top + height < this[this.directionKey.top] ||
                      top + height > this[this.directionKey.top] + frameHeight) ;
                  else {
                      if (this.ellipsis &&
                          this.lines[i + 1] &&
                          this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                          const lineWidth = this.lines[i].getWidthWithEllips();
                          if (lineWidth > widthBound) {
                              widthBound = lineWidth;
                          }
                          heightBound += this.lines[i].height;
                      }
                      else {
                          if (this.lines[i].actualWidth > widthBound) {
                              widthBound = this.lines[i].actualWidth;
                          }
                          heightBound += this.lines[i].height;
                      }
                  }
              }
          }
          return {
              width: this.layoutDirection === 'vertical' ? heightBound : widthBound,
              height: this.layoutDirection === 'vertical' ? widthBound : heightBound
          };
      }
  }

  class Paragraph {
      text;
      ascent;
      descent;
      width;
      height;
      lineHeight;
      fontSize;
      length;
      newLine;
      character;
      left;
      top;
      direction;
      widthOrigin;
      heightOrigin;
      textBaseline;
      ellipsis;
      ellipsisWidth;
      ellipsisOtherParagraphWidth;
      verticalEllipsis;
      constructor(text, newLine, character) {
          this.fontSize = character.fontSize || 16;
          this.textBaseline = character.textBaseline || 'alphabetic';
          if (typeof character.lineHeight === 'number') {
              this.lineHeight = character.lineHeight > this.fontSize ? character.lineHeight : this.fontSize;
          }
          else {
              this.lineHeight = Math.floor(1.2 * this.fontSize);
          }
          this.height = this.lineHeight;
          const { ascent, height, descent, width } = measureTextCanvas(text, character);
          let halfDetaHeight = 0;
          let deltaAscent = 0;
          let deltaDescent = 0;
          if (this.height > height) {
              halfDetaHeight = (this.height - height) / 2;
              deltaAscent = Math.ceil(halfDetaHeight);
              deltaDescent = Math.floor(halfDetaHeight);
          }
          if (this.textBaseline === 'top') {
              this.ascent = halfDetaHeight;
              this.descent = height - halfDetaHeight;
          }
          else if (this.textBaseline === 'bottom') {
              this.ascent = height - halfDetaHeight;
              this.descent = halfDetaHeight;
          }
          else if (this.textBaseline === 'middle') {
              this.ascent = this.height / 2;
              this.descent = this.height / 2;
          }
          else {
              this.ascent = ascent + deltaAscent;
              this.descent = descent + deltaDescent;
          }
          this.length = text.length;
          this.width = width || 0;
          this.text = text || '';
          this.newLine = newLine || false;
          this.character = character;
          this.left = 0;
          this.top = 0;
          this.ellipsis = 'normal';
          this.ellipsisWidth = 0;
          this.ellipsisOtherParagraphWidth = 0;
          if (character.direction === 'vertical') {
              this.direction = character.direction;
              this.widthOrigin = this.width;
              this.heightOrigin = this.height;
              this.width = this.heightOrigin;
              this.height = this.widthOrigin;
              this.lineHeight = this.height;
          }
      }
      updateWidth() {
          const { width } = measureTextCanvas(this.text, this.character);
          this.width = width;
          if (this.direction === 'vertical') {
              this.widthOrigin = this.width;
              this.width = this.heightOrigin;
              this.height = this.widthOrigin;
          }
      }
      draw(ctx, baseline, deltaLeft, isLineFirst, textAlign) {
          let text = this.text;
          let left = this.left + deltaLeft;
          baseline += this.top;
          let direction = this.direction;
          if (this.verticalEllipsis) {
              text = '...';
              direction = 'vertical';
              baseline -= this.ellipsisWidth / 2;
          }
          else if (this.ellipsis === 'hide') {
              return;
          }
          else if (this.ellipsis === 'add') {
              text += '...';
              if (textAlign === 'right') {
                  left -= this.ellipsisWidth;
              }
          }
          else if (this.ellipsis === 'replace') {
              const index = getStrByWithCanvas(text, (direction === 'vertical' ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
              text = text.slice(0, index);
              text += '...';
              if (textAlign === 'right') {
                  const { width } = measureTextCanvas(this.text.slice(index), this.character);
                  if (direction === 'vertical') ;
                  else {
                      left -= this.ellipsisWidth - width;
                  }
              }
          }
          switch (this.character.script) {
              case 'super':
                  baseline -= this.ascent * (1 / 3);
                  break;
              case 'sub':
                  baseline += this.descent / 2;
                  break;
          }
          if (direction === 'vertical') {
              ctx.save();
              ctx.rotateAbout(Math.PI / 2, left, baseline);
              ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2);
              ctx.translate(left, baseline);
              left = 0;
              baseline = 0;
          }
          if (this.character.stroke) {
              applyStrokeStyle(ctx, this.character);
              ctx.strokeText(text, left, baseline);
          }
          applyFillStyle(ctx, this.character);
          if (this.character.fill) {
              ctx.fillText(text, left, baseline);
          }
          if (this.character.fill) {
              if (typeof this.character.lineThrough === 'boolean' || typeof this.character.underline === 'boolean') {
                  if (this.character.underline) {
                      ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
                  }
                  if (this.character.lineThrough) {
                      ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
                  }
              }
              else if (this.character.textDecoration === 'underline') {
                  ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
              }
              else if (this.character.textDecoration === 'line-through') {
                  ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
              }
          }
          if (direction === 'vertical') {
              ctx.restore();
          }
      }
      getWidthWithEllips(direction) {
          let text = this.text;
          const width = direction === 'vertical' ? this.height : this.width;
          if (this.ellipsis === 'hide') {
              return width;
          }
          else if (this.ellipsis === 'add') {
              return width + this.ellipsisWidth;
          }
          else if (this.ellipsis === 'replace') {
              const index = getStrByWithCanvas(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
              text = text.slice(0, index);
              text += '...';
              const { width: measureWidth } = measureTextCanvas(this.text.slice(index), this.character);
              return width + this.ellipsisWidth - measureWidth;
          }
          return width;
      }
  }
  function seperateParagraph(paragraph, index) {
      const text1 = paragraph.text.slice(0, index);
      const text2 = paragraph.text.slice(index);
      const p1 = new Paragraph(text1, paragraph.newLine, paragraph.character);
      const p2 = new Paragraph(text2, true, paragraph.character);
      return [p1, p2];
  }

  const IMAGE_UPDATE_TAG_KEY = ['width', 'height', 'image', ...GRAPHIC_UPDATE_TAG_KEY];
  class Image extends Graphic {
      type = 'image';
      successCallback;
      failCallback;
      constructor(params) {
          super(params);
          this.numberType = IMAGE_NUMBER_TYPE;
          this.loadImage(this.attribute.image);
      }
      get width() {
          return this.attribute.width ?? 0;
      }
      set width(width) {
          if (this.attribute.width === width) {
              this.attribute.width = width;
              this.addUpdateShapeAndBoundsTag();
          }
      }
      get height() {
          return this.attribute.height ?? 0;
      }
      set height(height) {
          if (this.attribute.height === height) {
              this.attribute.height = height;
              this.addUpdateShapeAndBoundsTag();
          }
      }
      get repeatX() {
          return this.attribute.repeatX ?? 'no-repeat';
      }
      set repeatX(repeatX) {
          if (this.attribute.repeatX === repeatX) {
              this.attribute.repeatX = repeatX;
          }
      }
      get repeatY() {
          return this.attribute.repeatY ?? 'no-repeat';
      }
      set repeatY(repeatY) {
          if (this.attribute.repeatY === repeatY) {
              this.attribute.repeatY = repeatY;
          }
      }
      get image() {
          return this.attribute.image;
      }
      set image(image) {
          if (image !== this.attribute.image) {
              this.attribute.image = image;
              this.loadImage(this.attribute.image);
          }
      }
      imageLoadSuccess(url, image, cb) {
          super.imageLoadSuccess(url, image, () => {
              if (this.successCallback) {
                  this.successCallback();
              }
          });
      }
      imageLoadFail(url, cb) {
          super.imageLoadFail(url, () => {
              if (this.failCallback) {
                  this.failCallback();
              }
          });
      }
      doUpdateAABBBounds() {
          const imageTheme = getTheme(this).image;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateImageAABBBounds(attribute, getTheme(this).image, this._AABBBounds, this);
          const { boundsPadding = imageTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      getDefaultAttribute(name) {
          return DefaultImageAttribute[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < IMAGE_UPDATE_TAG_KEY.length; i++) {
              const attrKey = IMAGE_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < IMAGE_UPDATE_TAG_KEY.length; i++) {
              const attrKey = IMAGE_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      clone() {
          return new Image({ ...this.attribute });
      }
  }

  class RichTextIcon extends Image {
      richtextId;
      globalX;
      globalY;
      _x = 0;
      _y = 0;
      _hovered = false;
      _marginArray = [0, 0, 0, 0];
      constructor(params) {
          super(params);
          if (params.backgroundShowMode === 'always') {
              this._hovered = true;
          }
          if (params.margin) {
              const marginArray = parsePadding(params.margin);
              if (typeof marginArray === 'number') {
                  this._marginArray = [marginArray, marginArray, marginArray, marginArray];
              }
              else {
                  this._marginArray = marginArray;
              }
          }
          this.onBeforeAttributeUpdate = (val, attributes, key) => {
              if ((isArray(key) && key.indexOf('margin') !== -1) || key === 'margin') {
                  if (attributes.margin) {
                      const marginArray = parsePadding(attributes.margin);
                      if (typeof marginArray === 'number') {
                          this._marginArray = [marginArray, marginArray, marginArray, marginArray];
                      }
                      else {
                          this._marginArray = marginArray;
                      }
                  }
                  else {
                      this._marginArray = [0, 0, 0, 0];
                  }
              }
              return undefined;
          };
      }
      animationBackUps;
      incrementalAt;
      toCustomPath;
      get width() {
          return (this.attribute.width ?? 0) + this._marginArray[1] + this._marginArray[3];
      }
      get height() {
          return (this.attribute.height ?? 0) + this._marginArray[0] + this._marginArray[2];
      }
      tryUpdateAABBBounds() {
          if (!this.shouldUpdateAABBBounds()) {
              return this._AABBBounds;
          }
          this.doUpdateAABBBounds();
          const { width = DefaultImageAttribute.width, height = DefaultImageAttribute.height } = this.attribute;
          const { backgroundWidth = width, backgroundHeight = height } = this.attribute;
          const expandX = (backgroundWidth - width) / 2;
          const expandY = (backgroundHeight - height) / 2;
          this._AABBBounds.expand([0, expandX * 2, expandY * 2, 0]);
          return this._AABBBounds;
      }
      setHoverState(hovered) {
          if (this.attribute.backgroundShowMode === 'hover' && this._hovered !== hovered) {
              this._hovered = hovered;
          }
      }
  }

  class Line {
      left;
      top;
      width;
      height;
      baseline;
      ascent;
      descent;
      paragraphs;
      actualWidth;
      blankWidth;
      textAlign;
      direction;
      directionKey;
      constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
          this.left = left;
          this.width = width;
          this.baseline = baseline;
          this.ascent = ascent;
          this.descent = descent;
          this.top = baseline - ascent;
          this.paragraphs = lineBuffer.map(p => p);
          this.textAlign =
              (this.paragraphs[0] instanceof RichTextIcon
                  ? this.paragraphs[0].attribute.textAlign
                  : this.paragraphs[0].character.textAlign) || 'left';
          this.direction = direction;
          this.directionKey = DIRECTION_KEY[this.direction];
          const directionKey = this.directionKey;
          this.actualWidth = 0;
          let maxHeight = 0;
          this.paragraphs.forEach((word, index) => {
              if (index === 0 && word instanceof Paragraph) {
                  const result = regFirstSpace.exec(word.text);
                  if (result?.index !== 0) {
                      word.text = word.text.slice(result?.index);
                      word.updateWidth();
                  }
              }
              this.actualWidth += word[this.directionKey.width];
              maxHeight = Math.max(word[this.directionKey.height], maxHeight);
          });
          this.height = maxHeight;
          this.blankWidth = !isWidthMax ? this.width - this.actualWidth : 0;
          let x = this.left;
          let spacing = 0;
          if (this.actualWidth < width && !isWidthMax) {
              switch (this.textAlign) {
                  case 'right':
                      x = width - this.actualWidth;
                      break;
                  case 'center':
                      x = (width - this.actualWidth) / 2;
                      break;
                  case 'justify':
                      if (this.paragraphs.length < 2) {
                          x = (width - this.actualWidth) / 2;
                      }
                      else {
                          spacing = (width - this.actualWidth) / (this.paragraphs.length - 1);
                      }
                      break;
              }
          }
          this.paragraphs.map(function (paragraph) {
              if (paragraph instanceof RichTextIcon) {
                  paragraph['_' + directionKey.x] = x;
                  x += paragraph[directionKey.width] + spacing;
                  paragraph['_' + directionKey.y] =
                      paragraph.attribute.textBaseline === 'top'
                          ? 0
                          : paragraph.attribute.textBaseline === 'bottom'
                              ? maxHeight - paragraph.height
                              : (maxHeight - paragraph.height) / 2;
              }
              else {
                  paragraph[directionKey.left] = x;
                  x += paragraph[directionKey.width] + spacing;
              }
          });
      }
      draw(ctx, lastLine, x, y, drawIcon) {
          if (lastLine) {
              let otherParagraphWidth = 0;
              for (let i = this.paragraphs.length - 1; i >= 0; i--) {
                  const paragraph = this.paragraphs[i];
                  if (paragraph instanceof RichTextIcon) {
                      break;
                  }
                  if (this.direction === 'vertical' && paragraph.direction !== 'vertical') {
                      paragraph.verticalEllipsis = true;
                      break;
                  }
                  const { width } = measureTextCanvas('...', paragraph.character);
                  const ellipsisWidth = width || 0;
                  if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
                      paragraph.ellipsis = 'add';
                      break;
                  }
                  else if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
                      paragraph.ellipsis = 'replace';
                      paragraph.ellipsisWidth = ellipsisWidth;
                      paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
                      break;
                  }
                  else {
                      paragraph.ellipsis = 'hide';
                      otherParagraphWidth += paragraph.width;
                  }
              }
          }
          this.paragraphs.map((paragraph, index) => {
              if (paragraph instanceof RichTextIcon) {
                  paragraph.setAttributes({
                      x: x + paragraph._x,
                      y: y + paragraph._y
                  });
                  drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
                  return;
              }
              paragraph.draw(ctx, y + this.ascent, x, index === 0, this.textAlign);
          });
      }
      getWidthWithEllips() {
          let otherParagraphWidth = 0;
          for (let i = this.paragraphs.length - 1; i >= 0; i--) {
              const paragraph = this.paragraphs[i];
              if (paragraph instanceof RichTextIcon) {
                  break;
              }
              const { width } = measureTextCanvas('...', paragraph.character);
              const ellipsisWidth = width || 0;
              if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
                  paragraph.ellipsis = 'add';
                  paragraph.ellipsisWidth = ellipsisWidth;
                  break;
              }
              else if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
                  paragraph.ellipsis = 'replace';
                  paragraph.ellipsisWidth = ellipsisWidth;
                  paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
                  break;
              }
              else {
                  paragraph.ellipsis = 'hide';
                  otherParagraphWidth += paragraph.width;
              }
          }
          let width = 0;
          this.paragraphs.map((paragraph, index) => {
              if (paragraph instanceof RichTextIcon) {
                  width += paragraph.width;
              }
              else {
                  width += paragraph.getWidthWithEllips(this.direction);
              }
          });
          return width;
      }
  }

  class Wrapper {
      frame;
      lineWidth;
      width;
      height;
      y;
      maxAscent;
      maxDescent;
      maxAscentForBlank;
      maxDescentForBlank;
      lineBuffer;
      direction;
      directionKey;
      constructor(frame) {
          this.frame = frame;
          this.width = this.frame.width;
          this.height = this.frame.height;
          this.lineWidth = 0;
          this.y = this.frame.top;
          this.maxAscent = 0;
          this.maxDescent = 0;
          this.maxAscentForBlank = 0;
          this.maxDescentForBlank = 0;
          this.lineBuffer = [];
          this.direction = frame.layoutDirection;
          this.directionKey = DIRECTION_KEY[this.direction];
      }
      store(paragraph) {
          if (paragraph instanceof RichTextIcon) {
              this.frame.icons.set(paragraph.richtextId, paragraph);
              this.lineBuffer.push(paragraph);
              this.lineWidth += paragraph[this.directionKey.width];
              let iconAscent = 0;
              let iconDescent = 0;
              if (paragraph.attribute.textBaseline === 'top') {
                  iconAscent = 0;
                  iconDescent = paragraph.height;
              }
              else if (paragraph.attribute.textBaseline === 'bottom') {
                  iconAscent = paragraph.height;
                  iconDescent = 0;
              }
              else {
                  iconAscent = paragraph.height / 2;
                  iconDescent = paragraph.height / 2;
              }
              this.maxAscent = Math.max(this.maxAscent, iconAscent);
              this.maxDescent = Math.max(this.maxDescent, iconDescent);
          }
          else {
              this.lineBuffer.push(paragraph);
              if (paragraph.text.length !== 0) {
                  this.lineWidth += paragraph[this.directionKey.width];
                  this.maxAscent = Math.max(this.maxAscent, paragraph.ascent);
                  this.maxDescent = Math.max(this.maxDescent, paragraph.descent);
              }
              else {
                  this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent);
                  this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent);
              }
          }
      }
      send() {
          if (this.lineBuffer.length === 0) {
              return;
          }
          const maxAscent = this.maxAscent === 0 ? this.maxAscentForBlank : this.maxAscent;
          const maxDescent = this.maxDescent === 0 ? this.maxDescentForBlank : this.maxDescent;
          const line = new Line(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, this.direction === 'horizontal' ? this.frame.isWidthMax : this.frame.isHeightMax);
          this.frame.lines.push(line);
          this.frame.actualHeight += line.height;
          this.y += line.height;
          this.lineBuffer.length = 0;
          this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
      }
      deal(paragraph) {
          if (paragraph instanceof RichTextIcon) {
              if ((this.direction === 'horizontal' && this.width === 0) ||
                  (this.direction === 'vertical' && this.height === 0)) {
                  this.store(paragraph);
              }
              else {
                  if (this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width]) {
                      this.store(paragraph);
                  }
                  else if (this.lineBuffer.length === 0) {
                      this.store(paragraph);
                      this.send();
                  }
                  else {
                      this.send();
                      this.deal(paragraph);
                  }
              }
              return;
          }
          if (typeof this.width !== 'number' || this.width < 0) {
              return;
          }
          if (paragraph.newLine) {
              this.send();
          }
          if (paragraph.text.length === 0) {
              return;
          }
          if ((this.direction === 'horizontal' && this.width === 0) || (this.direction === 'vertical' && this.height === 0)) {
              this.store(paragraph);
          }
          else {
              if (this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width]) {
                  this.store(paragraph);
              }
              else if (this.lineWidth === this[this.directionKey.width]) {
                  this.send();
                  this.deal(paragraph);
              }
              else {
                  this.cut(paragraph);
              }
          }
      }
      cut(paragraph) {
          const availableWidth = this[this.directionKey.width] - this.lineWidth || 0;
          const guessIndex = Math.ceil((availableWidth / paragraph[this.directionKey.width]) * paragraph.length) || 0;
          const index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, this.frame.wordBreak === 'break-word');
          if (index !== 0) {
              const [p1, p2] = seperateParagraph(paragraph, index);
              this.store(p1);
              this.deal(p2);
          }
          else if (this.lineBuffer.length !== 0) {
              this.send();
              this.deal(paragraph);
          }
      }
  }

  const RICHTEXT_UPDATE_TAG_KEY = [
      'width',
      'height',
      'ellipsis',
      'wordBreak',
      'verticalDirection',
      'maxHeight',
      'maxWidth',
      'textAlign',
      'textBaseline',
      'textConfig',
      'layoutDirection',
      ...GRAPHIC_UPDATE_TAG_KEY
  ];
  class RichText extends Graphic {
      type = 'richtext';
      _frameCache;
      _currentHoverIcon = null;
      constructor(params) {
          super(params);
          this.numberType = RICHTEXT_NUMBER_TYPE;
      }
      get width() {
          return this.attribute.width ?? DefaultRichTextAttribute.width;
      }
      set width(w) {
          if (this.attribute.width === w) {
              return;
          }
          this.attribute.width = w;
          this.addUpdateShapeAndBoundsTag();
      }
      get height() {
          return this.attribute.height ?? DefaultRichTextAttribute.height;
      }
      set height(h) {
          if (this.attribute.height === h) {
              return;
          }
          this.attribute.height = h;
          this.addUpdateShapeAndBoundsTag();
      }
      get maxWidth() {
          return this.attribute.maxWidth;
      }
      set maxWidth(mw) {
          if (this.attribute.maxWidth === mw) {
              return;
          }
          this.attribute.maxWidth = mw;
          this.addUpdateShapeAndBoundsTag();
      }
      get maxHeight() {
          return this.attribute.maxHeight;
      }
      set maxHeight(mh) {
          if (this.attribute.maxHeight === mh) {
              return;
          }
          this.attribute.maxHeight = mh;
          this.addUpdateShapeAndBoundsTag();
      }
      get ellipsis() {
          return this.attribute.ellipsis ?? DefaultRichTextAttribute.ellipsis;
      }
      set ellipsis(e) {
          if (this.attribute.ellipsis === e) {
              return;
          }
          this.attribute.ellipsis = e;
          this.addUpdateShapeAndBoundsTag();
      }
      get wordBreak() {
          return this.attribute.wordBreak ?? DefaultRichTextAttribute.wordBreak;
      }
      set wordBreak(wb) {
          if (this.attribute.wordBreak === wb) {
              return;
          }
          this.attribute.wordBreak = wb;
          this.addUpdateShapeAndBoundsTag();
      }
      get verticalDirection() {
          return this.attribute.verticalDirection ?? DefaultRichTextAttribute.verticalDirection;
      }
      set verticalDirection(vd) {
          if (this.attribute.verticalDirection === vd) {
              return;
          }
          this.attribute.verticalDirection = vd;
          this.addUpdateShapeAndBoundsTag();
      }
      get textAlign() {
          return this.attribute.textAlign ?? DefaultRichTextAttribute.textAlign;
      }
      set textAlign(align) {
          if (this.attribute.textAlign === align) {
              return;
          }
          this.attribute.textAlign = align;
          this.addUpdateShapeAndBoundsTag();
      }
      get textBaseline() {
          return this.attribute.textBaseline ?? DefaultRichTextAttribute.textBaseline;
      }
      set textBaseline(baseline) {
          if (this.attribute.textBaseline === baseline) {
              return;
          }
          this.attribute.textBaseline = baseline;
          this.addUpdateShapeAndBoundsTag();
      }
      get textConfig() {
          return this.attribute.textConfig ?? DefaultRichTextAttribute.textConfig;
      }
      set textConfig(config) {
          this.attribute.textConfig = config;
          this.addUpdateShapeAndBoundsTag();
      }
      doUpdateAABBBounds() {
          const richTextTheme = getTheme(this).richtext;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateRichTextAABBBounds(attribute, getTheme(this).richtext, this._AABBBounds, this);
          const { boundsPadding = richTextTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      getDefaultAttribute(name) {
          return DefaultRichTextAttribute[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < RICHTEXT_UPDATE_TAG_KEY.length; i++) {
              const attrKey = RICHTEXT_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < RICHTEXT_UPDATE_TAG_KEY.length; i++) {
              const attrKey = RICHTEXT_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      getFrameCache() {
          if (this.shouldUpdateShape()) {
              this.doUpdateFrameCache();
              this.clearUpdateShapeTag();
          }
          return this._frameCache;
      }
      doUpdateFrameCache() {
          const { textConfig, maxWidth, maxHeight, width, height, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection, singleLine } = this.attribute;
          const paragraphs = [];
          for (let i = 0; i < textConfig.length; i++) {
              if ('image' in textConfig[i]) {
                  const config = textConfig[i];
                  const iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
                  if (iconCache) {
                      paragraphs.push(iconCache);
                  }
                  else {
                      const icon = new RichTextIcon(config);
                      icon.successCallback = () => {
                          this.addUpdateBoundTag();
                          this.stage?.renderNextFrame();
                      };
                      icon.richtextId = config.id;
                      paragraphs.push(icon);
                  }
              }
              else if (textConfig[i].text.includes('\n')) {
                  const textParts = textConfig[i].text.split('\n');
                  for (let j = 0; j < textParts.length; j++) {
                      paragraphs.push(new Paragraph(textParts[j], j !== 0, textConfig[i]));
                  }
              }
              else {
                  paragraphs.push(new Paragraph(textConfig[i].text, false, textConfig[i]));
              }
          }
          const frameHeight = typeof maxHeight === 'number' && (!height || height > maxHeight)
              ? maxHeight
              : height;
          const frameWidth = typeof maxWidth === 'number' && (!width || width > maxWidth)
              ? maxWidth
              : width;
          const frame = new Frame(0, 0, frameWidth || 0, frameHeight || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || 'horizontal', typeof maxWidth === 'number' && (!width || width > maxWidth), typeof maxHeight === 'number' && (!height || height > maxHeight), singleLine || false, this._frameCache?.icons);
          const wrapper = new Wrapper(frame);
          for (let i = 0; i < paragraphs.length; i++) {
              wrapper.deal(paragraphs[i]);
          }
          wrapper.send();
          this._frameCache = frame;
      }
      clone() {
          return new RichText({ ...this.attribute });
      }
      setStage(stage, layer) {
          super.setStage(stage, layer);
          const frameCache = this.getFrameCache();
          frameCache.icons.forEach(icon => {
              icon.setStage(stage, layer);
          });
      }
      bindIconEvent() {
          this.addEventListener('pointermove', (e) => {
              const pickedIcon = this.pickIcon(e.global);
              if (pickedIcon && pickedIcon === this._currentHoverIcon) ;
              else if (pickedIcon) {
                  this._currentHoverIcon?.setHoverState(false);
                  this._currentHoverIcon = pickedIcon;
                  this._currentHoverIcon.setHoverState(true);
                  this.stage?.setCursor(pickedIcon.attribute.cursor);
                  this.stage?.renderNextFrame();
              }
              else if (!pickedIcon && this._currentHoverIcon) {
                  this._currentHoverIcon.setHoverState(false);
                  this._currentHoverIcon = null;
                  this.stage?.setCursor();
                  this.stage?.renderNextFrame();
              }
          });
          this.addEventListener('pointerleave', (e) => {
              if (this._currentHoverIcon) {
                  this._currentHoverIcon.setHoverState(false);
                  this._currentHoverIcon = null;
                  this.stage?.setCursor();
                  this.stage?.renderNextFrame();
              }
          });
      }
      pickIcon(point) {
          const frameCache = this.getFrameCache();
          const { e: x, f: y } = this.globalTransMatrix;
          let pickIcon;
          frameCache.icons.forEach(icon => {
              if (icon.AABBBounds.containsPoint({ x: point.x - x, y: point.y - y })) {
                  pickIcon = icon;
                  pickIcon.globalX = (pickIcon.attribute.x ?? 0) + x;
                  pickIcon.globalY = (pickIcon.attribute.y ?? 0) + y;
              }
          });
          return pickIcon;
      }
  }

  const PATH_UPDATE_TAG_KEY = ['path', 'customPath', ...GRAPHIC_UPDATE_TAG_KEY];
  class Path extends Graphic {
      type = 'path';
      cache;
      constructor(params) {
          super(params);
          this.numberType = PATH_NUMBER_TYPE;
      }
      get pathShape() {
          this.tryUpdateAABBBounds();
          return this.getParsedPathShape();
      }
      isValid() {
          return super.isValid() && this._isValid();
      }
      _isValid() {
          const { path } = this.attribute;
          return path != null && path !== '';
      }
      getParsedPathShape() {
          const pathTheme = getTheme(this).path;
          if (!this.valid) {
              return pathTheme.path;
          }
          const attribute = this.attribute;
          if (attribute.path instanceof CustomPath2D) {
              return attribute.path;
          }
          if (isNil(this.cache)) {
              this.doUpdatePathShape();
          }
          if (this.cache instanceof CustomPath2D) {
              return this.cache;
          }
          return pathTheme.path;
      }
      doUpdateAABBBounds() {
          const pathTheme = getTheme(this).path;
          this.doUpdatePathShape();
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updatePathAABBBounds(attribute, getTheme(this).path, this._AABBBounds, this);
          const { boundsPadding = pathTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      doUpdatePathShape() {
          const attribute = this.attribute;
          if (isString(attribute.path, true)) {
              this.cache = new CustomPath2D().fromString(attribute.path);
          }
          else if (attribute.customPath) {
              this.cache = new CustomPath2D();
              attribute.customPath(this.cache, this);
          }
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      getDefaultAttribute(name) {
          const pathTheme = getTheme(this).path;
          return pathTheme[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < PATH_UPDATE_TAG_KEY.length; i++) {
              const attrKey = PATH_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < PATH_UPDATE_TAG_KEY.length; i++) {
              const attrKey = PATH_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      toCustomPath() {
          const x = 0;
          const y = 0;
          return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), x, y);
      }
      clone() {
          return new Path({ ...this.attribute });
      }
  }

  const AREA_UPDATE_TAG_KEY = ['segments', 'points', 'curveType', ...GRAPHIC_UPDATE_TAG_KEY];
  class Area extends Graphic {
      type = 'area';
      cache;
      constructor(params) {
          super(params);
          this.numberType = AREA_NUMBER_TYPE;
      }
      isValid() {
          return super.isValid() && this._isValid();
      }
      _isValid() {
          const { points, segments } = this.attribute;
          if (segments) {
              if (segments.length === 0) {
                  return false;
              }
              return true;
          }
          else if (points) {
              if (points.length === 0) {
                  return false;
              }
              return true;
          }
          return false;
      }
      doUpdateAABBBounds() {
          const areaTheme = getTheme(this).area;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateAreaAABBBounds(attribute, getTheme(this).area, this._AABBBounds, this);
          const { boundsPadding = areaTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
          if (key === 'points') {
              nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio);
          }
      }
      getDefaultAttribute(name) {
          const areaTheme = getTheme(this).area;
          return areaTheme[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < AREA_UPDATE_TAG_KEY.length; i++) {
              const attrKey = AREA_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < AREA_UPDATE_TAG_KEY.length; i++) {
              const attrKey = AREA_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      toCustomPath() {
          const path = new CustomPath2D();
          const attribute = this.attribute;
          const segments = attribute.segments;
          const parsePoints = (points) => {
              if (points && points.length) {
                  let isFirst = true;
                  const basePoints = [];
                  points.forEach(point => {
                      if (point.defined === false) {
                          return;
                      }
                      if (isFirst) {
                          path.moveTo(point.x, point.y);
                      }
                      else {
                          path.lineTo(point.x, point.y);
                      }
                      basePoints.push({ x: point.x1 ?? point.x, y: point.y1 ?? point.y });
                      isFirst = false;
                  });
                  if (basePoints.length) {
                      for (let i = basePoints.length - 1; i >= 0; i--) {
                          path.lineTo(basePoints[i].x, basePoints[i].y);
                      }
                      path.closePath();
                  }
              }
          };
          if (attribute.points) {
              parsePoints(attribute.points);
          }
          else if (segments && segments.length) {
              segments.forEach(seg => {
                  parsePoints(seg.points);
              });
          }
          return path;
      }
      clone() {
          return new Area({ ...this.attribute });
      }
  }

  const ARC_UPDATE_TAG_KEY = [
      'innerRadius',
      'outerRadius',
      'startAngle',
      'endAngle',
      'cornerRadius',
      'padAngle',
      'padRadius',
      'cap',
      ...GRAPHIC_UPDATE_TAG_KEY
  ];
  class Arc extends Graphic {
      type = 'arc';
      constructor(params) {
          super(params);
          this.numberType = ARC_NUMBER_TYPE;
      }
      isValid() {
          return super.isValid() && this._isValid();
      }
      _isValid() {
          const { startAngle, endAngle, outerRadius, innerRadius } = this.attribute;
          return (this._validNumber(startAngle) &&
              this._validNumber(endAngle) &&
              this._validNumber(outerRadius) &&
              this._validNumber(innerRadius));
      }
      getParsedCornerRadius() {
          const arcTheme = getTheme(this).arc;
          const { cornerRadius = arcTheme.cornerRadius, outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
          if (cornerRadius === 0 || cornerRadius === '0%') {
              return 0;
          }
          const deltaRadius = Math.abs(outerRadius - innerRadius);
          return Math.min(isNumber(cornerRadius, true)
              ? cornerRadius
              : (deltaRadius * parseFloat(cornerRadius)) / 100, deltaRadius / 2);
      }
      getParsedAngle() {
          const arcTheme = getTheme(this).arc;
          let { startAngle = arcTheme.startAngle, endAngle = arcTheme.endAngle } = this.attribute;
          const { cap = arcTheme.cap } = this.attribute;
          const sign = endAngle - startAngle >= 0 ? 1 : -1;
          const deltaAngle = endAngle - startAngle;
          startAngle = clampAngleByRadian(startAngle);
          endAngle = startAngle + deltaAngle;
          if (cap && abs(deltaAngle) < pi2 - epsilon) {
              let startCap = 1;
              let endCap = 1;
              if (cap.length) {
                  startCap = Number(cap[0]);
                  endCap = Number(cap[1]);
              }
              const { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
              const capWidth = Math.abs(outerRadius - innerRadius) / 2;
              const capAngle = capWidth / outerRadius;
              if (capWidth > epsilon && outerRadius > epsilon) {
                  return {
                      startAngle: startAngle - sign * capAngle * startCap,
                      endAngle: endAngle + sign * capAngle * endCap
                  };
              }
          }
          return {
              startAngle: startAngle,
              endAngle: endAngle
          };
      }
      getParsePadAngle(startAngle, endAngle) {
          const arcTheme = getTheme(this).arc;
          const { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius, padAngle = arcTheme.padAngle } = this.attribute;
          const { padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius) } = this.attribute;
          const deltaAngle = abs(endAngle - startAngle);
          let outerStartAngle = startAngle;
          let outerEndAngle = endAngle;
          let innerStartAngle = startAngle;
          let innerEndAngle = endAngle;
          const halfPadAngle = padAngle / 2;
          let innerDeltaAngle = deltaAngle;
          let outerDeltaAngle = deltaAngle;
          if (halfPadAngle > epsilon && padRadius > epsilon) {
              const sign = endAngle > startAngle ? 1 : -1;
              let p0 = asin((Number(padRadius) / innerRadius) * sin(halfPadAngle));
              let p1 = asin((Number(padRadius) / outerRadius) * sin(halfPadAngle));
              if ((innerDeltaAngle -= p0 * 2) > epsilon) {
                  p0 *= sign;
                  innerStartAngle += p0;
                  innerEndAngle -= p0;
              }
              else {
                  innerDeltaAngle = 0;
                  innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2;
              }
              if ((outerDeltaAngle -= p1 * 2) > epsilon) {
                  p1 *= sign;
                  outerStartAngle += p1;
                  outerEndAngle -= p1;
              }
              else {
                  outerDeltaAngle = 0;
                  outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2;
              }
              return {
                  outerStartAngle,
                  outerEndAngle,
                  innerStartAngle,
                  innerEndAngle,
                  innerDeltaAngle,
                  outerDeltaAngle
              };
          }
          return {
              outerStartAngle,
              outerEndAngle,
              innerStartAngle,
              innerEndAngle,
              innerDeltaAngle,
              outerDeltaAngle
          };
      }
      doUpdateAABBBounds(full) {
          const arcTheme = getTheme(this).arc;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateArcAABBBounds(attribute, getTheme(this).arc, this._AABBBounds, full, this);
          const { boundsPadding = arcTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return bounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      needUpdateTags(keys) {
          for (let i = 0; i < ARC_UPDATE_TAG_KEY.length; i++) {
              const attrKey = ARC_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < ARC_UPDATE_TAG_KEY.length; i++) {
              const attrKey = ARC_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      getDefaultAttribute(name) {
          const arcTheme = getTheme(this).arc;
          return arcTheme[name];
      }
      toCustomPath() {
          const x = 0;
          const y = 0;
          const attribute = this.attribute;
          const { startAngle, endAngle } = this.getParsedAngle();
          let innerRadius = attribute.innerRadius;
          let outerRadius = attribute.outerRadius;
          const deltaAngle = abs(endAngle - startAngle);
          const clockwise = endAngle > startAngle;
          if (outerRadius < innerRadius) {
              const temp = outerRadius;
              outerRadius = innerRadius;
              innerRadius = temp;
          }
          const path = new CustomPath2D();
          if (outerRadius <= epsilon) {
              path.moveTo(x, y);
          }
          else if (deltaAngle >= pi2 - epsilon) {
              path.moveTo(x + outerRadius * cos(startAngle), y + outerRadius * sin(startAngle));
              path.arc(x, y, outerRadius, startAngle, endAngle, !clockwise);
              if (innerRadius > epsilon) {
                  path.moveTo(x + innerRadius * cos(endAngle), y + innerRadius * sin(endAngle));
                  path.arc(x, y, innerRadius, endAngle, startAngle, clockwise);
              }
          }
          else {
              const xors = outerRadius * cos(startAngle);
              const yors = outerRadius * sin(startAngle);
              const xire = innerRadius * cos(endAngle);
              const yire = innerRadius * sin(endAngle);
              path.moveTo(x + xors, y + yors);
              path.arc(x, y, outerRadius, startAngle, endAngle, !clockwise);
              path.lineTo(x + xire, y + yire);
              path.arc(x, y, innerRadius, endAngle, startAngle, clockwise);
              path.closePath();
          }
          return path;
      }
      clone() {
          return new Arc({ ...this.attribute });
      }
  }

  class Arc3d extends Arc {
      type = 'arc3d';
      constructor(params) {
          super(params);
          this.numberType = ARC3D_NUMBER_TYPE;
      }
      doUpdateAABBBounds() {
          const polygonTheme = getTheme(this).arc;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updateArc3dAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this);
          const { boundsPadding = polygonTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return this._AABBBounds;
      }
  }

  const POLYGON_UPDATE_TAG_KEY = ['points', 'cornerRadius', ...GRAPHIC_UPDATE_TAG_KEY];
  class Polygon extends Graphic {
      type = 'polygon';
      constructor(params) {
          super(params);
          this.numberType = POLYGON_NUMBER_TYPE;
      }
      isValid() {
          return super.isValid() && this._isValid();
      }
      _isValid() {
          const { points } = this.attribute;
          return points && points.length >= 2;
      }
      doUpdateAABBBounds() {
          const polygonTheme = getTheme(this).polygon;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updatePolygonAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this);
          const { boundsPadding = polygonTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return this._AABBBounds;
      }
      tryUpdateOBBBounds() {
          throw new Error('');
      }
      _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
          if (key === 'points') {
              nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio);
          }
      }
      getDefaultAttribute(name) {
          const polygonTheme = getTheme(this).polygon;
          return polygonTheme[name];
      }
      needUpdateTags(keys) {
          for (let i = 0; i < POLYGON_UPDATE_TAG_KEY.length; i++) {
              const attrKey = POLYGON_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return false;
      }
      needUpdateTag(key) {
          for (let i = 0; i < POLYGON_UPDATE_TAG_KEY.length; i++) {
              const attrKey = POLYGON_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return false;
      }
      toCustomPath() {
          const points = this.attribute.points;
          const path = new CustomPath2D();
          points.forEach((point, index) => {
              if (index === 0) {
                  path.moveTo(point.x, point.y);
              }
              else {
                  path.lineTo(point.x, point.y);
              }
          });
          path.closePath();
          return path;
      }
      clone() {
          return new Polygon({ ...this.attribute });
      }
  }

  class Pyramid3d extends Polygon {
      type = 'pyramid3d';
      constructor(params) {
          super(params);
          this.numberType = PYRAMID3D_NUMBER_TYPE;
      }
      doUpdateAABBBounds() {
          const polygonTheme = getTheme(this).polygon;
          this._AABBBounds.setValue(Infinity, Infinity, -Infinity, -Infinity);
          const attribute = this.attribute;
          const bounds = application.graphicService.updatePyramid3dAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this);
          const { boundsPadding = polygonTheme.boundsPadding } = attribute;
          const paddingArray = parsePadding(boundsPadding);
          if (paddingArray) {
              bounds.expand(paddingArray);
          }
          this.clearUpdateBoundTag();
          return this._AABBBounds;
      }
      findFace() {
          const { points } = this.attribute;
          const kList = points.map((p, i) => {
              const p1 = i === 3 ? points[0] : points[i + 1];
              const dx = p.x - p1.x;
              if (dx === 0) {
                  return 0;
              }
              return (p.y - p1.y) / dx;
          });
          const pointsMap = points.map(p => ({ p, d: 0 }));
          let find = false;
          let maxD = 0;
          for (let i = 0; i < kList.length - 1; i++) {
              for (let j = i + 1; j < kList.length; j++) {
                  if (kList[i] === kList[j]) {
                      find = true;
                      const d1 = PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
                      pointsMap[i].d = d1;
                      pointsMap[i + 1].d = d1;
                      maxD = max(maxD, d1);
                      const d2 = PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
                      pointsMap[j].d = d2;
                      pointsMap[j + 1].d = d2;
                      maxD = max(maxD, d2);
                  }
                  if (find) {
                      break;
                  }
              }
              if (find) {
                  break;
              }
          }
          for (let i = points.length - 1; i >= 0; i--) {
              const p = points[i];
              pointsMap.unshift({
                  p,
                  d: 0
              });
          }
          for (let i = 0; i < points.length; i++) {
              const delta = (maxD - pointsMap[i + points.length].d) / 2;
              pointsMap[i].d += delta;
              pointsMap[i + points.length].d += delta;
          }
          const faces = { polygons: [], vertices: [], edges: [] };
          pointsMap.forEach(p => {
              faces.vertices.push([p.p.x, p.p.y, p.d]);
          });
          faces.polygons.push({ polygon: [0, 4, 5, 1], normal: [0, -1, 0] });
          faces.polygons.push({ polygon: [7, 6, 2, 3], normal: [0, 1, 0] });
          faces.polygons.push({ polygon: [0, 4, 7, 3], normal: [-1, 0, 0] });
          faces.polygons.push({ polygon: [1, 5, 6, 2], normal: [1, 0, 0] });
          faces.polygons.push({ polygon: [0, 1, 2, 3], normal: [0, 0, -1] });
          faces.polygons.push({ polygon: [4, 5, 6, 7], normal: [0, 0, 1] });
          faces.edges = [
              [0, 1],
              [1, 2],
              [2, 3],
              [3, 0],
              [4, 5],
              [5, 6],
              [6, 7],
              [7, 4],
              [0, 4],
              [3, 7],
              [1, 5],
              [2, 6]
          ];
          return faces;
      }
      _isValid() {
          return super._isValid() && this.attribute.points.length === 4;
      }
  }

  let DefaultOuterBorderBoundsContribution = class DefaultOuterBorderBoundsContribution {
      updateBounds(attribute, theme, aabbBounds, graphic) {
          const { outerBorder, shadowBlur = theme.shadowBlur } = attribute;
          if (outerBorder) {
              const defaultOuterBorder = theme.outerBorder;
              const { distance = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
              aabbBounds.expand(distance + shadowBlur + lineWidth / 2);
          }
          return aabbBounds;
      }
  };
  DefaultOuterBorderBoundsContribution = __decorate([
      injectable()
  ], DefaultOuterBorderBoundsContribution);

  const RectBoundsContribution = Symbol.for('RectBoundsContribution');
  let DefaultRectOuterBorderBoundsContribution = class DefaultRectOuterBorderBoundsContribution extends DefaultOuterBorderBoundsContribution {
  };
  DefaultRectOuterBorderBoundsContribution = __decorate([
      injectable()
  ], DefaultRectOuterBorderBoundsContribution);

  const SymbolBoundsContribution = Symbol.for('SymbolBoundsContribution');
  let DefaultSymbolOuterBorderBoundsContribution = class DefaultSymbolOuterBorderBoundsContribution extends DefaultOuterBorderBoundsContribution {
      updateBounds(attribute, symbolTheme, aabbBounds, graphic) {
          const { outerBorder, shadowBlur = symbolTheme.shadowBlur, strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer } = attribute;
          if (outerBorder) {
              const defaultOuterBorder = symbolTheme.outerBorder;
              const { distance = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
              boundStroke(aabbBounds, distance + shadowBlur + lineWidth / 2, true, strokeBoundsBuffer);
          }
          return aabbBounds;
      }
  };
  DefaultSymbolOuterBorderBoundsContribution = __decorate([
      injectable()
  ], DefaultSymbolOuterBorderBoundsContribution);

  const CircleBoundsContribution = Symbol.for('CircleBoundsContribution');
  let DefaultCircleOuterBorderBoundsContribution = class DefaultCircleOuterBorderBoundsContribution extends DefaultOuterBorderBoundsContribution {
  };
  DefaultCircleOuterBorderBoundsContribution = __decorate([
      injectable()
  ], DefaultCircleOuterBorderBoundsContribution);

  const ArcBoundsContribution = Symbol.for('ArcBoundsContribution');
  let DefaultArcOuterBorderBoundsContribution = class DefaultArcOuterBorderBoundsContribution extends DefaultOuterBorderBoundsContribution {
  };
  DefaultArcOuterBorderBoundsContribution = __decorate([
      injectable()
  ], DefaultArcOuterBorderBoundsContribution);

  const PathBoundsContribution = Symbol.for('PathBoundsContribution');
  let DefaultPathOuterBorderBoundsContribution = class DefaultPathOuterBorderBoundsContribution extends DefaultOuterBorderBoundsContribution {
  };
  DefaultPathOuterBorderBoundsContribution = __decorate([
      injectable()
  ], DefaultPathOuterBorderBoundsContribution);

  function createMat4() {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  class DefaultMatrixAllocate {
      pools = [];
      allocate(a, b, c, d, e, f) {
          if (!this.pools.length) {
              return new Matrix(a, b, c, d, e, f);
          }
          const m = this.pools.pop();
          m.a = a;
          m.b = b;
          m.c = c;
          m.d = d;
          m.e = e;
          m.f = f;
          return m;
      }
      allocateByObj(matrix) {
          if (!this.pools.length) {
              return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
          }
          const m = this.pools.pop();
          m.a = matrix.a;
          m.b = matrix.b;
          m.c = matrix.c;
          m.d = matrix.d;
          m.e = matrix.e;
          m.f = matrix.f;
          return m;
      }
      free(d) {
          this.pools.push(d);
      }
      get length() {
          return this.pools.length;
      }
      release(...params) {
          this.pools = [];
      }
  }
  class DefaultMat4Allocate {
      pools = [];
      static identity(out) {
          out[0] = 1;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = 1;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[10] = 1;
          out[11] = 0;
          out[12] = 0;
          out[13] = 0;
          out[14] = 0;
          out[15] = 1;
          return out;
      }
      allocate() {
          if (!this.pools.length) {
              return createMat4();
          }
          const m = this.pools.pop();
          DefaultMat4Allocate.identity(m);
          return m;
      }
      allocateByObj(d) {
          let m;
          if (!this.pools.length) {
              m = createMat4();
          }
          else {
              m = this.pools.pop();
          }
          for (let i = 0; i < m.length; i++) {
              m[i] = d[i];
          }
          return m;
      }
      free(m) {
          m && this.pools.push(m);
      }
      get length() {
          return this.pools.length;
      }
      release(...params) {
          this.pools = [];
      }
  }
  const matrixAllocate = new DefaultMatrixAllocate();
  const mat4Allocate = new DefaultMat4Allocate();

  function identity(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
  }
  function rotateX(out, a, rad) {
      const s = Math.sin(rad);
      const c = Math.cos(rad);
      const a10 = a[4];
      const a11 = a[5];
      const a12 = a[6];
      const a13 = a[7];
      const a20 = a[8];
      const a21 = a[9];
      const a22 = a[10];
      const a23 = a[11];
      if (a !== out) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
      }
      out[4] = a10 * c + a20 * s;
      out[5] = a11 * c + a21 * s;
      out[6] = a12 * c + a22 * s;
      out[7] = a13 * c + a23 * s;
      out[8] = a20 * c - a10 * s;
      out[9] = a21 * c - a11 * s;
      out[10] = a22 * c - a12 * s;
      out[11] = a23 * c - a13 * s;
      return out;
  }
  function rotateY(out, a, rad) {
      const s = Math.sin(rad);
      const c = Math.cos(rad);
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a20 = a[8];
      const a21 = a[9];
      const a22 = a[10];
      const a23 = a[11];
      if (a !== out) {
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
      }
      out[0] = a00 * c - a20 * s;
      out[1] = a01 * c - a21 * s;
      out[2] = a02 * c - a22 * s;
      out[3] = a03 * c - a23 * s;
      out[8] = a00 * s + a20 * c;
      out[9] = a01 * s + a21 * c;
      out[10] = a02 * s + a22 * c;
      out[11] = a03 * s + a23 * c;
      return out;
  }
  function rotateZ(out, a, rad) {
      const s = Math.sin(rad);
      const c = Math.cos(rad);
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a10 = a[4];
      const a11 = a[5];
      const a12 = a[6];
      const a13 = a[7];
      if (a !== out) {
          out[8] = a[8];
          out[9] = a[9];
          out[10] = a[10];
          out[11] = a[11];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
      }
      out[0] = a00 * c + a10 * s;
      out[1] = a01 * c + a11 * s;
      out[2] = a02 * c + a12 * s;
      out[3] = a03 * c + a13 * s;
      out[4] = a10 * c - a00 * s;
      out[5] = a11 * c - a01 * s;
      out[6] = a12 * c - a02 * s;
      out[7] = a13 * c - a03 * s;
      return out;
  }
  function translate(out, a, v) {
      const x = v[0];
      const y = v[1];
      const z = v[2];
      let a00;
      let a01;
      let a02;
      let a03;
      let a10;
      let a11;
      let a12;
      let a13;
      let a20;
      let a21;
      let a22;
      let a23;
      if (a === out) {
          out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      }
      else {
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          out[0] = a00;
          out[1] = a01;
          out[2] = a02;
          out[3] = a03;
          out[4] = a10;
          out[5] = a11;
          out[6] = a12;
          out[7] = a13;
          out[8] = a20;
          out[9] = a21;
          out[10] = a22;
          out[11] = a23;
          out[12] = a00 * x + a10 * y + a20 * z + a[12];
          out[13] = a01 * x + a11 * y + a21 * z + a[13];
          out[14] = a02 * x + a12 * y + a22 * z + a[14];
          out[15] = a03 * x + a13 * y + a23 * z + a[15];
      }
      return out;
  }
  function mat3Tomat4(out, b) {
      out[0] = b.a;
      out[1] = b.b;
      out[2] = 0;
      out[3] = 0;
      out[4] = b.c;
      out[5] = b.d;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = b.e;
      out[13] = b.f;
      out[14] = 0;
      out[15] = 1;
  }
  function multiplyMat4Mat3(out, a, b) {
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a10 = a[4];
      const a11 = a[5];
      const a12 = a[6];
      const a13 = a[7];
      const a20 = a[8];
      const a21 = a[9];
      const a22 = a[10];
      const a23 = a[11];
      const a30 = a[12];
      const a31 = a[13];
      const a32 = a[14];
      const a33 = a[15];
      let b0 = b.a;
      let b1 = b.b;
      let b2 = 0;
      let b3 = 0;
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b.c;
      b1 = b.d;
      b2 = 0;
      b3 = 0;
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = 0;
      b1 = 0;
      b2 = 1;
      b3 = 0;
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b.e;
      b1 = b.f;
      b2 = 0;
      b3 = 1;
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
  }
  function scale(out, a, v) {
      const x = v[0];
      const y = v[1];
      const z = v[2];
      out[0] = a[0] * x;
      out[1] = a[1] * x;
      out[2] = a[2] * x;
      out[3] = a[3] * x;
      out[4] = a[4] * y;
      out[5] = a[5] * y;
      out[6] = a[6] * y;
      out[7] = a[7] * y;
      out[8] = a[8] * z;
      out[9] = a[9] * z;
      out[10] = a[10] * z;
      out[11] = a[11] * z;
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
  }
  function multiplyMat4Mat4(out, a, b) {
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a10 = a[4];
      const a11 = a[5];
      const a12 = a[6];
      const a13 = a[7];
      const a20 = a[8];
      const a21 = a[9];
      const a22 = a[10];
      const a23 = a[11];
      const a30 = a[12];
      const a31 = a[13];
      const a32 = a[14];
      const a33 = a[15];
      let b0 = b[0];
      let b1 = b[1];
      let b2 = b[2];
      let b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
  }
  function getExtraModelMatrix(dx, dy, graphic) {
      const { alpha, beta } = graphic.attribute;
      if (!alpha && !beta) {
          return null;
      }
      const { anchor3d = graphic.attribute.anchor } = graphic.attribute;
      const _anchor = [0, 0];
      if (anchor3d) {
          if (typeof anchor3d[0] === 'string') {
              const ratio = parseFloat(anchor3d[0]) / 100;
              const bounds = graphic.AABBBounds;
              _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
          }
          else {
              _anchor[0] = anchor3d[0];
          }
          if (typeof anchor3d[1] === 'string') {
              const ratio = parseFloat(anchor3d[1]) / 100;
              const bounds = graphic.AABBBounds;
              _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
          }
          else {
              _anchor[1] = anchor3d[1];
          }
      }
      if (graphic.type === 'text') {
          const { textAlign } = graphic.attribute;
          _anchor[0] += textDrawOffsetX(textAlign, graphic.clipedWidth);
      }
      _anchor[0] += dx;
      _anchor[1] += dy;
      const modelMatrix = mat4Allocate.allocate();
      translate(modelMatrix, modelMatrix, [_anchor[0], _anchor[1], 0]);
      if (beta) {
          rotateX(modelMatrix, modelMatrix, beta);
      }
      if (alpha) {
          rotateY(modelMatrix, modelMatrix, alpha);
      }
      translate(modelMatrix, modelMatrix, [-_anchor[0], -_anchor[1], 0]);
      return modelMatrix;
  }
  function getModelMatrix(out, graphic, theme) {
      const { x = theme.x, y = theme.y, z = theme.z, dx = theme.dx, dy = theme.dy, dz = theme.dz, scaleX = theme.scaleX, scaleY = theme.scaleY, scaleZ = theme.scaleZ, alpha = theme.alpha, beta = theme.beta, angle = theme.angle, anchor3d = graphic.attribute.anchor, anchor } = graphic.attribute;
      const _anchor = [0, 0, 0];
      if (anchor3d) {
          if (typeof anchor3d[0] === 'string') {
              const ratio = parseFloat(anchor3d[0]) / 100;
              const bounds = graphic.AABBBounds;
              _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
          }
          else {
              _anchor[0] = anchor3d[0];
          }
          if (typeof anchor3d[1] === 'string') {
              const ratio = parseFloat(anchor3d[1]) / 100;
              const bounds = graphic.AABBBounds;
              _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
          }
          else {
              _anchor[1] = anchor3d[1];
          }
          _anchor[2] = anchor3d[2] ?? 0;
      }
      identity(out);
      translate(out, out, [x + dx, y + dy, z + dz]);
      translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]);
      rotateX(out, out, beta);
      rotateY(out, out, alpha);
      translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]);
      scale(out, out, [scaleX, scaleY, scaleZ]);
      if (angle) {
          const m = mat4Allocate.allocate();
          const _anchor = [0, 0];
          if (anchor) {
              if (typeof anchor3d[0] === 'string') {
                  const ratio = parseFloat(anchor3d[0]) / 100;
                  const bounds = graphic.AABBBounds;
                  _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
              }
              else {
                  _anchor[0] = anchor3d[0];
              }
              if (typeof anchor3d[1] === 'string') {
                  const ratio = parseFloat(anchor3d[1]) / 100;
                  const bounds = graphic.AABBBounds;
                  _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
              }
              else {
                  _anchor[1] = anchor3d[1];
              }
          }
          translate(m, m, [_anchor[0], _anchor[1], 0]);
          rotateZ(m, m, angle);
          translate(m, m, [-_anchor[0], -_anchor[1], 0]);
          multiplyMat4Mat4(out, out, m);
      }
  }
  function shouldUseMat4(graphic) {
      const { alpha, beta } = graphic.attribute;
      return alpha || beta;
  }
  exports.DefaultGraphicService = class DefaultGraphicService {
      creator;
      rectBoundsContribitions;
      symbolBoundsContribitions;
      circleBoundsContribitions;
      arcBoundsContribitions;
      pathBoundsContribitions;
      _rectBoundsContribitions;
      _symbolBoundsContribitions;
      _circleBoundsContribitions;
      _arcBoundsContribitions;
      _pathBoundsContribitions;
      tempAABBBounds1;
      tempAABBBounds2;
      constructor(creator, rectBoundsContribitions, symbolBoundsContribitions, circleBoundsContribitions, arcBoundsContribitions, pathBoundsContribitions) {
          this.creator = creator;
          this.rectBoundsContribitions = rectBoundsContribitions;
          this.symbolBoundsContribitions = symbolBoundsContribitions;
          this.circleBoundsContribitions = circleBoundsContribitions;
          this.arcBoundsContribitions = arcBoundsContribitions;
          this.pathBoundsContribitions = pathBoundsContribitions;
          this.hooks = {
              onAttributeUpdate: new SyncHook(['graphic']),
              onSetStage: new SyncHook(['graphic', 'stage']),
              onRemove: new SyncHook(['graphic']),
              onAddIncremental: new SyncHook(['graphic', 'group', 'stage']),
              onClearIncremental: new SyncHook(['graphic', 'group', 'stage']),
              beforeUpdateAABBBounds: new SyncHook([
                  'graphic',
                  'stage',
                  'willUpdate',
                  'aabbBounds'
              ]),
              afterUpdateAABBBounds: new SyncHook([
                  'graphic',
                  'stage',
                  'aabbBounds',
                  'globalAABBBounds',
                  'selfChange'
              ])
          };
          this.tempAABBBounds1 = new AABBBounds();
          this.tempAABBBounds2 = new AABBBounds();
      }
      onAttributeUpdate(graphic) {
          if (this.hooks.onAttributeUpdate.taps.length) {
              this.hooks.onAttributeUpdate.call(graphic);
          }
      }
      onSetStage(graphic, stage) {
          if (this.hooks.onSetStage.taps.length) {
              this.hooks.onSetStage.call(graphic, stage);
          }
      }
      onRemove(graphic) {
          if (this.hooks.onRemove.taps.length) {
              this.hooks.onRemove.call(graphic);
          }
      }
      onAddIncremental(graphic, group, stage) {
          if (this.hooks.onAddIncremental.taps.length) {
              this.hooks.onAddIncremental.call(graphic, group, stage);
          }
      }
      onClearIncremental(group, stage) {
          if (this.hooks.onClearIncremental.taps.length) {
              this.hooks.onClearIncremental.call(group, stage);
          }
      }
      beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
          if (this.hooks.beforeUpdateAABBBounds.taps.length) {
              this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
          }
      }
      afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {
          if (this.hooks.afterUpdateAABBBounds.taps.length) {
              this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);
          }
      }
      updatePathProxyAABBBounds(aabbBounds, graphic) {
          const path = typeof graphic.pathProxy === 'function' ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
          if (!path) {
              return false;
          }
          const boundsContext = new BoundsContext(aabbBounds);
          renderCommandList(path.commandList, boundsContext, 0, 0);
          return true;
      }
      updateRectAABBBounds(attribute, rectTheme, aabbBounds, graphic) {
          if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
              const { width = rectTheme.width, height = rectTheme.height } = attribute;
              aabbBounds.set(0, 0, width, height);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          if (!this._rectBoundsContribitions) {
              this._rectBoundsContribitions = this.rectBoundsContribitions.getContributions() || [];
          }
          this._rectBoundsContribitions.length &&
              this._rectBoundsContribitions.forEach(c => {
                  c.updateBounds(attribute, rectTheme, tb1, graphic);
                  aabbBounds.union(tb1);
                  tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
              });
          this.transformAABBBounds(attribute, aabbBounds, rectTheme, false, graphic);
          return aabbBounds;
      }
      updateGroupAABBBounds(attribute, groupTheme, aabbBounds, graphic) {
          const { width, height, path, clip = groupTheme.clip } = attribute;
          if (path && path.length) {
              path.forEach(g => {
                  aabbBounds.union(g.AABBBounds);
              });
          }
          else if (width != null && height != null) {
              aabbBounds.set(0, 0, width, height);
          }
          if (!clip) {
              graphic.forEachChildren((node) => {
                  aabbBounds.union(node.AABBBounds);
              });
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          this.transformAABBBounds(attribute, aabbBounds, groupTheme, false, graphic);
          return aabbBounds;
      }
      updateGlyphAABBBounds(attribute, theme, aabbBounds, graphic) {
          graphic.getSubGraphic().forEach((node) => {
              aabbBounds.union(node.AABBBounds);
          });
          return aabbBounds;
      }
      updateRichTextAABBBounds(attribute, richtextTheme, aabbBounds, graphic) {
          if (!graphic) {
              return aabbBounds;
          }
          const { width = richtextTheme.width, height = richtextTheme.height, maxWidth = richtextTheme.maxWidth, maxHeight = richtextTheme.maxHeight, textAlign = richtextTheme.textAlign, textBaseline = richtextTheme.textBaseline } = attribute;
          if (width > 0 && height > 0) {
              aabbBounds.set(0, 0, width, height);
          }
          else {
              const frameCache = graphic.getFrameCache();
              const { width: actualWidth, height: actualHeight } = frameCache.getActualSize();
              let contentWidth = width || actualWidth || 0;
              let contentHeight = height || actualHeight || 0;
              contentHeight = typeof maxHeight === 'number' && contentHeight > maxHeight ? maxHeight : contentHeight || 0;
              contentWidth = typeof maxWidth === 'number' && contentWidth > maxWidth ? maxWidth : contentWidth || 0;
              aabbBounds.set(0, 0, contentWidth, contentHeight);
          }
          let deltaY = 0;
          switch (textBaseline) {
              case 'top':
                  deltaY = 0;
                  break;
              case 'middle':
                  deltaY = -aabbBounds.height() / 2;
                  break;
              case 'bottom':
                  deltaY = -aabbBounds.height();
                  break;
          }
          let deltaX = 0;
          switch (textAlign) {
              case 'left':
                  deltaX = 0;
                  break;
              case 'center':
                  deltaX = -aabbBounds.width() / 2;
                  break;
              case 'right':
                  deltaX = -aabbBounds.width();
                  break;
          }
          aabbBounds.translate(deltaX, deltaY);
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          this.transformAABBBounds(attribute, aabbBounds, richtextTheme, false, graphic);
          return aabbBounds;
      }
      updateTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
          if (!graphic) {
              return aabbBounds;
          }
          const { text = textTheme.text } = graphic.attribute;
          if (Array.isArray(text)) {
              graphic.updateMultilineAABBBounds(text);
          }
          else {
              graphic.updateSingallineAABBBounds(text);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          transformBoundsWithMatrix(aabbBounds, aabbBounds, graphic.transMatrix);
          return aabbBounds;
      }
      updatePathAABBBounds(attribute, pathTheme, aabbBounds, graphic) {
          if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
              this.updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          if (!this._pathBoundsContribitions) {
              this._pathBoundsContribitions = this.pathBoundsContribitions.getContributions() || [];
          }
          this._pathBoundsContribitions.length &&
              this._pathBoundsContribitions.forEach(c => {
                  c.updateBounds(attribute, pathTheme, tb1, graphic);
                  aabbBounds.union(tb1);
                  tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
              });
          const { lineJoin = pathTheme.lineJoin } = attribute;
          this.transformAABBBounds(attribute, aabbBounds, pathTheme, lineJoin === 'miter', graphic);
          return aabbBounds;
      }
      updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic) {
          if (!graphic) {
              return aabbBounds;
          }
          const pathShape = graphic.getParsedPathShape();
          aabbBounds.union(pathShape.getBounds());
          return aabbBounds;
      }
      updatePyramid3dAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
          if (!graphic) {
              return aabbBounds;
          }
          const stage = graphic.stage;
          if (!stage || !stage.camera) {
              return aabbBounds;
          }
          const faces = graphic.findFace();
          faces.vertices.forEach(v => {
              const x = v[0];
              const y = v[1];
              aabbBounds.add(x, y);
          });
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          this.transformAABBBounds(attribute, aabbBounds, polygonTheme, false, graphic);
          return aabbBounds;
      }
      updateArc3dAABBBounds(attribute, arcTheme, aabbBounds, graphic) {
          if (!graphic) {
              return aabbBounds;
          }
          const stage = graphic.stage;
          if (!stage || !stage.camera) {
              return aabbBounds;
          }
          const { outerRadius = arcTheme.outerRadius, height = 0 } = attribute;
          const r = outerRadius + height;
          aabbBounds.setValue(-r, -r, r, r);
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          this.transformAABBBounds(attribute, aabbBounds, arcTheme, false, graphic);
          return aabbBounds;
      }
      updatePolygonAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
          if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
              this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          const { lineJoin = polygonTheme.lineJoin } = attribute;
          this.transformAABBBounds(attribute, aabbBounds, polygonTheme, lineJoin === 'miter', graphic);
          return aabbBounds;
      }
      updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic) {
          const { points = polygonTheme.points } = attribute;
          points.forEach(p => {
              aabbBounds.add(p.x, p.y);
          });
          return aabbBounds;
      }
      updateLineAABBBounds(attribute, lineTheme, aabbBounds, graphic) {
          if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
              attribute.segments
                  ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic)
                  : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          const { lineJoin = lineTheme.lineJoin } = attribute;
          this.transformAABBBounds(attribute, aabbBounds, lineTheme, lineJoin === 'miter', graphic);
          return aabbBounds;
      }
      updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
          const { points = lineTheme.points } = attribute;
          const b = aabbBounds;
          points.forEach(p => {
              b.add(p.x, p.y);
          });
          return b;
      }
      updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
          const { segments = lineTheme.segments } = attribute;
          const b = aabbBounds;
          segments.forEach(s => {
              s.points.forEach(p => {
                  b.add(p.x, p.y);
              });
          });
          return b;
      }
      updateAreaAABBBounds(attribute, areaTheme, aabbBounds, graphic) {
          if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
              attribute.segments
                  ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic)
                  : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          const { lineJoin = areaTheme.lineJoin } = attribute;
          this.transformAABBBounds(attribute, aabbBounds, areaTheme, lineJoin === 'miter', graphic);
          return aabbBounds;
      }
      updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
          const { points = areaTheme.points } = attribute;
          const b = aabbBounds;
          points.forEach(p => {
              b.add(p.x, p.y);
              b.add(p.x1 ?? p.x, p.y1 ?? p.y);
          });
          return b;
      }
      updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
          const { segments = areaTheme.segments } = attribute;
          const b = aabbBounds;
          segments.forEach(s => {
              s.points.forEach(p => {
                  b.add(p.x, p.y);
                  b.add(p.x1 ?? p.x, p.y1 ?? p.y);
              });
          });
          return b;
      }
      updateCircleAABBBounds(attribute, circleTheme, aabbBounds, full, graphic) {
          if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
              full
                  ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic)
                  : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          if (!this._circleBoundsContribitions) {
              this._circleBoundsContribitions = this.circleBoundsContribitions.getContributions() || [];
          }
          this._circleBoundsContribitions.length &&
              this._circleBoundsContribitions.forEach(c => {
                  c.updateBounds(attribute, circleTheme, tb1, graphic);
                  aabbBounds.union(tb1);
                  tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
              });
          this.transformAABBBounds(attribute, aabbBounds, circleTheme, false, graphic);
          return aabbBounds;
      }
      updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) {
          const { radius = circleTheme.radius } = attribute;
          aabbBounds.set(-radius, -radius, radius, radius);
          return aabbBounds;
      }
      updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic) {
          const { startAngle = circleTheme.startAngle, endAngle = circleTheme.endAngle, radius = circleTheme.radius } = attribute;
          if (endAngle - startAngle > pi2 - epsilon) {
              aabbBounds.set(-radius, -radius, radius, radius);
          }
          else {
              circleBounds(startAngle, endAngle, radius, aabbBounds);
          }
          return aabbBounds;
      }
      updateArcAABBBounds(attribute, arcTheme, aabbBounds, full, graphic) {
          if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
              full
                  ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic)
                  : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          if (!this._arcBoundsContribitions) {
              this._arcBoundsContribitions = this.arcBoundsContribitions.getContributions() || [];
          }
          this._arcBoundsContribitions.length &&
              this._arcBoundsContribitions.forEach(c => {
                  c.updateBounds(attribute, arcTheme, tb1, graphic);
                  aabbBounds.union(tb1);
                  tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
              });
          const { lineJoin = arcTheme.lineJoin } = attribute;
          this.transformAABBBounds(attribute, aabbBounds, arcTheme, lineJoin === 'miter', graphic);
          return aabbBounds;
      }
      updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) {
          const { outerRadius = arcTheme.outerRadius } = attribute;
          aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius);
          return aabbBounds;
      }
      updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic) {
          const { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
          let { endAngle = arcTheme.endAngle, startAngle = arcTheme.startAngle } = attribute;
          if (startAngle > endAngle) {
              const temp = startAngle;
              startAngle = endAngle;
              endAngle = temp;
          }
          if (outerRadius <= epsilon) {
              aabbBounds.set(0, 0, 0, 0);
          }
          else if (Math.abs(endAngle - startAngle) > pi2 - epsilon) {
              aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius);
          }
          else {
              circleBounds(startAngle, endAngle, outerRadius, aabbBounds);
              circleBounds(startAngle, endAngle, innerRadius, aabbBounds);
          }
          return aabbBounds;
      }
      updateSymbolAABBBounds(attribute, symbolTheme, aabbBounds, full, graphic) {
          if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
              full
                  ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic)
                  : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          if (!this._symbolBoundsContribitions) {
              this._symbolBoundsContribitions = this.symbolBoundsContribitions.getContributions() || [];
          }
          this._symbolBoundsContribitions.length &&
              this._symbolBoundsContribitions.forEach(c => {
                  c.updateBounds(attribute, symbolTheme, tb1, graphic);
                  aabbBounds.union(tb1);
                  tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
              });
          const { lineJoin = symbolTheme.lineJoin } = attribute;
          this.transformAABBBounds(attribute, aabbBounds, symbolTheme, lineJoin === 'miter', graphic);
          return aabbBounds;
      }
      updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) {
          const { size = symbolTheme.size } = attribute;
          if (isArray(size)) {
              aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);
          }
          else {
              const halfWH = size / 2;
              aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
          }
          return aabbBounds;
      }
      updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic) {
          if (!graphic) {
              return aabbBounds;
          }
          const { size = symbolTheme.size } = attribute;
          const symbolClass = graphic.getParsedPath();
          symbolClass.bounds(size, aabbBounds);
          return aabbBounds;
      }
      updateImageAABBBounds(attribute, imageTheme, aabbBounds, graphic) {
          if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
              const { width = imageTheme.width, height = imageTheme.height } = attribute;
              aabbBounds.set(0, 0, width, height);
          }
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
          this.transformAABBBounds(attribute, aabbBounds, imageTheme, false, graphic);
          return aabbBounds;
      }
      combindShadowAABBBounds(bounds, graphic) {
          if (graphic && graphic.shadowRoot) {
              const b = graphic.shadowRoot.AABBBounds;
              bounds.union(b);
          }
      }
      transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {
          const { scaleX = theme.scaleX, scaleY = theme.scaleY, stroke = theme.stroke, shadowBlur = theme.shadowBlur, lineWidth = theme.lineWidth, strokeBoundsBuffer = theme.strokeBoundsBuffer } = attribute;
          const tb1 = this.tempAABBBounds1;
          const tb2 = this.tempAABBBounds2;
          if (stroke) {
              const scaledHalfLineWidth = lineWidth / Math.abs(scaleX + scaleY);
              boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer);
              aabbBounds.union(tb1);
              tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
          }
          if (shadowBlur) {
              const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
              boundStroke(tb1, shadowBlurHalfWidth, miter, strokeBoundsBuffer);
              aabbBounds.union(tb1);
          }
          this.combindShadowAABBBounds(aabbBounds, graphic);
          transformBoundsWithMatrix(aabbBounds, aabbBounds, graphic.transMatrix);
      }
  };
  exports.DefaultGraphicService = __decorate([
      injectable(),
      __param(0, inject(GraphicCreator)),
      __param(1, inject(ContributionProvider)),
      __param(1, named(RectBoundsContribution)),
      __param(2, inject(ContributionProvider)),
      __param(2, named(SymbolBoundsContribution)),
      __param(3, inject(ContributionProvider)),
      __param(3, named(CircleBoundsContribution)),
      __param(4, inject(ContributionProvider)),
      __param(4, named(ArcBoundsContribution)),
      __param(5, inject(ContributionProvider)),
      __param(5, named(PathBoundsContribution)),
      __metadata("design:paramtypes", [Object, Object, Object, Object, Object, Object])
  ], exports.DefaultGraphicService);

  class ShadowRoot extends Group {
      type = 'shadowroot';
      constructor(graphic) {
          super({ x: 0, y: 0 });
          this.shadowHost = graphic;
      }
      addUpdateBoundTag() {
          super.addUpdateBoundTag();
          if (this.shadowHost) {
              this.shadowHost.addUpdateBoundTag();
          }
      }
      addUpdateShapeAndBoundsTag() {
          super.addUpdateShapeAndBoundsTag();
          if (this.shadowHost) {
              this.shadowHost.addUpdateBoundTag();
          }
      }
      tryUpdateGlobalTransMatrix(clearTag = true) {
          if (this.shouldUpdateGlobalMatrix()) {
              const m = this.transMatrix;
              if (!this._globalTransMatrix) {
                  this._globalTransMatrix = m.clone();
              }
              else {
                  this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
              }
              this.doUpdateGlobalMatrix();
              clearTag && this.clearUpdateGlobalPositionTag();
          }
          return this._globalTransMatrix;
      }
      doUpdateGlobalMatrix() {
          if (this.shadowHost) {
              const parentMatrix = this.shadowHost.globalTransMatrix;
              this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
          }
      }
      tryUpdateGlobalAABBBounds() {
          if (!this._globalAABBBounds) {
              this._globalAABBBounds = this._AABBBounds.clone();
          }
          else {
              this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2);
          }
          if (this.shadowHost) {
              this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix);
          }
          return this._globalAABBBounds;
      }
  }

  const WRAP_TEXT_UPDATE_TAG_KEY = ['heightLimit', 'lineClamp'];
  class WrapText extends Text {
      _isValid() {
          const { text } = this.attribute;
          if (isArray(text)) {
              return !text.every((t) => t == null || t === '');
          }
          return text != null && text !== '';
      }
      updateMultilineAABBBounds(text) {
          const textTheme = getTheme(this).text;
          const { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, lineHeight = this.attribute.lineHeight || this.attribute.fontSize || textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke = textTheme.stroke, lineWidth = textTheme.lineWidth, heightLimit = 0, lineClamp } = this.attribute;
          const buf = 2;
          if (!this.shouldUpdateShape() && this.cache?.layoutData) {
              const bbox = this.cache.layoutData.bbox;
              this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
              if (stroke) {
                  this._AABBBounds.expand(lineWidth / 2);
              }
              return this._AABBBounds;
          }
          const textMeasure = application.graphicUtil.textMeasure;
          const layoutObj = new CanvasTextLayout(fontFamily, { fontSize }, textMeasure);
          const lines = text.map(l => l.toString());
          const linesLayout = [];
          const bboxWH = [0, 0];
          let lineCountLimit = Infinity;
          if (heightLimit > 0) {
              lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1);
          }
          if (lineClamp) {
              lineCountLimit = Math.min(lineCountLimit, lineClamp);
          }
          if (typeof maxLineWidth === 'number' && maxLineWidth !== Infinity) {
              if (maxLineWidth > 0) {
                  for (let i = 0; i < lines.length; i++) {
                      const str = lines[i];
                      if (i === lineCountLimit - 1) {
                          const clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis);
                          linesLayout.push({
                              str: clip.str,
                              width: clip.width
                          });
                          break;
                      }
                      const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth);
                      linesLayout.push({
                          str: clip.str,
                          width: clip.width
                      });
                      if (clip.str.length === str.length) ;
                      else {
                          const newStr = str.substring(clip.str.length);
                          lines.splice(i + 1, 0, newStr);
                      }
                  }
              }
              let maxWidth = 0;
              linesLayout.forEach(layout => {
                  maxWidth = Math.max(maxWidth, layout.width);
              });
              bboxWH[0] = maxWidth;
          }
          else {
              let lineWidth = 0;
              let width;
              let text;
              for (let i = 0, len = lines.length; i < len; i++) {
                  if (i === lineCountLimit - 1) {
                      const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis);
                      linesLayout.push({
                          str: clip.str,
                          width: clip.width
                      });
                      lineWidth = Math.max(lineWidth, clip.width);
                      break;
                  }
                  text = lines[i];
                  width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions);
                  lineWidth = Math.max(lineWidth, width);
                  linesLayout.push({ str: text, width });
              }
              bboxWH[0] = lineWidth;
          }
          bboxWH[1] = linesLayout.length * (lineHeight + buf);
          const bbox = {
              xOffset: 0,
              yOffset: 0,
              width: bboxWH[0],
              height: bboxWH[1]
          };
          layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
          const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
          this.cache.layoutData = layoutData;
          this.clearUpdateShapeTag();
          this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
          if (stroke) {
              this._AABBBounds.expand(lineWidth / 2);
          }
          return this._AABBBounds;
      }
      needUpdateTags(keys) {
          for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
              const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
              if (keys.indexOf(attrKey) !== -1) {
                  return true;
              }
          }
          return super.needUpdateTags(keys);
      }
      needUpdateTag(key) {
          for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
              const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
              if (key === attrKey) {
                  return true;
              }
          }
          return super.needUpdateTag(key);
      }
  }

  function createArc(attributes) {
      return new Arc(attributes);
  }
  function createArc3d(attributes) {
      return new Arc3d(attributes);
  }
  function createPyramid3d(attributes) {
      return new Pyramid3d(attributes);
  }
  function createArea(attributes) {
      return new Area(attributes);
  }
  function createCircle(attributes) {
      return new Circle(attributes);
  }
  function createGroup(attributes) {
      return new Group(attributes);
  }
  function createLine(attributes) {
      return new Line$1(attributes);
  }
  function createPath(attributes) {
      return new Path(attributes);
  }
  function createRect(attributes) {
      return new Rect(attributes);
  }
  function createRect3d(attributes) {
      return new Rect3d(attributes);
  }
  function createGlyph(attributes) {
      return new Glyph(attributes);
  }
  function createText(attributes) {
      return new Text(attributes);
  }
  function createWrapText(attributes) {
      return new WrapText(attributes);
  }
  function createSymbol(attributes) {
      return new Symbol$1(attributes);
  }
  function createImage(attributes) {
      return new Image(attributes);
  }
  function createPolygon(attributes) {
      return new Polygon(attributes);
  }
  function createShadowRoot(graphic) {
      return new ShadowRoot(graphic);
  }
  function createRichText(attributes) {
      return new RichText(attributes);
  }
  const graphicCreator = {
      arc: createArc,
      area: createArea,
      circle: createCircle,
      group: createGroup,
      image: createImage,
      line: createLine,
      path: createPath,
      rect: createRect,
      rect3d: createRect3d,
      symbol: createSymbol,
      text: createText,
      richtext: createRichText,
      polygon: createPolygon,
      shadowRoot: createShadowRoot,
      wrapText: createWrapText
  };

  const text = createText({
      text: ''
  });
  function getTextBounds(params) {
      text.setAttributes(params);
      return text.AABBBounds;
  }
  const richText = createRichText({});
  function getRichTextBounds(params) {
      richText.setAttributes(params);
      return richText.AABBBounds;
  }

  class DefaultCanvasAllocate {
      pools = [];
      allocate(data) {
          if (!this.pools.length) {
              return wrapCanvas({
                  nativeCanvas: application.global.createCanvas(data),
                  ...data
              });
          }
          const m = this.pools.pop();
          m.resize(data.width, data.height);
          m.dpr = data.dpr;
          return m;
      }
      allocateByObj(canvas) {
          if (!this.pools.length) {
              const data = {
                  width: canvas.width / canvas.dpr,
                  height: canvas.height / canvas.dpr,
                  dpr: canvas.dpr
              };
              return wrapCanvas({
                  nativeCanvas: application.global.createCanvas(data),
                  ...data
              });
          }
          const m = this.pools.pop();
          m.width = canvas.width;
          m.height = canvas.height;
          return m;
      }
      free(d) {
          this.pools.push(d);
      }
      get length() {
          return this.pools.length;
      }
      release(...params) {
          this.pools = [];
      }
  }
  const canvasAllocate = new DefaultCanvasAllocate();

  exports.DefaultBaseBackgroundRenderContribution = class DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
      useStyle = true;
      order = 0;
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb, options) {
          const { background } = graphic.attribute;
          if (!background) {
              return;
          }
          if (graphic.backgroundImg && graphic.resources) {
              const res = graphic.resources.get(background);
              if (res.state !== 'success' || !res.data) {
                  return;
              }
              context.save();
              if (graphic.parent && !graphic.transMatrix.onlyTranslate()) {
                  const groupAttribute = getTheme(graphic.parent).group;
                  const { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;
                  context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
                  context.translate(scrollX, scrollY);
              }
              context.clip();
              const b = graphic.AABBBounds;
              context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
              context.drawImage(res.data, b.x1, b.y1, b.width(), b.height());
              context.restore();
              if (!graphic.transMatrix.onlyTranslate()) {
                  context.setTransformForCurrent();
              }
          }
          else {
              context.highPerformanceSave();
              context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
              context.fillStyle = background;
              context.fill();
              context.highPerformanceRestore();
          }
      }
  };
  exports.DefaultBaseBackgroundRenderContribution = __decorate([
      injectable()
  ], exports.DefaultBaseBackgroundRenderContribution);
  exports.DefaultBaseTextureRenderContribution = class DefaultBaseTextureRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
      useStyle = true;
      textureMap;
      order = 10;
      createCommonPattern(size, padding, color, targetContext, cb) {
          const r = (size - padding * 2) / 2;
          const canvas = canvasAllocate.allocate({ width: size, height: size, dpr: 1 });
          const ctx = canvas.getContext('2d');
          if (!ctx) {
              return null;
          }
          ctx.clearRect(0, 0, size, size);
          cb(r, ctx);
          const pattern = targetContext.createPattern(canvas.nativeCanvas, 'repeat');
          canvasAllocate.free(canvas);
          return pattern;
      }
      createCirclePattern(size, padding, color, targetContext) {
          return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
              ctx.fillStyle = color;
              ctx.arc(r, r, r, 0, pi2);
              ctx.fill();
          });
      }
      createDiamondPattern(size, padding, color, targetContext) {
          return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
              const x = size / 2;
              const y = x;
              ctx.fillStyle = color;
              ctx.moveTo(x, y - r);
              ctx.lineTo(r + x, y);
              ctx.lineTo(x, y + r);
              ctx.lineTo(x - r, y);
              ctx.closePath();
              ctx.fill();
          });
      }
      createRectPattern(size, padding, color, targetContext) {
          return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
              const x = padding;
              const y = x;
              ctx.fillStyle = color;
              ctx.fillRect(x, y, r * 2, r * 2);
          });
      }
      createVerticalLinePattern(size, padding, color, targetContext) {
          return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
              const x = padding;
              const y = 0;
              ctx.fillStyle = color;
              ctx.fillRect(x, y, r * 2, size);
          });
      }
      createHorizontalLinePattern(size, padding, color, targetContext) {
          return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
              const x = 0;
              const y = padding;
              ctx.fillStyle = color;
              ctx.fillRect(x, y, size, r * 2);
          });
      }
      createBiasLRLinePattern(size, padding, color, targetContext) {
          return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
              ctx.strokeStyle = color;
              ctx.lineWidth = r;
              ctx.moveTo(0, 0);
              ctx.lineTo(size, size);
              const dx = size / 2;
              const dy = -dx;
              ctx.moveTo(dx, dy);
              ctx.lineTo(dx + size, dy + size);
              ctx.moveTo(-dx, -dy);
              ctx.lineTo(-dx + size, -dy + size);
              ctx.stroke();
          });
      }
      createBiasRLLinePattern(size, padding, color, targetContext) {
          return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
              ctx.strokeStyle = color;
              ctx.lineWidth = r;
              ctx.moveTo(size, 0);
              ctx.lineTo(0, size);
              const dx = size / 2;
              const dy = dx;
              ctx.moveTo(size + dx, dy);
              ctx.lineTo(dx, dy + size);
              ctx.moveTo(size - dx, -dy);
              ctx.lineTo(-dx, -dy + size);
              ctx.stroke();
          });
      }
      createGridPattern(size, padding, color, targetContext) {
          return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
              const x = padding;
              const y = x;
              ctx.fillStyle = color;
              ctx.fillRect(x, y, r, r);
              ctx.fillRect(x + r, y + r, r, r);
          });
      }
      initTextureMap(ctx, stage) {
          this.textureMap = new Map();
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb, options) {
          if (!this.textureMap) {
              this.initTextureMap(context, graphic.stage);
          }
          const { texture = graphicAttribute.texture, textureColor = graphicAttribute.textureColor, textureSize = graphicAttribute.textureSize, texturePadding = graphicAttribute.texturePadding } = graphic.attribute;
          if (!texture) {
              return;
          }
          let pattern = this.textureMap.get(texture);
          if (!pattern) {
              switch (texture) {
                  case 'circle':
                      pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'diamond':
                      pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'rect':
                      pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'vertical-line':
                      pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'horizontal-line':
                      pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'bias-lr':
                      pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'bias-rl':
                      pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'grid':
                      pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
                      break;
              }
          }
          if (pattern) {
              context.highPerformanceSave();
              context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
              context.fillStyle = pattern;
              context.fill();
              context.highPerformanceRestore();
          }
      }
  };
  exports.DefaultBaseTextureRenderContribution = __decorate([
      injectable()
  ], exports.DefaultBaseTextureRenderContribution);

  const ArcRenderContribution = Symbol.for('ArcRenderContribution');
  exports.DefaultArcRenderContribution = class DefaultArcRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
      useStyle = true;
      order = 0;
      drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, fillCb, strokeCb) {
          const { innerRadius = arcAttribute.innerRadius, outerRadius = arcAttribute.outerRadius, startAngle = arcAttribute.startAngle, endAngle = arcAttribute.endAngle, opacity = arcAttribute.opacity, outerBorder, innerBorder } = arc.attribute;
          if (outerBorder) {
              const { distance = arcAttribute.outerBorder.distance } = outerBorder;
              const d = getScaledStroke(context, distance, context.dpr);
              const deltaAngle = distance / outerRadius;
              arc.setAttributes({
                  outerRadius: outerRadius + d,
                  innerRadius: innerRadius - d,
                  startAngle: startAngle - deltaAngle,
                  endAngle: endAngle + deltaAngle
              });
              context.beginPath();
              drawArcPath$1(arc, context, x, y, outerRadius + d, innerRadius - d);
              context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute);
              if (strokeCb) {
                  strokeCb(context, outerBorder, arcAttribute.outerBorder);
              }
              else if (sVisible) {
                  const lastOpacity = arcAttribute.outerBorder.opacity;
                  arcAttribute.outerBorder.opacity = opacity;
                  context.setStrokeStyle(arc, outerBorder, x, y, arcAttribute.outerBorder);
                  arcAttribute.outerBorder.opacity = lastOpacity;
                  context.stroke();
              }
          }
          if (innerBorder) {
              const { distance = arcAttribute.innerBorder.distance } = innerBorder;
              const d = getScaledStroke(context, distance, context.dpr);
              const deltaAngle = distance / outerRadius;
              arc.setAttributes({
                  outerRadius: outerRadius - d,
                  innerRadius: innerRadius + d,
                  startAngle: startAngle + deltaAngle,
                  endAngle: endAngle - deltaAngle
              });
              context.beginPath();
              drawArcPath$1(arc, context, x, y, outerRadius - d, innerRadius + d);
              context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute);
              if (strokeCb) {
                  strokeCb(context, innerBorder, arcAttribute.innerBorder);
              }
              else if (sVisible) {
                  const lastOpacity = arcAttribute.innerBorder.opacity;
                  arcAttribute.innerBorder.opacity = opacity;
                  context.setStrokeStyle(arc, innerBorder, x, y, arcAttribute.innerBorder);
                  arcAttribute.innerBorder.opacity = lastOpacity;
                  context.stroke();
              }
          }
          arc.setAttributes({ outerRadius: outerRadius, innerRadius: innerRadius, startAngle, endAngle });
      }
  };
  exports.DefaultArcRenderContribution = __decorate([
      injectable()
  ], exports.DefaultArcRenderContribution);
  exports.DefaultArcBackgroundRenderContribution = class DefaultArcBackgroundRenderContribution extends exports.DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
  };
  exports.DefaultArcBackgroundRenderContribution = __decorate([
      injectable()
  ], exports.DefaultArcBackgroundRenderContribution);
  exports.DefaultArcTextureRenderContribution = class DefaultArcTextureRenderContribution extends exports.DefaultBaseTextureRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
  };
  exports.DefaultArcTextureRenderContribution = __decorate([
      injectable()
  ], exports.DefaultArcTextureRenderContribution);

  exports.DefaultCanvasArcRender = class DefaultCanvasArcRender {
      arcRenderContribitions;
      type;
      numberType = ARC_NUMBER_TYPE;
      _arcRenderContribitions;
      constructor(arcRenderContribitions) {
          this.arcRenderContribitions = arcRenderContribitions;
      }
      drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
          const capAngle = _ea - _sa;
          const data = arc.getParsedAngle();
          const startAngle = data.startAngle;
          let endAngle = data.endAngle;
          endAngle = _ea;
          const deltaAngle = abs(endAngle - startAngle);
          const clockwise = endAngle > startAngle;
          let collapsedToLine = false;
          if (outerRadius < innerRadius) {
              const temp = outerRadius;
              outerRadius = innerRadius;
              innerRadius = temp;
          }
          const cornerRadius = arc.getParsedCornerRadius();
          const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
          const outerCornerRadiusStart = cornerRadius;
          const outerCornerRadiusEnd = cornerRadius;
          const innerCornerRadiusEnd = cornerRadius;
          const innerCornerRadiusStart = cornerRadius;
          const maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart);
          const maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
          let limitedOcr = maxOuterCornerRadius;
          let limitedIcr = maxInnerCornerRadius;
          const xors = outerRadius * cos(outerStartAngle);
          const yors = outerRadius * sin(outerStartAngle);
          const xire = innerRadius * cos(innerEndAngle);
          const yire = innerRadius * sin(innerEndAngle);
          let xore;
          let yore;
          let xirs;
          let yirs;
          if (maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) {
              xore = outerRadius * cos(outerEndAngle);
              yore = outerRadius * sin(outerEndAngle);
              xirs = innerRadius * cos(innerStartAngle);
              yirs = innerRadius * sin(innerStartAngle);
              if (deltaAngle < pi) {
                  const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
                  if (oc) {
                      const ax = xors - oc[0];
                      const ay = yors - oc[1];
                      const bx = xore - oc[0];
                      const by = yore - oc[1];
                      const kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2);
                      const lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                      limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1));
                      limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
                  }
              }
          }
          if (limitedOcr > epsilon) {
              const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr);
              const cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr);
              const t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise));
              const t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
              if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                  context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
                  context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);
              }
              else {
                  const a1 = endAngle - capAngle - 0.03;
                  const a2 = atan2(t1.y11, t1.x11);
                  context.arc(cx, cy, outerRadius, a1, a2, !clockwise);
                  cornerRadiusEnd > 0 &&
                      context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
              }
          }
          else {
              context.moveTo(cx + xors, cy + yors);
          }
          if (!(innerRadius > epsilon) || innerDeltaAngle < 0.001) {
              context.lineTo(cx + xire, cy + yire);
              collapsedToLine = true;
          }
          else if (limitedIcr > epsilon) {
              const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr);
              const cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr);
              const t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise));
              const t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
              context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
              if (limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                  const arcEndAngle = atan2(t1.y01, t1.x01);
                  context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
              }
              else {
                  cornerRadiusEnd > 0 &&
                      context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
                  const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11);
                  const a2 = endAngle - capAngle - 0.03;
                  context.arc(cx, cy, innerRadius, a1, a2, clockwise);
              }
          }
          else {
              context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
          }
          return collapsedToLine;
      }
      drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
          const arcAttribute = getTheme(arc, params?.theme).arc;
          const { fill = arcAttribute.fill, background, stroke = arcAttribute.stroke, opacity = arcAttribute.opacity, fillOpacity = arcAttribute.fillOpacity, lineWidth = arcAttribute.lineWidth, strokeOpacity = arcAttribute.strokeOpacity, visible = arcAttribute.visible, x: originX = arcAttribute.x, y: originY = arcAttribute.y } = arc.attribute;
          const fVisible = fillVisible(opacity, fillOpacity);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(arc.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke || background)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
              return;
          }
          const { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius, cap = arcAttribute.cap, forceShowCap = arcAttribute.forceShowCap } = arc.attribute;
          const { isFullStroke, stroke: arrayStroke } = parseStroke(stroke);
          if (doFill || isFullStroke || background) {
              context.beginPath();
              drawArcPath$1(arc, context, x, y, outerRadius, innerRadius);
              if (!this._arcRenderContribitions) {
                  this._arcRenderContribitions = this.arcRenderContribitions.getContributions() || [];
                  this._arcRenderContribitions.sort((a, b) => b.order - a.order);
              }
              this._arcRenderContribitions.forEach(c => {
                  if (c.time === exports.BaseRenderContributionTime.beforeFillStroke) {
                      c.drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, fillCb, strokeCb);
                  }
              });
              context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute);
              if (doFill) {
                  if (fillCb) {
                      fillCb(context, arc.attribute, arcAttribute);
                  }
                  else if (fVisible) {
                      context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute);
                      context.fill();
                  }
              }
              if (doStroke && isFullStroke) {
                  if (strokeCb) {
                      strokeCb(context, arc.attribute, arcAttribute);
                  }
                  else if (sVisible) {
                      context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute);
                      context.stroke();
                  }
              }
          }
          if (!isFullStroke && doStroke) {
              context.beginPath();
              drawArcPath$1(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
              if (strokeCb) {
                  strokeCb(context, arc.attribute, arcAttribute);
              }
              else if (sVisible) {
                  context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);
                  context.stroke();
              }
          }
          if (cap && forceShowCap) {
              const { startAngle: sa, endAngle: ea } = arc.getParsedAngle();
              const deltaAngle = abs(ea - sa);
              if (deltaAngle >= pi2 - epsilon) {
                  context.beginPath();
                  const capWidth = Math.abs(outerRadius - innerRadius) / 2;
                  const capAngle = capWidth / outerRadius;
                  const { endAngle = arcAttribute.endAngle, fill = arcAttribute.fill } = arc.attribute;
                  const startAngle = endAngle;
                  this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle);
                  if (doFill) {
                      const color = fill;
                      if (color.gradient === 'conical') {
                          const lastColor = getConicGradientAt(0, 0, endAngle, color);
                          if (fillCb) ;
                          else if (fillVisible) {
                              context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute);
                              context.fillStyle = lastColor;
                              context.fill();
                          }
                      }
                  }
                  if (doStroke) {
                      if (strokeCb) ;
                      else if (sVisible) {
                          context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);
                          context.stroke();
                      }
                  }
              }
          }
          if (!this._arcRenderContribitions) {
              this._arcRenderContribitions = this.arcRenderContribitions.getContributions() || [];
          }
          this._arcRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.afterFillStroke) {
                  c.drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, fillCb, strokeCb);
              }
          });
      }
      draw(arc, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          const arcAttribute = getTheme(arc, params?.theme).arc;
          context.highPerformanceSave();
          let { x = arcAttribute.x, y = arcAttribute.y } = arc.attribute;
          if (!arc.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              context.transformFromMatrix(arc.transMatrix, true);
          }
          else {
              const point = arc.getOffsetXY(arcAttribute);
              x += point.x;
              y += point.y;
              context.setTransformForCurrent();
          }
          if (drawPathProxy(arc, context, x, y, drawContext, params)) {
              context.highPerformanceRestore();
              return;
          }
          this.drawShape(arc, context, x, y, drawContext, params);
          context.highPerformanceRestore();
      }
  };
  exports.DefaultCanvasArcRender = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(ArcRenderContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultCanvasArcRender);

  const CircleRenderContribution = Symbol.for('CircleRenderContribution');
  exports.DefaultCircleRenderContribution = class DefaultCircleRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
      useStyle = true;
      order = 0;
      drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, fillCb, strokeCb) {
          const { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, opacity = circleAttribute.opacity, outerBorder, innerBorder } = circle.attribute;
          if (outerBorder) {
              const { distance = circleAttribute.outerBorder.distance } = outerBorder;
              const d = getScaledStroke(context, distance, context.dpr);
              const dw = d;
              context.beginPath();
              context.arc(x, y, radius + dw, startAngle, endAngle);
              context.closePath();
              context.setShadowStyle && context.setShadowStyle(circle, circle.attribute, circleAttribute);
              if (strokeCb) {
                  strokeCb(context, outerBorder, circleAttribute.outerBorder);
              }
              else if (sVisible) {
                  const lastOpacity = circleAttribute.outerBorder.opacity;
                  circleAttribute.outerBorder.opacity = opacity;
                  context.setStrokeStyle(circle, outerBorder, x, y, circleAttribute.outerBorder);
                  circleAttribute.outerBorder.opacity = lastOpacity;
                  context.stroke();
              }
          }
          if (innerBorder) {
              const { distance = circleAttribute.innerBorder.distance } = innerBorder;
              const d = getScaledStroke(context, distance, context.dpr);
              const dw = d;
              context.beginPath();
              context.arc(x, y, radius - dw, startAngle, endAngle);
              context.closePath();
              context.setShadowStyle && context.setShadowStyle(circle, circle.attribute, circleAttribute);
              if (strokeCb) {
                  strokeCb(context, innerBorder, circleAttribute.innerBorder);
              }
              else if (sVisible) {
                  const lastOpacity = circleAttribute.innerBorder.opacity;
                  circleAttribute.innerBorder.opacity = opacity;
                  context.setStrokeStyle(circle, innerBorder, x, y, circleAttribute.innerBorder);
                  circleAttribute.innerBorder.opacity = lastOpacity;
                  context.stroke();
              }
          }
      }
  };
  exports.DefaultCircleRenderContribution = __decorate([
      injectable()
  ], exports.DefaultCircleRenderContribution);
  exports.DefaultCircleBackgroundRenderContribution = class DefaultCircleBackgroundRenderContribution extends exports.DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
  };
  exports.DefaultCircleBackgroundRenderContribution = __decorate([
      injectable()
  ], exports.DefaultCircleBackgroundRenderContribution);
  exports.DefaultCircleTextureRenderContribution = class DefaultCircleTextureRenderContribution extends exports.DefaultBaseTextureRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
  };
  exports.DefaultCircleTextureRenderContribution = __decorate([
      injectable()
  ], exports.DefaultCircleTextureRenderContribution);

  exports.DefaultCanvasCircleRender = class DefaultCanvasCircleRender {
      circleRenderContribitions;
      type;
      numberType = CIRCLE_NUMBER_TYPE;
      _circleRenderContribitions;
      constructor(circleRenderContribitions) {
          this.circleRenderContribitions = circleRenderContribitions;
      }
      drawShape(circle, context, x, y, drawContext, params, fillCb, strokeCb) {
          const circleAttribute = getTheme(circle, params?.theme).circle;
          const { fill = circleAttribute.fill, background, stroke = circleAttribute.stroke, radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, fillOpacity = circleAttribute.fillOpacity, strokeOpacity = circleAttribute.strokeOpacity, opacity = circleAttribute.opacity, lineWidth = circleAttribute.lineWidth, visible = circleAttribute.visible, x: originX = circleAttribute.x, y: originY = circleAttribute.y } = circle.attribute;
          const fVisible = fillVisible(opacity, fillOpacity);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(circle.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke || background)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
              return;
          }
          context.beginPath();
          context.arc(x, y, radius, startAngle, endAngle);
          context.closePath();
          if (!this._circleRenderContribitions) {
              this._circleRenderContribitions = this.circleRenderContribitions.getContributions() || [];
              this._circleRenderContribitions.sort((a, b) => b.order - a.order);
          }
          this._circleRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.beforeFillStroke) {
                  c.drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, fillCb, strokeCb);
              }
          });
          context.setShadowStyle && context.setShadowStyle(circle, circle.attribute, circleAttribute);
          if (doFill) {
              if (fillCb) {
                  fillCb(context, circle.attribute, circleAttribute);
              }
              else if (fVisible) {
                  context.setCommonStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute);
                  context.fill();
              }
          }
          if (doStroke) {
              if (strokeCb) {
                  strokeCb(context, circle.attribute, circleAttribute);
              }
              else if (sVisible) {
                  context.setStrokeStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute);
                  context.stroke();
              }
          }
          this._circleRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.afterFillStroke) {
                  c.drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, fillCb, strokeCb);
              }
          });
      }
      draw(circle, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          const circleAttribute = getTheme(circle, params?.theme).circle;
          let { x = circleAttribute.x, y = circleAttribute.y } = circle.attribute;
          if (!circle.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              context.transformFromMatrix(circle.transMatrix, true);
          }
          else {
              const point = circle.getOffsetXY(circleAttribute);
              x += point.x;
              y += point.y;
              context.setTransformForCurrent();
          }
          if (drawPathProxy(circle, context, x, y, drawContext, params)) {
              context.highPerformanceRestore();
              return;
          }
          this.drawShape(circle, context, x, y, drawContext, params);
          context.highPerformanceRestore();
      }
  };
  exports.DefaultCanvasCircleRender = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(CircleRenderContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultCanvasCircleRender);

  let BaseRender = class BaseRender {
      camera;
      transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = false) {
          const transMatrix = graphic.transMatrix;
          const { x = graphicAttribute.x, y = graphicAttribute.y, z = graphicAttribute.z, scaleX = graphicAttribute.scaleX, scaleY = graphicAttribute.scaleY, angle = graphicAttribute.angle, postMatrix } = graphic.attribute;
          const onlyTranslate = transMatrix.onlyTranslate() && !postMatrix;
          const lastModelMatrix = context.modelMatrix;
          const camera = context.camera;
          const result = { x, y, z, lastModelMatrix };
          const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic));
          if (shouldTransform3d) {
              const nextModelMatrix = mat4Allocate.allocate();
              const modelMatrix = mat4Allocate.allocate();
              getModelMatrix(modelMatrix, graphic, graphicAttribute);
              if (lastModelMatrix) {
                  multiplyMat4Mat4(nextModelMatrix, lastModelMatrix, modelMatrix);
              }
              else {
                  multiplyMat4Mat4(nextModelMatrix, nextModelMatrix, modelMatrix);
              }
              result.x = 0;
              result.y = 0;
              result.z = 0;
              context.modelMatrix = nextModelMatrix;
              context.setTransform(1, 0, 0, 1, 0, 0, true);
              mat4Allocate.free(modelMatrix);
          }
          if (onlyTranslate && !lastModelMatrix) {
              const point = graphic.getOffsetXY(graphicAttribute);
              result.x += point.x;
              result.y += point.y;
              result.z = z;
              context.setTransformForCurrent();
          }
          else if (shouldTransform3d) {
              result.x = 0;
              result.y = 0;
              result.z = 0;
              context.setTransform(1, 0, 0, 1, 0, 0, true);
          }
          else {
              if (camera && context.project) {
                  const point = graphic.getOffsetXY(graphicAttribute);
                  result.x += point.x;
                  result.y += point.y;
                  this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);
              }
              else {
                  context.transformFromMatrix(graphic.transMatrix, true);
                  result.x = 0;
                  result.y = 0;
                  result.z = 0;
              }
          }
          return result;
      }
      transformUseContext2d(graphic, graphicAttribute, z, context) {
          const camera = context.camera;
          this.camera = camera;
          if (camera) {
              const bounds = graphic.AABBBounds;
              const width = bounds.x2 - bounds.x1;
              const height = bounds.y2 - bounds.y1;
              const p1 = context.project(0, 0, z);
              const p2 = context.project(width, 0, z);
              const p3 = context.project(width, height, z);
              const _p1 = { x: 0, y: 0 };
              const _p2 = { x: width, y: 0 };
              const _p3 = { x: width, y: height };
              context.camera = null;
              const denom = 1.0 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y);
              const m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom;
              const m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom;
              const m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom;
              const m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom;
              const dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) +
                  _p1.y * (_p2.x * p3.x - _p3.x * p2.x) +
                  (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) *
                  denom;
              const dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) +
                  _p1.y * (_p2.x * p3.y - _p3.x * p2.y) +
                  (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) *
                  denom;
              context.setTransform(m11, m12, m21, m22, dx, dy, true);
          }
      }
      restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
          if (this.camera) {
              context.camera = this.camera;
          }
      }
      transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle) {
          const p = context.project(x, y, z);
          context.translate(p.x, p.y, false);
          context.scale(scaleX, scaleY, false);
          context.rotate(angle, false);
          context.translate(-p.x, -p.y, false);
          context.setTransformForCurrent();
      }
  };
  BaseRender = __decorate([
      injectable()
  ], BaseRender);

  function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
      const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params || {};
      let needMoveTo = true;
      const { curves } = segPath;
      if (percent >= 1) {
          curves.forEach(curve => {
              if (!curve.defined) {
                  needMoveTo = true;
                  return;
              }
              if (needMoveTo) {
                  path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);
              }
              drawSegItem$1(path, curve, 1, params);
              needMoveTo = false;
          });
          return;
      }
      if (percent <= 0) {
          return;
      }
      let direction;
      if (clipRangeByDimension === 'x') {
          direction = exports.Direction.ROW;
      }
      else if (clipRangeByDimension === 'y') {
          direction = exports.Direction.COLUMN;
      }
      else if (clipRangeByDimension === 'auto') {
          direction = segPath.direction;
      }
      const totalLength = segPath.tryUpdateLength(direction);
      const totalDrawLength = percent * totalLength;
      let drawedLengthUntilLast = 0;
      for (let i = 0, n = curves.length; i < n; i++) {
          const curve = curves[i];
          const curCurveLength = curve.getLength(direction);
          const _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
          drawedLengthUntilLast += curCurveLength;
          if (_p < 0) {
              break;
          }
          if (!curve.defined) {
              needMoveTo = true;
              continue;
          }
          if (needMoveTo) {
              path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);
          }
          drawSegItem$1(path, curve, min(_p, 1), params);
          needMoveTo = false;
      }
  }
  function drawIncrementalSegments(path, lastSeg, segments, params) {
      const { offsetX = 0, offsetY = 0 } = params || {};
      const startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
      path.moveTo(startP.x + offsetX, startP.y + offsetY);
      segments.points.forEach(p => {
          if (p.defined === false) {
              path.moveTo(p.x + offsetX, p.y + offsetY);
              return;
          }
          path.lineTo(p.x + offsetX, p.y + offsetY);
      });
  }
  function drawIncrementalAreaSegments(path, lastSeg, segments, params) {
      const { offsetX = 0, offsetY = 0 } = params || {};
      const { points } = segments;
      const definedPointsList = [];
      for (let i = 0; i < points.length; i++) {
          if (points[i].defined === false) ;
      }
      definedPointsList.push(points);
      definedPointsList.forEach((points, i) => {
          const startP = lastSeg && i === 0 ? lastSeg.points[lastSeg.points.length - 1] : points[0];
          path.moveTo(startP.x + offsetX, startP.y + offsetY);
          points.forEach(p => {
              if (p.defined === false) {
                  path.moveTo(p.x + offsetX, p.y + offsetY);
                  return;
              }
              path.lineTo(p.x + offsetX, p.y + offsetY);
          });
          for (let i = points.length - 1; i >= 0; i--) {
              const p = points[i];
              path.lineTo(p.x1 ?? p.x, p.y1 ?? p.y);
          }
          path.lineTo(startP.x1 ?? startP.x, startP.y1 ?? startP.y);
          path.closePath();
      });
  }
  function drawSegItem$1(ctx, curve, endPercent, params) {
      if (!curve.p1) {
          return;
      }
      const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params || {};
      if (endPercent === 1) {
          if (curve.p2 && curve.p3) {
              ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ);
          }
          else {
              ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);
          }
      }
      else {
          if (curve.p2 && curve.p3) {
              const [curve1] = divideCubic(curve, endPercent);
              ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
          }
          else {
              const p = curve.getPointAt(endPercent);
              ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
          }
      }
  }

  exports.DefaultCanvasLineRender = class DefaultCanvasLineRender extends BaseRender {
      type;
      numberType = LINE_NUMBER_TYPE;
      draw(line, renderService, drawContext, params) {
          const { context } = drawContext;
          context.highPerformanceSave();
          const lineAttribute = getTheme(line, params?.theme).line;
          const data = this.transform(line, lineAttribute, context);
          const { x, y, z, lastModelMatrix } = data;
          this.z = z;
          if (drawPathProxy(line, context, x, y)) {
              context.highPerformanceRestore();
              return;
          }
          this.drawShape(line, context, x, y, drawContext, params);
          this.z = 0;
          if (context.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(context.modelMatrix);
          }
          context.modelMatrix = lastModelMatrix;
          context.highPerformanceRestore();
      }
      drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
          context.beginPath();
          const z = this.z ?? 0;
          drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
              offsetX,
              offsetY,
              offsetZ: z
          });
          if (line.cache && !isArray(line.cache) && line.attribute.curveType && line.attribute.curveType.includes('Closed')) {
              context.closePath();
          }
          context.setShadowStyle && context.setShadowStyle(line, attribute, defaultAttribute);
          const { x: originX = 0, x: originY = 0 } = attribute;
          const ret = false;
          if (fill !== false) {
              if (fillCb) {
                  fillCb(context, attribute, defaultAttribute);
              }
              else if (fillOpacity) {
                  context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute);
                  context.fill();
              }
          }
          if (stroke !== false) {
              if (strokeCb) {
                  strokeCb(context, attribute, defaultAttribute);
              }
              else if (strokeOpacity) {
                  context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute);
                  context.stroke();
              }
          }
          return !!ret;
      }
      drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
          const lineAttribute = getTheme(line, params?.theme).line;
          const { fill = lineAttribute.fill, stroke = lineAttribute.stroke, opacity = lineAttribute.opacity, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, lineWidth = lineAttribute.lineWidth, visible = lineAttribute.visible } = line.attribute;
          const fVisible = fillVisible(opacity, fillOpacity);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(line.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb)) {
              return;
          }
          if (line.shouldUpdateShape()) {
              const { points, segments, curveType = lineAttribute.curveType } = line.attribute;
              const _points = points;
              if (segments && segments.length) {
                  let startPoint;
                  let lastSeg;
                  line.cache = segments.map((seg, index) => {
                      if (index === 1) {
                          startPoint = {
                              x: lastSeg.endX,
                              y: lastSeg.endY,
                              defined: lastSeg.curves[lastSeg.curves.length - 1].defined
                          };
                      }
                      else if (index > 1) {
                          startPoint.x = lastSeg.endX;
                          startPoint.y = lastSeg.endY;
                          startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined;
                      }
                      lastSeg = calcLineCache$1(seg.points, curveType, {
                          startPoint
                      });
                      return lastSeg;
                  });
              }
              else if (points && points.length) {
                  line.cache = calcLineCache$1(_points, curveType);
              }
              else {
                  line.cache = null;
                  line.clearUpdateShapeTag();
                  return;
              }
              line.clearUpdateShapeTag();
          }
          const { clipRange = lineAttribute.clipRange, clipRangeByDimension = lineAttribute.clipRangeByDimension } = line.attribute;
          if (Array.isArray(line.cache)) {
              if (clipRange === 1) {
                  let skip = false;
                  line.cache.forEach((cache, index) => {
                      if (skip) {
                          return;
                      }
                      skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute.segments[index], [lineAttribute, line.attribute], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
                  });
              }
              else {
                  const totalLength = line.cache.reduce((l, c) => l + c.getLength(), 0);
                  const totalDrawLength = clipRange * totalLength;
                  let drawedLengthUntilLast = 0;
                  let skip = false;
                  line.cache.forEach((cache, index) => {
                      if (skip) {
                          return;
                      }
                      const curSegLength = cache.getLength();
                      const _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
                      drawedLengthUntilLast += curSegLength;
                      if (_cr > 0) {
                          skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute.segments[index], [lineAttribute, line.attribute], min(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb);
                      }
                  });
              }
          }
          else {
              this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
          }
      }
  };
  exports.DefaultCanvasLineRender = __decorate([
      injectable()
  ], exports.DefaultCanvasLineRender);

  const AreaRenderContribution = Symbol.for('AreaRenderContribution');
  let DefaultAreaBackgroundRenderContribution = class DefaultAreaBackgroundRenderContribution extends exports.DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
  };
  DefaultAreaBackgroundRenderContribution = __decorate([
      injectable()
  ], DefaultAreaBackgroundRenderContribution);
  let DefaultAreaTextureRenderContribution = class DefaultAreaTextureRenderContribution extends exports.DefaultBaseTextureRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb, options) {
          if (!this.textureMap) {
              this.initTextureMap(context, graphic.stage);
          }
          const { attribute = graphic.attribute } = options || {};
          const { texture = graphic.attribute.texture ?? getAttributeFromDefaultAttrList(graphicAttribute, 'texture'), textureColor = graphic.attribute.textureColor ??
              getAttributeFromDefaultAttrList(graphicAttribute, 'textureColor'), textureSize = graphic.attribute.textureSize ?? getAttributeFromDefaultAttrList(graphicAttribute, 'textureSize'), texturePadding = graphic.attribute.texturePadding ??
              getAttributeFromDefaultAttrList(graphicAttribute, 'texturePadding') } = attribute;
          if (!texture) {
              return;
          }
          let pattern = this.textureMap.get(texture);
          if (!pattern) {
              switch (texture) {
                  case 'circle':
                      pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'diamond':
                      pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'rect':
                      pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'vertical-line':
                      pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'horizontal-line':
                      pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'bias-lr':
                      pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'bias-rl':
                      pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
                      break;
                  case 'grid':
                      pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
                      break;
              }
          }
          if (pattern) {
              context.highPerformanceSave();
              context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
              context.fillStyle = pattern;
              context.fill();
              context.highPerformanceRestore();
          }
      }
  };
  DefaultAreaTextureRenderContribution = __decorate([
      injectable()
  ], DefaultAreaTextureRenderContribution);

  function drawAreaSegments(path, segPath, percent, params) {
      const { top, bottom } = segPath;
      if (percent >= 1) {
          const topList = [];
          const bottomList = [];
          let lastDefined = true;
          for (let i = 0, n = top.curves.length; i < n; i++) {
              const topCurve = top.curves[i];
              if (lastDefined !== topCurve.defined) {
                  if (lastDefined) {
                      drawAreaBlock(path, topList, bottomList, params);
                      topList.length = 0;
                      bottomList.length = 0;
                  }
                  else {
                      topList.push(topCurve);
                      bottomList.push(bottom.curves[n - i - 1]);
                  }
                  lastDefined = !lastDefined;
              }
              else {
                  if (lastDefined) {
                      topList.push(topCurve);
                      bottomList.push(bottom.curves[n - i - 1]);
                  }
              }
          }
          drawAreaBlock(path, topList, bottomList, params);
          return;
      }
      if (percent <= 0) {
          return;
      }
      let { direction } = params || {};
      const { curves: topCurves } = top;
      const endP = topCurves[topCurves.length - 1].p3 ?? topCurves[topCurves.length - 1].p1;
      const xTotalLength = abs(endP.x - topCurves[0].p0.x);
      const yTotalLength = abs(endP.y - topCurves[0].p0.y);
      direction = direction ?? (xTotalLength > yTotalLength ? exports.Direction.ROW : exports.Direction.COLUMN);
      if (!Number.isFinite(xTotalLength)) {
          direction = exports.Direction.COLUMN;
      }
      if (!Number.isFinite(yTotalLength)) {
          direction = exports.Direction.ROW;
      }
      const totalLength = direction === exports.Direction.ROW ? xTotalLength : yTotalLength;
      const totalDrawLength = percent * totalLength;
      let drawedLengthUntilLast = 0;
      let lastDefined = true;
      const topList = [];
      const bottomList = [];
      for (let i = 0, n = top.curves.length; i < n; i++) {
          const topCurve = top.curves[i];
          const curCurveLength = topCurve.getLength(direction);
          const percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
          if (percent < 0) {
              break;
          }
          drawedLengthUntilLast += curCurveLength;
          let tc = null;
          let bc = null;
          if (lastDefined !== topCurve.defined) {
              if (lastDefined) {
                  drawAreaBlock(path, topList, bottomList, params);
                  topList.length = 0;
                  bottomList.length = 0;
              }
              else {
                  tc = topCurve;
                  bc = bottom.curves[n - i - 1];
              }
              lastDefined = !lastDefined;
          }
          else {
              if (lastDefined) {
                  tc = topCurve;
                  bc = bottom.curves[n - i - 1];
              }
          }
          if (tc && bc) {
              if (percent < 1) {
                  if (tc.p2 && tc.p3) {
                      tc = divideCubic(tc, percent)[0];
                  }
                  else {
                      tc = divideLinear(tc, percent)[0];
                  }
                  if (bc.p2 && bc.p3) {
                      bc = divideCubic(bc, 1 - percent)[1];
                  }
                  else {
                      bc = divideLinear(bc, 1 - percent)[1];
                  }
              }
              tc.defined = lastDefined;
              bc.defined = lastDefined;
              topList.push(tc);
              bottomList.push(bc);
          }
          tc = null;
          bc = null;
      }
      drawAreaBlock(path, topList, bottomList, params);
  }
  function drawAreaBlock(path, topList, bottomList, params) {
      const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params || {};
      let needMoveTo = true;
      topList.forEach(curve => {
          if (!curve.defined) {
              needMoveTo = true;
              return;
          }
          if (needMoveTo) {
              path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);
          }
          drawSegItem(path, curve, 1, params);
          needMoveTo = false;
      });
      needMoveTo = true;
      for (let i = bottomList.length - 1; i >= 0; i--) {
          const curve = bottomList[i];
          if (!curve.defined) {
              needMoveTo = true;
              continue;
          }
          if (needMoveTo) {
              path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);
          }
          drawSegItem(path, curve, 1, params);
          needMoveTo = false;
      }
  }
  function drawSegItem(ctx, curve, endPercent, params) {
      if (!curve.p1) {
          return;
      }
      const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params || {};
      if (endPercent === 1) {
          if (curve.p2 && curve.p3) {
              ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ);
          }
          else {
              ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);
          }
      }
      else {
          if (curve.p2 && curve.p3) {
              const [curve1] = divideCubic(curve, endPercent);
              ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
          }
          else {
              const p = curve.getPointAt(endPercent);
              ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
          }
      }
  }

  function calcLineCache(points, curveType, params) {
      switch (curveType) {
          case 'linear':
              return genLinearSegments(points, params);
          case 'basis':
              return genBasisSegments(points, params);
          case 'monotoneX':
              return genMonotoneXSegments(points, params);
          case 'monotoneY':
              return genMonotoneYSegments(points, params);
          case 'step':
              return genStepSegments(points, 0.5, params);
          case 'stepBefore':
              return genStepSegments(points, 0, params);
          case 'stepAfter':
              return genStepSegments(points, 1, params);
          case 'linearClosed':
              return genLinearClosedSegments(points, params);
          default:
              return genLinearSegments(points, params);
      }
  }
  exports.DefaultCanvasAreaRender = class DefaultCanvasAreaRender {
      areaRenderContribitions;
      type;
      numberType = AREA_NUMBER_TYPE;
      _areaRenderContribitions;
      constructor(areaRenderContribitions) {
          this.areaRenderContribitions = areaRenderContribitions;
      }
      drawShape(area, context, x, y, drawContext, params, fillCb, strokeCb) {
          const areaAttribute = getTheme(area, params?.theme).area;
          const { fill = areaAttribute.fill, fillOpacity = areaAttribute.fillOpacity, opacity = areaAttribute.opacity, visible = areaAttribute.visible, z = areaAttribute.z, stroke = area.attribute.stroke, lineWidth = areaAttribute.lineWidth, strokeOpacity = areaAttribute.strokeOpacity } = area.attribute;
          const fVisible = fillVisible(opacity, fillOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          if (!(area.valid && visible)) {
              return;
          }
          if (!doFill && !doStroke) {
              return;
          }
          if (!(fVisible || fillCb) && !sVisible && !strokeCb) {
              return;
          }
          const { clipRange = areaAttribute.clipRange } = area.attribute;
          if (area.shouldUpdateShape()) {
              const { points, segments, curveType = areaAttribute.curveType } = area.attribute;
              if (segments && segments.length) {
                  let startPoint;
                  let lastTopSeg;
                  const topCaches = segments.map((seg, index) => {
                      if (index === 1) {
                          startPoint = { x: lastTopSeg.endX, y: lastTopSeg.endY };
                      }
                      else if (index > 1) {
                          startPoint.x = lastTopSeg.endX;
                          startPoint.y = lastTopSeg.endY;
                      }
                      lastTopSeg = calcLineCache(seg.points, curveType, {
                          startPoint
                      });
                      return lastTopSeg;
                  });
                  let lastBottomSeg;
                  const bottomCaches = [];
                  for (let i = segments.length - 1; i >= 0; i--) {
                      const points = segments[i].points;
                      const bottomPoints = [];
                      for (let i = points.length - 1; i >= 0; i--) {
                          bottomPoints.push({
                              x: points[i].x1 ?? points[i].x,
                              y: points[i].y1 ?? points[i].y
                          });
                      }
                      if (i !== 0) {
                          const lastSegmentPoints = segments[i - 1].points;
                          const endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
                          endPoint &&
                              bottomPoints.push({
                                  x: endPoint.x1 ?? endPoint.x,
                                  y: endPoint.y1 ?? endPoint.y
                              });
                      }
                      lastBottomSeg = calcLineCache(bottomPoints, curveType);
                      bottomCaches.unshift(lastBottomSeg);
                  }
                  area.cacheArea = bottomCaches.map((item, index) => ({
                      top: topCaches[index],
                      bottom: item
                  }));
              }
              else if (points && points.length) {
                  const topPoints = points;
                  const bottomPoints = [];
                  for (let i = points.length - 1; i >= 0; i--) {
                      bottomPoints.push({
                          x: points[i].x1 ?? points[i].x,
                          y: points[i].y1 ?? points[i].y
                      });
                  }
                  const topCache = calcLineCache(topPoints, curveType);
                  const bottomCache = calcLineCache(bottomPoints, curveType === 'stepBefore' ? 'stepAfter' : curveType === 'stepAfter' ? 'stepBefore' : curveType);
                  area.cacheArea = { top: topCache, bottom: bottomCache };
              }
              else {
                  area.cache = null;
                  area.clearUpdateShapeTag();
                  return;
              }
              area.clearUpdateShapeTag();
          }
          if (Array.isArray(area.cacheArea)) {
              if (clipRange === 1) {
                  let skip = false;
                  area.cacheArea.forEach((cache, index) => {
                      if (skip) {
                          return;
                      }
                      skip = this.drawSegmentItem(context, cache, !!fill, fillOpacity, area.attribute.segments[index], [areaAttribute, area.attribute], clipRange, x, y, z, area, fillCb);
                  });
              }
              else {
                  const totalLength = area.cacheArea.reduce((l, c) => l + c.top.getLength(), 0);
                  const totalDrawLength = clipRange * totalLength;
                  let drawedLengthUntilLast = 0;
                  let skip = false;
                  area.cacheArea.forEach((cache, index) => {
                      if (skip) {
                          return;
                      }
                      const curSegLength = cache.top.getLength();
                      const _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
                      drawedLengthUntilLast += curSegLength;
                      if (_cr > 0) {
                          skip = this.drawSegmentItem(context, cache, !!fill, fillOpacity, area.attribute.segments[index], [areaAttribute, area.attribute], min(_cr, 1), x, y, z, area, fillCb);
                      }
                  });
              }
          }
          else {
              this.drawSegmentItem(context, area.cacheArea, !!fill, fillOpacity, area.attribute, areaAttribute, clipRange, x, y, z, area, fillCb);
          }
      }
      draw(area, renderService, drawContext, params) {
          const { context } = drawContext;
          const areaAttribute = getTheme(area, params?.theme).area;
          let { x = areaAttribute.x, y = areaAttribute.y } = area.attribute;
          context.highPerformanceSave();
          if (!area.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              context.transformFromMatrix(area.transMatrix, true);
          }
          else {
              const point = area.getOffsetXY(areaAttribute);
              x += point.x;
              y += point.y;
              context.setTransformForCurrent();
          }
          if (drawPathProxy(area, context, x, y, drawContext, params)) {
              context.highPerformanceRestore();
              return;
          }
          this.drawShape(area, context, x, y, drawContext, params);
          context.highPerformanceRestore();
      }
      drawSegmentItem(context, cache, fill, fillOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, fillCb) {
          context.beginPath();
          const ret = false;
          drawAreaSegments(context.camera ? context : context.nativeContext, cache, clipRange, {
              offsetX,
              offsetY,
              offsetZ
          });
          if (!this._areaRenderContribitions) {
              this._areaRenderContribitions = this.areaRenderContribitions.getContributions() || [];
              this._areaRenderContribitions.sort((a, b) => b.order - a.order);
          }
          this._areaRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.beforeFillStroke) {
                  c.drawShape(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, fillCb, null, { attribute });
              }
          });
          context.setShadowStyle && context.setShadowStyle(area, attribute, defaultAttribute);
          const { x: originX = 0, x: originY = 0 } = attribute;
          if (fill !== false) {
              if (fillCb) {
                  fillCb(context, attribute, defaultAttribute);
              }
              else if (fillOpacity) {
                  context.setCommonStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute);
                  context.fill();
              }
          }
          if (!this._areaRenderContribitions) {
              this._areaRenderContribitions = this.areaRenderContribitions.getContributions() || [];
          }
          this._areaRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.afterFillStroke) {
                  c.drawShape(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, fillCb, null, { attribute });
              }
          });
          return ret;
      }
  };
  exports.DefaultCanvasAreaRender = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(AreaRenderContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultCanvasAreaRender);

  const PathRenderContribution = Symbol.for('PathRenderContribution');
  let DefaultPathBackgroundRenderContribution = class DefaultPathBackgroundRenderContribution extends exports.DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
  };
  DefaultPathBackgroundRenderContribution = __decorate([
      injectable()
  ], DefaultPathBackgroundRenderContribution);
  let DefaultPathTextureRenderContribution = class DefaultPathTextureRenderContribution extends exports.DefaultBaseTextureRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
  };
  DefaultPathTextureRenderContribution = __decorate([
      injectable()
  ], DefaultPathTextureRenderContribution);

  exports.DefaultCanvasPathRender = class DefaultCanvasPathRender extends BaseRender {
      pathRenderContribitions;
      type;
      numberType = PATH_NUMBER_TYPE;
      _pathRenderContribitions;
      constructor(pathRenderContribitions) {
          super();
          this.pathRenderContribitions = pathRenderContribitions;
      }
      drawShape(path, context, x, y, drawContext, params, fillCb, strokeCb) {
          const pathAttribute = getTheme(path, params?.theme).path;
          const { fill = pathAttribute.fill, stroke = pathAttribute.stroke, fillOpacity = pathAttribute.fillOpacity, strokeOpacity = pathAttribute.strokeOpacity, opacity = pathAttribute.opacity, background, lineWidth = pathAttribute.lineWidth, visible = pathAttribute.visible, x: originX = pathAttribute.x, y: originY = pathAttribute.y } = path.attribute;
          const z = this.z ?? 0;
          const fVisible = fillVisible(opacity, fillOpacity);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(path.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke || background)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
              return;
          }
          context.beginPath();
          if (path.pathShape) {
              renderCommandList(path.pathShape.commandList, context, x, y, 1, 1, z);
          }
          else {
              const path2D = path.attribute.path ?? pathAttribute.path;
              renderCommandList(path2D.commandList, context, x, y, 1, 1, z);
          }
          if (!this._pathRenderContribitions) {
              this._pathRenderContribitions = this.pathRenderContribitions.getContributions() || [];
              this._pathRenderContribitions.sort((a, b) => b.order - a.order);
          }
          this._pathRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.beforeFillStroke) {
                  c.drawShape(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, fillCb, strokeCb);
              }
          });
          context.setShadowStyle && context.setShadowStyle(path, path.attribute, pathAttribute);
          if (doStroke) {
              if (strokeCb) {
                  strokeCb(context, path.attribute, pathAttribute);
              }
              else if (sVisible) {
                  context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute);
                  context.stroke();
              }
          }
          if (doFill) {
              if (fillCb) {
                  fillCb(context, path.attribute, pathAttribute);
              }
              else if (fVisible) {
                  context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute);
                  context.fill();
              }
          }
          this._pathRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.afterFillStroke) {
                  c.drawShape(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, fillCb, strokeCb);
              }
          });
      }
      draw(path, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          const pathAttribute = getTheme(path, params?.theme).path;
          const data = this.transform(path, pathAttribute, context);
          const { x, y, z, lastModelMatrix } = data;
          this.z = z;
          if (drawPathProxy(path, context, x, y, drawContext, params)) {
              context.highPerformanceRestore();
              return;
          }
          this.drawShape(path, context, x, y, drawContext, params);
          this.z = 0;
          if (context.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(context.modelMatrix);
          }
          context.modelMatrix = lastModelMatrix;
          context.highPerformanceRestore();
      }
  };
  exports.DefaultCanvasPathRender = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(PathRenderContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultCanvasPathRender);

  const halfPi = pi / 2;
  function createRectPath(path, x, y, width, height, rectCornerRadius) {
      let cornerRadius;
      if (isNumber(rectCornerRadius, true)) {
          cornerRadius = [
              rectCornerRadius,
              rectCornerRadius,
              rectCornerRadius,
              rectCornerRadius
          ];
      }
      else if (Array.isArray(rectCornerRadius)) {
          const cornerRadiusArr = rectCornerRadius;
          switch (cornerRadiusArr.length) {
              case 0:
                  cornerRadius = [0, 0, 0, 0];
                  break;
              case 1:
                  cornerRadius = [cornerRadiusArr[0], cornerRadiusArr[0], cornerRadiusArr[0], cornerRadiusArr[0]];
                  break;
              case 2:
              case 3:
                  cornerRadius = [cornerRadiusArr[0], cornerRadiusArr[1], cornerRadiusArr[0], cornerRadiusArr[1]];
                  break;
              default:
                  cornerRadius = cornerRadiusArr.slice(0, 5);
                  break;
          }
      }
      else {
          cornerRadius = [0, 0, 0, 0];
      }
      if (width < 0 ||
          Math.abs(cornerRadius[0]) + Math.abs(cornerRadius[1]) + Math.abs(cornerRadius[2]) + Math.abs(cornerRadius[3]) <
              1e-12) {
          return path.rect(x, y, width, height);
      }
      const [leftTop, rightTop, rightBottom, leftBottom] = [
          [x, y],
          [x + width, y],
          [x + width, y + height],
          [x, y + height]
      ];
      const maxCornerRadius = Math.min(width / 2, height / 2);
      const _cornerRadius = [
          Math.min(maxCornerRadius, cornerRadius[0]),
          Math.min(maxCornerRadius, cornerRadius[1]),
          Math.min(maxCornerRadius, cornerRadius[2]),
          Math.min(maxCornerRadius, cornerRadius[3])
      ];
      const leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]];
      const leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]];
      const rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]];
      const rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]];
      const rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]];
      const rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]];
      const leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]];
      const leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
      path.moveTo(leftTopPoint1[0], leftTopPoint1[1]);
      path.lineTo(rightTopPoint1[0], rightTopPoint1[1]);
      if (!arrayEqual(rightTopPoint1, rightTopPoint2)) {
          const centerX = rightTopPoint1[0];
          const centerY = rightTopPoint1[1] + _cornerRadius[1];
          path.arc(centerX, centerY, _cornerRadius[1], -halfPi, 0, false);
      }
      path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]);
      if (!arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
          const centerX = rightBottomPoint2[0] - _cornerRadius[2];
          const centerY = rightBottomPoint2[1];
          path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi, false);
      }
      path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]);
      if (!arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
          const centerX = leftBottomPoint1[0];
          const centerY = leftBottomPoint1[1] - _cornerRadius[3];
          path.arc(centerX, centerY, _cornerRadius[3], halfPi, pi, false);
      }
      path.lineTo(leftTopPoint2[0], leftTopPoint2[1]);
      if (!arrayEqual(leftTopPoint1, leftTopPoint2)) {
          const centerX = leftTopPoint1[0];
          const centerY = leftTopPoint1[1] + _cornerRadius[0];
          path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi, false);
      }
      path.closePath();
      return path;
  }

  const RectRenderContribution = Symbol.for('RectRenderContribution');
  exports.DefaultRectRenderContribution = class DefaultRectRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
      useStyle = true;
      order = 0;
      drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, fillCb, strokeCb) {
          const { width = rectAttribute.width, height = rectAttribute.height, cornerRadius = rectAttribute.cornerRadius, opacity = rectAttribute.opacity, outerBorder, innerBorder } = rect.attribute;
          if (outerBorder) {
              const { distance = rectAttribute.outerBorder.distance } = outerBorder;
              const d = getScaledStroke(context, distance, context.dpr);
              const nextX = x - d;
              const nextY = y - d;
              const dw = d * 2;
              if (cornerRadius === 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
                  context.beginPath();
                  context.rect(nextX, nextY, width + dw, height + dw);
              }
              else {
                  context.beginPath();
                  createRectPath(context, nextX, nextY, width + dw, height + dw, cornerRadius);
              }
              context.setShadowStyle && context.setShadowStyle(rect, rect.attribute, rectAttribute);
              if (strokeCb) {
                  strokeCb(context, outerBorder, rectAttribute.outerBorder);
              }
              else if (sVisible) {
                  const lastOpacity = rectAttribute.outerBorder.opacity;
                  rectAttribute.outerBorder.opacity = opacity;
                  context.setStrokeStyle(rect, outerBorder, x, y, rectAttribute.outerBorder);
                  rectAttribute.outerBorder.opacity = lastOpacity;
                  context.stroke();
              }
          }
          if (innerBorder) {
              const { distance = rectAttribute.innerBorder.distance } = innerBorder;
              const d = getScaledStroke(context, distance, context.dpr);
              const nextX = x + d;
              const nextY = y + d;
              const dw = d * 2;
              if (cornerRadius === 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
                  context.beginPath();
                  context.rect(nextX, nextY, width - dw, height - dw);
              }
              else {
                  context.beginPath();
                  createRectPath(context, nextX, nextY, width - dw, height - dw, cornerRadius);
              }
              context.setShadowStyle && context.setShadowStyle(rect, rect.attribute, rectAttribute);
              if (strokeCb) {
                  strokeCb(context, innerBorder, rectAttribute.innerBorder);
              }
              else if (sVisible) {
                  const lastOpacity = rectAttribute.innerBorder.opacity;
                  rectAttribute.innerBorder.opacity = opacity;
                  context.setStrokeStyle(rect, innerBorder, x, y, rectAttribute.innerBorder);
                  rectAttribute.innerBorder.opacity = lastOpacity;
                  context.stroke();
              }
          }
      }
  };
  exports.DefaultRectRenderContribution = __decorate([
      injectable()
  ], exports.DefaultRectRenderContribution);
  exports.DefaultRectBackgroundRenderContribution = class DefaultRectBackgroundRenderContribution extends exports.DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
  };
  exports.DefaultRectBackgroundRenderContribution = __decorate([
      injectable()
  ], exports.DefaultRectBackgroundRenderContribution);
  exports.DefaultRectTextureRenderContribution = class DefaultRectTextureRenderContribution extends exports.DefaultBaseTextureRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
  };
  exports.DefaultRectTextureRenderContribution = __decorate([
      injectable()
  ], exports.DefaultRectTextureRenderContribution);
  exports.SplitRectBeforeRenderContribution = class SplitRectBeforeRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
      useStyle = true;
      order = 0;
      drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb, doFillOrStroke) {
          const { stroke = groupAttribute.stroke } = group.attribute;
          if (Array.isArray(stroke) && stroke.some(s => s === false)) {
              doFillOrStroke.doStroke = false;
          }
      }
  };
  exports.SplitRectBeforeRenderContribution = __decorate([
      injectable()
  ], exports.SplitRectBeforeRenderContribution);
  exports.SplitRectAfterRenderContribution = class SplitRectAfterRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
      useStyle = true;
      order = 0;
      drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb) {
          const { width = groupAttribute.width, height = groupAttribute.height, stroke = groupAttribute.stroke } = rect.attribute;
          if (!(Array.isArray(stroke) && stroke.some(s => s === false))) {
              return;
          }
          context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute);
          context.beginPath();
          context.moveTo(x, y);
          if (stroke[0]) {
              context.lineTo(x + width, y);
          }
          else {
              context.moveTo(x + width, y);
          }
          if (stroke[1]) {
              context.lineTo(x + width, y + height);
          }
          else {
              context.moveTo(x + width, y + height);
          }
          if (stroke[2]) {
              context.lineTo(x, y + height);
          }
          else {
              context.moveTo(x, y + height);
          }
          if (stroke[3]) {
              const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;
              context.lineTo(x, adjustY);
          }
          else {
              context.moveTo(x, y);
          }
          context.stroke();
      }
  };
  exports.SplitRectAfterRenderContribution = __decorate([
      injectable()
  ], exports.SplitRectAfterRenderContribution);

  exports.DefaultCanvasRectRender = class DefaultCanvasRectRender {
      rectRenderContribitions;
      type = 'rect';
      numberType = RECT_NUMBER_TYPE;
      _rectRenderContribitions;
      constructor(rectRenderContribitions) {
          this.rectRenderContribitions = rectRenderContribitions;
      }
      drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
          const rectAttribute = getTheme(rect, params?.theme).rect;
          const { fill = rectAttribute.fill, background, stroke = rectAttribute.stroke, width = rectAttribute.width, height = rectAttribute.height, cornerRadius = rectAttribute.cornerRadius, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible, x: originX = rectAttribute.x, y: originY = rectAttribute.y } = rect.attribute;
          const fVisible = rectFillVisible(opacity, fillOpacity, width, height);
          const sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(rect.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke || background)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
              return;
          }
          if (cornerRadius === 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
              context.beginPath();
              context.rect(x, y, width, height);
          }
          else {
              context.beginPath();
              createRectPath(context, x, y, width, height, cornerRadius);
          }
          if (!this._rectRenderContribitions) {
              this._rectRenderContribitions = this.rectRenderContribitions.getContributions() || [];
              this._rectRenderContribitions.sort((a, b) => b.order - a.order);
          }
          const doFillOrStroke = {
              doFill,
              doStroke
          };
          this._rectRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.beforeFillStroke) {
                  c.drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, fillCb, strokeCb, doFillOrStroke);
              }
          });
          context.setShadowStyle && context.setShadowStyle(rect, rect.attribute, rectAttribute);
          if (doFillOrStroke.doFill) {
              if (fillCb) {
                  fillCb(context, rect.attribute, rectAttribute);
              }
              else if (fVisible) {
                  context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute);
                  context.fill();
              }
          }
          if (doFillOrStroke.doStroke) {
              if (strokeCb) {
                  strokeCb(context, rect.attribute, rectAttribute);
              }
              else if (sVisible) {
                  context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute);
                  context.stroke();
              }
          }
          this._rectRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.afterFillStroke) {
                  c.drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, fillCb, strokeCb);
              }
          });
      }
      draw(rect, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          const rectAttribute = getTheme(rect, params?.theme).rect;
          let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;
          if (!rect.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              context.transformFromMatrix(rect.transMatrix, true);
          }
          else {
              const point = rect.getOffsetXY(rectAttribute);
              x += point.x;
              y += point.y;
              context.setTransformForCurrent();
          }
          if (drawPathProxy(rect, context, x, y, drawContext, params)) {
              context.highPerformanceRestore();
              return;
          }
          this.drawShape(rect, context, x, y, drawContext, params);
          context.highPerformanceRestore();
      }
  };
  exports.DefaultCanvasRectRender = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(RectRenderContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultCanvasRectRender);

  const SymbolRenderContribution = Symbol.for('SymbolRenderContribution');
  exports.DefaultSymbolRenderContribution = class DefaultSymbolRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
      useStyle = true;
      order = 0;
      drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, fillCb, strokeCb) {
          const { size = symbolAttribute.size, opacity = symbolAttribute.opacity, outerBorder, innerBorder } = symbol.attribute;
          const parsedPath = symbol.getParsedPath();
          if (!parsedPath) {
              return;
          }
          if (outerBorder) {
              const { distance = symbolAttribute.outerBorder.distance } = outerBorder;
              const d = getScaledStroke(context, distance, context.dpr);
              context.beginPath();
              if (parsedPath.drawOffset(context, size, x, y, d) === false) {
                  context.closePath();
              }
              context.setShadowStyle && context.setShadowStyle(symbol, symbol.attribute, symbolAttribute);
              if (strokeCb) {
                  strokeCb(context, outerBorder, symbolAttribute.outerBorder);
              }
              else if (sVisible) {
                  const lastOpacity = symbolAttribute.outerBorder.opacity;
                  symbolAttribute.outerBorder.opacity = opacity;
                  context.setStrokeStyle(symbol, outerBorder, x, y, symbolAttribute.outerBorder);
                  symbolAttribute.outerBorder.opacity = lastOpacity;
                  context.stroke();
              }
          }
          if (innerBorder) {
              const { distance = symbolAttribute.innerBorder.distance } = innerBorder;
              const d = getScaledStroke(context, distance, context.dpr);
              context.beginPath();
              if (parsedPath.drawOffset(context, size, x, y, -d) === false) {
                  context.closePath();
              }
              context.setShadowStyle && context.setShadowStyle(symbol, symbol.attribute, symbolAttribute);
              if (strokeCb) {
                  strokeCb(context, innerBorder, symbolAttribute.innerBorder);
              }
              else if (sVisible) {
                  const lastOpacity = symbolAttribute.innerBorder.opacity;
                  symbolAttribute.innerBorder.opacity = opacity;
                  context.setStrokeStyle(symbol, innerBorder, x, y, symbolAttribute.innerBorder);
                  symbolAttribute.innerBorder.opacity = lastOpacity;
                  context.stroke();
              }
          }
      }
  };
  exports.DefaultSymbolRenderContribution = __decorate([
      injectable()
  ], exports.DefaultSymbolRenderContribution);
  class DefaultSymbolBackgroundRenderContribution extends exports.DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
  }
  class DefaultSymbolTextureRenderContribution extends exports.DefaultBaseTextureRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
  }

  exports.DefaultCanvasSymbolRender = class DefaultCanvasSymbolRender extends BaseRender {
      symbolRenderContribitions;
      type;
      numberType = SYMBOL_NUMBER_TYPE;
      _symbolRenderContribitions;
      constructor(symbolRenderContribitions) {
          super();
          this.symbolRenderContribitions = symbolRenderContribitions;
      }
      drawShape(symbol, context, x, y, drawContext, params, fillCb, strokeCb) {
          const symbolAttribute = getTheme(symbol, params?.theme).symbol;
          const { size = symbolAttribute.size, fill = symbolAttribute.fill, background, fillOpacity = symbolAttribute.fillOpacity, strokeOpacity = symbolAttribute.strokeOpacity, opacity = symbolAttribute.opacity, lineWidth = symbolAttribute.lineWidth, stroke = symbolAttribute.stroke, visible = symbolAttribute.visible, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY } = symbol.attribute;
          const fVisible = fillVisible(opacity, fillOpacity);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(symbol.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke || background)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
              return;
          }
          const parsedPath = symbol.getParsedPath();
          if (!parsedPath) {
              return;
          }
          const { keepDirIn3d = symbolAttribute.keepDirIn3d } = symbol.attribute;
          const z = this.z ?? 0;
          context.beginPath();
          if (keepDirIn3d && context.camera && context.project) {
              const p = context.project(x, y, z);
              const camera = context.camera;
              context.camera = null;
              if (parsedPath.draw(context, size, p.x, p.y) === false) {
                  context.closePath();
              }
              context.camera = camera;
          }
          else {
              if (parsedPath.draw(context, size, x, y, z) === false) {
                  context.closePath();
              }
          }
          if (!this._symbolRenderContribitions) {
              this._symbolRenderContribitions = this.symbolRenderContribitions.getContributions() || [];
              this._symbolRenderContribitions.sort((a, b) => b.order - a.order);
          }
          this._symbolRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.beforeFillStroke) {
                  c.drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, fillCb, strokeCb);
              }
          });
          context.setShadowStyle && context.setShadowStyle(symbol, symbol.attribute, symbolAttribute);
          if (doFill) {
              if (fillCb) {
                  fillCb(context, symbol.attribute, symbolAttribute);
              }
              else if (fVisible) {
                  context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute);
                  context.fill();
              }
          }
          if (doStroke) {
              if (strokeCb) {
                  strokeCb(context, symbol.attribute, symbolAttribute);
              }
              else if (sVisible) {
                  context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute);
                  context.stroke();
              }
          }
          this._symbolRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.afterFillStroke) {
                  c.drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, fillCb, strokeCb);
              }
          });
      }
      draw(symbol, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          const symbolAttribute = getTheme(symbol, params?.theme).symbol;
          const data = this.transform(symbol, symbolAttribute, context);
          const { x, y, z, lastModelMatrix } = data;
          this.z = z;
          if (drawPathProxy(symbol, context, x, y, drawContext, params)) {
              context.highPerformanceRestore();
              return;
          }
          this.drawShape(symbol, context, x, y, drawContext, params);
          this.z = 0;
          if (context.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(context.modelMatrix);
          }
          context.modelMatrix = lastModelMatrix;
          context.highPerformanceRestore();
      }
  };
  exports.DefaultCanvasSymbolRender = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(SymbolRenderContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultCanvasSymbolRender);

  exports.DefaultCanvasTextRender = class DefaultCanvasTextRender extends BaseRender {
      type;
      numberType = TEXT_NUMBER_TYPE;
      z;
      drawShape(text, context, x, y, drawContext, params, fillCb, strokeCb) {
          const textAttribute = getTheme(text, params?.theme).text;
          const { text: str, fill = textAttribute.fill, stroke = textAttribute.stroke, fillOpacity = textAttribute.fillOpacity, strokeOpacity = textAttribute.strokeOpacity, opacity = textAttribute.opacity, lineWidth = textAttribute.lineWidth, visible = textAttribute.visible, underline = textAttribute.underline, lineThrough = textAttribute.lineThrough, keepDirIn3d = textAttribute.keepDirIn3d, fontSize = textAttribute.fontSize, textBaseline = textAttribute.textBaseline, x: originX = textAttribute.x, y: originY = textAttribute.y } = text.attribute;
          const lineHeight = text.attribute.lineHeight ?? fontSize;
          const fVisible = fillVisible(opacity, fillOpacity);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(text.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke || fVisible || sVisible)) {
              return;
          }
          const transform3dMatrixToContextMatrix = !keepDirIn3d;
          const z = this.z || 0;
          context.beginPath();
          context.setShadowStyle && context.setShadowStyle(text, text.attribute, textAttribute);
          transform3dMatrixToContextMatrix && this.transformUseContext2d(text, textAttribute, z, context);
          if (Array.isArray(str)) {
              context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z);
              const { multilineLayout } = text;
              if (!multilineLayout) {
                  context.highPerformanceRestore();
                  return;
              }
              const { xOffset, yOffset } = multilineLayout.bbox;
              if (doStroke) {
                  if (strokeCb) {
                      strokeCb(context, text.attribute, textAttribute);
                  }
                  else if (sVisible) {
                      context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                      multilineLayout.lines.forEach(line => {
                          context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
                      });
                  }
              }
              if (doFill) {
                  if (fillCb) {
                      fillCb(context, text.attribute, textAttribute);
                  }
                  else if (fVisible) {
                      context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                      multilineLayout.lines.forEach(line => {
                          context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
                          this.drawMultiUnderLine(underline, lineThrough, text, (line.leftOffset || 0) + x, (line.topOffset || 0) + yOffset + y, z, line.width, textAttribute, context);
                      });
                  }
              }
          }
          else {
              context.setTextStyle(text.attribute, textAttribute, z);
              const t = text.clipedText;
              let dy = 0;
              if (lineHeight !== fontSize) {
                  if (textBaseline === 'top') {
                      dy = (lineHeight - fontSize) / 2;
                  }
                  else if (textBaseline === 'middle') ;
                  else if (textBaseline === 'bottom') {
                      dy = -(lineHeight - fontSize) / 2;
                  }
                  else ;
              }
              if (doStroke) {
                  if (strokeCb) {
                      strokeCb(context, text.attribute, textAttribute);
                  }
                  else if (sVisible) {
                      context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                      context.strokeText(t, x, y + dy, z);
                  }
              }
              if (doFill) {
                  if (fillCb) {
                      fillCb(context, text.attribute, textAttribute);
                  }
                  else if (fVisible) {
                      context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                      context.fillText(t, x, y + dy, z);
                      this.drawUnderLine(underline, lineThrough, text, x, y + dy, z, textAttribute, context);
                  }
              }
          }
          transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text, textAttribute, z, context);
      }
      draw(text, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          const textAttribute = getTheme(text, params?.theme).text;
          const { keepDirIn3d = textAttribute.keepDirIn3d } = text.attribute;
          const computed3dMatrix = !keepDirIn3d;
          const data = this.transform(text, textAttribute, context, computed3dMatrix);
          const { x, y, z, lastModelMatrix } = data;
          this.z = z;
          this.drawShape(text, context, x, y, drawContext, params);
          this.z = 0;
          context.modelMatrix = lastModelMatrix;
          context.highPerformanceRestore();
      }
      drawUnderLine(underline, lineThrough, text, x, y, z, textAttribute, context) {
          if (lineThrough + underline <= 0) {
              return;
          }
          const { textAlign = textAttribute.textAlign, textBaseline = textAttribute.textBaseline, fontSize = textAttribute.fontSize, fill = textAttribute.fill, opacity = textAttribute.opacity, fillOpacity = textAttribute.fillOpacity } = text.attribute;
          const w = text.clipedWidth;
          const offsetX = textDrawOffsetX(textAlign, w);
          const offsetY = textLayoutOffsetY(textBaseline, fontSize, fontSize);
          const attribute = { lineWidth: 0, stroke: fill, opacity, strokeOpacity: fillOpacity };
          if (underline) {
              attribute.lineWidth = underline;
              context.setStrokeStyle(text, attribute, x, y, textAttribute);
              context.beginPath();
              const dy = y + offsetY + fontSize;
              context.moveTo(x + offsetX, dy, z);
              context.lineTo(x + offsetX + w, dy, z);
              context.stroke();
          }
          if (lineThrough) {
              attribute.lineWidth = lineThrough;
              context.setStrokeStyle(text, attribute, x, y, textAttribute);
              context.beginPath();
              const dy = y + offsetY + fontSize / 2;
              context.moveTo(x + offsetX, dy, z);
              context.lineTo(x + offsetX + w, dy, z);
              context.stroke();
          }
      }
      drawMultiUnderLine(underline, lineThrough, text, x, y, z, w, textAttribute, context) {
          if (lineThrough + underline <= 0) {
              return;
          }
          const { textAlign = textAttribute.textAlign, fontSize = textAttribute.fontSize, fill = textAttribute.fill, opacity = textAttribute.opacity, fillOpacity = textAttribute.fillOpacity } = text.attribute;
          const offsetX = textDrawOffsetX(textAlign, w);
          const offsetY = textLayoutOffsetY('alphabetic', fontSize, fontSize);
          const attribute = { lineWidth: 0, stroke: fill, opacity, strokeOpacity: fillOpacity };
          let deltaY = -3;
          if (underline) {
              attribute.lineWidth = underline;
              context.setStrokeStyle(text, attribute, x, y, textAttribute);
              context.beginPath();
              const dy = y + offsetY + fontSize + deltaY;
              context.moveTo(x + offsetX, dy, z);
              context.lineTo(x + offsetX + w, dy, z);
              context.stroke();
          }
          deltaY = -1;
          if (lineThrough) {
              attribute.lineWidth = lineThrough;
              context.setStrokeStyle(text, attribute, x, y, textAttribute);
              context.beginPath();
              const dy = y + offsetY + fontSize / 2 + deltaY;
              context.moveTo(x + offsetX, dy, z);
              context.lineTo(x + offsetX + w, dy, z);
              context.stroke();
          }
      }
  };
  exports.DefaultCanvasTextRender = __decorate([
      injectable()
  ], exports.DefaultCanvasTextRender);

  exports.AbstractGraphicRender = class AbstractGraphicRender {
      type;
      numberType;
  };
  exports.AbstractGraphicRender = __decorate([
      injectable()
  ], exports.AbstractGraphicRender);

  function drawPolygon(path, points, x, y) {
      path.moveTo(points[0].x + x, points[0].y + y);
      for (let i = 1; i < points.length; i++) {
          path.lineTo(points[i].x + x, points[i].y + y);
      }
  }
  function drawRoundedPolygon(path, points, x, y, cornerRadius) {
      if (points.length < 3) {
          drawPolygon(path, points, x, y);
          return;
      }
      for (let i = 0; i < points.length; i++) {
          const p1 = points[i];
          const angularPoint = points[(i + 1) % points.length];
          const p2 = points[(i + 2) % points.length];
          const dx1 = angularPoint.x - p1.x;
          const dy1 = angularPoint.y - p1.y;
          const dx2 = angularPoint.x - p2.x;
          const dy2 = angularPoint.y - p2.y;
          const angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2;
          const tan = Math.abs(Math.tan(angle));
          let radius = Array.isArray(cornerRadius) ? cornerRadius[(i + 1) % points.length] ?? 0 : cornerRadius;
          let segment = radius / tan;
          const length1 = getLength(dx1, dy1);
          const length2 = getLength(dx2, dy2);
          const length = Math.min(length1, length2);
          if (segment > length) {
              segment = length;
              radius = length * tan;
          }
          const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1);
          const p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2);
          const dx = angularPoint.x * 2 - p1Cross.x - p2Cross.x;
          const dy = angularPoint.y * 2 - p1Cross.y - p2Cross.y;
          const L = getLength(dx, dy);
          const d = getLength(segment, radius);
          const circlePoint = getProportionPoint(angularPoint, d, L, dx, dy);
          let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
          const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
          let sweepAngle = endAngle - startAngle;
          if (sweepAngle < 0) {
              startAngle = endAngle;
              sweepAngle = -sweepAngle;
          }
          if (sweepAngle > Math.PI) {
              sweepAngle = sweepAngle - Math.PI;
          }
          if (i === 0) {
              path.moveTo(p1Cross.x + x, p1Cross.y + y);
          }
          else {
              path.lineTo(p1Cross.x + x, p1Cross.y + y);
          }
          if (sweepAngle) {
              path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius);
          }
          path.lineTo(p2Cross.x + x, p2Cross.y + y);
      }
  }
  function getLength(dx, dy) {
      return Math.sqrt(dx * dx + dy * dy);
  }
  function getProportionPoint(point, segment, length, dx, dy) {
      const factor = segment / length;
      return {
          x: point.x - dx * factor,
          y: point.y - dy * factor
      };
  }

  const PolygonRenderContribution = Symbol.for('PolygonRenderContribution');
  let DefaultPolygonBackgroundRenderContribution = class DefaultPolygonBackgroundRenderContribution extends exports.DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
  };
  DefaultPolygonBackgroundRenderContribution = __decorate([
      injectable()
  ], DefaultPolygonBackgroundRenderContribution);
  let DefaultPolygonTextureRenderContribution = class DefaultPolygonTextureRenderContribution extends exports.DefaultBaseTextureRenderContribution {
      time = exports.BaseRenderContributionTime.afterFillStroke;
  };
  DefaultPolygonTextureRenderContribution = __decorate([
      injectable()
  ], DefaultPolygonTextureRenderContribution);

  exports.DefaultCanvasPolygonRender = class DefaultCanvasPolygonRender {
      polygonRenderContribitions;
      type;
      numberType = POLYGON_NUMBER_TYPE;
      _polygonRenderContribitions;
      constructor(polygonRenderContribitions) {
          this.polygonRenderContribitions = polygonRenderContribitions;
      }
      drawShape(polygon, context, x, y, drawContext, params, fillCb, strokeCb) {
          const polygonAttribute = getTheme(polygon, params?.theme).polygon;
          const { points = polygonAttribute.points, fill = polygonAttribute.fill, stroke = polygonAttribute.stroke, cornerRadius = polygonAttribute.cornerRadius, fillOpacity = polygonAttribute.fillOpacity, background, strokeOpacity = polygonAttribute.strokeOpacity, lineWidth = polygonAttribute.lineWidth, opacity = polygonAttribute.opacity, visible = polygonAttribute.visible, x: originX = polygonAttribute.x, y: originY = polygonAttribute.y } = polygon.attribute;
          const fVisible = fillVisible(opacity, fillOpacity);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(polygon.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke || background)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
              return;
          }
          context.beginPath();
          if (cornerRadius <= 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
              drawPolygon(context.camera ? context : context.nativeContext, points, x, y);
          }
          else {
              drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius);
          }
          context.closePath();
          if (!this._polygonRenderContribitions) {
              this._polygonRenderContribitions = this.polygonRenderContribitions.getContributions() || [];
              this._polygonRenderContribitions.sort((a, b) => b.order - a.order);
          }
          this._polygonRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.beforeFillStroke) {
                  c.drawShape(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, fillCb, strokeCb);
              }
          });
          context.setShadowStyle && context.setShadowStyle(polygon, polygon.attribute, polygonAttribute);
          if (doFill) {
              if (fillCb) {
                  fillCb(context, polygon.attribute, polygonAttribute);
              }
              else if (fillOpacity) {
                  context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute);
                  context.fill();
              }
          }
          if (doStroke) {
              if (strokeCb) {
                  strokeCb(context, polygon.attribute, polygonAttribute);
              }
              else if (strokeOpacity) {
                  context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute);
                  context.stroke();
              }
          }
          this._polygonRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.afterFillStroke) {
                  c.drawShape(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, fillCb, strokeCb);
              }
          });
      }
      draw(polygon, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          const polygonAttribute = getTheme(polygon, params?.theme).polygon;
          let { x = polygonAttribute.x, y = polygonAttribute.y } = polygon.attribute;
          if (!polygon.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              context.transformFromMatrix(polygon.transMatrix, true);
          }
          else {
              const point = polygon.getOffsetXY(polygonAttribute);
              x += point.x;
              y += point.y;
              context.setTransformForCurrent();
          }
          if (drawPathProxy(polygon, context, x, y, drawContext, params)) {
              context.highPerformanceRestore();
              return;
          }
          this.drawShape(polygon, context, x, y, drawContext, params);
          context.highPerformanceRestore();
      }
  };
  exports.DefaultCanvasPolygonRender = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(PolygonRenderContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultCanvasPolygonRender);

  const ImageRenderContribution = Symbol.for('ImageRenderContribution');
  exports.DefaultImageBackgroundRenderContribution = class DefaultImageBackgroundRenderContribution extends exports.DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb) {
          const { background, width, height } = graphic.attribute;
          if (!background) {
              return;
          }
          if (!graphic.backgroundImg) {
              context.beginPath();
              const b = graphic.AABBBounds;
              context.rect(x, y, b.width(), b.height());
              context.fillStyle = background;
              context.globalAlpha = 1;
              context.fill();
          }
          else {
              const res = graphic.resources.get(background);
              if (res.state !== 'success' || !res.data) {
                  return;
              }
              context.save();
              if (graphic.parent && !graphic.transMatrix.onlyTranslate()) {
                  const groupAttribute = getTheme(graphic.parent).group;
                  const { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;
                  context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
                  context.translate(scrollX, scrollY);
              }
              const b = graphic.AABBBounds;
              context.drawImage(res.data, b.x1, b.y1, b.width(), b.height());
              context.restore();
              if (!graphic.transMatrix.onlyTranslate()) {
                  context.setTransformForCurrent();
              }
          }
      }
  };
  exports.DefaultImageBackgroundRenderContribution = __decorate([
      injectable()
  ], exports.DefaultImageBackgroundRenderContribution);

  const repeatStr = ['', 'repeat-x', 'repeat-y', 'repeat'];
  exports.DefaultCanvasImageRender = class DefaultCanvasImageRender {
      imageRenderContribitions;
      type;
      numberType = IMAGE_NUMBER_TYPE;
      _imageRenderContribitions;
      constructor(imageRenderContribitions) {
          this.imageRenderContribitions = imageRenderContribitions;
      }
      drawShape(image, context, x, y, drawContext, params, fillCb) {
          const imageAttribute = getTheme(image).image;
          const { fill = imageAttribute.fill, width = imageAttribute.width, height = imageAttribute.height, opacity = imageAttribute.opacity, fillOpacity = imageAttribute.fillOpacity, visible = imageAttribute.visible, repeatX = imageAttribute.repeatX, repeatY = imageAttribute.repeatY, image: url } = image.attribute;
          const fVisible = fillVisible(opacity, fillOpacity);
          const doFill = runFill(fill);
          if (!(image.valid && visible)) {
              return;
          }
          if (!doFill) {
              return;
          }
          if (!(fVisible || fillCb)) {
              return;
          }
          if (!this._imageRenderContribitions) {
              this._imageRenderContribitions = this.imageRenderContribitions.getContributions() || [];
          }
          this._imageRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.beforeFillStroke) {
                  c.drawShape(image, context, x, y, doFill, false, fVisible, false, imageAttribute, fillCb);
              }
          });
          context.setShadowStyle && context.setShadowStyle(image, imageAttribute);
          if (doFill) {
              if (fillCb) {
                  fillCb(context, image.attribute, imageAttribute);
              }
              else if (fVisible) {
                  if (!url || !image.resources) {
                      return;
                  }
                  const res = image.resources.get(url);
                  if (res.state !== 'success') {
                      return;
                  }
                  context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
                  let repeat = 0;
                  if (repeatX === 'repeat') {
                      repeat |= 0b0001;
                  }
                  if (repeatY === 'repeat') {
                      repeat |= 0b0010;
                  }
                  if (repeat) {
                      const pattern = context.createPattern(res.data, repeatStr[repeat]);
                      context.fillStyle = pattern;
                      context.fillRect(x, y, width, height);
                  }
                  else {
                      context.drawImage(res.data, x, y, width, height);
                  }
              }
          }
          this._imageRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.afterFillStroke) {
                  c.drawShape(image, context, x, y, doFill, false, fVisible, false, imageAttribute, fillCb);
              }
          });
      }
      draw(image, renderService, drawContext) {
          const { context } = renderService.drawParams;
          if (!context) {
              return;
          }
          const imageAttribute = getTheme(image).image;
          let { x = imageAttribute.x, y = imageAttribute.y } = image.attribute;
          const { image: url } = image.attribute;
          if (!url || !image.resources) {
              return;
          }
          const res = image.resources.get(url);
          if (res.state !== 'success') {
              return;
          }
          context.highPerformanceSave();
          if (!image.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              context.transformFromMatrix(image.transMatrix, true);
          }
          else {
              const point = image.getOffsetXY(imageAttribute);
              x += point.x;
              y += point.y;
              context.setTransformForCurrent();
          }
          this.drawShape(image, context, x, y, drawContext);
          context.highPerformanceRestore();
      }
  };
  exports.DefaultCanvasImageRender = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(ImageRenderContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultCanvasImageRender);

  const IncrementalDrawContribution = Symbol.for('IncrementalDrawContribution');
  const ArcRender = Symbol.for('ArcRender');
  const Arc3dRender = Symbol.for('Arc3dRender');
  const AreaRender = Symbol.for('AreaRender');
  const CircleRender = Symbol.for('CircleRender');
  const GraphicRender = Symbol.for('GraphicRender');
  const GroupRender = Symbol.for('GroupRender');
  const LineRender = Symbol.for('LineRender');
  const PathRender = Symbol.for('PathRender');
  const PolygonRender = Symbol.for('PolygonRender');
  const RectRender = Symbol.for('RectRender');
  const Rect3DRender = Symbol.for('Rect3DRender');
  const SymbolRender = Symbol.for('SymbolRender');
  const TextRender = Symbol.for('TextRender');
  const RichTextRender = Symbol.for('RichTextRender');
  const Pyramid3dRender = Symbol.for('Pyramid3dRender');
  const GlyphRender = Symbol.for('GlyphRender');
  const ImageRender = Symbol.for('ImageRender');
  const RenderSelector = Symbol.for('RenderSelector');
  const DrawContribution = Symbol.for('DrawContribution');

  const GroupRenderContribution = Symbol.for('GroupRenderContribution');
  exports.DefaultGroupBackgroundRenderContribution = class DefaultGroupBackgroundRenderContribution extends exports.DefaultBaseBackgroundRenderContribution {
      time = exports.BaseRenderContributionTime.beforeFillStroke;
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb) {
          const { background } = graphic.attribute;
          if (!background) {
              return;
          }
          if (graphic.backgroundImg && graphic.resources) {
              const res = graphic.resources.get(background);
              if (res.state !== 'success' || !res.data) {
                  return;
              }
              context.highPerformanceSave();
              context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
              const b = graphic.AABBBounds;
              context.drawImage(res.data, b.x1, b.y1, b.width(), b.height());
              context.highPerformanceRestore();
              context.setTransformForCurrent();
          }
          else {
              context.highPerformanceSave();
              context.fillStyle = background;
              context.fill();
              context.highPerformanceRestore();
          }
      }
  };
  exports.DefaultGroupBackgroundRenderContribution = __decorate([
      injectable()
  ], exports.DefaultGroupBackgroundRenderContribution);

  const RenderService = Symbol.for('RenderService');
  const BeforeRenderConstribution = Symbol.for('BeforeRenderConstribution');
  exports.DefaultRenderService = class DefaultRenderService {
      drawContribution;
      dirtyBounds;
      renderTreeRoots;
      renderLists;
      drawParams;
      constructor(drawContribution) {
          this.drawContribution = drawContribution;
      }
      prepare(updateBounds) {
          this.renderTreeRoots.forEach(g => {
              this._prepare(g, updateBounds);
          });
          return;
      }
      _prepare(g, updateBounds) {
          g.forEachChildren(g => {
              this._prepare(g, updateBounds);
          });
          g.update({ bounds: updateBounds, trans: true });
      }
      prepareRenderList() {
          return;
      }
      beforeDraw(params) {
          return;
      }
      draw(params) {
          this.drawContribution.draw(this, { ...this.drawParams });
      }
      afterDraw(params) {
          return;
      }
      render(groups, params) {
          this.renderTreeRoots = groups;
          this.drawParams = params;
          const updateBounds = params.updateBounds;
          this.prepare(updateBounds);
          this.prepareRenderList();
          this.beforeDraw(params);
          this.draw(params);
          this.afterDraw(params);
      }
  };
  exports.DefaultRenderService = __decorate([
      injectable(),
      __param(0, inject(DrawContribution)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultRenderService);

  var renderModule$1 = new ContainerModule(bind => {
      bind(exports.DefaultRenderService).toSelf();
      bind(RenderService).toService(exports.DefaultRenderService);
  });

  function foreach(graphic, defaultZIndex, cb, reverse = false, sort3d = false) {
      const childMap = {};
      const zIdxArray = [];
      let needSort = false;
      if (sort3d) {
          needSort = true;
      }
      else {
          let lastZIndex;
          graphic.forEachChildren((item, i) => {
              const { zIndex = defaultZIndex } = item.attribute;
              if (i === 0) {
                  lastZIndex = zIndex;
              }
              else if (lastZIndex !== zIndex) {
                  needSort = true;
                  return true;
              }
              return false;
          }, reverse);
      }
      if (needSort) {
          graphic.forEachChildren((item) => {
              const { zIndex = defaultZIndex } = item.attribute;
              if (childMap[zIndex]) {
                  childMap[zIndex].push(item);
              }
              else {
                  childMap[zIndex] = [item];
                  zIdxArray.push(zIndex);
              }
          }, reverse);
          zIdxArray.sort((a, b) => (reverse ? b - a : a - b));
          let skip = false;
          for (let i = 0; i < zIdxArray.length; i++) {
              if (skip) {
                  break;
              }
              const idx = zIdxArray[i];
              const children = childMap[idx];
              if (sort3d) {
                  children.sort((a, b) => {
                      return (reverse ? -1 : 1) * ((b.attribute.z ?? 0) - (a.attribute.z ?? 0));
                  });
              }
              for (let i = 0; i < children.length; i++) {
                  if (cb(children[i], i)) {
                      skip = true;
                      break;
                  }
              }
          }
      }
      else {
          graphic.forEachChildren(cb, reverse);
      }
  }
  async function foreachAsync(graphic, defaultZIndex, cb, reverse = false) {
      await graphic.forEachChildrenAsync(cb, reverse);
  }
  function findNextGraphic(graphic, id, defaultZIndex, reverse = false) {
      const childMap = {};
      const zIdxArray = [];
      let needSort = false;
      let lastZIndex;
      graphic.forEachChildren((item, i) => {
          const { zIndex = defaultZIndex } = item.attribute;
          if (i === 0) ;
          else if (lastZIndex !== zIndex) {
              needSort = true;
              return true;
          }
          return false;
      }, reverse);
      let result = null;
      let next = false;
      if (needSort) {
          graphic.forEachChildren((item) => {
              const { zIndex = defaultZIndex } = item.attribute;
              if (childMap[zIndex]) {
                  childMap[zIndex].push(item);
              }
              else {
                  childMap[zIndex] = [item];
                  zIdxArray.push(zIndex);
              }
          }, reverse);
          zIdxArray.sort((a, b) => (reverse ? b - a : a - b));
          let skip = false;
          for (let i = 0; i < zIdxArray.length; i++) {
              if (skip) {
                  break;
              }
              const idx = zIdxArray[i];
              const children = childMap[idx];
              for (let i = 0; i < children.length; i++) {
                  if (next) {
                      skip = true;
                      result = children[i];
                      break;
                  }
                  if (children[i]._uid === id) {
                      next = true;
                      continue;
                  }
              }
          }
      }
      else {
          graphic.forEachChildren(item => {
              if (next) {
                  result = item;
                  return true;
              }
              if (item._uid === id) {
                  next = true;
              }
              return false;
          }, reverse);
      }
      return result;
  }

  const PickItemInterceptor = Symbol.for('PickItemInterceptor');
  let Canvas3DPickItemInterceptor = class Canvas3DPickItemInterceptor {
      order = 1;
      beforePickItem(graphic, pickerService, point, pickParams, params) {
          if (!graphic.in3dMode || pickParams.in3dInterceptor) {
              return null;
          }
          const context = pickerService.pickContext;
          const stage = graphic.stage;
          if (!(context && stage)) {
              return null;
          }
          pickParams.in3dInterceptor = true;
          context.save();
          this.initCanvasCtx(context);
          context.camera = stage.camera;
          if (graphic.isContainer) {
              let isPie = false;
              let is3d = false;
              graphic.forEachChildren((c) => {
                  isPie = c.numberType === ARC3D_NUMBER_TYPE;
                  return !isPie;
              });
              graphic.forEachChildren((c) => {
                  is3d = !!c.findFace;
                  return !is3d;
              });
              let result;
              if (isPie) {
                  const children = graphic.getChildren();
                  const sortedChildren = [...children];
                  sortedChildren.sort((a, b) => {
                      let angle1 = (a.attribute.startAngle ?? 0 + a.attribute.endAngle ?? 0) / 2;
                      let angle2 = (b.attribute.startAngle ?? 0 + b.attribute.endAngle ?? 0) / 2;
                      while (angle1 < 0) {
                          angle1 += pi2;
                      }
                      while (angle2 < 0) {
                          angle2 += pi2;
                      }
                      return angle2 - angle1;
                  });
                  sortedChildren.forEach(c => {
                      c._next = null;
                      c._prev = null;
                  });
                  graphic.removeAllChild();
                  graphic.update();
                  sortedChildren.forEach(c => {
                      graphic.appendChild(c);
                  });
                  pickParams.hack_pieFace = 'outside';
                  result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);
                  if (!result.graphic) {
                      pickParams.hack_pieFace = 'inside';
                      result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);
                  }
                  if (!result.graphic) {
                      pickParams.hack_pieFace = 'top';
                      result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);
                  }
                  graphic.removeAllChild();
                  children.forEach(c => {
                      c._next = null;
                      c._prev = null;
                  });
                  children.forEach(c => {
                      graphic.appendChild(c);
                  });
              }
              else if (is3d) {
                  const children = graphic.getChildren();
                  const zChildren = children.map(g => {
                      const face3d = g.findFace();
                      const vertices = face3d.vertices;
                      const viewdVerticesZ = vertices.map(v => {
                          return context.view(v[0], v[1], v[2] + g.attribute.z ?? 0)[2];
                      });
                      const ave_z = viewdVerticesZ.reduce((a, b) => a + b, 0);
                      return {
                          ave_z,
                          g
                      };
                  });
                  zChildren.sort((a, b) => b.ave_z - a.ave_z);
                  graphic.removeAllChild();
                  zChildren.forEach(i => {
                      i.g._next = null;
                      i.g._prev = null;
                  });
                  graphic.update();
                  zChildren.forEach(i => {
                      graphic.add(i.g);
                  });
                  result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);
                  graphic.removeAllChild();
                  children.forEach(g => {
                      g._next = null;
                      g._prev = null;
                  });
                  graphic.update();
                  children.forEach(g => {
                      graphic.add(g);
                  });
              }
              else {
                  result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);
              }
              context.camera = null;
              context.restore();
              pickParams.in3dInterceptor = false;
              return result;
          }
          return null;
      }
      initCanvasCtx(context) {
          context.setTransformForCurrent();
      }
  };
  Canvas3DPickItemInterceptor = __decorate([
      injectable()
  ], Canvas3DPickItemInterceptor);

  const GraphicPicker = Symbol.for('GraphicPicker');
  const PickerService = Symbol.for('PickerService');
  exports.DefaultPickService = class DefaultPickService {
      global;
      pickItemInterceptorContributions;
      type = 'default';
      constructor(global, pickItemInterceptorContributions) {
          this.global = global;
          this.pickItemInterceptorContributions = pickItemInterceptorContributions;
      }
      _init() {
          this.InterceptorContributions = this.pickItemInterceptorContributions
              .getContributions()
              .sort((a, b) => a.order - b.order);
      }
      pick(graphics, point, params) {
          let result = {
              graphic: null,
              group: null
          };
          params.pickerService = this;
          let offsetX = 0;
          let offsetY = 0;
          if (params && params.bounds) {
              if (!params.bounds.contains(point.x, point.y)) {
                  return result;
              }
              offsetX = params.bounds.x1;
              offsetY = params.bounds.y1;
          }
          if (this.pickContext) {
              this.pickContext.inuse = true;
          }
          params.pickContext = this.pickContext;
          this.pickContext && this.pickContext.clearMatrix(true, 1);
          const parentMatrix = new Matrix(1, 0, 0, 1, offsetX, offsetY);
          let group;
          for (let i = graphics.length - 1; i >= 0; i--) {
              if (graphics[i].isContainer) {
                  result = this.pickGroup(graphics[i], point, parentMatrix, params);
              }
              else {
                  result.graphic = this.pickItem(graphics[i], point, params);
              }
              if (result.graphic) {
                  break;
              }
              if (!group) {
                  group = result.group;
              }
          }
          if (!result.graphic) {
              result.group = group;
          }
          if (this.pickContext) {
              this.pickContext.inuse = false;
          }
          return result;
      }
      containsPoint(graphic, point, params) {
          return !!this.pickItem(graphic, point, params);
      }
      pickGroup(group, point, parentMatrix, params) {
          let result = {
              group: null,
              graphic: null
          };
          if (group.attribute.visibleAll === false) {
              return result;
          }
          const context = params.pickContext;
          const lastMatrix = context.modelMatrix;
          if (context.camera) {
              const m = group.transMatrix;
              const matrix = mat4Allocate.allocate();
              mat3Tomat4(matrix, m);
              if (lastMatrix) {
                  if (matrix) {
                      const m = mat4Allocate.allocate();
                      context.modelMatrix = multiplyMat4Mat4(m, lastMatrix, matrix);
                      mat4Allocate.free(matrix);
                  }
              }
              else {
                  mat3Tomat4(matrix, group.globalTransMatrix);
                  context.modelMatrix = matrix;
              }
          }
          if (this.InterceptorContributions.length) {
              for (let i = 0; i < this.InterceptorContributions.length; i++) {
                  const drawContribution = this.InterceptorContributions[i];
                  if (drawContribution.beforePickItem) {
                      const result = drawContribution.beforePickItem(group, this, point, params, { parentMatrix });
                      if (result) {
                          if (context.modelMatrix !== lastMatrix) {
                              mat4Allocate.free(context.modelMatrix);
                          }
                          context.modelMatrix = lastMatrix;
                          return result;
                      }
                  }
              }
          }
          const transMatrix = group.transMatrix;
          const currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix);
          const newPoint = new Point(point.x, point.y);
          currentGroupMatrix.transformPoint(newPoint, newPoint);
          const insideGroup = group.AABBBounds.containsPoint(newPoint);
          if (!insideGroup && !group.stage.camera) {
              return result;
          }
          const groupPicked = group.attribute.pickable !== false && insideGroup;
          currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f);
          if (group.attribute.childrenPickable !== false) {
              foreach(group, DefaultAttribute.zIndex, (graphic) => {
                  if (graphic.isContainer) {
                      const newPoint = new Point(point.x, point.y);
                      const theme = getTheme(group).group;
                      const { scrollX = theme.scrollX, scrollY = theme.scrollY } = group.attribute;
                      newPoint.x -= scrollX;
                      newPoint.y -= scrollY;
                      result = this.pickGroup(graphic, newPoint, currentGroupMatrix, params);
                  }
                  else {
                      const newPoint = new Point(point.x, point.y);
                      currentGroupMatrix.transformPoint(newPoint, newPoint);
                      const theme = getTheme(group).group;
                      const { scrollX = theme.scrollX, scrollY = theme.scrollY } = group.attribute;
                      newPoint.x -= scrollX;
                      newPoint.y -= scrollY;
                      const pickedItem = this.pickItem(graphic, newPoint, params);
                      result.graphic = pickedItem;
                  }
                  return !!result.graphic || !!result.group;
              }, true, !!context.camera);
          }
          if (context.modelMatrix !== lastMatrix) {
              mat4Allocate.free(context.modelMatrix);
          }
          context.modelMatrix = lastMatrix;
          if (!result.graphic && !result.group && groupPicked && !group.stage.camera) {
              result.group = group;
          }
          matrixAllocate.free(currentGroupMatrix);
          return result;
      }
      selectPicker(graphic) {
          const picker = this.pickerMap.get(graphic.numberType);
          if (!picker) {
              return null;
          }
          return picker;
      }
  };
  exports.DefaultPickService = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __param(1, inject(ContributionProvider)),
      __param(1, named(PickItemInterceptor)),
      __metadata("design:paramtypes", [Object, Object])
  ], exports.DefaultPickService);

  const BoundsPicker = Symbol.for('BoundsPicker');
  const GlobalPickerService = Symbol.for('GlobalPickerService');
  exports.DefaultGlobalPickerService = class DefaultGlobalPickerService {
      global;
      type;
      constructor(global) {
          this.global = global;
          this.global.hooks.onSetEnv.tap('global-picker-service', (lastEnv, env, global) => {
              this.configure(global, env);
          });
          this.configure(this.global, this.global.env);
      }
      configure(global, env) {
      }
      pick(graphics, point, params) {
          let result = {
              graphic: null,
              group: null
          };
          const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
          let group;
          for (let i = 0; i < graphics.length; i++) {
              if (graphics[i].isContainer) {
                  result = this.pickGroup(graphics[i], point, parentMatrix, params);
              }
              else {
                  result.graphic = this.pickItem(graphics[i], point, params);
              }
              if (result.graphic) {
                  break;
              }
              if (!group) {
                  group = result.group;
              }
          }
          if (!result.graphic) {
              result.group = group;
          }
          return result;
      }
      containsPoint(graphic, point, params) {
          return !!this.pickItem(graphic, point, params);
      }
      pickGroup(group, point, parentMatrix, params) {
          let result = {
              group: null,
              graphic: null
          };
          if (group.attribute.visibleAll === false) {
              return result;
          }
          const transMatrix = group.transMatrix;
          const newPoint = new Point(point.x, point.y);
          parentMatrix.transformPoint(newPoint, newPoint);
          const insideGroup = group.AABBBounds.containsPoint(newPoint);
          if (!insideGroup) {
              return result;
          }
          const groupPicked = group.attribute.pickable !== false && insideGroup;
          parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f);
          if (group.attribute.childrenPickable !== false) {
              group.forEachChildren((graphic) => {
                  if (graphic.isContainer) {
                      result = this.pickGroup(graphic, point, parentMatrix, params);
                  }
                  else {
                      const newPoint = new Point(point.x, point.y);
                      parentMatrix.transformPoint(newPoint, newPoint);
                      result.graphic = this.pickItem(graphic, newPoint, params);
                  }
                  return !!result.graphic || !!result.group;
              });
          }
          if (!result.graphic && !result.group && groupPicked) {
              result.group = group;
          }
          return result;
      }
      pickItem(graphic, point, params) {
          if (graphic.attribute.pickable === false) {
              return null;
          }
          if (graphic.AABBBounds.containsPoint(point)) {
              return graphic;
          }
          return null;
      }
  };
  exports.DefaultGlobalPickerService = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], exports.DefaultGlobalPickerService);

  function lookAt(out, eye, center, up) {
      let x0;
      let x1;
      let x2;
      let y0;
      let y1;
      let y2;
      let z0;
      let z1;
      let z2;
      let len;
      const eyex = eye[0];
      const eyey = eye[1];
      const eyez = eye[2];
      const upx = up[0];
      const upy = up[1];
      const upz = up[2];
      const centerx = center[0];
      const centery = center[1];
      const centerz = center[2];
      if (Math.abs(eyex - centerx) < epsilon && Math.abs(eyey - centery) < epsilon && Math.abs(eyez - centerz) < epsilon) {
          return DefaultMat4Allocate.identity(out);
      }
      z0 = eyex - centerx;
      z1 = eyey - centery;
      z2 = eyez - centerz;
      len = 1 / Math.hypot(z0, z1, z2);
      z0 *= len;
      z1 *= len;
      z2 *= len;
      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;
      len = Math.hypot(x0, x1, x2);
      if (!len) {
          x0 = 0;
          x1 = 0;
          x2 = 0;
      }
      else {
          len = 1 / len;
          x0 *= len;
          x1 *= len;
          x2 *= len;
      }
      y0 = z1 * x2 - z2 * x1;
      y1 = z2 * x0 - z0 * x2;
      y2 = z0 * x1 - z1 * x0;
      len = Math.hypot(y0, y1, y2);
      if (!len) {
          y0 = 0;
          y1 = 0;
          y2 = 0;
      }
      else {
          len = 1 / len;
          y0 *= len;
          y1 *= len;
          y2 *= len;
      }
      out[0] = x0;
      out[1] = y0;
      out[2] = z0;
      out[3] = 0;
      out[4] = x1;
      out[5] = y1;
      out[6] = z1;
      out[7] = 0;
      out[8] = x2;
      out[9] = y2;
      out[10] = z2;
      out[11] = 0;
      out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
      out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
      out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
      out[15] = 1;
      return out;
  }
  function ortho(out, left, right, bottom, top, near, far) {
      const lr = 1 / (left - right);
      const bt = 1 / (bottom - top);
      const nf = 1 / (near - far);
      out[0] = -2 * lr;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = -2 * bt;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 2 * nf;
      out[11] = 0;
      out[12] = (left + right) * lr;
      out[13] = (top + bottom) * bt;
      out[14] = (far + near) * nf;
      out[15] = 1;
      return out;
  }
  function multiply(out, a, b) {
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a10 = a[4];
      const a11 = a[5];
      const a12 = a[6];
      const a13 = a[7];
      const a20 = a[8];
      const a21 = a[9];
      const a22 = a[10];
      const a23 = a[11];
      const a30 = a[12];
      const a31 = a[13];
      const a32 = a[14];
      const a33 = a[15];
      let b0 = b[0];
      let b1 = b[1];
      let b2 = b[2];
      let b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
  }
  function transformMat4(out, a, m) {
      const x = a[0];
      const y = a[1];
      const z = a[2];
      let w = m[3] * x + m[7] * y + m[11] * z + m[15];
      w = w || 1.0;
      out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
      out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
      out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
      return out;
  }
  class OrthoCamera {
      _params;
      _projectionMatrixCached;
      _viewMatrixCached;
      _vp;
      set params(params) {
          this._params = { ...params };
          this._projectionMatrixCached = this.forceGetProjectionMatrix();
          this._viewMatrixCached = this.forceGetViewMatrix();
      }
      get params() {
          return { ...this._params };
      }
      constructor(params) {
          this.params = params;
      }
      getViewMatrix() {
          if (!this._viewMatrixCached) {
              this._viewMatrixCached = mat4Allocate.allocate();
          }
          return this._viewMatrixCached;
      }
      forceGetViewMatrix() {
          if (!this._viewMatrixCached) {
              this._viewMatrixCached = mat4Allocate.allocate();
          }
          const { pos, center, up } = this.params.viewParams;
          lookAt(this._viewMatrixCached, pos, center, up);
          if (!this._vp) {
              this._vp = mat4Allocate.allocate();
          }
          this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix());
          return this._viewMatrixCached;
      }
      getProjectionMatrix() {
          if (!this._projectionMatrixCached) {
              this._projectionMatrixCached = mat4Allocate.allocate();
          }
          return this._projectionMatrixCached;
      }
      forceGetProjectionMatrix() {
          if (!this._projectionMatrixCached) {
              this._projectionMatrixCached = mat4Allocate.allocate();
          }
          const { left, top, right, bottom } = this._params;
          ortho(this._projectionMatrixCached, left, right, bottom, top, 0.0, -2000000.0);
          if (!this._vp) {
              this._vp = mat4Allocate.allocate();
          }
          this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix());
          return this._projectionMatrixCached;
      }
      getField() {
          const { fieldRatio = 0.8, fieldDepth, left, right } = this._params;
          return (fieldDepth ?? right - left) * fieldRatio;
      }
      getProjectionScale(z) {
          const field = this.getField();
          return field / (field + z);
      }
      view(x, y, z) {
          const outP = [0, 0, 0];
          transformMat4(outP, [x, y, z], this._viewMatrixCached);
          return outP;
      }
      vp(x, y, z) {
          const outP = [0, 0, 0];
          const { pos } = this._params.viewParams;
          transformMat4(outP, [x, y, z], this._viewMatrixCached);
          x = outP[0];
          y = outP[1];
          z = outP[2];
          const sizeProjection = this.getProjectionScale(z);
          const xProject = x * sizeProjection + pos[0];
          const yProject = y * sizeProjection + pos[1];
          return {
              x: xProject,
              y: yProject
          };
      }
  }

  const outP = [0, 0, 0];
  const initMatrix$1 = new Matrix(1, 0, 0, 1, 0, 0);
  const addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) => {
      if (clockwise) {
          while (endAngle > startAngle) {
              endAngle -= pi2;
          }
      }
      else {
          while (endAngle < startAngle) {
              endAngle += pi2;
          }
      }
      const step = (pi / 3) * (endAngle > startAngle ? 1 : -1);
      let sa = startAngle;
      let ea = sa;
      while (ea !== endAngle) {
          ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);
          const delta = Math.abs(ea - sa);
          const len = (Math.tan(delta / 4) * 4) / 3;
          const dir = ea < sa ? -1 : 1;
          const c1 = Math.cos(sa);
          const s1 = Math.sin(sa);
          const c2 = Math.cos(ea);
          const s2 = Math.sin(ea);
          const x1 = c1 * rx + cx;
          const y1 = s1 * ry + cy;
          const x4 = c2 * rx + cx;
          const y4 = s2 * ry + cy;
          const hx = rx * len * dir;
          const hy = ry * len * dir;
          bezierPath.push([x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4]);
          sa = ea;
      }
  };
  exports.BrowserContext2d = class BrowserContext2d {
      static env = 'browser';
      drawPromise;
      modelMatrix;
      matrix;
      applyedMatrix;
      set fillStyle(d) {
          this.nativeContext.fillStyle = d;
      }
      get fillStyle() {
          return this.nativeContext.fillStyle;
      }
      set font(d) {
          this.nativeContext.font = d;
      }
      get font() {
          return this.nativeContext.font;
      }
      set globalAlpha(d) {
          this.nativeContext.globalAlpha = d;
      }
      get globalAlpha() {
          return this.nativeContext.globalAlpha;
      }
      set lineCap(d) {
          this.nativeContext.lineCap = d;
      }
      get lineCap() {
          return this.nativeContext.lineCap;
      }
      set lineDashOffset(d) {
          this.nativeContext.lineDashOffset = d;
      }
      get lineDashOffset() {
          return this.nativeContext.lineDashOffset;
      }
      set lineJoin(d) {
          this.nativeContext.lineJoin = d;
      }
      get lineJoin() {
          return this.nativeContext.lineJoin;
      }
      set lineWidth(d) {
          this.nativeContext.lineWidth = d;
      }
      get lineWidth() {
          return this.nativeContext.lineWidth;
      }
      set miterLimit(d) {
          this.nativeContext.miterLimit = d;
      }
      get miterLimit() {
          return this.nativeContext.miterLimit;
      }
      set shadowBlur(d) {
          this.nativeContext.shadowBlur = d;
      }
      get shadowBlur() {
          return this.nativeContext.shadowBlur;
      }
      set shadowColor(d) {
          this.nativeContext.shadowColor = d;
      }
      get shadowColor() {
          return this.nativeContext.shadowColor;
      }
      set shadowOffsetX(d) {
          this.nativeContext.shadowOffsetX = d;
      }
      get shadowOffsetX() {
          return this.nativeContext.shadowOffsetX;
      }
      set shadowOffsetY(d) {
          this.nativeContext.shadowOffsetY = d;
      }
      get shadowOffsetY() {
          return this.nativeContext.shadowOffsetY;
      }
      set strokeStyle(d) {
          this.nativeContext.strokeStyle = d;
      }
      get strokeStyle() {
          return this.nativeContext.strokeStyle;
      }
      set textAlign(d) {
          this.nativeContext.textAlign = d;
      }
      get textAlign() {
          return this.nativeContext.textAlign;
      }
      set textBaseline(d) {
          this.nativeContext.textBaseline = d;
      }
      get textBaseline() {
          return this.nativeContext.textBaseline;
      }
      get inuse() {
          return !!this._inuse;
      }
      set inuse(use) {
          if (use === !!this._inuse) {
              return;
          }
          this._inuse = use;
          if (use) {
              this.nativeContext.save();
              this.reset();
          }
          else {
              this.nativeContext.restore();
          }
      }
      dpr;
      constructor(canvas, dpr) {
          const context = canvas.nativeCanvas.getContext('2d');
          if (!context) {
              throw new Error('2d');
          }
          this.nativeContext = context;
          this.canvas = canvas;
          this.matrix = new Matrix(1, 0, 0, 1, 0, 0);
          this.stack = [];
          this.dpr = dpr;
          this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0);
      }
      reset() {
          if (this.stack.length) {
              console.warn('bugmatrix');
          }
          this.matrix.setValue(1, 0, 0, 1, 0, 0);
          this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0);
          this.stack.length = 0;
          this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
      }
      getCanvas() {
          return this.canvas;
      }
      getContext() {
          return this.nativeContext;
      }
      setTransformForCurrent(force = false) {
          if (!force && this.applyedMatrix.equalToMatrix(this.matrix)) {
              return;
          }
          this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f);
          this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f);
      }
      get currentMatrix() {
          return this.matrix;
      }
      cloneMatrix(m) {
          return matrixAllocate.allocateByObj(m);
      }
      clear() {
          this.save();
          this.resetTransform();
          this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.restore();
      }
      restore() {
          this.nativeContext.restore();
          if (this.stack.length > 0) {
              matrixAllocate.free(this.matrix);
              this.matrix = this.stack.pop();
              this.setTransformForCurrent(true);
          }
      }
      highPerformanceRestore() {
          if (this.stack.length > 0) {
              matrixAllocate.free(this.matrix);
              this.matrix = this.stack.pop();
          }
      }
      rotate(rad, setTransform = true) {
          this.matrix.rotate(rad);
          setTransform && this.setTransformForCurrent();
      }
      save() {
          const matrix = this.cloneMatrix(this.matrix);
          this.stack.push(matrix);
          this.nativeContext.save();
      }
      highPerformanceSave() {
          const matrix = this.cloneMatrix(this.matrix);
          this.stack.push(matrix);
      }
      scale(sx, sy, setTransform = true) {
          this.matrix.scale(sx, sy);
          setTransform && this.setTransformForCurrent();
      }
      setScale(sx, sy, setTransform = true) {
          this.matrix.setScale(sx, sy);
          setTransform && this.setTransformForCurrent();
      }
      scalePoint(sx, sy, px, py, setTransform = true) {
          this.translate(px, py, false);
          this.scale(sx, sy, false);
          this.translate(-px, -py, false);
          setTransform && this.setTransformForCurrent();
      }
      setTransform(a, b, c, d, e, f, setTransform = true, dpr = this.dpr) {
          this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f);
          setTransform && this.setTransformForCurrent();
      }
      setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
          this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr);
          setTransform && this.setTransformForCurrent();
      }
      resetTransform(setTransform = true, dpr = this.dpr) {
          this.setTransform(dpr, 0, 0, dpr, 0, 0);
          setTransform && this.setTransformForCurrent();
      }
      transform(a, b, c, d, e, f, setTransform = true) {
          this.matrix.multiply(a, b, c, d, e, f);
          setTransform && this.setTransformForCurrent();
      }
      transformFromMatrix(matrix, setTransform) {
          this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
          setTransform && this.setTransformForCurrent();
      }
      translate(x, y, setTransform = true) {
          this.matrix.translate(x, y);
          setTransform && this.setTransformForCurrent();
      }
      rotateDegrees(deg, setTransform = true) {
          const rad = (deg * Math.PI) / 180;
          this.rotate(rad, setTransform);
      }
      rotateAbout(rad, x, y, setTransform = true) {
          this.translate(x, y, false);
          this.rotate(rad, false);
          this.translate(-x, -y, false);
          setTransform && this.setTransformForCurrent();
      }
      rotateDegreesAbout(deg, x, y, setTransform = true) {
          this.translate(x, y, false);
          this.rotateDegrees(deg, false);
          this.translate(-x, -y, false);
          setTransform && this.setTransformForCurrent();
      }
      beginPath() {
          if (this.disableBeginPath) {
              return;
          }
          this.nativeContext.beginPath();
      }
      clip(path, fillRule) {
          if (path) {
              if (typeof path === 'string') {
                  this.nativeContext.clip(path);
              }
              else {
                  this.nativeContext.clip(path, fillRule);
              }
          }
          else {
              this.nativeContext.clip();
          }
      }
      arc(x, y, radius, startAngle, endAngle, anticlockwise, z) {
          z = z || 0;
          if (this.camera) {
              const arr = [];
              addArcToBezierPath(arr, startAngle, endAngle, x, y, radius, radius, anticlockwise);
              for (let i = 0; i < arr.length; ++i) {
                  const bez = arr[i];
                  this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z);
              }
          }
          else {
              this.nativeContext.arc(x, y, radius, startAngle, endAngle, anticlockwise);
          }
      }
      arcTo(x1, y1, x2, y2, radiusX) {
          this.nativeContext.arcTo(x1, y1, x2, y2, radiusX);
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, z) {
          z = z || 0;
          if (this.camera) {
              let cp1z = z;
              let cp2z = z;
              if (this.modelMatrix) {
                  transformMat4(outP, [cp1x, cp1y, z], this.modelMatrix);
                  cp1x = outP[0];
                  cp1y = outP[1];
                  cp1z = outP[2];
                  transformMat4(outP, [cp2x, cp2y, z], this.modelMatrix);
                  cp2x = outP[0];
                  cp2y = outP[1];
                  cp2z = outP[2];
                  transformMat4(outP, [x, y, z], this.modelMatrix);
                  x = outP[0];
                  y = outP[1];
                  z = outP[2];
              }
              let data = this.camera.vp(x, y, z);
              x = data.x;
              y = data.y;
              data = this.camera.vp(cp1x, cp1y, cp1z);
              cp1x = data.x;
              cp1y = data.y;
              data = this.camera.vp(cp2x, cp2y, cp2z);
              cp2x = data.x;
              cp2y = data.y;
          }
          this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      }
      closePath() {
          this.nativeContext.closePath();
      }
      ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
          if (anticlockwise == null) {
              this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle);
          }
          else {
              this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
          }
      }
      lineTo(x, y, z) {
          z = z || 0;
          if (this.camera) {
              if (this.modelMatrix) {
                  transformMat4(outP, [x, y, z], this.modelMatrix);
                  x = outP[0];
                  y = outP[1];
                  z = outP[2];
              }
              const data = this.camera.vp(x, y, z);
              x = data.x;
              y = data.y;
          }
          this.nativeContext.lineTo(x, y);
      }
      moveTo(x, y, z) {
          z = z || 0;
          if (this.camera) {
              if (this.modelMatrix) {
                  transformMat4(outP, [x, y, z], this.modelMatrix);
                  x = outP[0];
                  y = outP[1];
                  z = outP[2];
              }
              const data = this.camera.vp(x, y, z);
              x = data.x;
              y = data.y;
          }
          this.nativeContext.moveTo(x, y);
      }
      quadraticCurveTo(cpx, cpy, x, y, z) {
          z = z || 0;
          if (this.camera) {
              let cpz = z;
              if (this.modelMatrix) {
                  transformMat4(outP, [cpx, cpy, z], this.modelMatrix);
                  cpx = outP[0];
                  cpy = outP[1];
                  cpz = outP[2];
                  transformMat4(outP, [x, y, z], this.modelMatrix);
                  x = outP[0];
                  y = outP[1];
                  z = outP[2];
              }
              let data = this.camera.vp(x, y, z);
              x = data.x;
              y = data.y;
              data = this.camera.vp(cpx, cpy, cpz);
              cpx = data.x;
              cpy = data.y;
          }
          this.nativeContext.quadraticCurveTo(cpx, cpy, x, y);
      }
      rect(x, y, w, h, z) {
          z = z || 0;
          if (this.camera) {
              this.moveTo(x, y, z);
              this.lineTo(x + w, y, z);
              this.lineTo(x + w, y + h, z);
              this.lineTo(x, y + h, z);
              this.closePath();
          }
          else {
              this.nativeContext.rect(x, y, w, h);
          }
      }
      createImageData() {
          const a = arguments;
          if (a.length === 2) {
              return this.nativeContext.createImageData(a[0], a[1]);
          }
          else if (a.length === 1) {
              return this.nativeContext.createImageData(a[0]);
          }
          return null;
      }
      createLinearGradient(x0, y0, x1, y1) {
          return this.nativeContext.createLinearGradient(x0, y0, x1, y1);
      }
      createPattern(image, repetition) {
          if (image.width === 0 || image.height === 0) {
              return null;
          }
          return this.nativeContext.createPattern(image, repetition);
      }
      createRadialGradient(x0, y0, r0, x1, y1, r1) {
          return this.nativeContext.createRadialGradient(x0, y0, r0, x1, y1, r1);
      }
      createConicGradient(x, y, startAngle, endAngle) {
          let edit = false;
          let pattern;
          const ctx = this;
          const obj = {
              stops: [],
              addColorStop(offset, color) {
                  this.stops.push([offset, color]);
                  edit = true;
              },
              GetPattern(minW, minH, deltaAngle) {
                  if (edit) {
                      if (!deltaAngle) {
                          deltaAngle = endAngle - startAngle;
                      }
                      pattern = createConicalGradient(ctx, this.stops, x, y, deltaAngle, startAngle, endAngle, minW, minH);
                      edit = false;
                  }
                  return pattern;
              }
          };
          return obj;
      }
      fill(path, fillRule) {
          if (this.disableFill) {
              return;
          }
          path ? this.nativeContext.fill(path) : this.nativeContext.fill();
      }
      fillRect(x, y, width, height) {
          this.nativeContext.fillRect(x, y, width, height);
      }
      clearRect(x, y, w, h) {
          this.nativeContext.clearRect(x, y, w, h);
      }
      project(x, y, z) {
          z = z || 0;
          if (this.camera) {
              if (this.modelMatrix) {
                  transformMat4(outP, [x, y, z], this.modelMatrix);
                  x = outP[0];
                  y = outP[1];
                  z = outP[2];
              }
              const data = this.camera.vp(x, y, z);
              x = data.x;
              y = data.y;
          }
          return { x, y };
      }
      view(x, y, z) {
          z = z || 0;
          if (this.camera) {
              if (this.modelMatrix) {
                  transformMat4(outP, [x, y, z], this.modelMatrix);
                  x = outP[0];
                  y = outP[1];
                  z = outP[2];
              }
              return this.camera.view(x, y, z);
          }
          return [x, y, z];
      }
      fillText(text, x, y, z) {
          z = z || 0;
          if (this.camera) {
              if (this.modelMatrix) {
                  transformMat4(outP, [x, y, z], this.modelMatrix);
                  x = outP[0];
                  y = outP[1];
                  z = outP[2];
              }
              const data = this.camera.vp(x, y, z);
              x = data.x;
              y = data.y;
          }
          this.nativeContext.fillText(text, x, y);
      }
      getImageData(sx, sy, sw, sh) {
          return this.nativeContext.getImageData(sx, sy, sw, sh);
      }
      getLineDash() {
          return this.nativeContext.getLineDash();
      }
      isPointInPath(x, y) {
          return this.nativeContext.isPointInPath(x, y);
      }
      isPointInStroke(x, y) {
          return this.nativeContext.isPointInStroke(x, y);
      }
      measureText(text, method = application.global.measureTextMethod) {
          if (!method || method === 'native') {
              return this.nativeContext.measureText(text);
          }
          if (!this.mathTextMeasure) {
              this.mathTextMeasure = application.graphicUtil.createTextMeasureInstance({}, {}, () => this.canvas);
          }
          this.mathTextMeasure.textSpec.fontFamily = this.fontFamily ?? DefaultTextStyle.fontFamily;
          this.mathTextMeasure.textSpec.fontSize = this.fontSize ?? DefaultTextStyle.fontSize;
          this.mathTextMeasure._numberCharSize = null;
          this.mathTextMeasure._fullCharSize = null;
          this.mathTextMeasure._letterCharSize = null;
          this.mathTextMeasure._specialCharSizeMap = {};
          return this.mathTextMeasure.measure(text, method);
      }
      putImageData(imagedata, dx, dy) {
          this.nativeContext.putImageData(imagedata, dx, dy);
      }
      setLineDash(segments) {
          const a = arguments;
          const _context = this.nativeContext;
          if (!!this.nativeContext.setLineDash) {
              _context.setLineDash(a[0]);
          }
          else if ('mozDash' in _context) {
              _context.mozDash = a[0];
          }
          else if ('webkitLineDash' in _context) {
              _context.webkitLineDash = a[0];
          }
      }
      stroke(path) {
          if (this.disableStroke) {
              return;
          }
          path ? this.nativeContext.stroke(path) : this.nativeContext.stroke();
      }
      strokeRect(x, y, width, height) {
          this.nativeContext.strokeRect(x, y, width, height);
      }
      strokeText(text, x, y, z) {
          z = z || 0;
          if (this.camera) {
              if (this.modelMatrix) {
                  transformMat4(outP, [x, y, z], this.modelMatrix);
                  x = outP[0];
                  y = outP[1];
                  z = outP[2];
              }
              const data = this.camera.vp(x, y, z);
              x = data.x;
              y = data.y;
          }
          this.nativeContext.strokeText(text, x, y);
      }
      drawImage() {
          const _context = this.nativeContext;
          const a = arguments;
          if (a.length === 3) {
              _context.drawImage(a[0], a[1], a[2]);
          }
          else if (a.length === 5) {
              _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
          }
          else if (a.length === 9) {
              _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
          }
      }
      fillAttributes = { ...DefaultFillStyle, opacity: 1 };
      strokeAttributes = { ...DefaultStrokeStyle, opacity: 1 };
      textAttributes = { ...DefaultTextStyle, opacity: 1 };
      setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
          if (Array.isArray(defaultParams)) {
              if (defaultParams.length <= 1) {
                  return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
              }
              const dp = {};
              defaultParams.forEach(p => {
                  Object.assign(dp, p);
              });
              return this._setCommonStyle(params, attribute, offsetX, offsetY, dp);
          }
          return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams);
      }
      _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.fillAttributes;
          }
          const { fillOpacity = defaultParams.fillOpacity, opacity = defaultParams.opacity, fill = defaultParams.fill } = attribute;
          if (fillOpacity > 1e-12 && opacity > 1e-12) {
              _context.globalAlpha = fillOpacity * opacity;
              _context.fillStyle = createColor(this, fill, params, offsetX, offsetY);
          }
          else {
              _context.globalAlpha = fillOpacity * opacity;
          }
      }
      setShadowStyle(params, attribute, defaultParams) {
          if (Array.isArray(defaultParams)) {
              if (defaultParams.length <= 1) {
                  return this._setShadowStyle(params, defaultParams[0]);
              }
              const dp = {};
              defaultParams.forEach(p => {
                  Object.assign(dp, p);
              });
              return this._setShadowStyle(params, attribute, dp);
          }
          return this._setShadowStyle(params, attribute, defaultParams);
      }
      _clearShadowStyle = false;
      _clearFilterStyle = false;
      _setShadowStyle(params, attribute, defaultParams) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.fillAttributes;
          }
          const { opacity = defaultParams.opacity, shadowBlur = defaultParams.shadowBlur, shadowColor = defaultParams.shadowColor, shadowOffsetX = defaultParams.shadowOffsetX, shadowOffsetY = defaultParams.shadowOffsetY, blur = defaultParams.blur } = attribute;
          if (opacity <= 1e-12) {
              return;
          }
          if (shadowBlur || shadowOffsetX || shadowOffsetY) {
              _context.shadowBlur = shadowBlur;
              _context.shadowColor = shadowColor;
              _context.shadowOffsetX = shadowOffsetX;
              _context.shadowOffsetY = shadowOffsetY;
              this._clearShadowStyle = true;
          }
          else if (this._clearShadowStyle) {
              _context.shadowBlur = 0;
              _context.shadowOffsetX = 0;
              _context.shadowOffsetY = 0;
          }
          if (blur) {
              _context.filter = `blur(${blur}px)`;
              this._clearFilterStyle = true;
          }
          else if (this._clearFilterStyle) {
              _context.filter = 'blur(0px)';
              this._clearFilterStyle = false;
          }
      }
      setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
          if (Array.isArray(defaultParams)) {
              if (defaultParams.length <= 1) {
                  return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
              }
              const dp = {};
              defaultParams.forEach(p => {
                  Object.assign(dp, p);
              });
              return this._setStrokeStyle(params, attribute, offsetX, offsetY, dp);
          }
          return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams);
      }
      _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.strokeAttributes;
          }
          const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
          if (strokeOpacity > 1e-12 && opacity > 1e-12) {
              const { lineWidth = defaultParams.lineWidth, stroke = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit } = attribute;
              _context.globalAlpha = strokeOpacity * opacity;
              _context.lineWidth = getScaledStroke(this, lineWidth, this.dpr);
              _context.strokeStyle = createColor(this, stroke, params, offsetX, offsetY);
              _context.lineJoin = lineJoin;
              _context.setLineDash(lineDash);
              _context.lineCap = lineCap;
              _context.miterLimit = miterLimit;
          }
      }
      setTextStyleWithoutAlignBaseline(params, defaultParams, z) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.textAttributes;
          }
          const { scaleIn3d = defaultParams.scaleIn3d } = params;
          if (params.font) {
              _context.font = params.font;
          }
          else {
              _context.font = getContextFont(params, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z));
          }
          const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params;
          this.fontFamily = fontFamily;
          this.fontSize = fontSize;
          _context.textAlign = 'left';
          _context.textBaseline = 'alphabetic';
      }
      setTextStyle(params, defaultParams, z) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.textAttributes;
          }
          if (params.font) {
              _context.font = params.font;
          }
          else {
              _context.font = getContextFont(params, defaultParams, this.camera && this.camera.getProjectionScale(z));
          }
          const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params;
          this.fontFamily = fontFamily;
          this.fontSize = fontSize;
          _context.textAlign = params.textAlign ?? defaultParams.textAlign;
          _context.textBaseline = params.textBaseline ?? defaultParams.textBaseline;
      }
      draw() {
          return;
      }
      clearMatrix(setTransform = true, dpr = this.dpr) {
          this.setTransformFromMatrix(initMatrix$1, setTransform, dpr);
      }
      onlyTranslate(dpr = this.dpr) {
          return this.matrix.a === dpr && this.matrix.b === 0 && this.matrix.c === 0 && this.matrix.d === dpr;
      }
      release(...params) {
          this.stack.forEach(m => matrixAllocate.free(m));
          this.stack.length = 0;
          return;
      }
  };
  exports.BrowserContext2d = __decorate([
      injectable(),
      __metadata("design:paramtypes", [Object, Number])
  ], exports.BrowserContext2d);

  const DefaultConfig$6 = {
      WIDTH: 500,
      HEIGHT: 500,
      DPR: 1
  };
  exports.BrowserCanvas = class BrowserCanvas {
      static env = 'browser';
      _displayWidth;
      _displayHeight;
      _id;
      _pixelWidth;
      _pixelHeight;
      _x;
      _y;
      _dpr;
      _container;
      _nativeCanvas;
      _context;
      _visiable;
      controled;
      get displayWidth() {
          return this._pixelWidth / this._dpr;
      }
      get displayHeight() {
          return this._pixelHeight / this._dpr;
      }
      get id() {
          return this._id;
      }
      get x() {
          return this._x;
      }
      get y() {
          return this._y;
      }
      get nativeCanvas() {
          return this._nativeCanvas;
      }
      get width() {
          return this._pixelWidth;
      }
      set width(width) {
          this._pixelWidth = width;
          this._displayWidth = width / (this._dpr || 1);
      }
      get height() {
          return this._pixelHeight;
      }
      set height(height) {
          this._pixelHeight = height;
          this._displayHeight = height / (this._dpr || 1);
      }
      getContext(str) {
          return this._context;
      }
      get visiable() {
          return this._visiable;
      }
      set visiable(visiable) {
          this._visiable = visiable;
          visiable ? this.show() : this.hide();
      }
      get dpr() {
          return this._dpr;
      }
      set dpr(dpr) {
          this._dpr = dpr;
          this.resize(this.width, this.height);
      }
      constructor(params) {
          const { nativeCanvas, width = DefaultConfig$6.WIDTH, height = DefaultConfig$6.HEIGHT, dpr = DefaultConfig$6.DPR, container, x, y, canvasControled = true } = params;
          const offsetX = 0;
          const offsetY = 0;
          this._x = x ?? offsetX;
          this._y = y ?? offsetY;
          this._pixelWidth = width * dpr;
          this._pixelHeight = height * dpr;
          this._visiable = params.visiable !== false;
          this.controled = canvasControled;
          if (typeof container === 'string') {
              const _c = application.global.getElementById(container);
              if (_c) {
                  this._container = _c;
              }
          }
          else {
              this._container = container;
          }
          this._displayWidth = width;
          this._displayHeight = height;
          this._dpr = dpr;
          this._nativeCanvas = nativeCanvas;
          this._context = new exports.BrowserContext2d(this, this._dpr);
          this._id = nativeCanvas.id;
          this.initStyle();
      }
      initStyle() {
          if (!this.controled) {
              return;
          }
          const { nativeCanvas } = this;
          nativeCanvas.width = this._pixelWidth;
          nativeCanvas.height = this._pixelHeight;
          const isOffscreen = !nativeCanvas.style;
          if (!isOffscreen) {
              this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight);
          }
          if (this.id != null) {
              nativeCanvas.id = this.id.toString();
          }
          if (this._container) {
              this._container.appendChild(nativeCanvas);
          }
          if (!this.visiable) {
              this.hide();
          }
      }
      applyPosition() {
          const canvas = this._nativeCanvas;
          canvas.style.position = 'absolute';
          canvas.style.top = `${this._y}px`;
          canvas.style.left = `${this._x}px`;
      }
      getNativeCanvas() {
          return this._nativeCanvas;
      }
      resetStyle(params) {
          if (!this.controled) {
              return;
          }
          const { width = this._displayWidth, height = this._displayHeight, dpr = this._dpr, x = this._x, y = this._y } = params;
          const { nativeCanvas } = this;
          nativeCanvas.width = width * dpr;
          nativeCanvas.height = height * dpr;
          const isOffscreen = !nativeCanvas.style;
          if (!isOffscreen) {
              this.setCanvasStyle(nativeCanvas, x, y, width, height);
          }
          params.id && (nativeCanvas.id = params.id);
          if (!this.visiable) {
              this.hide();
          }
      }
      setCanvasStyle(canvas, x, y, w, h) {
          if (!this.controled) {
              return;
          }
          canvas.style.padding = '0';
          canvas.style.margin = '0';
          canvas.style.border = '0';
          canvas.style.background = 'transparent';
          canvas.style.width = `${w}px`;
          canvas.style.height = `${h}px`;
      }
      hide() {
          this._nativeCanvas && (this._nativeCanvas.style.display = 'none');
      }
      show() {
          this._nativeCanvas && (this._nativeCanvas.style.display = 'block');
      }
      resize(width, height) {
          if (!this.controled) {
              return;
          }
          this._pixelWidth = width * this._dpr;
          this._pixelHeight = height * this._dpr;
          this._displayWidth = width;
          this._displayHeight = height;
          if (this._nativeCanvas.style) {
              this._nativeCanvas.style.width = `${width}px`;
              this._nativeCanvas.style.height = `${height}px`;
          }
          this._nativeCanvas.width = this._pixelWidth;
          this._nativeCanvas.height = this._pixelHeight;
          const _context = this._context;
          _context.dpr = this._dpr;
      }
      toDataURL(mimeType, quality) {
          if (mimeType === 'image/jpeg') {
              return this._nativeCanvas.toDataURL(mimeType, quality);
          }
          else if (mimeType === 'image/png') {
              return this._nativeCanvas.toDataURL(mimeType);
          }
          return this._nativeCanvas.toDataURL(mimeType, quality);
      }
      readPixels(x, y, w, h) {
          return this._context.getImageData(x, y, w, h);
      }
      convertToBlob(options) {
          throw new Error('');
      }
      transferToImageBitmap() {
          throw new Error('');
      }
      release(...params) {
          if (this.controled) {
              this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
          }
      }
  };
  exports.BrowserCanvas = __decorate([
      injectable(),
      __metadata("design:paramtypes", [Object])
  ], exports.BrowserCanvas);

  const CanvasArcPicker = Symbol.for('CanvasArcPicker');
  const CanvasArc3dPicker = Symbol.for('CanvasArc3dPicker');
  const CanvasAreaPicker = Symbol.for('CanvasAreaPicker');
  const CanvasCirclePicker = Symbol.for('CanvasCirclePicker');
  const CanvasImagePicker = Symbol.for('CanvasImagePicker');
  const CanvasLinePicker = Symbol.for('CanvasLinePicker');
  const CanvasPathPicker = Symbol.for('CanvasPathPicker');
  const CanvasRectPicker = Symbol.for('CanvasRectPicker');
  const CanvasRect3dPicker = Symbol.for('CanvasRect3dPicker');
  const CanvasSymbolPicker = Symbol.for('CanvasSymbolPicker');
  const CanvasTextPicker = Symbol.for('CanvasTextPicker');
  const CanvasPolygonPicker = Symbol.for('CanvasPolygonPicker');
  const CanvasPyramid3dPicker = Symbol.for('CanvasPyramid3dPicker');
  const CanvasRichTextPicker = Symbol.for('CanvasRichTextPicker');
  const CanvasGlyphPicker = Symbol.for('CanvasGlyphPicker');
  const CanvasPickerContribution = Symbol.for('CanvasPickerContribution');
  const MathArcPicker = Symbol.for('MathArcPicker');
  const MathAreaPicker = Symbol.for('MathAreaPicker');
  const MathCirclePicker = Symbol.for('MathCirclePicker');
  const MathLinePicker = Symbol.for('MathLinePicker');
  const MathPathPicker = Symbol.for('MathPathPicker');
  const MathRectPicker = Symbol.for('MathRectPicker');
  const MathSymbolPicker = Symbol.for('MathSymbolPicker');
  const MathTextPicker = Symbol.for('MathTextPicker');
  const MathPolygonPicker = Symbol.for('MathPolygonPicker');
  const MathGlyphPicker = Symbol.for('MathGlyphPicker');
  const MathPickerContribution = Symbol.for('MathPickerContribution');

  exports.DefaultCanvasPickerService = class DefaultCanvasPickerService extends exports.DefaultPickService {
      contributions;
      circlePicker;
      rectPicker;
      arcPicker;
      areaPicker;
      imagePicker;
      linePicker;
      pathPicker;
      symbolPicker;
      textPicker;
      polygonPicker;
      richtextPicker;
      drawContribution;
      global;
      pickItemInterceptorContributions;
      constructor(contributions, circlePicker, rectPicker, arcPicker, areaPicker, imagePicker, linePicker, pathPicker, symbolPicker, textPicker, polygonPicker, richtextPicker, drawContribution, global, pickItemInterceptorContributions) {
          super(global, pickItemInterceptorContributions);
          this.contributions = contributions;
          this.circlePicker = circlePicker;
          this.rectPicker = rectPicker;
          this.arcPicker = arcPicker;
          this.areaPicker = areaPicker;
          this.imagePicker = imagePicker;
          this.linePicker = linePicker;
          this.pathPicker = pathPicker;
          this.symbolPicker = symbolPicker;
          this.textPicker = textPicker;
          this.polygonPicker = polygonPicker;
          this.richtextPicker = richtextPicker;
          this.drawContribution = drawContribution;
          this.global = global;
          this.pickItemInterceptorContributions = pickItemInterceptorContributions;
          this.global.hooks.onSetEnv.tap('canvas-picker-service', (_, env, global) => {
              this.configure(global, env);
          });
          this.configure(this.global, this.global.env);
          this.pickerMap = new Map();
      }
      init() {
          this.contributions.getContributions().forEach(item => {
              this.pickerMap.set(item.numberType, item);
          });
          super._init();
      }
      configure(global, env) {
          const options = {
              width: 100,
              height: 100,
              nativeCanvas: global.createCanvas({ width: 100, height: 100 }),
              id: 'for-pick'
          };
          this.pickCanvas = new exports.BrowserCanvas(options);
          this.pickContext = this.pickCanvas.getContext('2d');
      }
      pickItem(graphic, point, params) {
          if (graphic.attribute.pickable === false) {
              return null;
          }
          if (this.InterceptorContributions.length) {
              for (let i = 0; i < this.InterceptorContributions.length; i++) {
                  const drawContribution = this.InterceptorContributions[i];
                  if (drawContribution.beforePickItem) {
                      if (drawContribution.beforePickItem(graphic, this, point, params)) {
                          return graphic;
                      }
                  }
              }
          }
          const picker = this.pickerMap.get(graphic.numberType);
          if (!picker) {
              return null;
          }
          return picker.contains(graphic, point, params) ? graphic : null;
      }
  };
  __decorate([
      postConstruct(),
      __metadata("design:type", Function),
      __metadata("design:paramtypes", []),
      __metadata("design:returntype", void 0)
  ], exports.DefaultCanvasPickerService.prototype, "init", null);
  exports.DefaultCanvasPickerService = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(CanvasPickerContribution)),
      __param(1, inject(CanvasCirclePicker)),
      __param(2, inject(CanvasRectPicker)),
      __param(3, inject(CanvasArcPicker)),
      __param(4, inject(CanvasAreaPicker)),
      __param(5, inject(CanvasImagePicker)),
      __param(6, inject(CanvasLinePicker)),
      __param(7, inject(CanvasPathPicker)),
      __param(8, inject(CanvasSymbolPicker)),
      __param(9, inject(CanvasTextPicker)),
      __param(10, inject(CanvasPolygonPicker)),
      __param(11, inject(CanvasRichTextPicker)),
      __param(12, inject(DrawContribution)),
      __param(13, inject(Global)),
      __param(14, inject(ContributionProvider)),
      __param(14, named(PickItemInterceptor)),
      __metadata("design:paramtypes", [Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object])
  ], exports.DefaultCanvasPickerService);

  const initMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  const globalPoint = { x: 0, y: 0 };
  exports.EmptyContext2d = class EmptyContext2d {
      path;
      canvas;
      stack;
      matrix;
      applyedMatrix;
      fillStyle;
      font;
      globalAlpha;
      lineCap;
      lineDashOffset;
      lineJoin;
      lineWidth;
      miterLimit;
      shadowBlur;
      shadowColor;
      shadowOffsetX;
      shadowOffsetY;
      strokeStyle;
      textAlign;
      textBaseline;
      dpr;
      get nativeContext() {
          return this.path;
      }
      constructor(canvas, dpr) {
          this.matrix = new Matrix(1, 0, 0, 1, 0, 0);
          this.stack = [];
          this.dpr = dpr;
          this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0);
          this.path = new CustomPath2D();
      }
      getCanvas() {
          throw new Error('getCanvas');
      }
      getContext() {
          throw new Error('getContext');
      }
      setTransformForCurrent(force = false) {
          if (!force && this.applyedMatrix.equalToMatrix(this.matrix)) {
              return;
          }
          this.applyedMatrix = this.cloneMatrix(this.matrix);
          return;
      }
      get currentMatrix() {
          return this.matrix;
      }
      cloneMatrix(m) {
          return matrixAllocate.allocateByObj(m);
      }
      clear() {
          this.save();
          this.resetTransform();
          this.restore();
      }
      restore() {
          if (this.stack.length > 0) {
              matrixAllocate.free(this.matrix);
              this.matrix = this.stack.pop();
              this.setTransformForCurrent();
          }
      }
      highPerformanceRestore() {
          if (this.stack.length > 0) {
              matrixAllocate.free(this.matrix);
              this.matrix = this.stack.pop();
          }
      }
      rotate(rad, setTransform = true) {
          this.matrix.rotate(rad);
          setTransform && this.setTransformForCurrent();
      }
      save() {
          const matrix = this.cloneMatrix(this.matrix);
          this.stack.push(matrix);
      }
      highPerformanceSave() {
          const matrix = this.cloneMatrix(this.matrix);
          this.stack.push(matrix);
      }
      scale(sx, sy, setTransform = true) {
          this.matrix.scale(sx, sy);
          setTransform && this.setTransformForCurrent();
      }
      setScale(sx, sy, setTransform = true) {
          this.matrix.setScale(sx, sy);
          setTransform && this.setTransformForCurrent();
      }
      scalePoint(sx, sy, px, py, setTransform = true) {
          this.translate(px, py, false);
          this.scale(sx, sy, false);
          this.translate(-px, -py, false);
          setTransform && this.setTransformForCurrent();
      }
      setTransform(a, b, c, d, e, f, setTransform = true, dpr = this.dpr) {
          this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f);
          setTransform && this.setTransformForCurrent();
      }
      setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
          this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr);
          setTransform && this.setTransformForCurrent();
      }
      resetTransform(setTransform = true, dpr = this.dpr) {
          this.setTransform(dpr, 0, 0, dpr, 0, 0);
          setTransform && this.setTransformForCurrent();
      }
      transform(a, b, c, d, e, f, setTransform = true) {
          this.matrix.multiply(a, b, c, d, e, f);
          setTransform && this.setTransformForCurrent();
      }
      transformFromMatrix(matrix, setTransform) {
          this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
          setTransform && this.setTransformForCurrent();
      }
      translate(x, y, setTransform = true) {
          this.matrix.translate(x, y);
          setTransform && this.setTransformForCurrent();
      }
      rotateDegrees(deg, setTransform = true) {
          const rad = (deg * Math.PI) / 180;
          this.rotate(rad, setTransform);
      }
      rotateAbout(rad, x, y, setTransform = true) {
          this.translate(x, y, false);
          this.rotate(rad, false);
          this.translate(-x, -y, false);
          setTransform && this.setTransformForCurrent();
      }
      rotateDegreesAbout(deg, x, y, setTransform = true) {
          this.translate(x, y, false);
          this.rotateDegrees(deg, false);
          this.translate(-x, -y, false);
          setTransform && this.setTransformForCurrent();
      }
      beginPath() {
          this.path.clear();
      }
      clip(path, fillRule) {
          return;
      }
      arc(x, y, radius, startAngle, endAngle, anticlockwise) {
          this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
      }
      arcTo(x1, y1, x2, y2, radiusX) {
          this.path.arcTo(x1, y1, x2, y2, radiusX);
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
          this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      }
      closePath() {
          this.path.closePath();
      }
      ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
          return;
      }
      lineTo(x, y) {
          this.path.lineTo(x, y);
      }
      moveTo(x, y) {
          this.path.moveTo(x, y);
      }
      quadraticCurveTo(cpx, cpy, x, y) {
          this.path.quadraticCurveTo(cpx, cpy, x, y);
      }
      rect(x, y, w, h) {
          this.path.rect(x, y, w, h);
      }
      createImageData(imageDataOrSw, sh) {
          return null;
      }
      createLinearGradient(x0, y0, x1, y1) {
          throw new Error('createLinearGradient');
      }
      createPattern(image, repetition) {
          throw new Error('createPattern');
      }
      createRadialGradient(x0, y0, r0, x1, y1, r1) {
          throw new Error('createRadialGradient');
      }
      createConicGradient(x, y, startAngle, endAngle) {
          return null;
      }
      fill(path, fillRule) {
          return;
      }
      fillRect(x, y, width, height) {
          this.path.rect(x, y, width, height);
      }
      clearRect(x, y, w, h) {
          return;
      }
      fillText(text, x, y) {
          return;
      }
      getImageData(sx, sy, sw, sh) {
          return null;
      }
      getLineDash() {
          return [];
      }
      isPointInPath(x, y) {
          this.matrix.transformPoint({ x, y }, globalPoint);
          return contain(this.path.commandList, globalPoint.x, globalPoint.y);
      }
      isPointInStroke(x, y) {
          if (!this.lineWidth) {
              return false;
          }
          this.matrix.transformPoint({ x, y }, globalPoint);
          const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
          return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
      }
      measureText(text) {
          throw new Error('measureText');
      }
      putImageData(imagedata, dx, dy) {
          throw new Error('measureText');
      }
      setLineDash(segments) {
          return;
      }
      stroke(path) {
          return;
      }
      strokeRect(x, y, width, height) {
          this.path.rect(x, y, width, height);
      }
      strokeText(text, x, y) {
          return;
      }
      drawImage() {
          return;
      }
      setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
          return;
      }
      _setCommonStyle(params, offsetX, offsetY, defaultParams) {
          return;
      }
      setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
          return;
      }
      _setStrokeStyle(params, offsetX, offsetY, defaultParams) {
          return;
      }
      setTextStyleWithoutAlignBaseline(params, defaultParams) {
          return;
      }
      setTextStyle(params, defaultParams) {
          return;
      }
      draw() {
          return;
      }
      clearMatrix(setTransform = true, dpr = this.dpr) {
          this.setTransformFromMatrix(initMatrix, setTransform, dpr);
      }
      onlyTranslate(dpr = this.dpr) {
          return this.matrix.a === dpr && this.matrix.b === 0 && this.matrix.c === 0 && this.matrix.d === dpr;
      }
      release(...params) {
          this.stack.forEach(m => matrixAllocate.free(m));
          this.stack.length = 0;
          return;
      }
  };
  exports.EmptyContext2d = __decorate([
      injectable(),
      __metadata("design:paramtypes", [Object, Number])
  ], exports.EmptyContext2d);

  exports.DefaultMathPickerService = class DefaultMathPickerService extends exports.DefaultPickService {
      contributions;
      global;
      pickItemInterceptorContributions;
      constructor(contributions, global, pickItemInterceptorContributions) {
          super(global, pickItemInterceptorContributions);
          this.contributions = contributions;
          this.global = global;
          this.pickItemInterceptorContributions = pickItemInterceptorContributions;
          this.global.hooks.onSetEnv.tap('math-picker-service', (lastEnv, env, global) => {
              this.configure(global, env);
          });
          this.configure(this.global, this.global.env);
          this.pickerMap = new Map();
      }
      init() {
          this.contributions.getContributions().forEach(item => {
              this.pickerMap.set(item.numberType, item);
          });
          super._init();
      }
      configure(global, env) {
          this.pickContext = new exports.EmptyContext2d(null, 1);
      }
      pickItem(graphic, point, params) {
          if (graphic.attribute.pickable === false) {
              return null;
          }
          const picker = this.pickerMap.get(graphic.numberType);
          if (!picker) {
              return null;
          }
          return picker.contains(graphic, point, params) ? graphic : null;
      }
  };
  __decorate([
      postConstruct(),
      __metadata("design:type", Function),
      __metadata("design:paramtypes", []),
      __metadata("design:returntype", void 0)
  ], exports.DefaultMathPickerService.prototype, "init", null);
  exports.DefaultMathPickerService = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(MathPickerContribution)),
      __param(1, inject(Global)),
      __param(2, inject(ContributionProvider)),
      __param(2, named(PickItemInterceptor)),
      __metadata("design:paramtypes", [Object, Object, Object])
  ], exports.DefaultMathPickerService);

  var pickModule = new ContainerModule(bind => {
      bind(exports.DefaultCanvasPickerService).toSelf().inSingletonScope();
      bind(exports.DefaultMathPickerService).toSelf().inSingletonScope();
      bind(PickerService).toService(exports.DefaultCanvasPickerService);
      bind(exports.DefaultGlobalPickerService).toSelf().inSingletonScope();
      bind(GlobalPickerService).toService(exports.DefaultGlobalPickerService);
      bind(Canvas3DPickItemInterceptor).toSelf().inSingletonScope();
      bind(PickItemInterceptor).toService(Canvas3DPickItemInterceptor);
      bindContributionProvider(bind, PickItemInterceptor);
  });

  var graphicModule = new ContainerModule(bind => {
      bind(exports.DefaultGraphicService).toSelf().inSingletonScope();
      bind(GraphicService).toService(exports.DefaultGraphicService);
      bind(DefaultRectOuterBorderBoundsContribution).toSelf().inSingletonScope();
      bind(RectBoundsContribution).toService(DefaultRectOuterBorderBoundsContribution);
      bindContributionProvider(bind, RectBoundsContribution);
      bind(DefaultSymbolOuterBorderBoundsContribution).toSelf().inSingletonScope();
      bind(SymbolBoundsContribution).toService(DefaultSymbolOuterBorderBoundsContribution);
      bindContributionProvider(bind, SymbolBoundsContribution);
      bind(DefaultCircleOuterBorderBoundsContribution).toSelf().inSingletonScope();
      bind(CircleBoundsContribution).toService(DefaultCircleOuterBorderBoundsContribution);
      bindContributionProvider(bind, CircleBoundsContribution);
      bind(DefaultArcOuterBorderBoundsContribution).toSelf().inSingletonScope();
      bind(ArcBoundsContribution).toService(DefaultArcOuterBorderBoundsContribution);
      bindContributionProvider(bind, ArcBoundsContribution);
      bind(DefaultPathOuterBorderBoundsContribution).toSelf().inSingletonScope();
      bind(PathBoundsContribution).toService(DefaultPathOuterBorderBoundsContribution);
      bindContributionProvider(bind, PathBoundsContribution);
      bind(GraphicCreator).toConstantValue(graphicCreator);
  });

  const PluginService = Symbol.for('PluginService');
  let DefaultPluginService = class DefaultPluginService {
      constructor() {
          this.onStartupFinishedPlugin = [];
          this.onRegisterPlugin = [];
          this.actived = false;
      }
      active(stage) {
          this.stage = stage;
          this.actived = true;
      }
      findPluginsByName(name) {
          const arr = [];
          this.onStartupFinishedPlugin.forEach(plugin => {
              if (plugin.name === name) {
                  arr.push(plugin);
              }
          });
          this.onRegisterPlugin.forEach(plugin => {
              if (plugin.name === name) {
                  arr.push(plugin);
              }
          });
          return arr;
      }
      register(plugin) {
          if (plugin.activeEvent === 'onStartupFinished') {
              this.onStartupFinishedPlugin.push(plugin);
          }
          else if (plugin.activeEvent === 'onRegister') {
              this.onRegisterPlugin.push(plugin);
              plugin.activate(this);
          }
      }
      release(...params) {
          this.onStartupFinishedPlugin.forEach(plugin => {
              plugin.deactivate(this);
          });
          this.onStartupFinishedPlugin = [];
          this.onRegisterPlugin.forEach(plugin => {
              plugin.deactivate(this);
          });
          this.onRegisterPlugin = [];
      }
  };
  DefaultPluginService = __decorate([
      injectable(),
      __metadata("design:paramtypes", [])
  ], DefaultPluginService);

  var pluginModule = new ContainerModule(bind => {
      bind(DefaultPluginService).toSelf();
      bind(PluginService).toService(DefaultPluginService);
  });

  exports.BaseEnvContribution = class BaseEnvContribution {
      type;
      supportsTouchEvents;
      supportsPointerEvents;
      supportsMouseEvents;
      applyStyles;
      supportEvent;
      configure(service, ...p) {
          if (service.env === this.type) {
              service.setActiveEnvContribution(this);
          }
      }
      getElementById(str) {
          return document.getElementById(str);
      }
      getRootElement() {
          return document.body;
      }
      loadJson(url) {
          const jsonPromise = fetch(url).then(data => data.json());
          jsonPromise
              .then(json => {
              return {
                  data: json,
                  state: 'success'
              };
          })
              .catch(() => {
              return {
                  data: null,
                  state: 'fail'
              };
          });
          return jsonPromise;
      }
      loadArrayBuffer(url) {
          const arrayBufferPromise = fetch(url).then(data => data.arrayBuffer());
          return arrayBufferPromise
              .then((arrayBuffer) => {
              return {
                  data: arrayBuffer,
                  loadState: 'success'
              };
          })
              .catch(() => {
              return {
                  data: null,
                  loadState: 'fail'
              };
          });
      }
      loadBlob(url) {
          const blobPromise = fetch(url).then(data => data.blob());
          return blobPromise
              .then((blob) => {
              return {
                  data: blob,
                  loadState: 'success'
              };
          })
              .catch(() => {
              return {
                  data: null,
                  loadState: 'fail'
              };
          });
      }
  };
  exports.BaseEnvContribution = __decorate([
      injectable()
  ], exports.BaseEnvContribution);

  function createImageElement(src, isSvg = false) {
      const img = document.createElement('img');
      img.crossOrigin = 'anonymous';
      if (isSvg) {
          const data = new Blob([src], { type: 'image/svg+xml' });
          src = window.URL.createObjectURL(data);
      }
      img.src = src;
      if (img.complete) {
          return Promise.resolve(img);
      }
      const promise = new Promise((resolve, reject) => {
          img.onload = () => {
              resolve(img);
          };
          img.onerror = () => {
              reject(new Error(''));
          };
      });
      return promise;
  }
  let BrowserEnvContribution = class BrowserEnvContribution extends exports.BaseEnvContribution {
      type = 'browser';
      supportEvent = true;
      constructor() {
          super();
          try {
              this.supportsTouchEvents = 'ontouchstart' in globalThis;
              this.supportsPointerEvents = !!globalThis.PointerEvent;
              this.supportsMouseEvents = !!globalThis.MouseEvent;
          }
          catch (err) {
              this.supportsTouchEvents = false;
              this.supportsPointerEvents = false;
              this.supportsPointerEvents = false;
          }
          this.applyStyles = true;
      }
      mapToCanvasPoint(nativeEvent, domElement) {
          if (domElement) {
              const { clientX: x, clientY: y } = nativeEvent;
              const rect = domElement.getBoundingClientRect();
              const nativeCanvas = domElement.getNativeHandler?.().nativeCanvas;
              let scaleX;
              let scaleY;
              if (nativeCanvas) {
                  scaleX = rect.width / nativeCanvas.offsetWidth;
                  scaleY = rect.height / nativeCanvas.offsetHeight;
              }
              return {
                  x: (x - rect.left) / (isValidNumber(scaleX) ? scaleX : 1),
                  y: (y - rect.top) / (isValidNumber(scaleY) ? scaleX : 1)
              };
          }
          return {
              x: nativeEvent.offsetX,
              y: nativeEvent.offsetY
          };
      }
      loadImage(url) {
          const imagePromise = createImageElement(url, false);
          return imagePromise
              .then((img) => {
              return {
                  data: img,
                  loadState: 'success'
              };
          })
              .catch(() => {
              return {
                  data: null,
                  loadState: 'fail'
              };
          });
      }
      loadSvg(url) {
          const imagePromise = createImageElement(url, true);
          return imagePromise
              .then((img) => {
              return {
                  data: img,
                  loadState: 'success'
              };
          })
              .catch(() => {
              return {
                  data: null,
                  loadState: 'fail'
              };
          });
      }
      createCanvas(params) {
          const canvas = document.createElement('canvas');
          params.id && (canvas.id = params.id ?? Generator.GenAutoIncrementId().toString());
          const dpr = params.dpr ?? window.devicePixelRatio;
          if (params.width && params.height) {
              canvas.style.width = `${params.width}px`;
              canvas.style.height = `${params.height}px`;
              canvas.width = params.width * dpr;
              canvas.height = params.height * dpr;
          }
          return canvas;
      }
      createOffscreenCanvas(params) {
          const dpr = params.dpr ?? window.devicePixelRatio;
          const canvas = new OffscreenCanvas(params.width * dpr, params.height * dpr);
          return canvas;
      }
      releaseCanvas(canvas) {
          let c;
          if (typeof canvas === 'string') {
              c = document.getElementById(canvas);
          }
          else {
              c = canvas;
          }
          if (!c) {
              return;
          }
          if (c.parentElement) {
              c.parentElement.removeChild(c);
          }
      }
      getDevicePixelRatio() {
          return window.devicePixelRatio;
      }
      getRequestAnimationFrame() {
          return window.requestAnimationFrame;
      }
      getCancelAnimationFrame() {
          return window.cancelAnimationFrame;
      }
      addEventListener(type, listener, options) {
          return document.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
          return document.removeEventListener(type, listener, options);
      }
      dispatchEvent(event) {
          return document.dispatchEvent(event);
      }
      getElementById(str) {
          return document.getElementById(str);
      }
      getRootElement() {
          return document.body;
      }
      getDocument() {
          return document;
      }
      release(...params) {
          return;
      }
  };
  BrowserEnvContribution = __decorate([
      injectable(),
      __metadata("design:paramtypes", [])
  ], BrowserEnvContribution);

  function loadFeishuContributions() {
      container.rebind(PickerService).toService(exports.DefaultMathPickerService);
  }
  function loadTaroContributions() {
      container.rebind(PickerService).toService(exports.DefaultMathPickerService);
  }

  function makeUpCanvas$3(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList) {
      const dpr = tt.getSystemInfoSync().pixelRatio;
      canvasIdLists.forEach((id, i) => {
          const ctx = tt.createCanvasContext(id);
          ctx.canvas = {
              width: domref.width * dpr,
              height: domref.height * dpr
          };
          const canvas = {
              width: domref.width,
              height: domref.height,
              offsetWidth: domref.width,
              offsetHeight: domref.height,
              id: id ?? '',
              getContext: () => ctx,
              getBoundingClientRect: () => ({
                  height: domref.height,
                  width: domref.width
              })
          };
          canvasMap.set(id, canvas);
          if (i >= freeCanvasIdx) {
              freeCanvasList.push(canvas);
          }
      });
  }
  let FeishuEnvContribution = class FeishuEnvContribution extends exports.BaseEnvContribution {
      type = 'feishu';
      supportEvent = true;
      canvasMap = new Map();
      freeCanvasList = [];
      canvasIdx = 0;
      constructor() {
          super();
          this.supportsTouchEvents = true;
          try {
              this.supportsPointerEvents = !!globalThis.PointerEvent;
              this.supportsMouseEvents = !!globalThis.MouseEvent;
          }
          catch (err) {
              this.supportsPointerEvents = false;
              this.supportsMouseEvents = false;
          }
          this.applyStyles = true;
      }
      configure(service, params) {
          if (service.env === this.type) {
              service.setActiveEnvContribution(this);
              makeUpCanvas$3(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList);
              loadFeishuContributions();
          }
      }
      loadImage(url) {
          return Promise.resolve({
              data: url,
              loadState: 'success'
          });
      }
      loadSvg(url) {
          return Promise.reject();
      }
      createCanvas(params) {
          const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
          this.canvasIdx++;
          return result;
      }
      createOffscreenCanvas(params) {
          return;
      }
      releaseCanvas(canvas) {
          return;
      }
      getDevicePixelRatio() {
          return tt.getSystemInfoSync().pixelRatio;
      }
      getRequestAnimationFrame() {
          return function (callback) {
              return setTimeout(callback, 1000 / 60, true);
          };
      }
      getCancelAnimationFrame() {
          return (h) => {
              clearTimeout(h);
          };
      }
      addEventListener(type, listener, options) {
          return null;
      }
      removeEventListener(type, listener, options) {
          return null;
      }
      dispatchEvent(event) {
          return null;
      }
      getElementById(str) {
          return this.canvasMap.get(str);
      }
      getRootElement() {
          return null;
      }
      getDocument() {
          return null;
      }
      release(...params) {
          return;
      }
      mapToCanvasPoint(event) {
          if (event?.type?.startsWith('mouse')) {
              return event;
          }
          return null;
      }
  };
  FeishuEnvContribution = __decorate([
      injectable(),
      __metadata("design:paramtypes", [])
  ], FeishuEnvContribution);

  function makeUpCanvas$2(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, taro, dpr) {
      canvasIdLists.forEach((id, i) => {
          const ctx = taro.createCanvasContext(id);
          ctx.canvas = {
              width: domref.width * dpr,
              height: domref.height * dpr
          };
          if (!ctx.createRadialGradient) {
              ctx.createRadialGradient = (...cc) => ctx.createCircularGradient(...cc);
          }
          if (!ctx.getImageData && taro.canvasGetImageData) {
              ctx.getImageData = (x, y, width, height) => new Promise((resolve, reject) => {
                  try {
                      taro.canvasGetImageData({
                          canvasId: id,
                          x,
                          y,
                          width,
                          height,
                          success(res) {
                              resolve(res);
                          }
                      });
                  }
                  catch (err) {
                      reject(err);
                  }
              });
          }
          const canvas = {
              id: id,
              width: domref.width,
              height: domref.height,
              offsetWidth: domref.width,
              offsetHeight: domref.height,
              getContext: () => ctx,
              getBoundingClientRect: () => ({
                  height: domref.height,
                  width: domref.width
              })
          };
          canvasMap.set(id, canvas);
          if (i >= freeCanvasIdx) {
              freeCanvasList.push(canvas);
          }
          return canvas;
      });
  }
  let TaroEnvContribution = class TaroEnvContribution extends exports.BaseEnvContribution {
      type = 'taro';
      supportEvent = true;
      canvasMap = new Map();
      freeCanvasList = [];
      canvasIdx = 0;
      taro;
      pixelRatio;
      constructor() {
          super();
          this.supportsTouchEvents = true;
          try {
              this.supportsPointerEvents = !!globalThis.PointerEvent;
              this.supportsMouseEvents = !!globalThis.MouseEvent;
          }
          catch (err) {
              this.supportsPointerEvents = false;
              this.supportsMouseEvents = false;
          }
          this.applyStyles = true;
      }
      configure(service, params) {
          if (service.env === this.type) {
              service.setActiveEnvContribution(this);
              makeUpCanvas$2(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.taro, params.pixelRatio);
              this.taro = params.taro;
              this.pixelRatio = params.pixelRatio;
              loadTaroContributions();
          }
      }
      loadImage(url) {
          return Promise.resolve({
              data: url,
              loadState: 'success'
          });
      }
      loadSvg(svgStr) {
          const _window = window || globalThis;
          if (_window.DOMParser) {
              const parser = new _window.DOMParser();
              const svg = parser.parseFromString(svgStr, 'image/svg+xml').children[0];
              const data = new XMLSerializer().serializeToString(svg);
              const url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;
              return Promise.resolve({
                  data: url,
                  loadState: 'success'
              });
          }
          else if (_window.Blob) {
              const data = new _window.Blob([svgStr], { type: 'image/svg+xml' });
              const url = _window.URL.createObjectURL(data);
              return Promise.resolve({
                  data: url,
                  loadState: 'success'
              });
          }
          return Promise.reject();
      }
      createCanvas(params) {
          const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
          this.canvasIdx++;
          return result;
      }
      createOffscreenCanvas(params) {
          return;
      }
      releaseCanvas(canvas) {
          return;
      }
      getDevicePixelRatio() {
          return this.pixelRatio;
      }
      getRequestAnimationFrame() {
          return requestAnimationFrame;
      }
      getCancelAnimationFrame() {
          return cancelAnimationFrame;
      }
      addEventListener(type, listener, options) {
          return null;
      }
      removeEventListener(type, listener, options) {
          return null;
      }
      dispatchEvent(event) {
          return null;
      }
      getElementById(str) {
          return this.canvasMap.get(str);
      }
      getRootElement() {
          return null;
      }
      getDocument() {
          return null;
      }
      release(...params) {
          return;
      }
  };
  TaroEnvContribution = __decorate([
      injectable(),
      __metadata("design:paramtypes", [])
  ], TaroEnvContribution);

  function makeUpCanvas$1(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList) {
      SystemInfo.pixelRatio;
      canvasIdLists.forEach((id, i) => {
          const _canvas = lynx.createCanvas(id);
          const ctx = _canvas.getContext('2d');
          ctx.draw = (a, b) => {
              b();
          };
          const canvas = {
              width: domref.width,
              height: domref.height,
              offsetWidth: domref.width,
              offsetHeight: domref.height,
              id: id ?? '',
              getContext: () => ctx,
              getBoundingClientRect: () => ({
                  height: domref.height,
                  width: domref.width
              })
          };
          canvasMap.set(id, canvas);
          if (i >= freeCanvasIdx) {
              freeCanvasList.push(canvas);
          }
      });
  }
  let LynxEnvContribution = class LynxEnvContribution extends exports.BaseEnvContribution {
      type = 'lynx';
      supportEvent = true;
      canvasMap = new Map();
      freeCanvasList = [];
      canvasIdx = 0;
      constructor() {
          super();
          this.supportsTouchEvents = true;
          try {
              this.supportsPointerEvents = !!globalThis.PointerEvent;
              this.supportsMouseEvents = !!globalThis.MouseEvent;
          }
          catch (err) {
              this.supportsPointerEvents = false;
              this.supportsMouseEvents = false;
          }
          this.applyStyles = true;
      }
      configure(service, params) {
          if (service.env === this.type) {
              service.setActiveEnvContribution(this);
              makeUpCanvas$1(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList);
              loadFeishuContributions();
          }
      }
      loadImage(url) {
          return Promise.resolve({
              data: url,
              loadState: 'success'
          });
      }
      loadSvg(url) {
          return Promise.reject();
      }
      createCanvas(params) {
          const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
          this.canvasIdx++;
          return result;
      }
      createOffscreenCanvas(params) {
          return;
      }
      releaseCanvas(canvas) {
          return;
      }
      getDevicePixelRatio() {
          return SystemInfo.pixelRatio;
      }
      getRequestAnimationFrame() {
          return function (callback) {
              return setTimeout(callback, 1000 / 60, true);
          };
      }
      getCancelAnimationFrame() {
          return (h) => {
              clearTimeout(h);
          };
      }
      addEventListener(type, listener, options) {
          return null;
      }
      removeEventListener(type, listener, options) {
          return null;
      }
      dispatchEvent(event) {
          return null;
      }
      getElementById(str) {
          return this.canvasMap.get(str);
      }
      getRootElement() {
          return null;
      }
      getDocument() {
          return null;
      }
      release(...params) {
          return;
      }
  };
  LynxEnvContribution = __decorate([
      injectable(),
      __metadata("design:paramtypes", [])
  ], LynxEnvContribution);

  let NodeEnvContribution = class NodeEnvContribution extends exports.BaseEnvContribution {
      type = 'node';
      pkg;
      _lastTime = 0;
      supportEvent = false;
      configure(service, pkg) {
          if (service.env === this.type) {
              service.setActiveEnvContribution(this);
              this.pkg = pkg;
          }
      }
      loadJson(url) {
          const jsonPromise = fetch(url).then(data => data.json());
          jsonPromise
              .then(json => {
              return {
                  data: json,
                  state: 'success'
              };
          })
              .catch(() => {
              return {
                  data: null,
                  state: 'fail'
              };
          });
          return jsonPromise;
      }
      loadArrayBuffer(url) {
          const arrayBufferPromise = fetch(url).then(data => data.arrayBuffer());
          return arrayBufferPromise
              .then((arrayBuffer) => {
              return {
                  data: arrayBuffer,
                  loadState: 'success'
              };
          })
              .catch(() => {
              return {
                  data: null,
                  loadState: 'fail'
              };
          });
      }
      loadImage(url) {
          const { loadImage } = this.pkg;
          if (loadImage) {
              return loadImage(url)
                  .then((image) => {
                  const loadState = image ? 'success' : 'fail';
                  return {
                      loadState,
                      data: image
                  };
              })
                  .catch(() => {
                  return {
                      loadState: 'fail',
                      data: null
                  };
              });
          }
          return Promise.reject(new Error('node-canvas loadImage could not be found!'));
      }
      loadSvg(svgStr) {
          const Resvg = this.pkg.Resvg;
          if (!Resvg) {
              return Promise.reject(new Error('@resvg/resvg-js svgParser could not be found!'));
          }
          const resvg = new Resvg(svgStr);
          const pngData = resvg.render().asPng();
          return this.loadImage(pngData);
      }
      createCanvas(params) {
          const canvas = this.pkg.createCanvas(params.width, params.height);
          return canvas;
      }
      releaseCanvas(canvas) {
          return;
      }
      getDevicePixelRatio() {
          return 1;
      }
      getRequestAnimationFrame() {
          return function (callback) {
              return setTimeout(callback, 1000 / 60, true);
          };
      }
      getCancelAnimationFrame() {
          return (h) => {
              clearTimeout(h);
          };
      }
      addEventListener(type, listener, options) {
          return;
      }
      removeEventListener(type, listener, options) {
          return;
      }
      getElementById(str) {
          return null;
      }
      getRootElement() {
          return null;
      }
      dispatchEvent(event) {
          return;
      }
      release(...params) {
          return;
      }
      createOffscreenCanvas(params) {
          return;
      }
  };
  NodeEnvContribution = __decorate([
      injectable()
  ], NodeEnvContribution);

  async function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList) {
      const dpr = wx.getSystemInfoSync().pixelRatio;
      for (let i = 0; i < canvasIdLists.length; i++) {
          const id = canvasIdLists[i];
          await new Promise(resolve => {
              wx.createSelectorQuery()
                  .select(`#${id}`)
                  .fields({ node: true, size: true })
                  .exec((res) => {
                  const canvas = res[0].node;
                  const width = res[0].width;
                  const height = res[0].height;
                  canvas.width = width * dpr;
                  canvas.height = height * dpr;
                  canvasMap.set(id, canvas);
                  if (i >= freeCanvasIdx) {
                      freeCanvasList.push(canvas);
                  }
                  resolve(null);
              });
          });
      }
  }
  let WxEnvContribution = class WxEnvContribution extends exports.BaseEnvContribution {
      type = 'wx';
      supportEvent = true;
      canvasMap = new Map();
      freeCanvasList = [];
      canvasIdx = 0;
      constructor() {
          super();
          this.supportsTouchEvents = true;
          try {
              this.supportsPointerEvents = !!globalThis.PointerEvent;
              this.supportsMouseEvents = !!globalThis.MouseEvent;
          }
          catch (err) {
              this.supportsPointerEvents = false;
              this.supportsMouseEvents = false;
          }
          this.applyStyles = true;
      }
      configure(service, params) {
          if (service.env === this.type) {
              service.setActiveEnvContribution(this);
              return makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList).then(() => {
                  loadFeishuContributions();
              });
          }
      }
      loadImage(url) {
          return Promise.resolve({
              data: url,
              loadState: 'success'
          });
      }
      loadSvg(url) {
          return Promise.reject();
      }
      createCanvas(params) {
          const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
          this.canvasIdx++;
          return result;
      }
      createOffscreenCanvas(params) {
          return;
      }
      releaseCanvas(canvas) {
          return;
      }
      getDevicePixelRatio() {
          return wx.getSystemInfoSync().pixelRatio;
      }
      getRequestAnimationFrame() {
          return function (callback) {
              return setTimeout(callback, 1000 / 60, true);
          };
      }
      getCancelAnimationFrame() {
          return (h) => {
              clearTimeout(h);
          };
      }
      addEventListener(type, listener, options) {
          return null;
      }
      removeEventListener(type, listener, options) {
          return null;
      }
      dispatchEvent(event) {
          return null;
      }
      getElementById(str) {
          return this.canvasMap.get(str);
      }
      getRootElement() {
          return null;
      }
      getDocument() {
          return null;
      }
      release(...params) {
          return;
      }
      mapToCanvasPoint(event) {
          if (event?.type?.startsWith('mouse')) {
              return event;
          }
          return null;
      }
  };
  WxEnvContribution = __decorate([
      injectable(),
      __metadata("design:paramtypes", [])
  ], WxEnvContribution);

  var envModules = new ContainerModule(bind => {
      bind(BrowserEnvContribution).toSelf().inSingletonScope();
      bind(EnvContribution).toService(BrowserEnvContribution);
      bind(FeishuEnvContribution).toSelf().inSingletonScope();
      bind(EnvContribution).toService(FeishuEnvContribution);
      bind(TaroEnvContribution).toSelf().inSingletonScope();
      bind(EnvContribution).toService(TaroEnvContribution);
      bind(LynxEnvContribution).toSelf().inSingletonScope();
      bind(EnvContribution).toService(LynxEnvContribution);
      bind(WxEnvContribution).toSelf().inSingletonScope();
      bind(EnvContribution).toService(WxEnvContribution);
      bind(NodeEnvContribution).toSelf().inSingletonScope();
      bind(EnvContribution).toService(NodeEnvContribution);
      bindContributionProvider(bind, EnvContribution);
  });

  exports.BaseWindowHandlerContribution = class BaseWindowHandlerContribution {
      constructor() {
          this._uid = Generator.GenAutoIncrementId();
      }
      onChange(cb) {
          this._onChangeCb = cb;
      }
      configure(window, global) {
          if (global.env === this.type) {
              window.setWindowHandler(this);
          }
      }
      release(...params) {
          this.releaseWindow();
      }
  };
  exports.BaseWindowHandlerContribution = __decorate([
      injectable(),
      __metadata("design:paramtypes", [])
  ], exports.BaseWindowHandlerContribution);

  let BrowserWindowHandlerContribution = class BrowserWindowHandlerContribution extends exports.BaseWindowHandlerContribution {
      global;
      static env = 'browser';
      type = 'browser';
      canvas;
      observer;
      get container() {
          return this.canvas.nativeCanvas.parentElement;
      }
      constructor(global) {
          super();
          this.global = global;
      }
      getTitle() {
          return this.canvas.id.toString();
      }
      getWH() {
          return {
              width: this.canvas.width / (this.canvas.dpr || 1),
              height: this.canvas.height / (this.canvas.dpr || 1)
          };
      }
      getXY() {
          return this.canvas.nativeCanvas.getBoundingClientRect();
      }
      createWindow(params) {
          if (!params.canvas) {
              this.createWindowByConfig(params);
          }
          else {
              this.createWindowByCanvas(params);
          }
      }
      createWindowByConfig(params) {
          const nativeCanvas = this.global.createCanvas({
              width: params.width,
              height: params.height
          });
          let container;
          if (typeof params.container === 'string') {
              container = this.global.getElementById(params.container);
          }
          else if (params.container) {
              container = params.container;
          }
          else {
              container = this.global.getRootElement();
          }
          if (!container) {
              throw new Error('containerId');
          }
          if (!params.offscreen) {
              container.appendChild(nativeCanvas);
          }
          else {
              container = null;
          }
          const options = {
              width: params.width,
              height: params.height,
              dpr: params.dpr,
              nativeCanvas,
              container,
              id: Generator.GenAutoIncrementId().toString(),
              canvasControled: true
          };
          this.canvas = new exports.BrowserCanvas(options);
      }
      createWindowByCanvas(params) {
          let canvas;
          if (typeof params.canvas === 'string') {
              canvas = this.global.getElementById(params.canvas);
              if (!canvas) {
                  throw new Error('canvasId canvasdom');
              }
          }
          else {
              canvas = params.canvas;
          }
          if (!canvas) {
              throw new Error('canvas');
          }
          let width = params.width;
          let height = params.height;
          if (width == null || height == null || !params.canvasControled) {
              const data = canvas.getBoundingClientRect();
              width = data.width;
              height = data.height;
          }
          let dpr = params.dpr;
          if (params.canvasControled === false) {
              if (dpr) {
                  console.warn('canvasControledfalsedpr');
              }
              dpr = null;
          }
          if (dpr == null) {
              const ctx = canvas.getContext('2d');
              dpr = ctx.pixelRatio ?? canvas.width / width;
          }
          this.canvas = new exports.BrowserCanvas({
              width: width,
              height: height,
              dpr: dpr,
              nativeCanvas: canvas,
              canvasControled: params.canvasControled
          });
      }
      releaseWindow() {
          this.canvas.release();
      }
      resizeWindow(width, height) {
          this.canvas.resize(width, height);
      }
      setDpr(dpr) {
          this.canvas.dpr = dpr;
      }
      getContext() {
          return this.canvas.getContext();
      }
      getNativeHandler() {
          return this.canvas;
      }
      getDpr() {
          return this.canvas.dpr;
      }
      addEventListener(type, listener, options) {
          return this.canvas.nativeCanvas.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
          return this.canvas.nativeCanvas.removeEventListener(type, listener, options);
      }
      dispatchEvent(event) {
          return this.canvas.nativeCanvas.dispatchEvent(event);
      }
      getStyle() {
          return this.canvas.nativeCanvas.style;
      }
      setStyle(style) {
          this.canvas.nativeCanvas.style = style;
      }
      getBoundingClientRect() {
          const c = this.canvas.nativeCanvas;
          const wh = this.getWH();
          if (!c.parentElement) {
              return {
                  x: 0,
                  y: 0,
                  width: wh.width,
                  height: wh.height,
                  left: 0,
                  top: 0,
                  right: 0,
                  bottom: 0
              };
          }
          return this.canvas.nativeCanvas.getBoundingClientRect();
      }
      clearViewBox(vb, color) {
          const context = this.getContext();
          const dpr = this.getDpr();
          context.nativeContext.save();
          context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0);
          context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          if (color) {
              context.fillStyle = color;
              context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          }
          context.nativeContext.restore();
      }
  };
  BrowserWindowHandlerContribution = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], BrowserWindowHandlerContribution);

  let FeishuContext2d = class FeishuContext2d extends exports.BrowserContext2d {
      static env = 'feishu';
      _globalAlpha;
      get globalAlpha() {
          return this._globalAlpha;
      }
      set globalAlpha(ga) {
          this.nativeContext.globalAlpha = ga;
          this._globalAlpha = ga;
      }
      getImageData(sx, sy, sw, sh) {
          return new Promise((resolve, reject) => {
              try {
                  tt.canvasGetImageData({
                      canvasId: this.canvas.nativeCanvas.id ?? this.canvas.id,
                      x: sx,
                      y: sy,
                      width: sw,
                      height: sh,
                      success(res) {
                          resolve(res);
                      }
                  });
              }
              catch (err) {
                  reject(err);
              }
          });
      }
      draw() {
          const _context = this.nativeContext;
          this.drawPromise = new Promise(resolve => {
              _context.draw(true, () => {
                  this.drawPromise = null;
                  resolve(null);
              });
          });
      }
      createPattern(image, repetition) {
          return null;
      }
  };
  FeishuContext2d = __decorate([
      injectable()
  ], FeishuContext2d);

  const DefaultConfig$5 = {
      WIDTH: 500,
      HEIGHT: 500,
      DPR: 1
  };
  let FeishuCanvas = class FeishuCanvas {
      static env = 'feishu';
      _displayWidth;
      _displayHeight;
      _id;
      _pixelWidth;
      _pixelHeight;
      _x;
      _y;
      _dpr;
      _container;
      _nativeCanvas;
      _context;
      _visiable;
      get id() {
          return this._id;
      }
      get x() {
          return this._x;
      }
      get y() {
          return this._y;
      }
      get nativeCanvas() {
          return this._nativeCanvas;
      }
      get width() {
          return this._pixelWidth;
      }
      set width(width) {
          this._pixelWidth = width;
          this._displayWidth = width / (this._dpr || 1);
      }
      get height() {
          return this._pixelHeight;
      }
      set height(height) {
          this._pixelHeight = height;
          this._displayHeight = height / (this._dpr || 1);
      }
      get displayWidth() {
          return this._displayWidth;
      }
      get displayHeight() {
          return this._displayHeight;
      }
      getContext(str) {
          return this._context;
      }
      get visiable() {
          return this._visiable;
      }
      set visiable(visiable) {
          this._visiable = visiable;
          visiable ? this.show() : this.hide();
      }
      get dpr() {
          return this._dpr;
      }
      set dpr(dpr) {
          this._dpr = dpr;
      }
      constructor(params) {
          const { nativeCanvas, width = DefaultConfig$5.WIDTH, height = DefaultConfig$5.HEIGHT, dpr = DefaultConfig$5.DPR } = params;
          const { x, y } = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : { x: 0, y: 0 };
          this._x = x;
          this._y = y;
          this._pixelWidth = width * dpr;
          this._pixelHeight = height * dpr;
          this._visiable = params.visiable !== false;
          this._displayWidth = width;
          this._displayHeight = height;
          this._dpr = dpr;
          this._nativeCanvas = nativeCanvas;
          this._context = new FeishuContext2d(this, this._dpr);
          this._id = nativeCanvas.id;
      }
      getNativeCanvas() {
          return this._nativeCanvas;
      }
      resetStyle(params) {
          return;
      }
      applyPosition() {
          return;
      }
      hide() {
          return;
      }
      show() {
          return;
      }
      resize(width, height) {
          return;
      }
      toDataURL(mimeType, quality) {
          return '';
      }
      readPixels(x, y, w, h) {
          throw new Error('');
      }
      convertToBlob(options) {
          throw new Error('');
      }
      transferToImageBitmap() {
          throw new Error('');
      }
      release(...params) {
          return;
      }
  };
  FeishuCanvas = __decorate([
      injectable(),
      __metadata("design:paramtypes", [Object])
  ], FeishuCanvas);

  let MiniAppEventManager$3 = class MiniAppEventManager {
      addEventListener(type, func) {
          if (!type || !func) {
              return;
          }
          this.cache[type] = this.cache[type] || {
              listener: []
          };
          this.cache[type].listener.push(func);
      }
      removeEventListener(type, func) {
          if (!type || !func) {
              return;
          }
          if (!this.cache[type]) {
              return;
          }
          const index = this.cache[type].listener.findIndex((f) => f === func);
          if (index >= 0) {
              this.cache[type].listener.splice(index, 1);
          }
      }
      cleanEvent() {
          this.cache = {};
      }
      cache = {};
  };
  let FeishuWindowHandlerContribution = class FeishuWindowHandlerContribution extends exports.BaseWindowHandlerContribution {
      global;
      static env = 'feishu';
      type = 'feishu';
      eventManager = new MiniAppEventManager$3();
      canvas;
      get container() {
          return null;
      }
      constructor(global) {
          super();
          this.global = global;
      }
      getTitle() {
          return this.canvas.id.toString();
      }
      getWH() {
          return {
              width: this.canvas.width / (this.canvas.dpr || 1),
              height: this.canvas.height / (this.canvas.dpr || 1)
          };
      }
      getXY() {
          return { x: 0, y: 0 };
      }
      createWindow(params) {
          if (!params.canvas) {
              this.createWindowByConfig(params);
          }
          else {
              this.createWindowByCanvas(params);
          }
      }
      createWindowByConfig(params) {
          const nativeCanvas = this.global.createCanvas({
              width: params.width,
              height: params.height
          });
          const options = {
              width: params.width,
              height: params.height,
              dpr: params.dpr,
              nativeCanvas,
              id: Generator.GenAutoIncrementId().toString(),
              canvasControled: false
          };
          this.canvas = new FeishuCanvas(options);
      }
      createWindowByCanvas(params) {
          let canvas;
          if (typeof params.canvas === 'string') {
              canvas = this.global.getElementById(params.canvas);
              if (!canvas) {
                  throw new Error('canvasId canvasdom');
              }
          }
          else {
              canvas = params.canvas;
          }
          let width = params.width;
          let height = params.height;
          if (width == null || height == null || !params.canvasControled) {
              const data = canvas.getBoundingClientRect();
              width = data.width;
              height = data.height;
          }
          let dpr = params.dpr;
          if (dpr == null) {
              dpr = canvas.width / width;
          }
          this.canvas = new FeishuCanvas({
              width: width,
              height: height,
              dpr: dpr,
              nativeCanvas: canvas,
              canvasControled: params.canvasControled
          });
      }
      releaseWindow() {
          return;
      }
      resizeWindow(width, height) {
          return;
      }
      setDpr(dpr) {
          this.canvas.dpr = dpr;
      }
      getContext() {
          return this.canvas.getContext();
      }
      getNativeHandler() {
          return this.canvas;
      }
      getDpr() {
          return this.canvas.dpr;
      }
      addEventListener(type, listener) {
          this.eventManager.addEventListener(type, listener);
      }
      removeEventListener(type, listener) {
          this.eventManager.removeEventListener(type, listener);
      }
      dispatchEvent(event) {
          const { type } = event;
          if (!this.eventManager.cache[type]) {
              return false;
          }
          if (event.changedTouches && event.changedTouches[0]) {
              event.offsetX = event.changedTouches[0].x;
              event.changedTouches[0].offsetX = event.changedTouches[0].x;
              event.changedTouches[0].clientX = event.changedTouches[0].x;
              event.offsetY = event.changedTouches[0].y;
              event.changedTouches[0].offsetY = event.changedTouches[0].y;
              event.changedTouches[0].clientY = event.changedTouches[0].y;
          }
          event.preventDefault = () => {
              return;
          };
          event.stopPropagation = () => {
              return;
          };
          if (this.eventManager.cache[type].listener) {
              this.eventManager.cache[type].listener.forEach((f) => {
                  f(event);
              });
          }
          return true;
      }
      getStyle() {
          return {};
      }
      setStyle(style) {
          return;
      }
      getBoundingClientRect() {
          const wh = this.getWH();
          return {
              x: 0,
              y: 0,
              width: wh.width,
              height: wh.height,
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
          };
      }
      clearViewBox(vb, color) {
          const context = this.getContext();
          const dpr = this.getDpr();
          context.nativeContext.save();
          context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0);
          context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          if (color) {
              context.fillStyle = color;
              context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          }
          context.nativeContext.restore();
      }
  };
  FeishuWindowHandlerContribution = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], FeishuWindowHandlerContribution);

  let TaroContext2d = class TaroContext2d extends exports.BrowserContext2d {
      static env = 'taro';
      get globalAlpha() {
          return this._globalAlpha;
      }
      set globalAlpha(ga) {
          this.nativeContext.setGlobalAlpha(ga);
          this._globalAlpha = ga;
      }
      draw() {
          const _context = this.nativeContext;
          _context.draw();
      }
      strokeText(text, x, y) {
          return;
      }
      _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.fillAttributes;
          }
          const { fillOpacity = defaultParams.fillOpacity, opacity = defaultParams.opacity, fill = defaultParams.fill } = attribute;
          if (fillOpacity > 1e-12 && opacity > 1e-12) {
              _context.setGlobalAlpha(fillOpacity * opacity);
              _context.setFillStyle(createColor(this, fill, params, offsetX, offsetY));
          }
      }
      _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.strokeAttributes;
          }
          const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
          if (strokeOpacity > 1e-12 && opacity > 1e-12) {
              const { lineWidth = defaultParams.lineWidth, stroke = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit } = attribute;
              _context.setGlobalAlpha(strokeOpacity * opacity);
              _context.setLineWidth(getScaledStroke(this, lineWidth, this.dpr));
              _context.setStrokeStyle(createColor(this, stroke, params, offsetX, offsetY));
              _context.setLineJoin(lineJoin);
              _context.setLineDash(lineDash);
              _context.setLineCap(lineCap);
              _context.setMiterLimit(miterLimit);
          }
      }
      setTextStyleWithoutAlignBaseline(params, defaultParams) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.textAttributes;
          }
          if (params.font) {
              _context.font = params.font;
          }
          else {
              _context.font = getContextFont(params, defaultParams);
          }
          _context.setFontSize(params.fontSize ?? defaultParams.fontSize);
      }
      setTextStyle(params, defaultParams) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.textAttributes;
          }
          if (params.font) {
              _context.font = params.font;
          }
          else {
              _context.font = getContextFont(params, defaultParams);
          }
          _context.setTextAlign(params.textAlign ?? defaultParams.textAlign);
          _context.setTextBaseline(params.textBaseline ?? defaultParams.textBaseline);
      }
      createConicGradient(x, y, startAngle, endAngle) {
          return null;
      }
      createPattern(image, repetition) {
          return null;
      }
  };
  TaroContext2d = __decorate([
      injectable()
  ], TaroContext2d);

  const DefaultConfig$4 = {
      WIDTH: 500,
      HEIGHT: 500,
      DPR: 1
  };
  let TaroCanvas = class TaroCanvas {
      static env = 'taro';
      _displayWidth;
      _displayHeight;
      _id;
      _pixelWidth;
      _pixelHeight;
      _x;
      _y;
      _dpr;
      _nativeCanvas;
      _context;
      _visiable;
      get id() {
          return this._id;
      }
      get x() {
          return this._x;
      }
      get y() {
          return this._y;
      }
      get nativeCanvas() {
          return this._nativeCanvas;
      }
      get width() {
          return this._pixelWidth;
      }
      set width(width) {
          this._pixelWidth = width;
          this._displayWidth = width / (this._dpr || 1);
      }
      get height() {
          return this._pixelHeight;
      }
      set height(height) {
          this._pixelHeight = height;
          this._displayHeight = height / (this._dpr || 1);
      }
      get displayWidth() {
          return this._displayWidth;
      }
      get displayHeight() {
          return this._displayHeight;
      }
      getContext(str) {
          return this._context;
      }
      get visiable() {
          return this._visiable;
      }
      set visiable(visiable) {
          this._visiable = visiable;
          visiable ? this.show() : this.hide();
      }
      get dpr() {
          return this._dpr;
      }
      set dpr(dpr) {
          this._dpr = dpr;
      }
      constructor(params) {
          const { nativeCanvas, width = DefaultConfig$4.WIDTH, height = DefaultConfig$4.HEIGHT, dpr = DefaultConfig$4.DPR } = params;
          const { x, y } = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : { x: 0, y: 0 };
          this._x = x;
          this._y = y;
          this._pixelWidth = width * dpr;
          this._pixelHeight = height * dpr;
          this._visiable = params.visiable !== false;
          this._displayWidth = width;
          this._displayHeight = height;
          this._dpr = dpr;
          this._nativeCanvas = nativeCanvas;
          this._context = new TaroContext2d(this, this._dpr);
          this._id = nativeCanvas.id;
      }
      getNativeCanvas() {
          return this._nativeCanvas;
      }
      resetStyle(params) {
          return;
      }
      applyPosition() {
          return;
      }
      hide() {
          return;
      }
      show() {
          return;
      }
      resize(width, height) {
          return;
      }
      toDataURL(mimeType, quality) {
          return '';
      }
      readPixels(x, y, w, h) {
          throw new Error('');
      }
      convertToBlob(options) {
          throw new Error('');
      }
      transferToImageBitmap() {
          throw new Error('');
      }
      release(...params) {
          return;
      }
  };
  TaroCanvas = __decorate([
      injectable(),
      __metadata("design:paramtypes", [Object])
  ], TaroCanvas);

  let MiniAppEventManager$2 = class MiniAppEventManager {
      addEventListener(type, func) {
          if (!type || !func) {
              return;
          }
          this.cache[type] = this.cache[type] || {
              listener: []
          };
          this.cache[type].listener.push(func);
      }
      removeEventListener(type, func) {
          if (!type || !func) {
              return;
          }
          if (!this.cache[type]) {
              return;
          }
          const index = this.cache[type].listener.findIndex((f) => f === func);
          if (index >= 0) {
              this.cache[type].listener.splice(index, 1);
          }
      }
      cleanEvent() {
          this.cache = {};
      }
      cache = {};
  };
  let TaroWindowHandlerContribution = class TaroWindowHandlerContribution extends exports.BaseWindowHandlerContribution {
      global;
      static env = 'taro';
      type = 'taro';
      eventManager = new MiniAppEventManager$2();
      canvas;
      get container() {
          return null;
      }
      constructor(global) {
          super();
          this.global = global;
      }
      getTitle() {
          return this.canvas.id.toString();
      }
      getWH() {
          return {
              width: this.canvas.width / (this.canvas.dpr || 1),
              height: this.canvas.height / (this.canvas.dpr || 1)
          };
      }
      getXY() {
          return { x: 0, y: 0 };
      }
      createWindow(params) {
          if (!params.canvas) {
              this.createWindowByConfig(params);
          }
          else {
              this.createWindowByCanvas(params);
          }
      }
      createWindowByConfig(params) {
          const nativeCanvas = this.global.createCanvas({
              width: params.width,
              height: params.height
          });
          const options = {
              width: params.width,
              height: params.height,
              dpr: params.dpr,
              nativeCanvas,
              id: Generator.GenAutoIncrementId().toString(),
              canvasControled: false
          };
          this.canvas = new TaroCanvas(options);
      }
      createWindowByCanvas(params) {
          let canvas;
          if (typeof params.canvas === 'string') {
              canvas = this.global.getElementById(params.canvas);
              if (!canvas) {
                  throw new Error('canvasId canvasdom');
              }
          }
          else {
              canvas = params.canvas;
          }
          let width = params.width;
          let height = params.height;
          if (width == null || height == null || !params.canvasControled) {
              const data = canvas.getBoundingClientRect();
              width = data.width;
              height = data.height;
          }
          let dpr = params.dpr;
          if (dpr == null) {
              dpr = canvas.width / width;
          }
          this.canvas = new TaroCanvas({
              width: width,
              height: height,
              dpr: dpr,
              nativeCanvas: canvas,
              canvasControled: params.canvasControled
          });
      }
      releaseWindow() {
          return;
      }
      resizeWindow(width, height) {
          return;
      }
      setDpr(dpr) {
          this.canvas.dpr = dpr;
      }
      getContext() {
          return this.canvas.getContext();
      }
      getNativeHandler() {
          return this.canvas;
      }
      getDpr() {
          return this.canvas.dpr;
      }
      addEventListener(type, listener) {
          this.eventManager.addEventListener(type, listener);
      }
      removeEventListener(type, listener) {
          this.eventManager.removeEventListener(type, listener);
      }
      dispatchEvent(event) {
          const { type } = event;
          if (!this.eventManager.cache[type]) {
              return false;
          }
          if (event.changedTouches.length > 0) {
              event.changedTouches.forEach((d, i) => {
                  event.changedTouches[i] = {
                      ...event.changedTouches[i],
                      offsetX: d.x,
                      offsetY: d.y
                  };
              });
              event.offsetX = event.changedTouches[0].offsetX;
              event.offsetY = event.changedTouches[0].offsetY;
          }
          if (event.touches.length > 0) {
              event.touches.forEach((d, i) => {
                  event.touches[i] = {
                      ...event.touches[i],
                      offsetX: d.x,
                      offsetY: d.y
                  };
              });
          }
          event.preventDefault = () => {
              return;
          };
          event.stopPropagation = () => {
              return;
          };
          if (this.eventManager.cache[type].listener) {
              this.eventManager.cache[type].listener.forEach((f) => {
                  f(event);
              });
          }
          return true;
      }
      getStyle() {
          return {};
      }
      setStyle(style) {
          return;
      }
      getBoundingClientRect() {
          const wh = this.getWH();
          return {
              x: 0,
              y: 0,
              width: wh.width,
              height: wh.height,
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
          };
      }
      clearViewBox(vb, color) {
          const context = this.getContext();
          const dpr = this.getDpr();
          context.nativeContext.save();
          context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0);
          context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          if (color) {
              context.fillStyle = color;
              context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          }
          context.nativeContext.restore();
      }
  };
  TaroWindowHandlerContribution = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], TaroWindowHandlerContribution);

  let LynxContext2d = class LynxContext2d extends exports.BrowserContext2d {
      static env = 'lynx';
      get globalAlpha() {
          return this._globalAlpha;
      }
      set globalAlpha(ga) {
          this.nativeContext.globalAlpha = ga;
          this._globalAlpha = ga;
      }
      setLineDash(segments) {
          const a = arguments;
          const _context = this.nativeContext;
          if (!!this.nativeContext.setLineDash) {
              const lineDash = a[0];
              if (lineDash[0] === 0 && lineDash[1] === 0) {
                  return;
              }
              _context.setLineDash(lineDash);
          }
      }
      _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
          const _context = this.nativeContext;
          if (!defaultParams) {
              defaultParams = this.strokeAttributes;
          }
          const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
          if (strokeOpacity > 1e-12 && opacity > 1e-12) {
              const { lineWidth = defaultParams.lineWidth, stroke = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit } = attribute;
              _context.globalAlpha = strokeOpacity * opacity;
              _context.lineWidth = getScaledStroke(this, lineWidth, this.dpr);
              _context.strokeStyle = createColor(this, stroke, params, offsetX, offsetY);
              _context.lineJoin = lineJoin;
              if (!(lineDash[0] === 0 && lineDash[1] === 0)) {
                  _context.setLineDash(lineDash);
              }
              _context.lineCap = lineCap;
              _context.miterLimit = miterLimit;
          }
      }
      createPattern(image, repetition) {
          return null;
      }
      draw() {
          const _context = this.nativeContext;
          this.drawPromise = new Promise(resolve => {
              _context.draw(true, () => {
                  this.drawPromise = null;
                  resolve(null);
              });
          });
      }
  };
  LynxContext2d = __decorate([
      injectable()
  ], LynxContext2d);

  const DefaultConfig$3 = {
      WIDTH: 500,
      HEIGHT: 500,
      DPR: 1
  };
  let LynxCanvas = class LynxCanvas {
      static env = 'lynx';
      _displayWidth;
      _displayHeight;
      _id;
      _pixelWidth;
      _pixelHeight;
      _x;
      _y;
      _dpr;
      _container;
      _nativeCanvas;
      _context;
      _visiable;
      get id() {
          return this._id;
      }
      get x() {
          return this._x;
      }
      get y() {
          return this._y;
      }
      get nativeCanvas() {
          return this._nativeCanvas;
      }
      get width() {
          return this._pixelWidth;
      }
      set width(width) {
          this._pixelWidth = width;
          this._displayWidth = width / (this._dpr || 1);
      }
      get height() {
          return this._pixelHeight;
      }
      set height(height) {
          this._pixelHeight = height;
          this._displayHeight = height / (this._dpr || 1);
      }
      get displayWidth() {
          return this._displayWidth;
      }
      get displayHeight() {
          return this._displayHeight;
      }
      getContext(str) {
          return this._context;
      }
      get visiable() {
          return this._visiable;
      }
      set visiable(visiable) {
          this._visiable = visiable;
          visiable ? this.show() : this.hide();
      }
      get dpr() {
          return this._dpr;
      }
      set dpr(dpr) {
          this._dpr = dpr;
      }
      constructor(params) {
          const { nativeCanvas, width = DefaultConfig$3.WIDTH, height = DefaultConfig$3.HEIGHT, dpr = DefaultConfig$3.DPR } = params;
          const { x, y } = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : { x: 0, y: 0 };
          this._x = x;
          this._y = y;
          this._pixelWidth = width * dpr;
          this._pixelHeight = height * dpr;
          this._visiable = params.visiable !== false;
          this._displayWidth = width;
          this._displayHeight = height;
          this._dpr = dpr;
          this._nativeCanvas = nativeCanvas;
          this._context = new LynxContext2d(this, this._dpr);
          this._id = nativeCanvas.id;
      }
      getNativeCanvas() {
          return this._nativeCanvas;
      }
      resetStyle(params) {
          return;
      }
      applyPosition() {
          return;
      }
      hide() {
          return;
      }
      show() {
          return;
      }
      resize(width, height) {
          return;
      }
      toDataURL(mimeType, quality) {
          return '';
      }
      readPixels(x, y, w, h) {
          throw new Error('');
      }
      convertToBlob(options) {
          throw new Error('');
      }
      transferToImageBitmap() {
          throw new Error('');
      }
      release(...params) {
          return;
      }
  };
  LynxCanvas = __decorate([
      injectable(),
      __metadata("design:paramtypes", [Object])
  ], LynxCanvas);

  let MiniAppEventManager$1 = class MiniAppEventManager {
      addEventListener(type, func) {
          if (!type || !func) {
              return;
          }
          this.cache[type] = this.cache[type] || {
              listener: []
          };
          this.cache[type].listener.push(func);
      }
      removeEventListener(type, func) {
          if (!type || !func) {
              return;
          }
          if (!this.cache[type]) {
              return;
          }
          const index = this.cache[type].listener.findIndex((f) => f === func);
          if (index >= 0) {
              this.cache[type].listener.splice(index, 1);
          }
      }
      cleanEvent() {
          this.cache = {};
      }
      cache = {};
  };
  let LynxWindowHandlerContribution = class LynxWindowHandlerContribution extends exports.BaseWindowHandlerContribution {
      global;
      static env = 'lynx';
      type = 'lynx';
      eventManager = new MiniAppEventManager$1();
      canvas;
      get container() {
          return null;
      }
      constructor(global) {
          super();
          this.global = global;
      }
      getTitle() {
          return this.canvas.id.toString();
      }
      getWH() {
          return {
              width: this.canvas.width / (this.canvas.dpr || 1),
              height: this.canvas.height / (this.canvas.dpr || 1)
          };
      }
      getXY() {
          return { x: 0, y: 0 };
      }
      createWindow(params) {
          if (!params.canvas) {
              this.createWindowByConfig(params);
          }
          else {
              this.createWindowByCanvas(params);
          }
      }
      createWindowByConfig(params) {
          const nativeCanvas = this.global.createCanvas({
              width: params.width,
              height: params.height
          });
          const options = {
              width: params.width,
              height: params.height,
              dpr: params.dpr,
              nativeCanvas,
              id: Generator.GenAutoIncrementId().toString(),
              canvasControled: false
          };
          this.canvas = new LynxCanvas(options);
      }
      createWindowByCanvas(params) {
          let canvas;
          if (typeof params.canvas === 'string') {
              canvas = this.global.getElementById(params.canvas);
              if (!canvas) {
                  throw new Error('canvasId canvasdom');
              }
          }
          else {
              canvas = params.canvas;
          }
          let width = params.width;
          let height = params.height;
          if (width == null || height == null || !params.canvasControled) {
              const data = canvas.getBoundingClientRect();
              width = data.width;
              height = data.height;
          }
          let dpr = params.dpr;
          if (dpr == null) {
              dpr = canvas.width / width;
          }
          this.canvas = new LynxCanvas({
              width: width,
              height: height,
              dpr: dpr,
              nativeCanvas: canvas,
              canvasControled: params.canvasControled
          });
      }
      releaseWindow() {
          return;
      }
      resizeWindow(width, height) {
          return;
      }
      setDpr(dpr) {
          this.canvas.dpr = dpr;
      }
      getContext() {
          return this.canvas.getContext();
      }
      getNativeHandler() {
          return this.canvas;
      }
      getDpr() {
          return this.canvas.dpr;
      }
      addEventListener(type, listener) {
          this.eventManager.addEventListener(type, listener);
      }
      removeEventListener(type, listener) {
          this.eventManager.removeEventListener(type, listener);
      }
      dispatchEvent(event) {
          const { type } = event;
          if (!this.eventManager.cache[type]) {
              return false;
          }
          if (event.changedTouches && event.changedTouches[0]) {
              event.offsetX = event.changedTouches[0].x;
              event.changedTouches[0].offsetX = event.changedTouches[0].x;
              event.changedTouches[0].clientX = event.changedTouches[0].x;
              event.offsetY = event.changedTouches[0].y;
              event.changedTouches[0].offsetY = event.changedTouches[0].y;
              event.changedTouches[0].clientY = event.changedTouches[0].y;
          }
          event.preventDefault = () => {
              return;
          };
          event.stopPropagation = () => {
              return;
          };
          if (this.eventManager.cache[type].listener) {
              this.eventManager.cache[type].listener.forEach((f) => {
                  f(event);
              });
          }
          return true;
      }
      getStyle() {
          return {};
      }
      setStyle(style) {
          return;
      }
      getBoundingClientRect() {
          const wh = this.getWH();
          return {
              x: 0,
              y: 0,
              width: wh.width,
              height: wh.height,
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
          };
      }
      clearViewBox(vb, color) {
          const context = this.getContext();
          const dpr = this.getDpr();
          context.nativeContext.save();
          context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0);
          context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          if (color) {
              context.fillStyle = color;
              context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          }
          context.nativeContext.restore();
      }
  };
  LynxWindowHandlerContribution = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], LynxWindowHandlerContribution);

  new Matrix(1, 0, 0, 1, 0, 0);
  let NodeContext2d = class NodeContext2d extends exports.BrowserContext2d {
      static env = 'node';
      constructor(canvas, dpr) {
          super(canvas, dpr);
          const context = canvas.nativeCanvas.getContext('2d');
          if (!context) {
              throw new Error('2d');
          }
          this.nativeContext = context;
          this.canvas = canvas;
          this.matrix = new Matrix(1, 0, 0, 1, 0, 0);
          this.stack = [];
          this.dpr = dpr ?? 1;
      }
      release(...params) {
          return;
      }
  };
  NodeContext2d = __decorate([
      injectable(),
      __metadata("design:paramtypes", [Object, Number])
  ], NodeContext2d);

  const DefaultConfig$2 = {
      WIDTH: 500,
      HEIGHT: 500,
      DPR: 1
  };
  let NodeCanvas = class NodeCanvas {
      static env = 'node';
      _id;
      _displayWidth;
      _displayHeight;
      _pixelWidth;
      _pixelHeight;
      _nativeCanvas;
      _context;
      _visiable;
      controled;
      _dpr;
      get id() {
          return this._id;
      }
      get x() {
          return 0;
      }
      get y() {
          return 0;
      }
      get nativeCanvas() {
          return this._nativeCanvas;
      }
      get width() {
          return this._pixelWidth;
      }
      set width(width) {
          this._pixelWidth = width;
          this._displayWidth = width / (this._dpr || 1);
      }
      get displayWidth() {
          return this._pixelWidth / this._dpr;
      }
      get displayHeight() {
          return this._pixelHeight / this._dpr;
      }
      get height() {
          return this._pixelHeight;
      }
      set height(height) {
          this._pixelHeight = height;
          this._displayHeight = height / (this._dpr || 1);
      }
      getContext(str) {
          return this._context;
      }
      get visiable() {
          return this._visiable;
      }
      set visiable(visiable) {
          this._visiable = visiable;
          visiable ? this.show() : this.hide();
      }
      get dpr() {
          return this._dpr;
      }
      set dpr(dpr) {
          this._dpr = dpr;
          this.resize(this.width, this.height);
          return;
      }
      constructor(params) {
          const { nativeCanvas, width = DefaultConfig$2.WIDTH, height = DefaultConfig$2.HEIGHT, canvasControled = true, dpr = DefaultConfig$2.DPR } = params;
          this._visiable = params.visiable !== false;
          this.controled = canvasControled;
          this._pixelWidth = width * dpr;
          this._pixelHeight = height * dpr;
          this._displayWidth = width;
          this._displayHeight = height;
          this._nativeCanvas = nativeCanvas;
          this._context = new NodeContext2d(this, params.dpr);
          this._id = nativeCanvas.id;
          this._dpr = dpr;
      }
      applyPosition() {
          return;
      }
      getNativeCanvas() {
          return this._nativeCanvas;
      }
      resetStyle(params) {
          return;
      }
      hide() {
          return;
      }
      show() {
          return;
      }
      resize(width, height) {
          this._pixelWidth = width * this._dpr;
          this._pixelHeight = height * this._dpr;
          this._displayWidth = width;
          this._displayHeight = height;
          if (this._nativeCanvas) {
              this._nativeCanvas.width = this._pixelWidth;
              this._nativeCanvas.height = this._pixelHeight;
          }
          return;
      }
      toDataURL(mimeType, quality) {
          return '';
      }
      readPixels(x, y, w, h) {
          return this._context.getImageData(x, y, w, h);
      }
      convertToBlob(options) {
          throw new Error('');
      }
      transferToImageBitmap() {
          throw new Error('');
      }
      release(...params) {
          if (this._nativeCanvas.release && isFunction(this._nativeCanvas.release)) {
              this._nativeCanvas.release();
          }
      }
  };
  NodeCanvas = __decorate([
      injectable(),
      __metadata("design:paramtypes", [Object])
  ], NodeCanvas);

  let NodeWindowHandlerContribution = class NodeWindowHandlerContribution extends exports.BaseWindowHandlerContribution {
      global;
      static env = 'node';
      type = 'node';
      canvas;
      get container() {
          return null;
      }
      constructor(global) {
          super();
          this.global = global;
      }
      getTitle() {
          return '';
      }
      getWH() {
          return {
              width: this.canvas.displayWidth,
              height: this.canvas.displayHeight
          };
      }
      getXY() {
          return { x: 0, y: 0 };
      }
      createWindow(params) {
          if (!params.canvas) {
              this.createWindowByConfig(params);
          }
          else {
              this.createWindowByCanvas(params);
          }
      }
      createWindowByConfig(params) {
          const nativeCanvas = this.global.createCanvas({ width: params.width, height: params.height });
          const options = {
              width: params.width,
              height: params.height,
              dpr: params.dpr,
              nativeCanvas,
              id: Generator.GenAutoIncrementId().toString(),
              canvasControled: true
          };
          this.canvas = new NodeCanvas(options);
      }
      createWindowByCanvas(params) {
          const canvas = params.canvas;
          let width = params.width;
          let height = params.height;
          if (width == null || height == null || !params.canvasControled) {
              width = canvas.width;
              height = canvas.height;
          }
          this.canvas = new NodeCanvas({
              width: width,
              height: height,
              dpr: 1,
              nativeCanvas: canvas,
              canvasControled: params.canvasControled
          });
      }
      releaseWindow() {
          this.canvas.release();
      }
      resizeWindow(width, height) {
          this.canvas.resize(width, height);
      }
      setDpr(dpr) {
          this.canvas.dpr = dpr;
      }
      getContext() {
          return this.canvas.getContext();
      }
      getNativeHandler() {
          return this.canvas;
      }
      getDpr() {
          return this.canvas.dpr;
      }
      getImageBuffer(type = 'image/png') {
          const canvas = this.canvas.nativeCanvas;
          return canvas.toBuffer(type);
      }
      addEventListener(type, listener, options) {
          return;
      }
      dispatchEvent(event) {
          return true;
      }
      removeEventListener(type, listener, options) {
          return;
      }
      getStyle() {
          return;
      }
      setStyle(style) {
          return;
      }
      getBoundingClientRect() {
          return null;
      }
      clearViewBox(vb, color) {
          return;
      }
  };
  NodeWindowHandlerContribution = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], NodeWindowHandlerContribution);

  let WxContext2d = class WxContext2d extends exports.BrowserContext2d {
      static env = 'wx';
      draw() {
          return;
      }
      createPattern(image, repetition) {
          return null;
      }
  };
  WxContext2d = __decorate([
      injectable()
  ], WxContext2d);

  const DefaultConfig$1 = {
      WIDTH: 500,
      HEIGHT: 500,
      DPR: 1
  };
  let WxCanvas = class WxCanvas {
      static env = 'wx';
      _displayWidth;
      _displayHeight;
      _id;
      _pixelWidth;
      _pixelHeight;
      _x;
      _y;
      _dpr;
      _container;
      _nativeCanvas;
      _context;
      _visiable;
      get id() {
          return this._id;
      }
      get x() {
          return this._x;
      }
      get y() {
          return this._y;
      }
      get nativeCanvas() {
          return this._nativeCanvas;
      }
      get width() {
          return this._pixelWidth;
      }
      set width(width) {
          this._pixelWidth = width;
          this._displayWidth = width / (this._dpr || 1);
      }
      get height() {
          return this._pixelHeight;
      }
      set height(height) {
          this._pixelHeight = height;
          this._displayHeight = height / (this._dpr || 1);
      }
      get displayWidth() {
          return this._displayWidth;
      }
      get displayHeight() {
          return this._displayHeight;
      }
      getContext(str) {
          return this._context;
      }
      get visiable() {
          return this._visiable;
      }
      set visiable(visiable) {
          this._visiable = visiable;
          visiable ? this.show() : this.hide();
      }
      get dpr() {
          return this._dpr;
      }
      set dpr(dpr) {
          this._dpr = dpr;
      }
      constructor(params) {
          const { nativeCanvas, width = DefaultConfig$1.WIDTH, height = DefaultConfig$1.HEIGHT, dpr = DefaultConfig$1.DPR } = params;
          const { x, y } = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : { x: 0, y: 0 };
          this._x = x;
          this._y = y;
          this._pixelWidth = width * dpr;
          this._pixelHeight = height * dpr;
          this._visiable = params.visiable !== false;
          this._displayWidth = width;
          this._displayHeight = height;
          this._dpr = dpr;
          this._nativeCanvas = nativeCanvas;
          this._context = new WxContext2d(this, this._dpr);
          this._id = nativeCanvas.id;
      }
      getNativeCanvas() {
          return this._nativeCanvas;
      }
      resetStyle(params) {
          return;
      }
      applyPosition() {
          return;
      }
      hide() {
          return;
      }
      show() {
          return;
      }
      resize(width, height) {
          return;
      }
      toDataURL(mimeType, quality) {
          return '';
      }
      readPixels(x, y, w, h) {
          throw new Error('');
      }
      convertToBlob(options) {
          throw new Error('');
      }
      transferToImageBitmap() {
          throw new Error('');
      }
      release(...params) {
          return;
      }
  };
  WxCanvas = __decorate([
      injectable(),
      __metadata("design:paramtypes", [Object])
  ], WxCanvas);

  class MiniAppEventManager {
      addEventListener(type, func) {
          if (!type || !func) {
              return;
          }
          this.cache[type] = this.cache[type] || {
              listener: []
          };
          this.cache[type].listener.push(func);
      }
      removeEventListener(type, func) {
          if (!type || !func) {
              return;
          }
          if (!this.cache[type]) {
              return;
          }
          const index = this.cache[type].listener.findIndex((f) => f === func);
          if (index >= 0) {
              this.cache[type].listener.splice(index, 1);
          }
      }
      cleanEvent() {
          this.cache = {};
      }
      cache = {};
  }
  let WxWindowHandlerContribution = class WxWindowHandlerContribution extends exports.BaseWindowHandlerContribution {
      global;
      static env = 'wx';
      type = 'wx';
      eventManager = new MiniAppEventManager();
      canvas;
      get container() {
          return null;
      }
      constructor(global) {
          super();
          this.global = global;
      }
      getTitle() {
          return this.canvas.id.toString();
      }
      getWH() {
          return {
              width: this.canvas.width / (this.canvas.dpr || 1),
              height: this.canvas.height / (this.canvas.dpr || 1)
          };
      }
      getXY() {
          return { x: 0, y: 0 };
      }
      createWindow(params) {
          if (!params.canvas) {
              this.createWindowByConfig(params);
          }
          else {
              this.createWindowByCanvas(params);
          }
      }
      createWindowByConfig(params) {
          const nativeCanvas = this.global.createCanvas({
              width: params.width,
              height: params.height
          });
          const options = {
              width: params.width,
              height: params.height,
              dpr: params.dpr,
              nativeCanvas,
              id: Generator.GenAutoIncrementId().toString(),
              canvasControled: false
          };
          this.canvas = new WxCanvas(options);
      }
      createWindowByCanvas(params) {
          let canvas;
          if (typeof params.canvas === 'string') {
              canvas = this.global.getElementById(params.canvas);
              if (!canvas) {
                  throw new Error('canvasId canvasdom');
              }
          }
          else {
              canvas = params.canvas;
          }
          let width = params.width;
          let height = params.height;
          if (width == null || height == null || !params.canvasControled) {
              const data = canvas.getBoundingClientRect();
              width = data.width;
              height = data.height;
          }
          let dpr = params.dpr;
          if (dpr == null) {
              dpr = canvas.width / width;
          }
          this.canvas = new WxCanvas({
              width: width,
              height: height,
              dpr: dpr,
              nativeCanvas: canvas,
              canvasControled: params.canvasControled
          });
      }
      releaseWindow() {
          return;
      }
      resizeWindow(width, height) {
          return;
      }
      setDpr(dpr) {
          this.canvas.dpr = dpr;
      }
      getContext() {
          return this.canvas.getContext();
      }
      getNativeHandler() {
          return this.canvas;
      }
      getDpr() {
          return this.canvas.dpr;
      }
      addEventListener(type, listener) {
          this.eventManager.addEventListener(type, listener);
      }
      removeEventListener(type, listener) {
          this.eventManager.removeEventListener(type, listener);
      }
      dispatchEvent(event) {
          const { type } = event;
          if (!this.eventManager.cache[type]) {
              return false;
          }
          if (event.changedTouches && event.changedTouches[0]) {
              event.offsetX = event.changedTouches[0].x;
              event.changedTouches[0].offsetX = event.changedTouches[0].x ?? event.changedTouches[0].pageX;
              event.changedTouches[0].clientX = event.changedTouches[0].x ?? event.changedTouches[0].pageX;
              event.offsetY = event.changedTouches[0].y;
              event.changedTouches[0].offsetY = event.changedTouches[0].y ?? event.changedTouches[0].pageY;
              event.changedTouches[0].clientY = event.changedTouches[0].y ?? event.changedTouches[0].pageY;
          }
          event.preventDefault = () => {
              return;
          };
          event.stopPropagation = () => {
              return;
          };
          if (this.eventManager.cache[type].listener) {
              this.eventManager.cache[type].listener.forEach((f) => {
                  f(event);
              });
          }
          return true;
      }
      getStyle() {
          return {};
      }
      setStyle(style) {
          return;
      }
      getBoundingClientRect() {
          const wh = this.getWH();
          return {
              x: 0,
              y: 0,
              width: wh.width,
              height: wh.height,
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
          };
      }
      clearViewBox(vb, color) {
          const context = this.getContext();
          const dpr = this.getDpr();
          context.nativeContext.save();
          context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0);
          context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          if (color) {
              context.fillStyle = color;
              context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1);
          }
          context.nativeContext.restore();
      }
  };
  WxWindowHandlerContribution = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], WxWindowHandlerContribution);

  var windowModules = new ContainerModule(bind => {
      bind(BrowserWindowHandlerContribution).toSelf();
      bind(WindowHandlerContribution)
          .toDynamicValue(ctx => ctx.container.get(BrowserWindowHandlerContribution))
          .whenTargetNamed(BrowserWindowHandlerContribution.env);
      bind(FeishuWindowHandlerContribution).toSelf();
      bind(WindowHandlerContribution)
          .toDynamicValue(ctx => ctx.container.get(FeishuWindowHandlerContribution))
          .whenTargetNamed(FeishuWindowHandlerContribution.env);
      bind(TaroWindowHandlerContribution).toSelf();
      bind(WindowHandlerContribution)
          .toDynamicValue(ctx => ctx.container.get(TaroWindowHandlerContribution))
          .whenTargetNamed(TaroWindowHandlerContribution.env);
      bind(LynxWindowHandlerContribution).toSelf();
      bind(WindowHandlerContribution)
          .toDynamicValue(ctx => ctx.container.get(LynxWindowHandlerContribution))
          .whenTargetNamed(LynxWindowHandlerContribution.env);
      bind(WxWindowHandlerContribution).toSelf();
      bind(WindowHandlerContribution)
          .toDynamicValue(ctx => ctx.container.get(WxWindowHandlerContribution))
          .whenTargetNamed(WxWindowHandlerContribution.env);
      bind(NodeWindowHandlerContribution).toSelf();
      bind(WindowHandlerContribution)
          .toDynamicValue(ctx => ctx.container.get(NodeWindowHandlerContribution))
          .whenTargetNamed(NodeWindowHandlerContribution.env);
  });

  var textMeasureModules = new ContainerModule(bind => {
      bind(DefaultTextMeasureContribution).toSelf().inSingletonScope();
      bind(TextMeasureContribution).toService(DefaultTextMeasureContribution);
      bindContributionProvider(bind, TextMeasureContribution);
  });

  let CanvasLayerHandlerContribution = class CanvasLayerHandlerContribution {
      global;
      layer;
      canvas;
      context;
      offscreen;
      constructor(global) {
          this.global = global;
          this.offscreen = false;
      }
      init(layer, window, params) {
          this.layer = layer;
          if (params.main) {
              this.context = window.getContext();
              this.canvas = this.context.getCanvas();
          }
          else {
              let nativeCanvas;
              if (params.canvasId) {
                  nativeCanvas = this.global.getElementById(params.canvasId);
              }
              else {
                  nativeCanvas = this.global.createCanvas({
                      width: window.width,
                      height: window.height
                  });
              }
              const windowContext = window.getContext();
              const windowCanvas = windowContext.getCanvas().nativeCanvas;
              const canvas = wrapCanvas({
                  nativeCanvas,
                  width: window.width,
                  height: window.height,
                  dpr: window.dpr,
                  canvasControled: true,
                  container: window.getContainer(),
                  x: windowCanvas.offsetLeft,
                  y: windowCanvas.offsetTop
              });
              canvas.applyPosition();
              this.canvas = canvas;
              this.context = canvas.getContext();
          }
      }
      resize(w, h) {
          this.canvas.resize(w, h);
          return;
      }
      resizeView(w, h) {
          return;
      }
      render(group, params, userParams) {
          params.renderService.render(group, {
              context: this.context,
              clear: params.background ?? '#ffffff',
              ...params,
              ...userParams
          });
      }
      merge(layerHandlers) {
          layerHandlers.forEach(l => {
              const ctx = l.getContext();
              const canvas = ctx.canvas.nativeCanvas;
              this.context.drawImage(canvas, 0, 0);
          });
      }
      prepare(dirtyBounds, params) {
          return;
      }
      drawTo(target, group, params) {
          const context = target.getContext();
          params.renderService.render(group, {
              context,
              ...params,
              clear: params.clear ? params.background ?? '#fff' : undefined
          });
          return;
      }
      getContext() {
          return this.context;
      }
      release() {
          this.canvas.release();
      }
  };
  CanvasLayerHandlerContribution = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], CanvasLayerHandlerContribution);

  let OffscreenLayerHandlerContribution = class OffscreenLayerHandlerContribution {
      global;
      layer;
      canvas;
      context;
      offscreen;
      constructor(global) {
          this.global = global;
          this.offscreen = true;
      }
      init(layer, window, params) {
          this.layer = layer;
          const nativeCanvas = this.global.createOffscreenCanvas({
              width: params.width,
              height: params.height,
              dpr: window.dpr
          });
          const canvas = wrapCanvas({
              nativeCanvas,
              width: params.width,
              height: params.height,
              dpr: window.dpr,
              canvasControled: true
          });
          this.canvas = canvas;
          this.context = canvas.getContext();
      }
      resize(w, h) {
          this.canvas.resize(w, h);
          return;
      }
      resizeView(w, h) {
          this.canvas.resize(w, h);
          return;
      }
      render(group, params) {
          params.renderService.render(group, {
              context: this.context,
              ...params,
              x: 0,
              y: 0,
              clear: params.background ?? '#ffffff'
          });
      }
      prepare(dirtyBounds, params) {
          return;
      }
      release() {
          this.canvas.release();
      }
      getContext() {
          return this.context;
      }
      drawTo(target, group, params) {
          const context = target.getContext();
          const targetDpr = target.dpr;
          const { x = 0, y = 0, width = this.layer.viewWidth, height = this.layer.viewHeight } = params;
          context.nativeContext.save();
          context.nativeContext.setTransform(targetDpr, 0, 0, targetDpr, 0, 0);
          if (params.clear) {
              context.clearRect(x, y, width, height);
          }
          context.drawImage(this.canvas.nativeCanvas, 0, 0, this.canvas.width, this.canvas.height, x, y, width, height);
          context.nativeContext.restore();
      }
      merge(layerHandlers) {
          return;
      }
  };
  OffscreenLayerHandlerContribution = __decorate([
      injectable(),
      __param(0, inject(Global)),
      __metadata("design:paramtypes", [Object])
  ], OffscreenLayerHandlerContribution);

  var layerHandlerModules = new ContainerModule(bind => {
      bind(CanvasLayerHandlerContribution).toSelf();
      bind(OffscreenLayerHandlerContribution).toSelf();
      bind(LayerHandlerContribution).toService(CanvasLayerHandlerContribution);
  });

  function load$3(container) {
      container.load(envModules);
      container.load(windowModules);
      container.load(textMeasureModules);
      container.load(layerHandlerModules);
  }

  const DrawItemInterceptor = Symbol.for('DrawItemInterceptor');
  const tempDirtyBounds = new AABBBounds();
  let ShadowRootDrawItemInterceptorContribution = class ShadowRootDrawItemInterceptorContribution {
      order = 1;
      afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
          if (!graphic.shadowRoot) {
              return false;
          }
          const { context } = drawContext;
          context.highPerformanceSave();
          context.transformFromMatrix(graphic.transMatrix, true);
          if (drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
              tempDirtyBounds.copy(drawContribution.dirtyBounds);
              const m = graphic.globalTransMatrix.getInverse();
              drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m);
          }
          drawContribution.renderGroup(graphic.shadowRoot, drawContext);
          context.highPerformanceRestore();
          if (drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
              drawContribution.dirtyBounds.copy(tempDirtyBounds);
          }
          return true;
      }
  };
  ShadowRootDrawItemInterceptorContribution = __decorate([
      injectable()
  ], ShadowRootDrawItemInterceptorContribution);
  let Canvas3DDrawItemInterceptor = class Canvas3DDrawItemInterceptor {
      order = 1;
      beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
          if (!graphic.in3dMode || drawContext.in3dInterceptor) {
              return false;
          }
          drawContext.in3dInterceptor = true;
          const { context, stage } = renderService.drawParams;
          context.canvas;
          context.save();
          this.initCanvasCtx(context);
          context.camera = stage.camera;
          const m = context.currentMatrix;
          m.a /= context.dpr;
          m.b /= context.dpr;
          m.c /= context.dpr;
          m.d /= context.dpr;
          m.e /= context.dpr;
          m.f /= context.dpr;
          const matrix = mat4Allocate.allocate();
          mat3Tomat4(matrix, m);
          const lastModelMatrix = context.modelMatrix;
          if (lastModelMatrix) {
              if (matrix) {
                  const m = mat4Allocate.allocate();
                  context.modelMatrix = multiplyMat4Mat4(m, lastModelMatrix, matrix);
              }
          }
          else {
              context.modelMatrix = matrix;
          }
          context.setTransform(1, 0, 0, 1, 0, 0, true);
          if (graphic.isContainer) {
              let isPie = false;
              let is3d = false;
              graphic.forEachChildren((c) => {
                  isPie = c.numberType === ARC3D_NUMBER_TYPE;
                  return !isPie;
              });
              graphic.forEachChildren((c) => {
                  is3d = !!c.findFace;
                  return !is3d;
              });
              if (isPie) {
                  const children = graphic.getChildren();
                  const sortedChildren = [...children];
                  sortedChildren.sort((a, b) => {
                      let angle1 = ((a.attribute.startAngle ?? 0) + (a.attribute.endAngle ?? 0)) / 2;
                      let angle2 = ((b.attribute.startAngle ?? 0) + (b.attribute.endAngle ?? 0)) / 2;
                      while (angle1 < 0) {
                          angle1 += pi2;
                      }
                      while (angle2 < 0) {
                          angle2 += pi2;
                      }
                      return angle2 - angle1;
                  });
                  sortedChildren.forEach(c => {
                      c._next = null;
                      c._prev = null;
                  });
                  graphic.removeAllChild();
                  graphic.update();
                  sortedChildren.forEach(c => {
                      graphic.appendChild(c);
                  });
                  drawContext.hack_pieFace = 'outside';
                  drawContribution.renderGroup(graphic, drawContext);
                  drawContext.hack_pieFace = 'inside';
                  drawContribution.renderGroup(graphic, drawContext);
                  drawContext.hack_pieFace = 'top';
                  drawContribution.renderGroup(graphic, drawContext);
                  graphic.removeAllChild();
                  children.forEach(c => {
                      c._next = null;
                      c._prev = null;
                  });
                  children.forEach(c => {
                      graphic.appendChild(c);
                  });
              }
              else if (is3d) {
                  const children = graphic.getChildren();
                  const zChildren = children.map(g => {
                      const face3d = g.findFace();
                      const vertices = face3d.vertices;
                      const viewdVerticesZ = vertices.map(v => {
                          return context.view(v[0], v[1], v[2] + g.attribute.z ?? 0)[2];
                      });
                      const ave_z = viewdVerticesZ.reduce((a, b) => a + b, 0);
                      return {
                          ave_z,
                          g
                      };
                  });
                  zChildren.sort((a, b) => b.ave_z - a.ave_z);
                  graphic.removeAllChild();
                  zChildren.forEach(i => {
                      i.g._next = null;
                      i.g._prev = null;
                  });
                  graphic.update();
                  zChildren.forEach(i => {
                      graphic.add(i.g);
                  });
                  drawContribution.renderGroup(graphic, drawContext, true);
                  graphic.removeAllChild();
                  children.forEach(g => {
                      g._next = null;
                      g._prev = null;
                  });
                  graphic.update();
                  children.forEach(g => {
                      graphic.add(g);
                  });
              }
              else {
                  drawContribution.renderGroup(graphic, drawContext);
              }
          }
          else {
              drawContribution.renderItem(graphic, drawContext);
          }
          context.camera = null;
          context.restore();
          if (context.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(context.modelMatrix);
          }
          context.modelMatrix = lastModelMatrix;
          drawContext.in3dInterceptor = false;
          return true;
      }
      initCanvasCtx(context) {
          context.setTransformForCurrent();
      }
  };
  Canvas3DDrawItemInterceptor = __decorate([
      injectable()
  ], Canvas3DDrawItemInterceptor);

  let DefaultDrawContribution = class DefaultDrawContribution {
      contributions;
      renderSelector;
      layerService;
      drawItemInterceptorContributions;
      constructor(contributions, renderSelector, layerService, drawItemInterceptorContributions) {
          this.contributions = contributions;
          this.renderSelector = renderSelector;
          this.layerService = layerService;
          this.drawItemInterceptorContributions = drawItemInterceptorContributions;
          this.currentRenderMap = new Map();
          this.defaultRenderMap = new Map();
          this.styleRenderMap = new Map();
          this.dirtyBounds = new Bounds();
          this.backupDirtyBounds = new Bounds();
      }
      init() {
          this.contributions.forEach(item => {
              if (item.style) {
                  const map = this.styleRenderMap.get(item.style) || new Map();
                  map.set(item.numberType, item);
                  this.styleRenderMap.set(item.style, map);
              }
              else {
                  this.defaultRenderMap.set(item.numberType, item);
              }
          });
          this.InterceptorContributions = this.drawItemInterceptorContributions
              .getContributions()
              .sort((a, b) => a.order - b.order);
      }
      draw(renderService, drawContext) {
          drawContext.drawContribution = this;
          this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap;
          this.currentRenderService = renderService;
          const { context, stage, x = 0, y = 0, width, height } = drawContext;
          if (!context) {
              return;
          }
          const dirtyBounds = this.dirtyBounds.setValue(0, 0, width, height);
          if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
              const b = getRectIntersect(dirtyBounds, stage.dirtyBounds, false);
              dirtyBounds.x1 = Math.floor(b.x1);
              dirtyBounds.y1 = Math.floor(b.y1);
              dirtyBounds.x2 = Math.ceil(b.x2);
              dirtyBounds.y2 = Math.ceil(b.y2);
          }
          this.backupDirtyBounds.copy(dirtyBounds);
          context.inuse = true;
          context.clearMatrix();
          context.setTransformForCurrent(true);
          const drawInArea = dirtyBounds.width() * context.dpr !== context.canvas.width ||
              dirtyBounds.height() * context.dpr !== context.canvas.height;
          context.save();
          context.translate(x, y, true);
          if (drawInArea) {
              context.beginPath();
              context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height());
              context.clip();
          }
          if (stage.camera) {
              this.dirtyBounds.setValue(-Infinity, -Infinity, Infinity, Infinity);
              this.backupDirtyBounds.setValue(-Infinity, -Infinity, Infinity, Infinity);
          }
          this.clearScreen(renderService, context, drawContext);
          context.save();
          renderService.renderTreeRoots
              .sort((a, b) => {
              return (a.attribute.zIndex ?? DefaultAttribute.zIndex) - (b.attribute.zIndex ?? DefaultAttribute.zIndex);
          })
              .forEach(group => {
              this.renderGroup(group, drawContext);
          });
          context.restore();
          context.restore();
          context.draw();
          context.inuse = false;
      }
      doRegister() {
          throw new Error('');
      }
      _findNextGraphic(group) {
          let parent = group.parent;
          let id = group._uid;
          while (parent) {
              const g = findNextGraphic(parent, id, DefaultAttribute.zIndex);
              if (g) {
                  return g;
              }
              id = parent._uid;
              parent = parent.parent;
          }
          return null;
      }
      renderGroup(group, drawContext, skipSort) {
          if (drawContext.break || group.attribute.visibleAll === false) {
              return;
          }
          if (group.incremental && (drawContext.startAtId == null || drawContext.startAtId === group._uid)) {
              drawContext.break = true;
              this._increaseRender(group, drawContext);
              return;
          }
          if (!isRectIntersect(group.AABBBounds, this.dirtyBounds, false)) {
              return;
          }
          const tempBounds = this.dirtyBounds.clone();
          const m = group.globalTransMatrix.getInverse();
          this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(m);
          this.renderItem(group, drawContext, {
              drawingCb: () => {
                  skipSort
                      ? group.forEachChildren((item) => {
                          if (drawContext.break) {
                              return;
                          }
                          if (item.isContainer) {
                              this.renderGroup(item, drawContext);
                          }
                          else {
                              this.renderItem(item, drawContext);
                          }
                      })
                      : foreach(group, DefaultAttribute.zIndex, (item) => {
                          if (drawContext.break) {
                              return;
                          }
                          if (item.isContainer) {
                              this.renderGroup(item, drawContext);
                          }
                          else {
                              this.renderItem(item, drawContext);
                          }
                      }, false, !!drawContext.context?.camera);
              }
          });
          this.dirtyBounds.copy(tempBounds);
      }
      _increaseRender(group, drawContext) {
          const { layer, stage } = drawContext;
          const { subLayers } = layer;
          let incrementalLayer = subLayers.get(group._uid);
          if (!incrementalLayer) {
              incrementalLayer = {
                  layer: this.layerService.createLayer(stage),
                  zIndex: subLayers.size,
                  group
              };
              subLayers.set(group._uid, incrementalLayer);
          }
          const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext();
          const idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
          idc.dirtyBounds.setValue(-Infinity, -Infinity, Infinity, Infinity);
          idc.backupDirtyBounds.setValue(-Infinity, -Infinity, Infinity, Infinity);
          idc.draw(this.currentRenderService, {
              ...drawContext,
              drawContribution: idc,
              clear: 'transparent',
              layer: incrementalLayer.layer,
              context: incrementalContext,
              startAtId: group._uid,
              break: false
          });
          incrementalLayer.drawContribution = idc;
          const nextGraphic = this._findNextGraphic(group);
          if (nextGraphic) {
              if (nextGraphic.isContainer && nextGraphic.incremental) {
                  this._increaseRender(nextGraphic, drawContext);
              }
              else {
                  let afterLayer = subLayers.get(nextGraphic._uid);
                  if (!afterLayer) {
                      afterLayer = {
                          layer: this.layerService.createLayer(stage),
                          zIndex: subLayers.size
                      };
                      subLayers.set(nextGraphic._uid, afterLayer);
                  }
                  const afterContext = afterLayer.layer.getNativeHandler().getContext();
                  this.draw(this.currentRenderService, {
                      ...drawContext,
                      drawContribution: idc,
                      clear: 'transparent',
                      layer: afterLayer.layer,
                      context: afterContext,
                      startAtId: nextGraphic._uid,
                      break: false
                  });
              }
          }
      }
      getRenderContribution(graphic) {
          let renderer = this.renderSelector.selector(graphic);
          if (!renderer) {
              renderer = this.selectRenderByNumberType(graphic.numberType);
          }
          if (!renderer) {
              renderer = this.selectRenderByType(graphic.type);
          }
          return renderer;
      }
      renderItem(graphic, drawContext, params) {
          if (this.InterceptorContributions.length) {
              for (let i = 0; i < this.InterceptorContributions.length; i++) {
                  const drawContribution = this.InterceptorContributions[i];
                  if (drawContribution.beforeDrawItem) {
                      if (drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params)) {
                          return;
                      }
                  }
              }
          }
          const renderer = this.getRenderContribution(graphic);
          if (!renderer) {
              return;
          }
          if (!(graphic.isContainer || isRectIntersect(graphic.AABBBounds, this.dirtyBounds, false))) {
              return;
          }
          const skipDraw = drawContext.startAtId != null && graphic._uid !== drawContext.startAtId;
          if (graphic._uid === drawContext.startAtId) {
              drawContext.startAtId = null;
          }
          params && (params.skipDraw = skipDraw);
          if (skipDraw) {
              graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params);
          }
          else {
              renderer.draw(graphic, this.currentRenderService, drawContext, params);
          }
          if (this.InterceptorContributions.length) {
              for (let i = 0; i < this.InterceptorContributions.length; i++) {
                  const drawContribution = this.InterceptorContributions[i];
                  if (drawContribution.afterDrawItem) {
                      if (drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) {
                          return;
                      }
                  }
              }
          }
      }
      selectRenderByType(type) {
          console.warn('');
          return null;
      }
      selectRenderByNumberType(type) {
          return this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
      }
      clearScreen(renderService, context, drawContext) {
          const { clear } = drawContext;
          if (clear) {
              const canvas = context.getCanvas();
              const { width = canvas.width, height = canvas.height } = drawContext;
              const x = 0;
              const y = 0;
              context.clearRect(x, y, width, height);
              context.fillStyle = createColor(context, clear, {
                  AABBBounds: { x1: x, y1: y, x2: x + width, y2: y + height }
              }, 0, 0);
              context.fillRect(x, y, width, height);
          }
      }
  };
  __decorate([
      postConstruct(),
      __metadata("design:type", Function),
      __metadata("design:paramtypes", []),
      __metadata("design:returntype", void 0)
  ], DefaultDrawContribution.prototype, "init", null);
  DefaultDrawContribution = __decorate([
      injectable(),
      __param(0, multiInject(GraphicRender)),
      __param(1, inject(RenderSelector)),
      __param(2, inject(LayerService)),
      __param(3, inject(ContributionProvider)),
      __param(3, named(DrawItemInterceptor)),
      __metadata("design:paramtypes", [Array, Object, Object, Object])
  ], DefaultDrawContribution);

  let DefaultRenderSelector = class DefaultRenderSelector {
      selector(graphic) {
          return null;
      }
  };
  DefaultRenderSelector = __decorate([
      injectable()
  ], DefaultRenderSelector);

  let DefaultCanvasGroupRender = class DefaultCanvasGroupRender {
      groupRenderContribitions;
      type;
      numberType = GROUP_NUMBER_TYPE;
      _groupRenderContribitions;
      constructor(groupRenderContribitions) {
          this.groupRenderContribitions = groupRenderContribitions;
      }
      drawShape(group, context, x, y, drawContext, params, fillCb, strokeCb) {
          const groupAttribute = getTheme(group, params?.theme).group;
          const { fill = groupAttribute.fill, background, stroke = groupAttribute.stroke, opacity = groupAttribute.opacity, width = groupAttribute.width, height = groupAttribute.height, clip = groupAttribute.clip, fillOpacity = groupAttribute.fillOpacity, strokeOpacity = groupAttribute.strokeOpacity, cornerRadius = groupAttribute.cornerRadius, path = groupAttribute.path, lineWidth = groupAttribute.lineWidth, visible = groupAttribute.visible } = group.attribute;
          const fVisible = rectFillVisible(opacity, fillOpacity, width, height);
          const sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(group.valid && visible)) {
              return;
          }
          if (!clip) {
              if (!(doFill || doStroke || background)) {
                  return;
              }
              if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
                  return;
              }
          }
          if (path && path.length && drawContext.drawContribution) {
              const disableFill = context.disableFill;
              const disableStroke = context.disableStroke;
              const disableBeginPath = context.disableBeginPath;
              context.disableFill = true;
              context.disableStroke = true;
              context.disableBeginPath = true;
              path.forEach(g => {
                  const rc = drawContext.drawContribution.getRenderContribution(g);
                  rc.draw(g, drawContext.renderService, drawContext, params);
              });
              context.disableFill = disableFill;
              context.disableStroke = disableStroke;
              context.disableBeginPath = disableBeginPath;
          }
          else if (cornerRadius === 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
              context.beginPath();
              context.rect(x, y, width, height);
          }
          else {
              context.beginPath();
              createRectPath(context, x, y, width, height, cornerRadius);
          }
          if (!this._groupRenderContribitions) {
              this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [];
          }
          const doFillOrStroke = {
              doFill,
              doStroke
          };
          this._groupRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.beforeFillStroke) {
                  c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb, doFillOrStroke);
              }
          });
          if (clip) {
              context.clip();
          }
          context.setShadowStyle && context.setShadowStyle(group, group.attribute, groupAttribute);
          if (doFillOrStroke.doFill) {
              if (fillCb) {
                  fillCb(context, group.attribute, groupAttribute);
              }
              else if (fVisible) {
                  context.setCommonStyle(group, group.attribute, x, y, groupAttribute);
                  context.fill();
              }
          }
          if (doFillOrStroke.doStroke) {
              if (strokeCb) {
                  strokeCb(context, group.attribute, groupAttribute);
              }
              else if (sVisible) {
                  context.setStrokeStyle(group, group.attribute, x, y, groupAttribute);
                  context.stroke();
              }
          }
          this._groupRenderContribitions.forEach(c => {
              if (c.time === exports.BaseRenderContributionTime.afterFillStroke) {
                  c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb);
              }
          });
      }
      draw(group, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          const { clip } = group.attribute;
          if (clip) {
              context.save();
          }
          else {
              context.highPerformanceSave();
          }
          const groupAttribute = getTheme(group, params?.theme).group;
          const lastModelMatrix = context.modelMatrix;
          const camera = context.camera;
          if (camera) {
              const nextModelMatrix = mat4Allocate.allocate();
              const modelMatrix = mat4Allocate.allocate();
              getModelMatrix(modelMatrix, group, groupAttribute);
              if (lastModelMatrix) {
                  multiplyMat4Mat4(nextModelMatrix, lastModelMatrix, modelMatrix);
              }
              else {
                  multiplyMat4Mat4(nextModelMatrix, nextModelMatrix, modelMatrix);
              }
              context.modelMatrix = nextModelMatrix;
              mat4Allocate.free(modelMatrix);
              context.setTransform(1, 0, 0, 1, 0, 0, true);
          }
          else {
              context.transformFromMatrix(group.transMatrix, true);
          }
          context.beginPath();
          if (params.skipDraw) {
              this.drawShape(group, context, 0, 0, drawContext, params, () => false, () => false);
          }
          else {
              this.drawShape(group, context, 0, 0, drawContext);
          }
          const { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = group.attribute;
          if (scrollX || scrollY) {
              context.translate(scrollX, scrollY);
          }
          let p;
          if (params && params.drawingCb) {
              p = params.drawingCb();
          }
          if (context.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(context.modelMatrix);
          }
          context.modelMatrix = lastModelMatrix;
          if (p && p.then) {
              p.then(() => {
                  if (clip) {
                      context.restore();
                  }
                  else {
                      context.highPerformanceRestore();
                  }
              });
          }
          else {
              if (clip) {
                  context.restore();
              }
              else {
                  context.highPerformanceRestore();
              }
          }
      }
  };
  DefaultCanvasGroupRender = __decorate([
      injectable(),
      __param(0, inject(ContributionProvider)),
      __param(0, named(GroupRenderContribution)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasGroupRender);

  let DefaultIncrementalCanvasLineRender = class DefaultIncrementalCanvasLineRender extends exports.DefaultCanvasLineRender {
      numberType = LINE_NUMBER_TYPE;
      drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
          if (line.incremental && drawContext.multiGraphicOptions) {
              const { startAtIdx, length } = drawContext.multiGraphicOptions;
              const { segments = [] } = line.attribute;
              if (startAtIdx > segments.length) {
                  return;
              }
              const lineAttribute = getTheme(line).line;
              const { fill = lineAttribute.fill, stroke = lineAttribute.stroke, opacity = lineAttribute.opacity, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, lineWidth = lineAttribute.lineWidth, visible = lineAttribute.visible } = line.attribute;
              const fVisible = fillVisible(opacity, fillOpacity);
              const sVisible = strokeVisible(opacity, strokeOpacity);
              const doFill = runFill(fill);
              const doStroke = runStroke(stroke, lineWidth);
              if (!(line.valid && visible)) {
                  return;
              }
              if (!(doFill || doStroke)) {
                  return;
              }
              if (!(fVisible || sVisible || fillCb || strokeCb)) {
                  return;
              }
              const { context } = drawContext;
              for (let i = startAtIdx; i < startAtIdx + length; i++) {
                  this.drawIncreaseSegment(line, context, segments[i - 1], segments[i], line.attribute.segments[i], [lineAttribute, line.attribute], x, y);
              }
          }
          else {
              super.drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb);
          }
      }
      drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
          if (!seg) {
              return;
          }
          context.beginPath();
          drawIncrementalSegments(context.nativeContext, lastSeg, seg, { offsetX, offsetY });
          context.setShadowStyle && context.setShadowStyle(line, attribute, defaultAttribute);
          context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute);
          context.stroke();
      }
  };
  DefaultIncrementalCanvasLineRender = __decorate([
      injectable()
  ], DefaultIncrementalCanvasLineRender);

  let DefaultIncrementalCanvasAreaRender = class DefaultIncrementalCanvasAreaRender extends exports.DefaultCanvasAreaRender {
      numberType = AREA_NUMBER_TYPE;
      drawShape(area, context, x, y, drawContext, params, fillCb) {
          if (area.incremental && drawContext.multiGraphicOptions) {
              const { startAtIdx, length } = drawContext.multiGraphicOptions;
              const { segments = [] } = area.attribute;
              if (startAtIdx > segments.length) {
                  return;
              }
              const areaAttribute = getTheme(area).area;
              const { fill = areaAttribute.fill, fillOpacity = areaAttribute.fillOpacity, opacity = areaAttribute.opacity, visible = areaAttribute.visible } = area.attribute;
              const fVisible = fillVisible(opacity, fillOpacity);
              const doFill = runFill(fill);
              if (!(area.valid && visible)) {
                  return;
              }
              if (!doFill) {
                  return;
              }
              if (!(fVisible || fillCb)) {
                  return;
              }
              for (let i = startAtIdx; i < startAtIdx + length; i++) {
                  this.drawIncreaseSegment(area, context, segments[i - 1], segments[i], area.attribute.segments[i], [areaAttribute, area.attribute], x, y);
              }
          }
          else {
              super.drawShape(area, context, x, y, drawContext, params, fillCb);
          }
      }
      drawIncreaseSegment(area, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
          if (!seg) {
              return;
          }
          context.beginPath();
          drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
              offsetX,
              offsetY
          });
          context.setShadowStyle && context.setShadowStyle(area, attribute, defaultAttribute);
          context.setCommonStyle(area, attribute, offsetX, offsetY, defaultAttribute);
          context.fill();
      }
  };
  DefaultIncrementalCanvasAreaRender = __decorate([
      injectable()
  ], DefaultIncrementalCanvasAreaRender);

  var STATUS;
  (function (STATUS) {
      STATUS[STATUS["NORMAL"] = 0] = "NORMAL";
      STATUS[STATUS["STOP"] = 1] = "STOP";
  })(STATUS || (STATUS = {}));
  let DefaultIncrementalDrawContribution = class DefaultIncrementalDrawContribution extends DefaultDrawContribution {
      contributions;
      renderSelector;
      lineRender;
      areaRender;
      layerService;
      drawItemInterceptorContributions;
      rendering = false;
      currFrameStartAt = 0;
      currentIdx = 0;
      status = STATUS.NORMAL;
      checkingForDrawPromise = null;
      hooks = {
          completeDraw: new SyncHook([])
      };
      lastRenderService;
      lastDrawContext;
      count;
      global;
      constructor(contributions, renderSelector, lineRender, areaRender, layerService, drawItemInterceptorContributions) {
          super(contributions, renderSelector, layerService, drawItemInterceptorContributions);
          this.contributions = contributions;
          this.renderSelector = renderSelector;
          this.lineRender = lineRender;
          this.areaRender = areaRender;
          this.layerService = layerService;
          this.drawItemInterceptorContributions = drawItemInterceptorContributions;
      }
      init() {
          super.init();
          this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender);
          this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
      }
      async draw(renderService, drawContext) {
          if (this.checkingForDrawPromise) {
              return;
          }
          this.lastRenderService = renderService;
          this.lastDrawContext = drawContext;
          this.checkingForDrawPromise = this.checkForDraw(drawContext);
          const skipDraw = await this.checkingForDrawPromise;
          this.checkingForDrawPromise = null;
          if (skipDraw) {
              return;
          }
          this.currentRenderService = renderService;
          const { context, x = 0, y = 0 } = drawContext;
          if (!context) {
              return;
          }
          context.inuse = true;
          context.clearMatrix();
          context.setTransformForCurrent(true);
          context.save();
          drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext);
          context.translate(x, y, true);
          context.save();
          renderService.renderTreeRoots
              .sort((a, b) => {
              return (a.attribute.zIndex ?? DefaultAttribute.zIndex) - (b.attribute.zIndex ?? DefaultAttribute.zIndex);
          })
              .forEach(group => {
              this.renderGroup(group, drawContext);
          });
          this.hooks.completeDraw.tap('top-draw', () => {
              context.restore();
              context.restore();
              context.draw();
              context.inuse = false;
              this.rendering = false;
          });
      }
      async _increaseRender(group, drawContext) {
          this.rendering = true;
          await this._renderIncrementalGroup(group, drawContext);
          return;
      }
      async _renderIncrementalGroup(group, drawContext) {
          this.count = group.count;
          await new Promise(resolve => {
              this.renderItem(group, drawContext, {
                  drawingCb: async () => {
                      if (group.count === 2) {
                          const graphic = group.getChildAt(0);
                          if (graphic.incremental && graphic.attribute.segments) {
                              if (!graphic.incrementalAt) {
                                  graphic.incrementalAt = 0;
                              }
                              while (graphic.incrementalAt < graphic.attribute.segments.length) {
                                  drawContext.multiGraphicOptions = {
                                      startAtIdx: graphic.incrementalAt,
                                      length: graphic.incremental
                                  };
                                  this.renderItem(graphic, drawContext);
                                  graphic.incrementalAt += graphic.incremental;
                                  await this.waitToNextFrame();
                              }
                          }
                          else {
                              this.renderItem(graphic, drawContext);
                          }
                          resolve(false);
                          return;
                      }
                      await foreachAsync(group, DefaultAttribute.zIndex, (item, i) => {
                          if (this.status === STATUS.STOP) {
                              return true;
                          }
                          if (item.isContainer) {
                              return false;
                          }
                          if (i < this.currentIdx) {
                              return false;
                          }
                          const frameTail = this.currFrameStartAt + group.incremental;
                          if (i < frameTail) {
                              this.currentIdx = i + 1;
                              this.renderItem(item, drawContext);
                          }
                          if (i === frameTail - 1) {
                              this.currFrameStartAt = this.currentIdx;
                              return this.waitToNextFrame();
                          }
                          return false;
                      });
                      resolve(false);
                  }
              });
          });
          this.hooks.completeDraw.call();
      }
      async waitToNextFrame() {
          return new Promise(resolve => {
              this.global.getRequestAnimationFrame()(() => {
                  resolve(false);
              });
          });
      }
      async checkForDraw(drawContext) {
          let skip = this.rendering;
          if (drawContext.restartIncremental) {
              skip = false;
              await this.forceStop();
              this.resetToInit();
          }
          return skip;
      }
      async forceStop() {
          if (this.rendering) {
              this.status = STATUS.STOP;
              await new Promise(resolve => {
                  this.hooks.completeDraw.tap('stopCb', () => {
                      this.status = STATUS.NORMAL;
                      this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter(item => {
                          return item.name !== 'stopCb';
                      });
                      resolve(false);
                  });
              });
          }
      }
      resetToInit() {
          this.currFrameStartAt = 0;
          this.currentIdx = 0;
      }
      async renderGroup(group, drawContext) {
          if (drawContext.break || group.attribute.visibleAll === false) {
              return;
          }
          if (group.incremental && drawContext.startAtId === group._uid) {
              await this._increaseRender(group, drawContext);
              drawContext.break = true;
              return;
          }
          await new Promise(resolve => {
              this.renderItem(group, drawContext, {
                  drawingCb: async () => {
                      await foreachAsync(group, DefaultAttribute.zIndex, async (item) => {
                          if (drawContext.break) {
                              return;
                          }
                          if (item.isContainer) {
                              await this.renderGroup(item, drawContext);
                          }
                          else {
                              return;
                          }
                      });
                      resolve(false);
                  }
              });
          });
      }
  };
  __decorate([
      inject(Global),
      __metadata("design:type", Object)
  ], DefaultIncrementalDrawContribution.prototype, "global", void 0);
  DefaultIncrementalDrawContribution = __decorate([
      injectable(),
      __param(0, multiInject(GraphicRender)),
      __param(1, inject(RenderSelector)),
      __param(2, inject(DefaultIncrementalCanvasLineRender)),
      __param(3, inject(DefaultIncrementalCanvasAreaRender)),
      __param(4, inject(LayerService)),
      __param(5, inject(ContributionProvider)),
      __param(5, named(DrawItemInterceptor)),
      __metadata("design:paramtypes", [Array, Object, Object, Object, Object, Object])
  ], DefaultIncrementalDrawContribution);

  let DefaultCanvasRect3dRender = class DefaultCanvasRect3dRender extends BaseRender {
      type = 'rect3d';
      numberType = RECT3D_NUMBER_TYPE;
      drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
          const rectAttribute = getTheme(rect, params?.theme).rect3d;
          const { fill = rectAttribute.fill, stroke = rectAttribute.stroke, width = rectAttribute.width, height = rectAttribute.height, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible } = rect.attribute;
          const z = this.z ?? 0;
          const fVisible = rectFillVisible(opacity, fillOpacity, width, height);
          const sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(rect.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb)) {
              return;
          }
          const { light, camera } = drawContext.stage || {};
          const face3d = rect.findFace();
          if (fill !== false) {
              context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);
              let fc = fill;
              if (typeof fc !== 'string') {
                  fc = 'black';
              }
              this.fill(x, y, z, face3d, fc, context, light, fillCb);
          }
          if (stroke !== false) {
              context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute);
              this.stroke(x, y, z, face3d, context);
          }
      }
      stroke(x, y, z, face3d, context) {
          const vertices = face3d.vertices;
          face3d.edges.forEach(edge => {
              const p1 = vertices[edge[0]];
              const v1 = {
                  x: x + p1[0],
                  y: y + p1[1],
                  z: z + p1[2]
              };
              const p2 = vertices[edge[1]];
              const v2 = {
                  x: x + p2[0],
                  y: y + p2[1],
                  z: z + p2[2]
              };
              context.beginPath();
              context.moveTo(v1.x, v1.y, v1.z);
              context.lineTo(v2.x, v2.y, v2.z);
              context.stroke();
          });
      }
      fill(x, y, z, face3d, fillColor, context, light, fillCb) {
          const rgbArray = colorString.get(fillColor).value;
          const vertices = face3d.vertices;
          const viewdVerticesZ = vertices.map(v => {
              return context.view(v[0], v[1], v[2])[2];
          });
          const sortFace = [];
          face3d.polygons.forEach((p, i) => {
              sortFace.push({
                  faceIdx: i,
                  polygon: p
              });
              const { polygon, normal } = p;
              const z1 = viewdVerticesZ[polygon[0]];
              const z2 = viewdVerticesZ[polygon[1]];
              const z3 = viewdVerticesZ[polygon[2]];
              const z4 = viewdVerticesZ[polygon[3]];
              p.ave_z = z1 + z2 + z3 + z4;
          });
          sortFace.sort((a, b) => b.polygon.ave_z - a.polygon.ave_z);
          sortFace.forEach(item => {
              const { polygon, normal } = item.polygon;
              const p1 = vertices[polygon[0]];
              const p2 = vertices[polygon[1]];
              const p3 = vertices[polygon[2]];
              const p4 = vertices[polygon[3]];
              const v1 = {
                  x: x + p1[0],
                  y: y + p1[1],
                  z: z + p1[2]
              };
              const v2 = {
                  x: x + p2[0],
                  y: y + p2[1],
                  z: z + p2[2]
              };
              const v3 = {
                  x: x + p3[0],
                  y: y + p3[1],
                  z: z + p3[2]
              };
              const v4 = {
                  x: x + p4[0],
                  y: y + p4[1],
                  z: z + p4[2]
              };
              context.beginPath();
              context.moveTo(v1.x, v1.y, v1.z);
              context.lineTo(v2.x, v2.y, v2.z);
              context.lineTo(v3.x, v3.y, v3.z);
              context.lineTo(v4.x, v4.y, v4.z);
              context.closePath();
              if (fillCb) {
                  fillCb(context, null, null);
              }
              else {
                  context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor;
                  context.fill();
              }
          });
      }
      draw(rect, renderService, drawContext) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          const rectAttribute = getTheme(rect).rect;
          const data = this.transform(rect, rectAttribute, context);
          const { x, y, z, lastModelMatrix } = data;
          this.z = z;
          this.drawShape(rect, context, x, y, drawContext);
          this.z = 0;
          if (context.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(context.modelMatrix);
          }
          context.modelMatrix = lastModelMatrix;
          context.highPerformanceRestore();
      }
  };
  DefaultCanvasRect3dRender = __decorate([
      injectable()
  ], DefaultCanvasRect3dRender);

  let DefaultCanvasRichTextRender = class DefaultCanvasRichTextRender {
      type;
      numberType = RICHTEXT_NUMBER_TYPE;
      drawShape(richtext, context, x, y, drawContext) {
          const richtextAttribute = getTheme(richtext).richtext;
          const { width = richtextAttribute.width, height = richtextAttribute.height, opacity = richtextAttribute.opacity, fillOpacity = richtextAttribute.fillOpacity, visible = richtextAttribute.visible } = richtext.attribute;
          if (!(richtext.valid && visible)) {
              return;
          }
          const fVisible = fillVisible(opacity, fillOpacity);
          if (!fVisible) {
              return;
          }
          context.translate(x, y);
          const frame = richtext.getFrameCache();
          frame.draw(context, this.drawIcon);
      }
      drawIcon(icon, context, x, y, baseline) {
          const richtextIconAttribute = getTheme(icon).richtextIcon;
          const { width = richtextIconAttribute.width, height = richtextIconAttribute.height, opacity = richtextIconAttribute.opacity, image: url, backgroundFill = richtextIconAttribute.backgroundFill, backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity, backgroundStroke = richtextIconAttribute.backgroundStroke, backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity, backgroundRadius = richtextIconAttribute.backgroundRadius, margin } = icon.attribute;
          const { backgroundWidth = width, backgroundHeight = height } = icon.attribute;
          if (margin) {
              x += icon._marginArray[3];
              y += icon._marginArray[0];
          }
          if (icon._hovered) {
              const expandX = (backgroundWidth - width) / 2;
              const expandY = (backgroundHeight - height) / 2;
              if (backgroundRadius === 0) {
                  context.beginPath();
                  context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight);
              }
              else {
                  context.beginPath();
                  createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius);
              }
              if (backgroundFill) {
                  context.globalAlpha = backgroundFillOpacity;
                  context.fillStyle = backgroundFill;
                  context.fill();
              }
              if (backgroundStroke) {
                  context.globalAlpha = backgroundStrokeOpacity;
                  context.strokeStyle = backgroundStroke;
                  context.stroke();
              }
          }
          const res = url && icon?.resources?.get(url);
          if (!res || res.state !== 'success') {
              return;
          }
          context.globalAlpha = opacity;
          context.drawImage(res.data, x, y, width, height);
      }
      draw(richtext, renderService, drawContext) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          const richtextAttribute = getTheme(richtext).richtext;
          let { x = richtextAttribute.x, y = richtextAttribute.y } = richtext.attribute;
          if (!richtext.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              context.transformFromMatrix(richtext.transMatrix, true);
          }
          else {
              const point = richtext.getOffsetXY(richtextAttribute);
              x += point.x;
              y += point.y;
              context.setTransformForCurrent();
          }
          this.drawShape(richtext, context, x, y, drawContext);
          context.highPerformanceRestore();
      }
  };
  DefaultCanvasRichTextRender = __decorate([
      injectable()
  ], DefaultCanvasRichTextRender);

  let DefaultCanvasGlyphRender = class DefaultCanvasGlyphRender {
      type;
      numberType = GLYPH_NUMBER_TYPE;
      drawShape(glyph, context, x, y, drawContext, params, fillCb, strokeCb) {
          if (!drawContext.drawContribution) {
              return;
          }
          glyph.getSubGraphic().forEach(item => {
              const renderer = drawContext.drawContribution.getRenderContribution(item);
              if (renderer && renderer.drawShape) {
                  renderer.drawShape(item, context, x, y, drawContext, params, fillCb, strokeCb);
              }
          });
      }
      draw(glyph, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          if (!drawContext.drawContribution) {
              return;
          }
          const glyphTheme = getTheme(glyph);
          const subGraphic = glyph.getSubGraphic();
          subGraphic.length &&
              subGraphic.forEach(g => {
                  drawContext.drawContribution.renderItem(g, drawContext, { theme: glyphTheme });
              });
          context.highPerformanceRestore();
      }
  };
  DefaultCanvasGlyphRender = __decorate([
      injectable()
  ], DefaultCanvasGlyphRender);

  function drawArcPath(arc, context, cx, cy, z, outerRadius, innerRadius) {
      const { startAngle, endAngle } = arc.getParsedAngle();
      const deltaAngle = abs(endAngle - startAngle);
      const clockwise = endAngle > startAngle;
      let collapsedToLine = false;
      if (outerRadius < innerRadius) {
          const temp = outerRadius;
          outerRadius = innerRadius;
          innerRadius = temp;
      }
      if (outerRadius <= epsilon) {
          context.moveTo(cx, cy, z);
      }
      else if (deltaAngle >= pi2 - epsilon) {
          context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z);
          context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z);
          if (innerRadius > epsilon) {
              context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z);
              context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z);
          }
      }
      else {
          const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
          const xors = outerRadius * cos(outerStartAngle);
          const yors = outerRadius * sin(outerStartAngle);
          const xire = innerRadius * cos(innerEndAngle);
          const yire = innerRadius * sin(innerEndAngle);
          if (outerDeltaAngle < 0.001) {
              collapsedToLine = true;
          }
          else {
              context.moveTo(cx + xors, cy + yors, z);
              context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z);
          }
          if (!(innerRadius > epsilon) || innerDeltaAngle < 0.001) {
              context.lineTo(cx + xire, cy + yire, z);
              collapsedToLine = true;
          }
          else {
              context.lineTo(cx + xire, cy + yire, z);
              context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z);
          }
      }
      context.closePath();
      return collapsedToLine;
  }
  function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
      const { startAngle, endAngle } = arc.getParsedAngle();
      const deltaAngle = abs(endAngle - startAngle);
      const clockwise = endAngle > startAngle;
      let collapsedToLine = false;
      if (radius <= epsilon) {
          context.moveTo(cx, cy, z1);
      }
      else if (deltaAngle >= pi2 - epsilon) {
          context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1);
          context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1);
          context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2);
          context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2);
      }
      else {
          const { innerouterDeltaAngle, innerouterStartAngle, innerouterEndAngle } = getParsePadAngle(startAngle, endAngle);
          const xors = radius * cos(innerouterStartAngle);
          const yors = radius * sin(innerouterStartAngle);
          const xore = radius * cos(innerouterEndAngle);
          const yore = radius * sin(innerouterEndAngle);
          if (innerouterDeltaAngle < 0.001) {
              collapsedToLine = true;
          }
          else {
              context.moveTo(cx + xors, cy + yors, z1);
              context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1);
              context.lineTo(cx + xore, cy + yore, z2);
              context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2);
          }
      }
      context.closePath();
      return collapsedToLine;
  }
  let DefaultCanvasArc3DRender = class DefaultCanvasArc3DRender extends BaseRender {
      type;
      numberType = ARC3D_NUMBER_TYPE;
      drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
          const arcAttribute = getTheme(arc, params?.theme).arc;
          const { fill = arcAttribute.fill, background, stroke = arcAttribute.stroke, opacity = arcAttribute.opacity, fillOpacity = arcAttribute.fillOpacity, lineWidth = arcAttribute.lineWidth, strokeOpacity = arcAttribute.strokeOpacity, visible = arcAttribute.visible } = arc.attribute;
          const fVisible = fillVisible(opacity, fillOpacity);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          const z = this.z ?? 0;
          if (!(arc.valid && visible)) {
              return;
          }
          if (!(doFill || doStroke || background)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
              return;
          }
          const { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius, height = 10 } = arc.attribute;
          const rgbArray = colorString.get(fill).value;
          const { light } = drawContext.stage || {};
          const face = drawContext.hack_pieFace;
          const z_face = {
              top: z,
              bottom: z + height
          };
          const n_face = {
              top: [0, 1, 0],
              bottom: [0, -1, 0],
              outside: [1, 0, -1],
              inside: [1, 0, -1]
          };
          if (face === 'bottom' || face === 'top') {
              context.beginPath();
              drawArcPath(arc, context, x, y, z_face[face], outerRadius, innerRadius);
              context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute);
              if (doFill) {
                  if (fillCb) {
                      fillCb(context, arc.attribute, arcAttribute);
                  }
                  else if (fVisible) {
                      context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute);
                      context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill;
                      context.fill();
                  }
              }
              if (doStroke) {
                  if (strokeCb) {
                      strokeCb(context, arc.attribute, arcAttribute);
                  }
                  else if (sVisible) {
                      context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);
                      context.stroke();
                  }
              }
          }
          else if (face === 'outside' || face === 'inside') {
              if (face === 'inside') {
                  context.save();
                  context.beginPath();
                  context.arc(x, y, innerRadius, 0, pi2, true, z_face.top);
                  context.clip();
              }
              context.beginPath();
              drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, face === 'outside' ? outerRadius : innerRadius, (startAngle, endAngle) => {
                  const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
                  if (face === 'outside') {
                      return {
                          innerouterDeltaAngle: outerDeltaAngle,
                          innerouterEndAngle: outerEndAngle,
                          innerouterStartAngle: outerStartAngle
                      };
                  }
                  return {
                      innerouterDeltaAngle: innerDeltaAngle,
                      innerouterEndAngle: innerEndAngle,
                      innerouterStartAngle: innerStartAngle
                  };
              });
              context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute);
              if (doFill) {
                  if (fillCb) {
                      fillCb(context, arc.attribute, arcAttribute);
                  }
                  else if (fVisible) {
                      context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute);
                      context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill;
                      context.fill();
                  }
              }
              if (doStroke) {
                  if (strokeCb) {
                      strokeCb(context, arc.attribute, arcAttribute);
                  }
                  else if (sVisible) {
                      context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);
                      context.stroke();
                  }
              }
              if (face === 'inside') {
                  context.restore();
              }
          }
      }
      draw(arc, renderService, drawContext, params) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          const arcAttribute = getTheme(arc, params?.theme).arc;
          context.save();
          const data = this.transform(arc, arcAttribute, context);
          const { x, y, z, lastModelMatrix } = data;
          this.z = z;
          if (drawPathProxy(arc, context, x, y, drawContext, params)) {
              context.restore();
              return;
          }
          this.drawShape(arc, context, x, y, drawContext, params);
          this.z = 0;
          if (context.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(context.modelMatrix);
          }
          context.modelMatrix = lastModelMatrix;
          context.restore();
      }
  };
  DefaultCanvasArc3DRender = __decorate([
      injectable()
  ], DefaultCanvasArc3DRender);

  let DefaultCanvasPyramid3dRender = class DefaultCanvasPyramid3dRender extends BaseRender {
      type = 'pyramid3d';
      numberType = PYRAMID3D_NUMBER_TYPE;
      drawShape(pyramid3d, context, x, y, drawContext, params, fillCb, strokeCb) {
          const pyramidAttribute = getTheme(pyramid3d, params?.theme).polygon;
          const { fill = pyramidAttribute.fill, stroke = pyramidAttribute.stroke, opacity = pyramidAttribute.opacity, fillOpacity = pyramidAttribute.fillOpacity, lineWidth = pyramidAttribute.lineWidth, strokeOpacity = pyramidAttribute.strokeOpacity, visible = pyramidAttribute.visible, points, face = [true, true, true, true, true, true] } = pyramid3d.attribute;
          const z = this.z ?? 0;
          const fVisible = fillVisible(opacity, fillOpacity);
          const sVisible = strokeVisible(opacity, strokeOpacity);
          const doFill = runFill(fill);
          const doStroke = runStroke(stroke, lineWidth);
          if (!(pyramid3d.valid && visible && points.length === 4)) {
              return;
          }
          if (!(doFill || doStroke)) {
              return;
          }
          if (!(fVisible || sVisible || fillCb || strokeCb)) {
              return;
          }
          const { light, camera } = drawContext.stage || {};
          const face3d = pyramid3d.findFace();
          if (fill !== false) {
              context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
              let fc = fill;
              if (typeof fc !== 'string') {
                  fc = 'black';
              }
              this.fill(x, y, z, face3d, face, fc, context, light, camera, pyramid3d, pyramidAttribute, fillCb);
          }
          if (stroke !== false) {
              context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
              this.stroke(x, y, z, face3d, context);
          }
      }
      stroke(x, y, z, face3d, context) {
          const vertices = face3d.vertices;
          face3d.edges.forEach(p => {
              const p1 = vertices[p[0]];
              const p2 = vertices[p[1]];
              const v1 = {
                  x: x + p1[0],
                  y: y + p1[1],
                  z: z + p1[2]
              };
              const v2 = {
                  x: x + p2[0],
                  y: y + p2[1],
                  z: z + p2[2]
              };
              context.beginPath();
              context.moveTo(v1.x, v1.y, v1.z);
              context.lineTo(v2.x, v2.y, v2.z);
              context.stroke();
          });
      }
      fill(x, y, z, face3d, faces, fillColor, context, light, camera, pyramid3d, pyramid3dAttribute, fillCb) {
          const rgbArray = colorString.get(fillColor).value;
          const vertices = face3d.vertices;
          const viewdVerticesZ = vertices.map(v => {
              return context.view(v[0], v[1], v[2])[2];
          });
          const sortFace = [];
          face3d.polygons.forEach((p, i) => {
              if (!faces[i]) {
                  return;
              }
              sortFace.push({
                  faceIdx: i,
                  polygon: p
              });
              const { polygon, normal } = p;
              const z1 = viewdVerticesZ[polygon[0]];
              const z2 = viewdVerticesZ[polygon[1]];
              const z3 = viewdVerticesZ[polygon[2]];
              const z4 = viewdVerticesZ[polygon[3]];
              p.ave_z = z1 + z2 + z3 + z4;
          });
          sortFace.sort((a, b) => b.polygon.ave_z - a.polygon.ave_z);
          sortFace.forEach(item => {
              const { polygon, normal } = item.polygon;
              const p1 = vertices[polygon[0]];
              const p2 = vertices[polygon[1]];
              const p3 = vertices[polygon[2]];
              const p4 = vertices[polygon[3]];
              const v1 = {
                  x: x + p1[0],
                  y: y + p1[1],
                  z: z + p1[2]
              };
              const v2 = {
                  x: x + p2[0],
                  y: y + p2[1],
                  z: z + p2[2]
              };
              const v3 = {
                  x: x + p3[0],
                  y: y + p3[1],
                  z: z + p3[2]
              };
              const v4 = {
                  x: x + p4[0],
                  y: y + p4[1],
                  z: z + p4[2]
              };
              context.beginPath();
              context.moveTo(v1.x, v1.y, v1.z);
              context.lineTo(v2.x, v2.y, v2.z);
              context.lineTo(v3.x, v3.y, v3.z);
              context.lineTo(v4.x, v4.y, v4.z);
              context.closePath();
              if (fillCb) {
                  fillCb(context, pyramid3d.attribute, pyramid3dAttribute);
              }
              else {
                  context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor;
                  context.fill();
              }
          });
      }
      draw(pyramid3d, renderService, drawContext) {
          const { context } = drawContext;
          if (!context) {
              return;
          }
          context.highPerformanceSave();
          const pyramid3dAttribute = getTheme(pyramid3d).polygon;
          const data = this.transform(pyramid3d, pyramid3dAttribute, context);
          const { x, y, z, lastModelMatrix } = data;
          this.z = z;
          this.drawShape(pyramid3d, context, x, y, drawContext);
          this.z = 0;
          if (context.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(context.modelMatrix);
          }
          context.modelMatrix = lastModelMatrix;
          context.highPerformanceRestore();
      }
  };
  DefaultCanvasPyramid3dRender = __decorate([
      injectable()
  ], DefaultCanvasPyramid3dRender);

  var renderModule = new ContainerModule(bind => {
      bind(DefaultDrawContribution).toSelf();
      bind(DrawContribution).toService(DefaultDrawContribution);
      bind(DefaultIncrementalDrawContribution).toSelf();
      bind(IncrementalDrawContribution).toService(DefaultIncrementalDrawContribution);
      bind(DefaultRenderSelector).toSelf();
      bind(RenderSelector).toService(DefaultRenderSelector);
      bind(exports.DefaultCanvasCircleRender).toSelf().inSingletonScope();
      bind(CircleRender).to(exports.DefaultCanvasCircleRender);
      bind(GraphicRender).to(exports.DefaultCanvasCircleRender);
      bind(exports.DefaultCircleRenderContribution).toSelf().inSingletonScope();
      bind(exports.DefaultCircleBackgroundRenderContribution).toSelf().inSingletonScope();
      bind(exports.DefaultCircleTextureRenderContribution).toSelf().inSingletonScope();
      bind(CircleRenderContribution).toService(exports.DefaultCircleRenderContribution);
      bind(CircleRenderContribution).toService(exports.DefaultCircleBackgroundRenderContribution);
      bind(CircleRenderContribution).toService(exports.DefaultCircleTextureRenderContribution);
      bindContributionProvider(bind, CircleRenderContribution);
      bind(exports.DefaultCanvasRectRender).toSelf().inSingletonScope();
      bind(RectRender).to(exports.DefaultCanvasRectRender);
      bind(GraphicRender).to(exports.DefaultCanvasRectRender);
      bind(DefaultCanvasRect3dRender).toSelf().inSingletonScope();
      bind(Rect3DRender).toService(DefaultCanvasRect3dRender);
      bind(GraphicRender).toService(Rect3DRender);
      bind(exports.DefaultRectRenderContribution).toSelf().inSingletonScope();
      bind(exports.DefaultRectBackgroundRenderContribution).toSelf().inSingletonScope();
      bind(exports.DefaultRectTextureRenderContribution).toSelf().inSingletonScope();
      bind(exports.SplitRectBeforeRenderContribution).toSelf().inSingletonScope();
      bind(exports.SplitRectAfterRenderContribution).toSelf().inSingletonScope();
      bind(RectRenderContribution).toService(exports.DefaultRectRenderContribution);
      bind(RectRenderContribution).toService(exports.DefaultRectBackgroundRenderContribution);
      bind(RectRenderContribution).toService(exports.DefaultRectTextureRenderContribution);
      bind(RectRenderContribution).toService(exports.SplitRectBeforeRenderContribution);
      bind(RectRenderContribution).toService(exports.SplitRectAfterRenderContribution);
      bindContributionProvider(bind, RectRenderContribution);
      bind(exports.DefaultCanvasTextRender).toSelf().inSingletonScope();
      bind(TextRender).to(exports.DefaultCanvasTextRender);
      bind(GraphicRender).to(exports.DefaultCanvasTextRender);
      bind(exports.DefaultCanvasPathRender).toSelf().inSingletonScope();
      bind(PathRender).to(exports.DefaultCanvasPathRender);
      bind(GraphicRender).to(exports.DefaultCanvasPathRender);
      bind(DefaultPathBackgroundRenderContribution).toSelf().inSingletonScope();
      bind(DefaultPathTextureRenderContribution).toSelf().inSingletonScope();
      bind(PathRenderContribution).toService(DefaultPathBackgroundRenderContribution);
      bind(PathRenderContribution).toService(DefaultPathTextureRenderContribution);
      bindContributionProvider(bind, PathRenderContribution);
      bind(exports.DefaultCanvasSymbolRender).toSelf().inSingletonScope();
      bind(SymbolRender).to(exports.DefaultCanvasSymbolRender);
      bind(GraphicRender).to(exports.DefaultCanvasSymbolRender);
      bind(exports.DefaultSymbolRenderContribution).toSelf().inSingletonScope();
      bind(DefaultSymbolBackgroundRenderContribution).toSelf().inSingletonScope();
      bind(DefaultSymbolTextureRenderContribution).toSelf().inSingletonScope();
      bind(SymbolRenderContribution).toService(exports.DefaultSymbolRenderContribution);
      bind(SymbolRenderContribution).toService(DefaultSymbolBackgroundRenderContribution);
      bind(SymbolRenderContribution).toService(DefaultSymbolTextureRenderContribution);
      bindContributionProvider(bind, SymbolRenderContribution);
      bind(exports.DefaultCanvasArcRender).toSelf().inSingletonScope();
      bind(ArcRender).to(exports.DefaultCanvasArcRender);
      bind(GraphicRender).to(exports.DefaultCanvasArcRender);
      bind(DefaultCanvasArc3DRender).toSelf().inSingletonScope();
      bind(Arc3dRender).toService(DefaultCanvasArc3DRender);
      bind(GraphicRender).toService(Arc3dRender);
      bind(exports.DefaultArcRenderContribution).toSelf().inSingletonScope();
      bind(exports.DefaultArcBackgroundRenderContribution).toSelf().inSingletonScope();
      bind(exports.DefaultArcTextureRenderContribution).toSelf().inSingletonScope();
      bind(ArcRenderContribution).toService(exports.DefaultArcRenderContribution);
      bind(ArcRenderContribution).toService(exports.DefaultArcBackgroundRenderContribution);
      bind(ArcRenderContribution).toService(exports.DefaultArcTextureRenderContribution);
      bindContributionProvider(bind, ArcRenderContribution);
      bind(exports.DefaultCanvasLineRender).toSelf().inSingletonScope();
      bind(LineRender).to(exports.DefaultCanvasLineRender);
      bind(GraphicRender).to(exports.DefaultCanvasLineRender);
      bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope();
      bind(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope();
      bind(exports.DefaultCanvasAreaRender).toSelf().inSingletonScope();
      bind(AreaRender).to(exports.DefaultCanvasAreaRender);
      bind(GraphicRender).to(exports.DefaultCanvasAreaRender);
      bind(DefaultAreaBackgroundRenderContribution).toSelf().inSingletonScope();
      bind(DefaultAreaTextureRenderContribution).toSelf().inSingletonScope();
      bind(AreaRenderContribution).toService(DefaultAreaBackgroundRenderContribution);
      bind(AreaRenderContribution).toService(DefaultAreaTextureRenderContribution);
      bindContributionProvider(bind, AreaRenderContribution);
      bind(DefaultCanvasGroupRender).toSelf().inSingletonScope();
      bind(GroupRender).to(DefaultCanvasGroupRender);
      bind(GraphicRender).to(DefaultCanvasGroupRender);
      bind(exports.DefaultGroupBackgroundRenderContribution).toSelf().inSingletonScope();
      bind(GroupRenderContribution).toService(exports.DefaultGroupBackgroundRenderContribution);
      bindContributionProvider(bind, GroupRenderContribution);
      bind(exports.DefaultCanvasPolygonRender).toSelf().inSingletonScope();
      bind(PolygonRender).to(exports.DefaultCanvasPolygonRender);
      bind(GraphicRender).to(exports.DefaultCanvasPolygonRender);
      bind(DefaultPolygonBackgroundRenderContribution).toSelf().inSingletonScope();
      bind(DefaultPolygonTextureRenderContribution).toSelf().inSingletonScope();
      bind(PolygonRenderContribution).toService(DefaultPolygonBackgroundRenderContribution);
      bind(PolygonRenderContribution).toService(DefaultPolygonTextureRenderContribution);
      bindContributionProvider(bind, PolygonRenderContribution);
      bind(DefaultCanvasGlyphRender).toSelf().inSingletonScope();
      bind(GlyphRender).toService(DefaultCanvasGlyphRender);
      bind(GraphicRender).toService(GlyphRender);
      bind(exports.DefaultCanvasImageRender).toSelf().inSingletonScope();
      bind(ImageRender).toService(exports.DefaultCanvasImageRender);
      bind(GraphicRender).toService(ImageRender);
      bind(exports.DefaultImageBackgroundRenderContribution).toSelf().inSingletonScope();
      bind(ImageRenderContribution).toService(exports.DefaultImageBackgroundRenderContribution);
      bindContributionProvider(bind, ImageRenderContribution);
      bind(DefaultCanvasRichTextRender).toSelf().inSingletonScope();
      bind(RichTextRender).toService(DefaultCanvasRichTextRender);
      bind(GraphicRender).toService(RichTextRender);
      bind(DefaultCanvasPyramid3dRender).toSelf().inSingletonScope();
      bind(Pyramid3dRender).toService(DefaultCanvasPyramid3dRender);
      bind(GraphicRender).toService(Pyramid3dRender);
      bindContributionProvider(bind, GraphicRender);
      bind(ShadowRootDrawItemInterceptorContribution).toSelf().inSingletonScope();
      bind(DrawItemInterceptor).toService(ShadowRootDrawItemInterceptorContribution);
      bind(Canvas3DDrawItemInterceptor).toSelf().inSingletonScope();
      bind(DrawItemInterceptor).toService(Canvas3DDrawItemInterceptor);
      bindContributionProvider(bind, DrawItemInterceptor);
  });

  function load$2(container) {
      container.load(renderModule);
  }

  let DefaultCanvasCirclePicker = class DefaultCanvasCirclePicker {
      canvasRenderer;
      type = 'circle';
      numberType = CIRCLE_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(circle, point, params) {
          if (!circle.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (circle.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const circleAttribute = getTheme(circle).circle;
          let { x = circleAttribute.x, y = circleAttribute.y } = circle.attribute;
          pickContext.highPerformanceSave();
          if (!circle.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(circle.transMatrix, true);
          }
          else {
              const point = circle.getOffsetXY(circleAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(circle, pickContext, x, y, {}, null, (context, circleAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          }, (context, circleAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = getScaledStroke(pickContext, lineWidth, pickContext.dpr);
              picked = context.isPointInStroke(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasCirclePicker = __decorate([
      injectable(),
      __param(0, inject(CircleRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasCirclePicker);

  const _bounds$1 = new AABBBounds();
  let DefaultCanvasRectPicker = class DefaultCanvasRectPicker {
      canvasRenderer;
      type = 'rect';
      numberType = RECT_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(rect, point, params) {
          if (!rect.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (rect.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const rectAttribute = getTheme(rect).rect;
          const { cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
          let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;
          pickContext.highPerformanceSave();
          let onlyTranslate = true;
          if (!rect.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              onlyTranslate = false;
              pickContext.transformFromMatrix(rect.transMatrix, true);
          }
          else {
              const point = rect.getOffsetXY(rectAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = true;
          if (!onlyTranslate ||
              (isNumber(cornerRadius, true) && cornerRadius !== 0) ||
              (isArray(cornerRadius) && cornerRadius.some(num => num !== 0))) {
              picked = false;
              this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute, themeAttribute) => {
                  if (picked) {
                      return true;
                  }
                  picked = context.isPointInPath(point.x, point.y);
                  return picked;
              }, (context, rectAttribute, themeAttribute) => {
                  if (picked) {
                      return true;
                  }
                  const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth;
                  pickContext.lineWidth = getScaledStroke(pickContext, lineWidth, pickContext.dpr);
                  picked = context.isPointInStroke(point.x, point.y);
                  return picked;
              });
          }
          else if (picked) {
              const { fill = rectAttribute.fill, stroke = rectAttribute.stroke, lineWidth = rectAttribute.lineWidth } = rect.attribute;
              if (fill) {
                  picked = true;
              }
              else if (stroke) {
                  const bounds = rect.AABBBounds;
                  _bounds$1.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2);
                  _bounds$1.expand(-lineWidth / 2);
                  picked = !_bounds$1.containsPoint(point);
              }
          }
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasRectPicker = __decorate([
      injectable(),
      __param(0, inject(RectRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasRectPicker);

  let DefaultCanvasArcPicker = class DefaultCanvasArcPicker {
      canvasRenderer;
      type = 'arc';
      numberType = ARC_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(arc, point, params) {
          if (!arc.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (arc.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const arcAttribute = getTheme(arc).arc;
          pickContext.highPerformanceSave();
          let { x = arcAttribute.x, y = arcAttribute.y } = arc.attribute;
          if (!arc.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(arc.transMatrix, true);
          }
          else {
              const point = arc.getOffsetXY(arcAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, (context, arcAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          }, (context, arcAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = getScaledStroke(pickContext, lineWidth, pickContext.dpr);
              picked = context.isPointInStroke(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasArcPicker = __decorate([
      injectable(),
      __param(0, inject(ArcRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasArcPicker);

  let DefaultCanvasAreaPicker = class DefaultCanvasAreaPicker {
      canvasRenderer;
      type = 'area';
      numberType = AREA_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(area, point, params) {
          if (!area.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (area.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const areaAttribute = getTheme(area).area;
          let { x = areaAttribute.x, y = areaAttribute.y } = area.attribute;
          pickContext.highPerformanceSave();
          if (!area.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(area.transMatrix, true);
          }
          else {
              const point = area.getOffsetXY(areaAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(area, pickContext, x, y, {}, null, context => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasAreaPicker = __decorate([
      injectable(),
      __param(0, inject(AreaRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasAreaPicker);

  let DefaultCanvasImagePicker = class DefaultCanvasImagePicker {
      type = 'image';
      numberType = IMAGE_NUMBER_TYPE;
      contains(image, point, params) {
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          if (!image.AABBBounds.containsPoint(point)) {
              return false;
          }
          return true;
      }
  };
  DefaultCanvasImagePicker = __decorate([
      injectable()
  ], DefaultCanvasImagePicker);

  let BasePicker = class BasePicker extends BaseRender {
  };
  BasePicker = __decorate([
      injectable()
  ], BasePicker);

  let DefaultCanvasLinePicker = class DefaultCanvasLinePicker extends BasePicker {
      canvasRenderer;
      type = 'line';
      numberType = LINE_NUMBER_TYPE;
      constructor(canvasRenderer) {
          super();
          this.canvasRenderer = canvasRenderer;
      }
      contains(line, point, params) {
          if (!line.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (line.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          pickContext.highPerformanceSave();
          const lineAttribute = getTheme(line).line;
          const data = this.transform(line, lineAttribute, pickContext);
          const { x, y, z, lastModelMatrix } = data;
          let pickPoint = point;
          if (pickContext.camera) {
              pickPoint = point.clone();
              const globalMatrix = line.parent.globalTransMatrix;
              pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e;
              pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
          }
          this.canvasRenderer.z = z;
          let picked = false;
          this.canvasRenderer.drawShape(line, pickContext, x, y, {}, null, context => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(pickPoint.x, pickPoint.y);
              return picked;
          }, (context, circleAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = getScaledStroke(pickContext, lineWidth, pickContext.dpr);
              picked = context.isPointInStroke(pickPoint.x, pickPoint.y);
              return picked;
          });
          this.canvasRenderer.z = 0;
          if (pickContext.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(pickContext.modelMatrix);
          }
          pickContext.modelMatrix = lastModelMatrix;
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasLinePicker = __decorate([
      injectable(),
      __param(0, inject(LineRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasLinePicker);

  let DefaultCanvasPathPicker = class DefaultCanvasPathPicker extends BasePicker {
      canvasRenderer;
      type = 'path';
      numberType = PATH_NUMBER_TYPE;
      constructor(canvasRenderer) {
          super();
          this.canvasRenderer = canvasRenderer;
      }
      contains(path, point, params) {
          if (!path.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (path.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const pathAttribute = getTheme(path).path;
          pickContext.highPerformanceSave();
          const data = this.transform(path, pathAttribute, pickContext);
          const { x, y, z, lastModelMatrix } = data;
          let pickPoint = point;
          if (pickContext.camera) {
              pickPoint = point.clone();
              const globalMatrix = path.parent.globalTransMatrix;
              pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e;
              pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
          }
          this.canvasRenderer.z = z;
          let picked = false;
          this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, (context, pathAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(pickPoint.x, pickPoint.y);
              return picked;
          }, (context, pathAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = getScaledStroke(pickContext, lineWidth, pickContext.dpr);
              picked = context.isPointInStroke(pickPoint.x, pickPoint.y);
              return picked;
          });
          this.canvasRenderer.z = 0;
          if (pickContext.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(pickContext.modelMatrix);
          }
          pickContext.modelMatrix = lastModelMatrix;
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasPathPicker = __decorate([
      injectable(),
      __param(0, inject(PathRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasPathPicker);

  let DefaultCanvasSymbolPicker = class DefaultCanvasSymbolPicker extends BasePicker {
      canvasRenderer;
      type = 'symbol';
      numberType = SYMBOL_NUMBER_TYPE;
      constructor(canvasRenderer) {
          super();
          this.canvasRenderer = canvasRenderer;
      }
      contains(symbol, point, params) {
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          if (!pickContext.camera) {
              if (!symbol.AABBBounds.containsPoint(point)) {
                  return false;
              }
              if (symbol.attribute.pickMode === 'imprecise') {
                  return true;
              }
          }
          pickContext.highPerformanceSave();
          const symbolAttribute = getTheme(symbol).symbol;
          const data = this.transform(symbol, symbolAttribute, pickContext);
          const { x, y, z, lastModelMatrix } = data;
          let pickPoint = point;
          if (pickContext.camera) {
              pickPoint = point.clone();
              const globalMatrix = symbol.parent.globalTransMatrix;
              pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e;
              pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
          }
          this.canvasRenderer.z = z;
          let picked = false;
          this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(pickPoint.x, pickPoint.y);
              return picked;
          }, (context, symbolAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = getScaledStroke(pickContext, lineWidth, pickContext.dpr);
              picked = context.isPointInStroke(pickPoint.x, pickPoint.y);
              return picked;
          });
          this.canvasRenderer.z = 0;
          if (pickContext.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(pickContext.modelMatrix);
          }
          pickContext.modelMatrix = lastModelMatrix;
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasSymbolPicker = __decorate([
      injectable(),
      __param(0, inject(SymbolRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasSymbolPicker);

  let DefaultCanvasTextPicker = class DefaultCanvasTextPicker extends BasePicker {
      canvasRenderer;
      type = 'text';
      numberType = TEXT_NUMBER_TYPE;
      constructor(canvasRenderer) {
          super();
          this.canvasRenderer = canvasRenderer;
      }
      contains(text, point, params) {
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const bounds = text.AABBBounds;
          if (!pickContext.camera) {
              if (!bounds.containsPoint(point)) {
                  return false;
              }
              return true;
          }
          pickContext.highPerformanceSave();
          const textAttribute = getTheme(text).text;
          const { keepDirIn3d = textAttribute.keepDirIn3d } = text.attribute;
          const computed3dMatrix = !keepDirIn3d;
          const data = this.transform(text, textAttribute, pickContext, computed3dMatrix);
          const { x, y, z, lastModelMatrix } = data;
          this.canvasRenderer.z = z;
          let pickPoint = point;
          if (pickContext.camera) {
              pickPoint = point.clone();
              const globalMatrix = text.parent.globalTransMatrix;
              pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e;
              pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
          }
          let picked = false;
          this.canvasRenderer.drawShape(text, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const { fontSize = textAttribute.fontSize, textBaseline = textAttribute.textBaseline, textAlign = textAttribute.textAlign } = text.attribute;
              const bounds = text.AABBBounds;
              const height = bounds.height();
              const width = bounds.width();
              const offsetY = textLayoutOffsetY(textBaseline, height, fontSize);
              const offsetX = textDrawOffsetX(textAlign, width);
              context.rect(offsetX + x, offsetY + y, width, height, z);
              picked = context.isPointInPath(pickPoint.x, pickPoint.y);
              return picked;
          }, (context, symbolAttribute, themeAttribute) => {
              return picked;
          });
          this.canvasRenderer.z = 0;
          if (pickContext.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(pickContext.modelMatrix);
          }
          pickContext.modelMatrix = lastModelMatrix;
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasTextPicker = __decorate([
      injectable(),
      __param(0, inject(TextRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasTextPicker);

  let DefaultCanvasPolygonPicker = class DefaultCanvasPolygonPicker {
      canvasRenderer;
      type = 'polygon';
      numberType = POLYGON_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(polygon, point, params) {
          if (!polygon.AABBBounds.contains(point.x, point.y)) {
              return false;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const polygonAttribute = getTheme(polygon).polygon;
          let { x = polygonAttribute.x, y = polygonAttribute.y } = polygon.attribute;
          pickContext.highPerformanceSave();
          if (!polygon.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(polygon.transMatrix, true);
          }
          else {
              const point = polygon.getOffsetXY(polygonAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, (context, pathAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          }, (context, pathAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = lineWidth;
              picked = context.isPointInStroke(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasPolygonPicker = __decorate([
      injectable(),
      __param(0, inject(PolygonRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasPolygonPicker);

  new AABBBounds();
  let DefaultCanvasRichTextPicker = class DefaultCanvasRichTextPicker {
      canvasRenderer;
      type = 'richtext';
      numberType = RICHTEXT_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(richtext, point, params) {
          if (richtext.AABBBounds.containsPoint(point)) {
              return true;
          }
          return false;
      }
  };
  DefaultCanvasRichTextPicker = __decorate([
      injectable(),
      __param(0, inject(RichTextRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasRichTextPicker);

  let DefaultCanvasGlyphPicker = class DefaultCanvasGlyphPicker {
      canvasRenderer;
      type = 'glyph';
      numberType = GLYPH_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(glyph, point, params) {
          if (!glyph.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (glyph.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const pickerService = params?.pickerService;
          if (pickerService) {
              let picked = false;
              glyph.getSubGraphic().forEach(g => {
                  if (picked) {
                      return;
                  }
                  picked = !!pickerService.pickItem(g, point, params);
              });
              return picked;
          }
          return false;
      }
  };
  DefaultCanvasGlyphPicker = __decorate([
      injectable(),
      __param(0, inject(GlyphRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasGlyphPicker);

  new AABBBounds();
  let DefaultCanvasRect3dPicker = class DefaultCanvasRect3dPicker extends BasePicker {
      canvasRenderer;
      type = 'rect3d';
      numberType = RECT3D_NUMBER_TYPE;
      constructor(canvasRenderer) {
          super();
          this.canvasRenderer = canvasRenderer;
      }
      contains(rect, point, params) {
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const rectAttribute = getTheme(rect).rect;
          pickContext.highPerformanceSave();
          const data = this.transform(rect, rectAttribute, pickContext);
          const { x, y, z, lastModelMatrix } = data;
          let pickPoint = point;
          if (pickContext.camera) {
              pickPoint = point.clone();
              const globalMatrix = rect.parent.globalTransMatrix;
              pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e;
              pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
          }
          this.canvasRenderer.z = z;
          let picked = false;
          this.canvasRenderer.drawShape(rect, pickContext, x, y, params, null, (context, arc3dAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(pickPoint.x, pickPoint.y);
              return picked;
          });
          this.canvasRenderer.z = 0;
          if (pickContext.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(pickContext.modelMatrix);
          }
          pickContext.modelMatrix = lastModelMatrix;
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasRect3dPicker = __decorate([
      injectable(),
      __param(0, inject(Rect3DRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasRect3dPicker);

  new AABBBounds();
  let DefaultCanvasPyramid3dPicker = class DefaultCanvasPyramid3dPicker extends BasePicker {
      canvasRenderer;
      type = 'pyramid3d';
      numberType = PYRAMID3D_NUMBER_TYPE;
      constructor(canvasRenderer) {
          super();
          this.canvasRenderer = canvasRenderer;
      }
      contains(pyramid3d, point, params) {
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const pyramid3dAttribute = getTheme(pyramid3d).polygon;
          pickContext.highPerformanceSave();
          const data = this.transform(pyramid3d, pyramid3dAttribute, pickContext);
          const { x, y, z, lastModelMatrix } = data;
          let pickPoint = point;
          if (pickContext.camera) {
              pickPoint = point.clone();
              const globalMatrix = pyramid3d.parent.globalTransMatrix;
              pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e;
              pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
          }
          this.canvasRenderer.z = z;
          let picked = false;
          this.canvasRenderer.drawShape(pyramid3d, pickContext, x, y, {}, null, (context, pyramid3dAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(pickPoint.x, pickPoint.y);
              return picked;
          }, (context, pyramid3dAttribute, themeAttribute) => {
              return false;
          });
          this.canvasRenderer.z = 0;
          if (pickContext.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(pickContext.modelMatrix);
          }
          pickContext.modelMatrix = lastModelMatrix;
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasPyramid3dPicker = __decorate([
      injectable(),
      __param(0, inject(Pyramid3dRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasPyramid3dPicker);

  new AABBBounds();
  let DefaultCanvasArc3dPicker = class DefaultCanvasArc3dPicker extends BasePicker {
      canvasRenderer;
      type = 'arc3d';
      numberType = ARC3D_NUMBER_TYPE;
      constructor(canvasRenderer) {
          super();
          this.canvasRenderer = canvasRenderer;
      }
      contains(arc3d, point, params) {
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const arc3dAttribute = getTheme(arc3d).arc;
          pickContext.highPerformanceSave();
          const data = this.transform(arc3d, arc3dAttribute, pickContext);
          const { x, y, z, lastModelMatrix } = data;
          let pickPoint = point;
          if (pickContext.camera) {
              pickPoint = point.clone();
              const globalMatrix = arc3d.parent.globalTransMatrix;
              pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e;
              pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
          }
          this.canvasRenderer.z = z;
          let picked = false;
          this.canvasRenderer.drawShape(arc3d, pickContext, x, y, params, null, (context, arc3dAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(pickPoint.x, pickPoint.y);
              return picked;
          });
          this.canvasRenderer.z = 0;
          if (pickContext.modelMatrix !== lastModelMatrix) {
              mat4Allocate.free(pickContext.modelMatrix);
          }
          pickContext.modelMatrix = lastModelMatrix;
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultCanvasArc3dPicker = __decorate([
      injectable(),
      __param(0, inject(Arc3dRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultCanvasArc3dPicker);

  var canvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      bind(DefaultCanvasCirclePicker).toSelf().inSingletonScope();
      bind(CanvasCirclePicker).toService(DefaultCanvasCirclePicker);
      bind(CanvasPickerContribution).toService(CanvasCirclePicker);
      bind(DefaultCanvasRectPicker).toSelf().inSingletonScope();
      bind(CanvasRectPicker).toService(DefaultCanvasRectPicker);
      bind(CanvasPickerContribution).toService(CanvasRectPicker);
      bind(DefaultCanvasRect3dPicker).toSelf().inSingletonScope();
      bind(CanvasRect3dPicker).toService(DefaultCanvasRect3dPicker);
      bind(CanvasPickerContribution).toService(CanvasRect3dPicker);
      bind(DefaultCanvasArcPicker).toSelf().inSingletonScope();
      bind(CanvasArcPicker).toService(DefaultCanvasArcPicker);
      bind(CanvasPickerContribution).toService(CanvasArcPicker);
      bind(DefaultCanvasAreaPicker).toSelf().inSingletonScope();
      bind(CanvasAreaPicker).toService(DefaultCanvasAreaPicker);
      bind(CanvasPickerContribution).toService(CanvasAreaPicker);
      bind(DefaultCanvasImagePicker).toSelf().inSingletonScope();
      bind(CanvasImagePicker).toService(DefaultCanvasImagePicker);
      bind(CanvasPickerContribution).toService(CanvasImagePicker);
      bind(DefaultCanvasLinePicker).toSelf().inSingletonScope();
      bind(CanvasLinePicker).toService(DefaultCanvasLinePicker);
      bind(CanvasPickerContribution).toService(CanvasLinePicker);
      bind(DefaultCanvasPathPicker).toSelf().inSingletonScope();
      bind(CanvasPathPicker).toService(DefaultCanvasPathPicker);
      bind(CanvasPickerContribution).toService(CanvasPathPicker);
      bind(DefaultCanvasSymbolPicker).toSelf().inSingletonScope();
      bind(CanvasSymbolPicker).toService(DefaultCanvasSymbolPicker);
      bind(CanvasPickerContribution).toService(CanvasSymbolPicker);
      bind(DefaultCanvasTextPicker).toSelf().inSingletonScope();
      bind(CanvasTextPicker).toService(DefaultCanvasTextPicker);
      bind(CanvasPickerContribution).toService(CanvasTextPicker);
      bind(DefaultCanvasPolygonPicker).toSelf().inSingletonScope();
      bind(CanvasPolygonPicker).toService(DefaultCanvasPolygonPicker);
      bind(CanvasPickerContribution).toService(CanvasPolygonPicker);
      bind(DefaultCanvasPyramid3dPicker).toSelf().inSingletonScope();
      bind(CanvasPyramid3dPicker).toService(DefaultCanvasPyramid3dPicker);
      bind(CanvasPickerContribution).toService(CanvasPyramid3dPicker);
      bind(DefaultCanvasArc3dPicker).toSelf().inSingletonScope();
      bind(CanvasArc3dPicker).toService(DefaultCanvasArc3dPicker);
      bind(CanvasPickerContribution).toService(CanvasArc3dPicker);
      bind(DefaultCanvasRichTextPicker).toSelf().inSingletonScope();
      bind(CanvasRichTextPicker).toService(DefaultCanvasRichTextPicker);
      bind(CanvasPickerContribution).toService(CanvasRichTextPicker);
      bind(DefaultCanvasGlyphPicker).toSelf().inSingletonScope();
      bind(CanvasGlyphPicker).toService(DefaultCanvasGlyphPicker);
      bind(CanvasPickerContribution).toService(CanvasGlyphPicker);
      bindContributionProvider(bind, CanvasPickerContribution);
  });

  let DefaultMathPathPicker = class DefaultMathPathPicker {
      canvasRenderer;
      type = 'path';
      numberType = PATH_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(path, point, params) {
          if (!path.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (path.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const pathAttribute = getTheme(path).path;
          let { x = pathAttribute.x, y = pathAttribute.y } = path.attribute;
          pickContext.highPerformanceSave();
          if (!path.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(path.transMatrix, true);
          }
          else {
              const point = path.getOffsetXY(pathAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, (context, pathAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          }, (context, pathAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = lineWidth;
              picked = context.isPointInStroke(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultMathPathPicker = __decorate([
      injectable(),
      __param(0, inject(PathRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultMathPathPicker);

  let DefaultMathCirclePicker = class DefaultMathCirclePicker {
      canvasRenderer;
      type = 'circle';
      numberType = CIRCLE_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(circle, point, params) {
          if (!circle.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (circle.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const circleAttribute = getTheme(circle).circle;
          let { x = circleAttribute.x, y = circleAttribute.y } = circle.attribute;
          pickContext.highPerformanceSave();
          if (!circle.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(circle.transMatrix, true);
          }
          else {
              const point = circle.getOffsetXY(circleAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(circle, pickContext, x, y, {}, null, (context, circleAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          }, (context, circleAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = lineWidth;
              picked = context.isPointInStroke(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultMathCirclePicker = __decorate([
      injectable(),
      __param(0, inject(CircleRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultMathCirclePicker);

  const _bounds = new AABBBounds();
  let DefaultMathRectPicker = class DefaultMathRectPicker {
      canvasRenderer;
      type = 'rect';
      numberType = RECT_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(rect, point, params) {
          if (!rect.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (rect.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const rectAttribute = getTheme(rect).rect;
          const { cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
          let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;
          pickContext.highPerformanceSave();
          let onlyTranslate = true;
          if (!rect.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              onlyTranslate = false;
              pickContext.transformFromMatrix(rect.transMatrix, true);
          }
          else {
              const point = rect.getOffsetXY(rectAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = true;
          if (!onlyTranslate ||
              (isNumber(cornerRadius, true) && cornerRadius !== 0) ||
              (isArray(cornerRadius) && cornerRadius.some(num => num !== 0))) {
              picked = false;
              this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute, themeAttribute) => {
                  if (picked) {
                      return true;
                  }
                  picked = context.isPointInPath(point.x, point.y);
                  return picked;
              }, (context, rectAttribute, themeAttribute) => {
                  if (picked) {
                      return true;
                  }
                  const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth;
                  pickContext.lineWidth = lineWidth;
                  picked = context.isPointInStroke(point.x, point.y);
                  return picked;
              });
          }
          else if (picked) {
              const { fill = rectAttribute.fill, stroke = rectAttribute.stroke, lineWidth = rectAttribute.lineWidth } = rect.attribute;
              if (fill) {
                  picked = true;
              }
              else if (stroke) {
                  const bounds = rect.AABBBounds;
                  _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2);
                  _bounds.expand(-lineWidth / 2);
                  picked = !_bounds.containsPoint(point);
              }
          }
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultMathRectPicker = __decorate([
      injectable(),
      __param(0, inject(RectRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultMathRectPicker);

  let DefaultMathArcPicker = class DefaultMathArcPicker {
      canvasRenderer;
      type = 'arc';
      numberType = ARC_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(arc, point, params) {
          if (!arc.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (arc.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const arcAttribute = getTheme(arc).arc;
          pickContext.highPerformanceSave();
          let { x = arcAttribute.x, y = arcAttribute.y } = arc.attribute;
          if (!arc.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(arc.transMatrix, true);
          }
          else {
              const point = arc.getOffsetXY(arcAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, (context, arcAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          }, (context, arcAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = lineWidth;
              picked = context.isPointInStroke(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultMathArcPicker = __decorate([
      injectable(),
      __param(0, inject(ArcRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultMathArcPicker);

  let DefaultMathAreaPicker = class DefaultMathAreaPicker {
      canvasRenderer;
      type = 'area';
      numberType = AREA_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(area, point, params) {
          if (!area.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (area.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const areaAttribute = getTheme(area).area;
          let { x = areaAttribute.x, y = areaAttribute.y } = area.attribute;
          pickContext.highPerformanceSave();
          if (!area.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(area.transMatrix, true);
          }
          else {
              const point = area.getOffsetXY(areaAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(area, pickContext, x, y, {}, null, context => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultMathAreaPicker = __decorate([
      injectable(),
      __param(0, inject(AreaRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultMathAreaPicker);

  let DefaultMathLinePicker = class DefaultMathLinePicker {
      canvasRenderer;
      type = 'line';
      numberType = LINE_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(line, point, params) {
          if (!line.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (line.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const lineAttribute = getTheme(line).line;
          let { x = lineAttribute.x, y = lineAttribute.y } = line.attribute;
          pickContext.highPerformanceSave();
          if (!line.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(line.transMatrix, true);
          }
          else {
              const point = line.getOffsetXY(lineAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(line, pickContext, x, y, {}, null, context => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          }, (context, circleAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = lineWidth;
              picked = context.isPointInStroke(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultMathLinePicker = __decorate([
      injectable(),
      __param(0, inject(LineRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultMathLinePicker);

  let DefaultMathSymbolPicker = class DefaultMathSymbolPicker {
      canvasRenderer;
      type = 'symbol';
      numberType = SYMBOL_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(symbol, point, params) {
          if (!symbol.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (symbol.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const symbolAttribute = getTheme(symbol).symbol;
          let { x = symbolAttribute.x, y = symbolAttribute.y } = symbol.attribute;
          pickContext.highPerformanceSave();
          if (!symbol.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(symbol.transMatrix, true);
          }
          else {
              const point = symbol.getOffsetXY(symbolAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          }, (context, symbolAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = lineWidth;
              picked = context.isPointInStroke(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultMathSymbolPicker = __decorate([
      injectable(),
      __param(0, inject(SymbolRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultMathSymbolPicker);

  let DefaultMathTextPicker = class DefaultMathTextPicker {
      type = 'text';
      numberType = TEXT_NUMBER_TYPE;
      contains(text, point, params) {
          if (!text.AABBBounds.containsPoint(point)) {
              return false;
          }
          return true;
      }
  };
  DefaultMathTextPicker = __decorate([
      injectable()
  ], DefaultMathTextPicker);

  let DefaultMathPolygonPicker = class DefaultMathPolygonPicker {
      canvasRenderer;
      type = 'polygon';
      numberType = POLYGON_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(polygon, point, params) {
          if (!polygon.AABBBounds.contains(point.x, point.y)) {
              return false;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const pathAttribute = getTheme(polygon).polygon;
          let { x = pathAttribute.x, y = pathAttribute.y } = polygon.attribute;
          pickContext.highPerformanceSave();
          if (!polygon.transMatrix.onlyTranslate()) {
              x = 0;
              y = 0;
              pickContext.transformFromMatrix(polygon.transMatrix, true);
          }
          else {
              const point = polygon.getOffsetXY(pathAttribute);
              x += point.x;
              y += point.y;
              pickContext.setTransformForCurrent();
          }
          let picked = false;
          this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, (context, pathAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              picked = context.isPointInPath(point.x, point.y);
              return picked;
          }, (context, pathAttribute, themeAttribute) => {
              if (picked) {
                  return true;
              }
              const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;
              pickContext.lineWidth = lineWidth;
              picked = context.isPointInStroke(point.x, point.y);
              return picked;
          });
          pickContext.highPerformanceRestore();
          return picked;
      }
  };
  DefaultMathPolygonPicker = __decorate([
      injectable(),
      __param(0, inject(PolygonRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultMathPolygonPicker);

  let DefaultMathGlyphPicker = class DefaultMathGlyphPicker {
      canvasRenderer;
      type = 'glyph';
      numberType = GLYPH_NUMBER_TYPE;
      constructor(canvasRenderer) {
          this.canvasRenderer = canvasRenderer;
      }
      contains(glyph, point, params) {
          if (!glyph.AABBBounds.containsPoint(point)) {
              return false;
          }
          if (glyph.attribute.pickMode === 'imprecise') {
              return true;
          }
          const { pickContext } = params ?? {};
          if (!pickContext) {
              return false;
          }
          const pickerService = params?.pickerService;
          if (pickerService) {
              let picked = false;
              glyph.getSubGraphic().forEach(g => {
                  if (picked) {
                      return;
                  }
                  picked = !!pickerService.pickItem(g, point, params);
              });
              return picked;
          }
          return false;
      }
  };
  DefaultMathGlyphPicker = __decorate([
      injectable(),
      __param(0, inject(GlyphRender)),
      __metadata("design:paramtypes", [Object])
  ], DefaultMathGlyphPicker);

  var mathPickModule = new ContainerModule(bind => {
      bind(DefaultMathCirclePicker).toSelf().inSingletonScope();
      bind(MathCirclePicker).toService(DefaultMathCirclePicker);
      bind(MathPickerContribution).toService(MathCirclePicker);
      bind(DefaultMathRectPicker).toSelf().inSingletonScope();
      bind(MathRectPicker).toService(DefaultMathRectPicker);
      bind(MathPickerContribution).toService(MathRectPicker);
      bind(DefaultMathArcPicker).toSelf().inSingletonScope();
      bind(MathArcPicker).toService(DefaultMathArcPicker);
      bind(MathPickerContribution).toService(MathArcPicker);
      bind(DefaultMathAreaPicker).toSelf().inSingletonScope();
      bind(MathAreaPicker).toService(DefaultMathAreaPicker);
      bind(MathPickerContribution).toService(MathAreaPicker);
      bind(DefaultMathLinePicker).toSelf().inSingletonScope();
      bind(MathLinePicker).toService(DefaultMathLinePicker);
      bind(MathPickerContribution).toService(MathLinePicker);
      bind(DefaultMathPathPicker).toSelf().inSingletonScope();
      bind(MathPathPicker).toService(DefaultMathPathPicker);
      bind(MathPickerContribution).toService(MathPathPicker);
      bind(DefaultMathSymbolPicker).toSelf().inSingletonScope();
      bind(MathSymbolPicker).toService(DefaultMathSymbolPicker);
      bind(MathPickerContribution).toService(MathSymbolPicker);
      bind(DefaultMathTextPicker).toSelf().inSingletonScope();
      bind(MathTextPicker).toService(DefaultMathTextPicker);
      bind(MathPickerContribution).toService(MathTextPicker);
      bind(DefaultMathPolygonPicker).toSelf().inSingletonScope();
      bind(MathPolygonPicker).toService(DefaultMathPolygonPicker);
      bind(MathPickerContribution).toService(MathPolygonPicker);
      bind(DefaultMathGlyphPicker).toSelf().inSingletonScope();
      bind(MathGlyphPicker).toService(DefaultMathGlyphPicker);
      bind(DefaultMathGlyphPicker).toService(MathGlyphPicker);
      bindContributionProvider(bind, MathPickerContribution);
  });

  function load$1(container) {
      container.load(canvasPickModule);
      container.load(mathPickModule);
  }

  var browserModule = new ContainerModule(bind => {
      bind(CanvasFactory)
          .toDynamicValue(() => {
          return (params) => new exports.BrowserCanvas(params);
      })
          .whenTargetNamed(exports.BrowserCanvas.env);
      bind(Context2dFactory)
          .toDynamicValue(() => {
          return (params, dpr) => new exports.BrowserContext2d(params, dpr);
      })
          .whenTargetNamed(exports.BrowserContext2d.env);
  });

  var taroModule = new ContainerModule(bind => {
      bind(CanvasFactory)
          .toDynamicValue(() => {
          return (params) => new TaroCanvas(params);
      })
          .whenTargetNamed(TaroCanvas.env);
      bind(Context2dFactory)
          .toDynamicValue(() => {
          return (params, dpr) => new TaroContext2d(params, dpr);
      })
          .whenTargetNamed(TaroContext2d.env);
  });

  var feishuModule = new ContainerModule(bind => {
      bind(CanvasFactory)
          .toDynamicValue(() => {
          return (params) => new FeishuCanvas(params);
      })
          .whenTargetNamed(FeishuCanvas.env);
      bind(Context2dFactory)
          .toDynamicValue(() => {
          return (params, dpr) => new FeishuContext2d(params, dpr);
      })
          .whenTargetNamed(FeishuContext2d.env);
  });

  var lynxModule = new ContainerModule(bind => {
      bind(CanvasFactory)
          .toDynamicValue(() => {
          return (params) => new LynxCanvas(params);
      })
          .whenTargetNamed(LynxCanvas.env);
      bind(Context2dFactory)
          .toDynamicValue(() => {
          return (params, dpr) => new LynxContext2d(params, dpr);
      })
          .whenTargetNamed(LynxContext2d.env);
  });

  var wxModule = new ContainerModule(bind => {
      bind(CanvasFactory)
          .toDynamicValue(() => {
          return (params) => new WxCanvas(params);
      })
          .whenTargetNamed(WxCanvas.env);
      bind(Context2dFactory)
          .toDynamicValue(() => {
          return (params, dpr) => new WxContext2d(params, dpr);
      })
          .whenTargetNamed(WxContext2d.env);
  });

  var nodeModule = new ContainerModule(bind => {
      bind(CanvasFactory)
          .toDynamicValue(() => {
          return (params) => new NodeCanvas(params);
      })
          .whenTargetNamed(NodeCanvas.env);
      bind(Context2dFactory)
          .toDynamicValue(() => {
          return (params, dpr) => new NodeContext2d(params, dpr);
      })
          .whenTargetNamed(NodeContext2d.env);
  });

  function load(container) {
      container.load(browserModule);
      container.load(feishuModule);
      container.load(taroModule);
      container.load(lynxModule);
      container.load(wxModule);
      container.load(nodeModule);
  }

  container.load(coreModule);
  container.load(graphicModule);
  container.load(renderModule$1);
  container.load(pickModule);
  container.load(pluginModule);
  load$3(container);
  load$2(container);
  load$1(container);
  load(container);
  const global$1 = container.get(Global);
  application.global = global$1;
  const graphicUtil = container.get(GraphicUtil);
  application.graphicUtil = graphicUtil;
  const transformUtil = container.get(TransformUtil);
  application.transformUtil = transformUtil;
  const graphicService = container.get(GraphicService);
  application.graphicService = graphicService;
  const pickerService = container.get(GlobalPickerService);
  const layerService = container.get(LayerService);
  application.layerService = layerService;

  class AutoRenderPlugin {
      name = 'AutoRenderPlugin';
      activeEvent = 'onRegister';
      pluginService;
      _uid = Generator.GenAutoIncrementId();
      key = this.name + this._uid;
      activate(context) {
          this.pluginService = context;
          application.graphicService.hooks.onAttributeUpdate.tap(this.key, graphic => {
              if (graphic.glyphHost) {
                  graphic = graphic.glyphHost;
              }
              if (graphic.stage === context.stage && graphic.stage != null) {
                  graphic.stage.renderNextFrame();
              }
          });
          application.graphicService.hooks.onSetStage.tap(this.key, graphic => {
              if (graphic.glyphHost) {
                  graphic = graphic.glyphHost;
              }
              if (graphic.stage === context.stage && graphic.stage != null) {
                  graphic.stage.renderNextFrame();
              }
          });
      }
      deactivate(context) {
          application.graphicService.hooks.onAttributeUpdate.taps =
              application.graphicService.hooks.onAttributeUpdate.taps.filter(item => {
                  return item.name !== this.key;
              });
          application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter(item => {
              return item.name !== this.key;
          });
      }
  }

  class ViewTransform3dPlugin {
      name = 'ViewTransform3dPlugin';
      activeEvent = 'onRegister';
      pluginService;
      _uid = Generator.GenAutoIncrementId();
      key = this.name + this._uid;
      mousedown;
      pageX;
      pageY;
      option3d;
      onMouseDown = (e) => {
          if (!this.option3d) {
              this.option3d = this.pluginService.stage.option3d;
          }
          if (!this.option3d) {
              return;
          }
          this.mousedown = true;
          this.pageX = e.page.x;
          this.pageY = e.page.y;
      };
      onMouseUp = (e) => {
          if (!this.option3d) {
              this.option3d = this.pluginService.stage.option3d;
          }
          if (!this.option3d) {
              return;
          }
          this.mousedown = false;
      };
      onMouseMove = (e) => {
          const stage = this.pluginService.stage;
          if (!this.option3d) {
              this.option3d = stage.option3d;
          }
          if (!this.option3d) {
              return;
          }
          if (this.mousedown) {
              if (!this.pageX || !this.pageY) {
                  this.pageX = e.page.x;
                  this.pageY = e.page.y;
              }
              else {
                  const deltaX = e.page.x - this.pageX;
                  const deltaY = e.page.y - this.pageY;
                  this.pageX = e.page.x;
                  this.pageY = e.page.y;
                  const angle1 = deltaX / 100;
                  const angle2 = deltaY / 100;
                  this.option3d.alpha = (this.option3d.alpha ?? 0) + angle1;
                  this.option3d.beta = (this.option3d.beta ?? 0) + angle2;
                  stage.set3dOptions(this.option3d);
                  stage.renderNextFrame();
              }
          }
      };
      activate(context) {
          this.pluginService = context;
          const stage = context.stage;
          this.option3d = stage.option3d;
          stage.addEventListener('mousedown', this.onMouseDown);
          stage.addEventListener('mouseup', this.onMouseUp);
          stage.addEventListener('mousemove', this.onMouseMove);
      }
      deactivate(context) {
          const stage = context.stage;
          stage.removeEventListener('mousedown', this.onMouseDown);
          stage.removeEventListener('mouseup', this.onMouseUp);
          stage.removeEventListener('mousemove', this.onMouseMove);
      }
  }

  class IncrementalAutoRenderPlugin {
      name = 'IncrementalAutoRenderPlugin';
      activeEvent = 'onRegister';
      pluginService;
      nextFrameRenderGroupSet = new Set();
      willNextFrameRender = false;
      nextUserParams = {};
      _uid = Generator.GenAutoIncrementId();
      key = this.name + this._uid;
      activate(context) {
          this.pluginService = context;
          application.graphicService.hooks.onAddIncremental.tap(this.key, (graphic, group, stage) => {
              if (graphic.glyphHost) {
                  graphic = graphic.glyphHost;
              }
              if (graphic.stage === context.stage && graphic.stage != null) {
                  this.nextUserParams.startAtId = group._uid;
                  this.renderNextFrame(group);
              }
          });
          application.graphicService.hooks.onClearIncremental.tap(this.key, (group, stage) => {
              if (group.stage === context.stage && group.stage != null) {
                  this.nextUserParams.startAtId = group._uid;
                  this.nextUserParams.restartIncremental = true;
                  this.renderNextFrame(group);
              }
          });
      }
      deactivate(context) {
          application.graphicService.hooks.onAddIncremental.taps =
              application.graphicService.hooks.onAddIncremental.taps.filter(item => {
                  return item.name !== this.key;
              });
          application.graphicService.hooks.onClearIncremental.taps =
              application.graphicService.hooks.onClearIncremental.taps.filter(item => {
                  return item.name !== this.key;
              });
      }
      renderNextFrame(group) {
          this.nextFrameRenderGroupSet.add(group);
          if (!this.willNextFrameRender) {
              this.willNextFrameRender = true;
              application.global.getRequestAnimationFrame()(() => {
                  this._doRenderInThisFrame();
                  this.willNextFrameRender = false;
              });
          }
      }
      _doRenderInThisFrame() {
          const stage = this.pluginService.stage;
          if (this.nextFrameRenderGroupSet.size) {
              this.nextFrameRenderGroupSet.forEach(group => {
                  const layer = group.layer;
                  if (!layer || !group.layer.subLayers) {
                      return;
                  }
                  const subLayer = group.layer.subLayers.get(group._uid);
                  if (!subLayer || !subLayer.drawContribution) {
                      return;
                  }
                  subLayer.drawContribution.draw(stage.renderService, {
                      x: stage.x,
                      y: stage.y,
                      width: layer.viewWidth,
                      height: layer.viewHeight,
                      stage,
                      layer,
                      clear: 'transparent',
                      renderService: stage.renderService,
                      updateBounds: false,
                      startAtId: group._uid,
                      context: subLayer.layer.getNativeHandler().getContext(),
                      ...this.nextUserParams
                  });
              });
              this.nextUserParams = {};
              this.nextFrameRenderGroupSet.clear();
          }
      }
  }

  const globalBounds = new AABBBounds();
  class DirtyBoundsPlugin {
      name = 'DirtyBoundsPlugin';
      activeEvent = 'onRegister';
      pluginService;
      _uid = Generator.GenAutoIncrementId();
      key = this.name + this._uid;
      activate(context) {
          this.pluginService = context;
          context.stage.hooks.afterRender.tap(this.key, stage => {
              if (!(stage && stage === this.pluginService.stage)) {
                  return;
              }
              stage.dirtyBounds.clear();
          });
          application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
              if (graphic.glyphHost) {
                  graphic = graphic.glyphHost;
              }
              if (!(stage && stage === this.pluginService.stage && stage.renderCount)) {
                  return;
              }
              if (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds()) {
                  return;
              }
              if (willUpdate) {
                  globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2);
                  stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix);
              }
          });
          application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params, selfChange) => {
              if (!(stage && stage === this.pluginService.stage && stage.renderCount)) {
                  return;
              }
              if (graphic.isContainer && !selfChange) {
                  return;
              }
              stage.dirty(params.globalAABBBounds);
          });
          application.graphicService.hooks.onRemove.tap(this.key, (graphic) => {
              const stage = graphic.stage;
              if (!(stage && stage === this.pluginService.stage && stage.renderCount)) {
                  return;
              }
              if (stage) {
                  stage.dirty(graphic.globalAABBBounds);
              }
          });
      }
      deactivate(context) {
          application.graphicService.hooks.beforeUpdateAABBBounds.taps =
              application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(item => {
                  return item.name !== this.key;
              });
          application.graphicService.hooks.afterUpdateAABBBounds.taps =
              application.graphicService.hooks.afterUpdateAABBBounds.taps.filter(item => {
                  return item.name !== this.key;
              });
          context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter(item => {
              return item.name !== this.key;
          });
          application.graphicService.hooks.onRemove.taps = application.graphicService.hooks.onRemove.taps.filter(item => {
              return item.name !== this.key;
          });
      }
  }

  const defaultTicker = new DefaultTicker();
  defaultTicker.addTimeline(defaultTimeline);
  const DEFAULT_TICKER_FPS = 60;
  defaultTicker.setFPS(DEFAULT_TICKER_FPS);

  class DirectionalLight {
      constructor(dir, color, ambient = 0.8) {
          this.dir = dir;
          this.color = color;
          this.colorRgb = colorString.get(color).value;
          this.colorRgb[0] /= 255;
          this.colorRgb[1] /= 255;
          this.colorRgb[2] /= 255;
          this.ambient = ambient;
          const length = sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
          this.formatedDir = [dir[0] / length, dir[1] / length, dir[2] / length];
      }
      computeColor(normal, color) {
          const lightDir = this.formatedDir;
          const brightness = min(max((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) +
              this.ambient, 1);
          let colorArray;
          if (isString(color)) {
              const result = colorString.get(color);
              colorArray = result.value;
          }
          else {
              colorArray = color;
          }
          const lightColorArray = this.colorRgb;
          return colorString.to.rgb(lightColorArray[0] * colorArray[0] * brightness, lightColorArray[1] * colorArray[1] * brightness, lightColorArray[2] * colorArray[2] * brightness);
      }
  }

  const DefaultConfig = {
      WIDTH: 500,
      HEIGHT: 500,
      X: 0,
      Y: 0,
      BACKGROUND: 'white'
  };
  class Stage extends Group {
      _viewBox;
      _background;
      _subView;
      nextFrameRenderLayerSet;
      willNextFrameRender;
      _cursor;
      renderCount;
      dirtyBounds;
      option3d;
      set viewBox(b) {
          this._viewBox.setValue(b.x1, b.y1, b.x2, b.y2);
      }
      get viewBox() {
          return this._viewBox;
      }
      get x() {
          return this._viewBox.x1;
      }
      set x(x) {
          this._viewBox.translate(x - this._viewBox.x1, 0);
      }
      get y() {
          return this._viewBox.y1;
      }
      set y(y) {
          this._viewBox.translate(0, y - this._viewBox.y1);
      }
      get width() {
          return this.window.width;
      }
      set width(w) {
          this.resize(w, this.height);
      }
      get viewWidth() {
          return this._viewBox.width();
      }
      set viewWidth(w) {
          this.resizeView(w, this.viewHeight);
      }
      get viewHeight() {
          return this._viewBox.height();
      }
      set viewHeight(h) {
          this.resizeView(this.viewWidth, h);
      }
      get height() {
          return this.window.height;
      }
      set height(h) {
          this.resize(this.width, h);
      }
      get dpr() {
          return this.window.dpr;
      }
      set dpr(r) {
          this.setDpr(r);
      }
      get background() {
          return this._background ?? DefaultConfig.BACKGROUND;
      }
      set background(b) {
          this._background = b;
      }
      get defaultLayer() {
          return this.at(0);
      }
      ticker;
      autoRender;
      increaseAutoRender;
      view3dTranform;
      window;
      global;
      renderService;
      pickerService;
      pluginService;
      eventSystem;
      _beforeRender;
      _afterRender;
      _afterNextRenderCbs;
      lastRenderparams;
      constructor(params) {
          super({});
          this.theme = new Theme();
          this.hooks = {
              beforeRender: new SyncHook(['stage']),
              afterRender: new SyncHook(['stage'])
          };
          this.global = container.get(Global);
          this.window = container.get(Window);
          this.renderService = container.get(RenderService);
          this.pickerService = container.get(PickerService);
          this.pluginService = container.get(PluginService);
          this.pluginService.active(this);
          this.window.create({
              width: params.width,
              height: params.height,
              container: params.container,
              dpr: params.dpr || this.global.devicePixelRatio,
              canvasControled: params.canvasControled !== false,
              title: params.title || '',
              canvas: params.canvas
          });
          this._viewBox = new AABBBounds();
          if (params.viewBox) {
              this._viewBox.setValue(params.viewBox.x1, params.viewBox.y1, params.viewBox.x2, params.viewBox.y2);
          }
          else {
              this._viewBox.setValue(0, 0, this.width, this.height);
          }
          this.renderCount = 0;
          this._subView = !(this._viewBox.width() === this.width && this._viewBox.height() === this.height);
          this._background = params.background ?? DefaultConfig.BACKGROUND;
          this.appendChild(new Layer(this, this.global, this.window, { main: true }));
          this.nextFrameRenderLayerSet = new Set();
          this.willNextFrameRender = false;
          this.stage = this;
          this.renderStyle = params.renderStyle;
          if (this.global.supportEvent) {
              this.eventSystem = new EventSystem({
                  targetElement: this.window,
                  resolution: this.window.dpr || this.global.devicePixelRatio,
                  rootNode: this,
                  global: this.global,
                  viewport: {
                      viewBox: this._viewBox,
                      get x() {
                          return this.viewBox.x1;
                      },
                      get y() {
                          return this.viewBox.y1;
                      },
                      get width() {
                          return this.viewBox.width();
                      },
                      get height() {
                          return this.viewBox.height();
                      }
                  }
              });
          }
          if (params.autoRender) {
              this.enableAutoRender();
          }
          if (params.disableDirtyBounds === false) {
              this.enableDirtyBounds();
          }
          this.hooks.beforeRender.tap('constructor', this.beforeRender);
          this.hooks.afterRender.tap('constructor', this.afterRender);
          this._beforeRender = params.beforeRender;
          this._afterRender = params.afterRender;
          this.ticker = params.ticker || defaultTicker;
      }
      get3dOptions(options) {
          const { center = { x: this.width / 2, y: this.height / 2, z: 0, dx: 0, dy: 0, dz: 0 }, light = {}, alpha = 0, beta = 0, camera, fieldRatio = 1, fieldDepth } = options;
          return {
              ...options,
              center,
              light,
              alpha,
              beta,
              camera,
              fieldRatio,
              fieldDepth
          };
      }
      set3dOptions(options) {
          this.option3d = options;
          const options3d = this.get3dOptions(options);
          const { light, center, camera, alpha, beta, fieldRatio, fieldDepth } = options3d;
          const { dir = [1, 1, -1], color = 'white', ambient } = light;
          const centerX = (center.x ?? this.width / 2) + (center.dx ?? 0);
          const centerY = (center.y ?? this.height / 2) + (center.dy ?? 0);
          const centerZ = (center.z ?? 0) + (center.dz ?? 0);
          const centerVec3 = [centerX, centerY, centerZ];
          const z = 1;
          let cameraX = 0;
          let cameraY = 0;
          let cameraZ = 0;
          if (!camera) {
              cameraX = Math.sin(alpha) + centerX;
              cameraY = Math.sin(beta) + centerY;
              cameraZ = Math.cos(alpha) * Math.cos(beta) * z;
          }
          this.light = new DirectionalLight(dir, color, ambient);
          const cameraParams = {
              left: 0,
              right: this.width,
              top: 0,
              bottom: this.height,
              fieldRatio: fieldRatio,
              fieldDepth,
              viewParams: {
                  pos: [cameraX, cameraY, cameraZ],
                  center: centerVec3,
                  up: [0, 1, 0]
              }
          };
          if (this.camera) {
              this.camera.params = cameraParams;
          }
          else {
              this.camera = new OrthoCamera(cameraParams);
          }
          if (options.enableView3dTransform) {
              this.enableView3dTransform();
          }
      }
      beforeRender = (stage) => {
          this._beforeRender && this._beforeRender(stage);
      };
      afterRender = (stage) => {
          this.renderCount++;
          this._afterRender && this._afterRender(stage);
          this._afterNextRenderCbs && this._afterNextRenderCbs.forEach(cb => cb(stage));
          this._afterNextRenderCbs = null;
      };
      setBeforeRender(cb) {
          this._beforeRender = cb;
      }
      setAfterRender(cb) {
          this._afterRender = cb;
      }
      afterNextRender(cb) {
          if (!this._afterNextRenderCbs) {
              this._afterNextRenderCbs = [];
          }
          this._afterNextRenderCbs.push(cb);
      }
      enableView3dTransform() {
          if (this.view3dTranform) {
              return;
          }
          this.view3dTranform = true;
          this.pluginService.register(new ViewTransform3dPlugin());
      }
      disableView3dTranform() {
          if (!this.view3dTranform) {
              return;
          }
          this.view3dTranform = false;
          this.pluginService.findPluginsByName('ViewTransform3dPlugin').forEach(plugin => {
              plugin.deactivate(this.pluginService);
          });
      }
      enableAutoRender() {
          if (this.autoRender) {
              return;
          }
          this.autoRender = true;
          this.pluginService.register(new AutoRenderPlugin());
      }
      disableAutoRender() {
          if (!this.autoRender) {
              return;
          }
          this.autoRender = false;
          this.pluginService.findPluginsByName('AutoRenderPlugin').forEach(plugin => {
              plugin.deactivate(this.pluginService);
          });
      }
      enableIncrementalAutoRender() {
          if (this.increaseAutoRender) {
              return;
          }
          this.increaseAutoRender = true;
          this.pluginService.register(new IncrementalAutoRenderPlugin());
      }
      disableIncrementalAutoRender() {
          if (!this.increaseAutoRender) {
              return;
          }
          this.increaseAutoRender = false;
          this.pluginService.findPluginsByName('IncrementalAutoRenderPlugin').forEach(plugin => {
              plugin.deactivate(this.pluginService);
          });
      }
      enableDirtyBounds() {
          if (this.dirtyBounds) {
              return;
          }
          this.dirtyBounds = new Bounds();
          let plugin = this.pluginService.findPluginsByName('DirtyBoundsPlugin')[0];
          if (!plugin) {
              plugin = new DirtyBoundsPlugin();
              this.pluginService.register(plugin);
          }
          plugin.activate(this.pluginService);
      }
      disableDirtyBounds() {
          if (!this.dirtyBounds) {
              return;
          }
          this.dirtyBounds = null;
          this.pluginService.findPluginsByName('DirtyBoundsPlugin').forEach(plugin => {
              plugin.deactivate(this.pluginService);
          });
      }
      tryUpdateAABBBounds() {
          const viewBox = this._viewBox;
          this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2);
          return this._AABBBounds;
      }
      combineLayer(ILayer1, ILayer2) {
          throw new Error('');
      }
      createLayer(canvasId) {
          const layer = new Layer(this, this.global, this.window, {
              main: false,
              canvasId
          });
          this.appendChild(layer);
          return layer;
      }
      sortLayer(cb) {
          throw new Error('');
      }
      removeLayer(ILayerId) {
          return this.removeChild(this.findChildByUid(ILayerId));
      }
      clearViewBox(color) {
          this.window.clearViewBox(this._viewBox, color);
      }
      render(layers, params) {
          this.ticker.start();
          this.lastRenderparams = params;
          this.hooks.beforeRender.call(this);
          (layers || this).forEach((layer, i) => {
              layer.render({
                  renderService: this.renderService,
                  background: layer === this.defaultLayer ? this.background : undefined,
                  updateBounds: !!this.dirtyBounds
              }, { renderStyle: this.renderStyle, ...params });
          });
          this.combineLayersToWindow();
          this.nextFrameRenderLayerSet.clear();
          this.hooks.afterRender.call(this);
      }
      combineLayersToWindow() {
          this.forEach((layer, i) => {
              layer.combineTo(this.window, {
                  clear: i === 0,
                  x: this.x,
                  y: this.y,
                  width: this.viewWidth,
                  height: this.viewHeight,
                  renderService: this.renderService,
                  background: layer === this.defaultLayer ? this.background : undefined,
                  updateBounds: !!this.dirtyBounds
              });
          });
      }
      renderNextFrame(layers) {
          if (this.nextFrameRenderLayerSet.size !== this.childrenCount) {
              (layers || this).forEach((layer) => {
                  this.nextFrameRenderLayerSet.add(layer);
              });
          }
          if (!this.willNextFrameRender) {
              this.willNextFrameRender = true;
              this.global.getRequestAnimationFrame()(() => {
                  this._doRenderInThisFrame(), (this.willNextFrameRender = false);
              });
          }
      }
      _doRenderInThisFrame() {
          if (this.nextFrameRenderLayerSet.size) {
              this.ticker.start();
              this.hooks.beforeRender.call(this);
              this.forEach((layer) => {
                  if (this.nextFrameRenderLayerSet.has(layer)) {
                      layer.render({
                          renderService: this.renderService,
                          background: layer === this.defaultLayer ? this.background : undefined,
                          updateBounds: !!this.dirtyBounds
                      }, { renderStyle: this.renderStyle, ...(this.lastRenderparams || {}) });
                  }
              });
              this.combineLayersToWindow();
              this.hooks.afterRender.call(this);
              this.nextFrameRenderLayerSet.clear();
          }
      }
      resizeWindow(w, h, rerender = true) {
          this.window.resize(w, h);
          rerender && this.render();
      }
      resize(w, h, rerender = true) {
          this.window.resize(w, h);
          this.forEachChildren(c => {
              c.resize(w, h);
          });
          if (!this._subView) {
              this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h);
          }
          this.camera && this.option3d && this.set3dOptions(this.option3d);
          rerender && this.render();
      }
      resizeView(w, h, rerender = true) {
          this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h);
          this.forEachChildren(c => {
              c.resizeView(w, h);
          });
          this.camera && (this.camera.params = { ...this.camera.params, right: this.width, bottom: this.height });
          rerender && this.render();
      }
      setViewBox(x, y, w, h, rerender) {
          let isRerender = true;
          if (typeof x === 'object') {
              this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2);
              if (y === false) {
                  isRerender = false;
              }
          }
          else {
              this.viewBox.setValue(x, y, x + w, y + h);
              if (rerender === false) {
                  isRerender = false;
              }
          }
          this.forEachChildren(c => {
              c.resizeView(this.viewBox.width(), this.viewBox.height());
          });
          isRerender && this.render();
      }
      setDpr(dpr) {
          this.forEachChildren(c => {
              c.setDpr(dpr);
          });
      }
      setOrigin(x, y) {
          throw new Error('');
      }
      export(type) {
          throw new Error('');
      }
      pick(x, y) {
          const result = this.pickerService.pick(this.children, new Point(x, y), {
              bounds: this.AABBBounds
          });
          if (result?.graphic || result?.group) {
              return result;
          }
          return false;
      }
      startAnimate(t) {
          throw new Error('');
      }
      setToFrame(t) {
          throw new Error('');
      }
      release() {
          super.release();
          this.eventSystem && this.eventSystem.release();
          this.pluginService.release();
          this.forEach(layer => {
              layer.release();
          });
          this.window.release();
      }
      setStage(stage) {
          return;
      }
      dirty(b, matrix) {
          if (matrix) {
              b.transformWithMatrix(matrix);
          }
          if (this.dirtyBounds.empty()) {
              this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2);
          }
          this.dirtyBounds.union(b);
      }
      renderTo(window, params) {
          this.forEachChildren((layer, i) => {
              layer.drawTo(window, {
                  ...params,
                  renderService: this.renderService,
                  background: layer === this.defaultLayer ? this.background : undefined,
                  clear: i === 0,
                  updateBounds: !!this.dirtyBounds
              });
          });
      }
      renderToNewWindow(fullImage = true) {
          const window = container.get(Window);
          if (fullImage) {
              window.create({
                  width: this.viewWidth,
                  height: this.viewHeight,
                  dpr: this.window.dpr,
                  canvasControled: true,
                  offscreen: true,
                  title: ''
              });
          }
          else {
              window.create({
                  width: Math.min(this.viewWidth, this.window.width - this.x),
                  height: Math.min(this.viewHeight, this.window.height - this.y),
                  dpr: this.window.dpr,
                  canvasControled: true,
                  offscreen: true,
                  title: ''
              });
          }
          this.renderTo(window, {
              x: 0,
              y: 0,
              width: window.width,
              height: window.height
          });
          return window;
      }
      toCanvas(fullImage = true) {
          const window = this.renderToNewWindow(fullImage);
          const c = window.getNativeHandler();
          if (c.nativeCanvas) {
              return c.nativeCanvas;
          }
          return null;
      }
      setCursor(mode) {
          this._cursor = mode;
          this.eventSystem.setCursor(mode);
      }
      getCursor() {
          return this._cursor;
      }
  }

  function createStage(params) {
      return new Stage(params);
  }

  var params;
  (function (params) {
      params[params["W"] = 1] = "W";
      params[params["H"] = 2] = "H";
      params[params["WH"] = 3] = "WH";
  })(params || (params = {}));

  const strCommandMap = [
      'arc',
      'arcTo',
      'bezierCurveTo',
      'closePath',
      'ellipse',
      'lineTo',
      'moveTo',
      'quadraticCurveTo',
      'rect'
  ];

  const version = "0.12.2";

  exports.ACustomAnimate = ACustomAnimate;
  exports.ARC3D_NUMBER_TYPE = ARC3D_NUMBER_TYPE;
  exports.ARC_NUMBER_TYPE = ARC_NUMBER_TYPE;
  exports.AREA_NUMBER_TYPE = AREA_NUMBER_TYPE;
  exports.Animate = Animate;
  exports.AnimateGroup = AnimateGroup;
  exports.AnimateGroup1 = AnimateGroup1;
  exports.Arc = Arc;
  exports.Arc3d = Arc3d;
  exports.Arc3dRender = Arc3dRender;
  exports.ArcRender = ArcRender;
  exports.ArcRenderContribution = ArcRenderContribution;
  exports.Area = Area;
  exports.AreaRender = AreaRender;
  exports.AttributeAnimate = AttributeAnimate;
  exports.Basis = Basis;
  exports.BeforeRenderConstribution = BeforeRenderConstribution;
  exports.BoundsContext = BoundsContext;
  exports.BoundsPicker = BoundsPicker;
  exports.CIRCLE_NUMBER_TYPE = CIRCLE_NUMBER_TYPE;
  exports.CanvasFactory = CanvasFactory;
  exports.CanvasTextLayout = CanvasTextLayout;
  exports.CbAnimate = CbAnimate;
  exports.Circle = Circle;
  exports.CircleRender = CircleRender;
  exports.CircleRenderContribution = CircleRenderContribution;
  exports.ClipAngleAnimate = ClipAngleAnimate;
  exports.ClipDirectionAnimate = ClipDirectionAnimate;
  exports.ClipGraphicAnimate = ClipGraphicAnimate;
  exports.ClipRadiusAnimate = ClipRadiusAnimate;
  exports.ColorInterpolate = ColorInterpolate;
  exports.Context2dFactory = Context2dFactory;
  exports.ContributionProvider = ContributionProvider;
  exports.CurveContext = CurveContext;
  exports.CustomEvent = CustomEvent;
  exports.CustomPath2D = CustomPath2D;
  exports.CustomSymbolClass = CustomSymbolClass;
  exports.DefaultArcAttribute = DefaultArcAttribute;
  exports.DefaultAreaAttribute = DefaultAreaAttribute;
  exports.DefaultAttribute = DefaultAttribute;
  exports.DefaultCircleAttribute = DefaultCircleAttribute;
  exports.DefaultFillStyle = DefaultFillStyle;
  exports.DefaultGlyphAttribute = DefaultGlyphAttribute;
  exports.DefaultGroupAttribute = DefaultGroupAttribute;
  exports.DefaultImageAttribute = DefaultImageAttribute;
  exports.DefaultLineAttribute = DefaultLineAttribute;
  exports.DefaultMorphingAnimateConfig = DefaultMorphingAnimateConfig;
  exports.DefaultPathAttribute = DefaultPathAttribute;
  exports.DefaultPolygonAttribute = DefaultPolygonAttribute;
  exports.DefaultRect3dAttribute = DefaultRect3dAttribute;
  exports.DefaultRectAttribute = DefaultRectAttribute;
  exports.DefaultRichTextAttribute = DefaultRichTextAttribute;
  exports.DefaultRichTextIconAttribute = DefaultRichTextIconAttribute;
  exports.DefaultStateAnimateConfig = DefaultStateAnimateConfig;
  exports.DefaultStrokeStyle = DefaultStrokeStyle;
  exports.DefaultStyle = DefaultStyle;
  exports.DefaultSymbolAttribute = DefaultSymbolAttribute;
  exports.DefaultSymbolBackgroundRenderContribution = DefaultSymbolBackgroundRenderContribution;
  exports.DefaultSymbolTextureRenderContribution = DefaultSymbolTextureRenderContribution;
  exports.DefaultTextAttribute = DefaultTextAttribute;
  exports.DefaultTextStyle = DefaultTextStyle;
  exports.DefaultTicker = DefaultTicker;
  exports.DefaultTimeline = DefaultTimeline;
  exports.DefaultTransform = DefaultTransform;
  exports.DragNDrop = DragNDrop;
  exports.DrawContribution = DrawContribution;
  exports.EventManager = EventManager;
  exports.EventSystem = EventSystem;
  exports.EventTarget = EventTarget;
  exports.FadeInPlus = FadeInPlus;
  exports.FederatedEvent = FederatedEvent;
  exports.FederatedMouseEvent = FederatedMouseEvent;
  exports.FederatedPointerEvent = FederatedPointerEvent;
  exports.FederatedWheelEvent = FederatedWheelEvent;
  exports.GLYPH_NUMBER_TYPE = GLYPH_NUMBER_TYPE;
  exports.GRAPHIC_UPDATE_TAG_KEY = GRAPHIC_UPDATE_TAG_KEY;
  exports.GROUP_NUMBER_TYPE = GROUP_NUMBER_TYPE;
  exports.Generator = Generator;
  exports.Gesture = Gesture;
  exports.GlobalPickerService = GlobalPickerService;
  exports.Glyph = Glyph;
  exports.GlyphRender = GlyphRender;
  exports.Graphic = Graphic;
  exports.GraphicAnimate = GraphicAnimate;
  exports.GraphicCreator = GraphicCreator;
  exports.GraphicPicker = GraphicPicker;
  exports.GraphicRender = GraphicRender;
  exports.GraphicService = GraphicService;
  exports.GraphicUtil = GraphicUtil;
  exports.Group = Group;
  exports.GroupFadeIn = GroupFadeIn;
  exports.GroupFadeOut = GroupFadeOut;
  exports.GroupRender = GroupRender;
  exports.GroupRenderContribution = GroupRenderContribution;
  exports.IMAGE_NUMBER_TYPE = IMAGE_NUMBER_TYPE;
  exports.Image = Image;
  exports.ImageRender = ImageRender;
  exports.ImageRenderContribution = ImageRenderContribution;
  exports.IncreaseCount = IncreaseCount;
  exports.IncrementalDrawContribution = IncrementalDrawContribution;
  exports.InputText = InputText;
  exports.LINE_NUMBER_TYPE = LINE_NUMBER_TYPE;
  exports.Layer = Layer;
  exports.LayerHandlerContribution = LayerHandlerContribution;
  exports.LayerService = LayerService;
  exports.Line = Line$1;
  exports.LineRender = LineRender;
  exports.Linear = Linear;
  exports.LinearClosed = LinearClosed;
  exports.ManualTickHandler = ManualTickHandler;
  exports.ManualTicker = ManualTicker;
  exports.Meteor = Meteor;
  exports.MonotoneX = MonotoneX;
  exports.MonotoneY = MonotoneY;
  exports.MorphingPath = MorphingPath;
  exports.MotionPath = MotionPath;
  exports.MultiToOneMorphingPath = MultiToOneMorphingPath;
  exports.Node = Node;
  exports.PATH_NUMBER_TYPE = PATH_NUMBER_TYPE;
  exports.POLYGON_NUMBER_TYPE = POLYGON_NUMBER_TYPE;
  exports.PURE_STYLE_KEY = PURE_STYLE_KEY;
  exports.PYRAMID3D_NUMBER_TYPE = PYRAMID3D_NUMBER_TYPE;
  exports.Path = Path;
  exports.PathRender = PathRender;
  exports.PickerService = PickerService;
  exports.Polygon = Polygon;
  exports.PolygonRender = PolygonRender;
  exports.Pyramid3d = Pyramid3d;
  exports.Pyramid3dRender = Pyramid3dRender;
  exports.RAFTickHandler = RAFTickHandler;
  exports.RECT3D_NUMBER_TYPE = RECT3D_NUMBER_TYPE;
  exports.RECT_NUMBER_TYPE = RECT_NUMBER_TYPE;
  exports.RICHTEXT_NUMBER_TYPE = RICHTEXT_NUMBER_TYPE;
  exports.Rect = Rect;
  exports.Rect3DRender = Rect3DRender;
  exports.Rect3d = Rect3d;
  exports.RectRender = RectRender;
  exports.RectRenderContribution = RectRenderContribution;
  exports.ReflectSegContext = ReflectSegContext;
  exports.RenderSelector = RenderSelector;
  exports.RenderService = RenderService;
  exports.ResourceLoader = ResourceLoader;
  exports.RichText = RichText;
  exports.RichTextRender = RichTextRender;
  exports.RotateBySphereAnimate = RotateBySphereAnimate;
  exports.SYMBOL_NUMBER_TYPE = SYMBOL_NUMBER_TYPE;
  exports.SegContext = SegContext;
  exports.Stage = Stage;
  exports.Step = Step$1;
  exports.StreamLight = StreamLight;
  exports.SubAnimate = SubAnimate;
  exports.Symbol = Symbol$1;
  exports.SymbolRender = SymbolRender;
  exports.SymbolRenderContribution = SymbolRenderContribution;
  exports.TEXT_NUMBER_TYPE = TEXT_NUMBER_TYPE;
  exports.TagPointsUpdate = TagPointsUpdate;
  exports.Text = Text;
  exports.TextRender = TextRender;
  exports.Theme = Theme;
  exports.TimeOutTickHandler = TimeOutTickHandler;
  exports.TransformUtil = TransformUtil;
  exports.Window = Window;
  exports.WindowHandlerContribution = WindowHandlerContribution;
  exports.addArcToBezierPath = addArcToBezierPath$1;
  exports.addAttributeToPrototype = addAttributeToPrototype;
  exports.alignBezierCurves = alignBezierCurves;
  exports.alignSubpath = alignSubpath;
  exports.applyTransformOnBezierCurves = applyTransformOnBezierCurves;
  exports.bezier = bezier;
  exports.bezierCurversToPath = bezierCurversToPath;
  exports.binarySplitPolygon = binarySplitPolygon;
  exports.bindContributionProvider = bindContributionProvider;
  exports.boundStroke = boundStroke;
  exports.builtinSymbols = builtinSymbols;
  exports.builtinSymbolsMap = builtinSymbolsMap;
  exports.calcLineCache = calcLineCache$1;
  exports.centroidOfSubpath = centroidOfSubpath;
  exports.circleBounds = circleBounds;
  exports.cloneGraphic = cloneGraphic;
  exports.container = container;
  exports.cornerTangents = cornerTangents;
  exports.createArc = createArc;
  exports.createArc3d = createArc3d;
  exports.createArea = createArea;
  exports.createCircle = createCircle;
  exports.createColor = createColor;
  exports.createConicalGradient = createConicalGradient;
  exports.createGlyph = createGlyph;
  exports.createGroup = createGroup;
  exports.createImage = createImage;
  exports.createLine = createLine;
  exports.createPath = createPath;
  exports.createPolygon = createPolygon;
  exports.createPyramid3d = createPyramid3d;
  exports.createRect = createRect;
  exports.createRect3d = createRect3d;
  exports.createRectPath = createRectPath;
  exports.createRichText = createRichText;
  exports.createShadowRoot = createShadowRoot;
  exports.createStage = createStage;
  exports.createSymbol = createSymbol;
  exports.createText = createText;
  exports.createWrapText = createWrapText;
  exports.cubicCalc = cubicCalc;
  exports.cubicLength = cubicLength;
  exports.cubicPointAt = cubicPointAt;
  exports.cubicSubdivide = cubicSubdivide;
  exports.defaultTicker = defaultTicker;
  exports.defaultTimeline = defaultTimeline;
  exports.drawArc = drawArc;
  exports.drawArcPath = drawArcPath$1;
  exports.drawAreaSegments = drawAreaSegments;
  exports.drawIncrementalAreaSegments = drawIncrementalAreaSegments;
  exports.drawIncrementalSegments = drawIncrementalSegments;
  exports.drawPathProxy = drawPathProxy;
  exports.drawSegments = drawSegments;
  exports.enumCommandMap = enumCommandMap;
  exports.fillVisible = fillVisible;
  exports.findBestMorphingRotation = findBestMorphingRotation;
  exports.findNextGraphic = findNextGraphic;
  exports.foreach = foreach;
  exports.foreachAsync = foreachAsync;
  exports.genBasisSegments = genBasisSegments;
  exports.genBasisTypeSegments = genBasisTypeSegments;
  exports.genLinearClosedSegments = genLinearClosedSegments;
  exports.genLinearClosedTypeSegments = genLinearClosedTypeSegments;
  exports.genLinearSegments = genLinearSegments;
  exports.genLinearTypeSegments = genLinearTypeSegments;
  exports.genMonotoneXSegments = genMonotoneXSegments;
  exports.genMonotoneYSegments = genMonotoneYSegments;
  exports.genMonotpneXTypeSegments = genMonotpneXTypeSegments;
  exports.genMonotpneYTypeSegments = genMonotpneYTypeSegments;
  exports.genNumberType = genNumberType;
  exports.genStepSegments = genStepSegments;
  exports.genStepTypeSegments = genStepTypeSegments;
  exports.getAttributeFromDefaultAttrList = getAttributeFromDefaultAttrList;
  exports.getConicGradientAt = getConicGradientAt;
  exports.getContextFont = getContextFont;
  exports.getExtraModelMatrix = getExtraModelMatrix;
  exports.getModelMatrix = getModelMatrix;
  exports.getRichTextBounds = getRichTextBounds;
  exports.getScaledStroke = getScaledStroke;
  exports.getTextBounds = getTextBounds;
  exports.getTheme = getTheme;
  exports.getThemeFromGroup = getThemeFromGroup;
  exports.global = global$1;
  exports.globalTheme = globalTheme;
  exports.graphicCreator = graphicCreator;
  exports.graphicService = graphicService;
  exports.graphicUtil = graphicUtil;
  exports.incrementalAddTo = incrementalAddTo;
  exports.intersect = intersect;
  exports.isTransformKey = isTransformKey;
  exports.layerService = layerService;
  exports.loadFeishuContributions = loadFeishuContributions;
  exports.loadTaroContributions = loadTaroContributions;
  exports.mat3Tomat4 = mat3Tomat4;
  exports.morphPath = morphPath;
  exports.multiToOneMorph = multiToOneMorph;
  exports.multiplyMat4Mat3 = multiplyMat4Mat3;
  exports.multiplyMat4Mat4 = multiplyMat4Mat4;
  exports.newThemeObj = newThemeObj;
  exports.oneToMultiMorph = oneToMultiMorph;
  exports.parsePadding = parsePadding;
  exports.parseStroke = parseStroke;
  exports.parseSvgPath = parseSvgPath;
  exports.pathToBezierCurves = pathToBezierCurves;
  exports.pickerService = pickerService;
  exports.point = point$2;
  exports.pointEqual = pointEqual;
  exports.pointInterpolation = pointInterpolation;
  exports.pointInterpolationHighPerformance = pointInterpolationHighPerformance;
  exports.pointsEqual = pointsEqual;
  exports.pointsInterpolation = pointsInterpolation;
  exports.rectFillVisible = rectFillVisible;
  exports.rectStrokeVisible = rectStrokeVisible;
  exports.recursiveCallBinarySplit = recursiveCallBinarySplit;
  exports.renderCommandList = renderCommandList;
  exports.rewriteProto = rewriteProto;
  exports.rotateX = rotateX;
  exports.rotateY = rotateY;
  exports.runFill = runFill;
  exports.runStroke = runStroke;
  exports.segments = segments;
  exports.shouldUseMat4 = shouldUseMat4;
  exports.snapLength = snapLength;
  exports.splitArc = splitArc;
  exports.splitArea = splitArea;
  exports.splitCircle = splitCircle;
  exports.splitGraphic = splitGraphic;
  exports.splitLine = splitLine;
  exports.splitPath = splitPath;
  exports.splitPolygon = splitPolygon;
  exports.splitRect = splitRect;
  exports.splitToGrids = splitToGrids;
  exports.strCommandMap = strCommandMap;
  exports.strokeVisible = strokeVisible;
  exports.textDrawOffsetX = textDrawOffsetX;
  exports.textDrawOffsetY = textDrawOffsetY;
  exports.textLayoutOffsetY = textLayoutOffsetY;
  exports.transformKeys = transformKeys;
  exports.transformUtil = transformUtil;
  exports.translate = translate;
  exports.version = version;
  exports.waitForAllSubLayers = waitForAllSubLayers;

}));
