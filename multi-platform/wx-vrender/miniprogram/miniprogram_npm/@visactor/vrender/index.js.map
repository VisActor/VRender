{"version":3,"sources":["index.js","modules.js","core/core-modules.js","core/global.js","common/contribution-provider.js","tapable/index.js","tapable/SyncHook.js","tapable/Hook.js","constants.js","core/graphic-utils.js","core/contributions/textMeasure/textMeasure-contribution.js","core/contributions/textMeasure/AtextMeasure.js","graphic/config.js","common/custom-path2d.js","common/bounds-context.js","common/segment/curve/path.js","common/path-svg.js","common/enums.js","common/shape/arc.js","common/render-command-list.js","common/segment/index.js","common/segment/linear.js","common/seg-context.js","common/segment/curve/cubic-bezier.js","common/segment/curve/base.js","common/bezier-utils.js","common/segment/curve/line.js","common/segment/common.js","common/segment/basis.js","common/segment/monotone.js","common/segment/step.js","common/segment/linear-closed.js","common/segment/curve/curve-context.js","canvas/util.js","container.js","application.js","canvas/constants.js","core/layer-service.js","core/layer.js","graphic/theme.js","graphic/group.js","graphic/graphic.js","graphic/node-tree.js","common/generator.js","event/index.js","event/federated-event/index.js","event/federated-event/base-event.js","event/federated-event/mouse-event.js","event/federated-event/pointer-event.js","event/federated-event/wheel-event.js","event/federated-event/custom-event.js","event/event-manager.js","event/constant.js","event/util.js","event/event-target.js","event/event-system.js","event/extension/index.js","event/extension/drag.js","event/extension/gesture.js","interface/event.js","animate/index.js","animate/Ticker/index.js","animate/Ticker/default-ticker.js","animate/animate.js","animate/easing.js","animate/timeline.js","animate/config.js","animate/custom-animate.js","common/utils.js","animate/morphing.js","common/split-path.js","common/morphing-utils.js","color-string/interpolate.js","color-string/index.js","color-string/colorName.js","resource-loader/loader.js","graphic/constants.js","graphic/tools.js","core/window.js","core/constants.js","render/render-modules.js","render/render-service.js","render/contributions/render/index.js","render/contributions/render/arc-render.js","render/contributions/render/utils.js","canvas/contributions/browser/conical-gradient.js","render/contributions/render/contributions/arc-contribution-render.js","common/canvas-utils.js","render/contributions/render/contributions/base-contribution-render.js","graphic/index.js","graphic/circle.js","graphic/text.js","common/text.js","core/contributions/textMeasure/layout.js","graphic/symbol.js","graphic/builtin-symbol/index.js","graphic/builtin-symbol/circle.js","graphic/builtin-symbol/cross.js","graphic/builtin-symbol/diamond.js","graphic/builtin-symbol/square.js","graphic/builtin-symbol/triangle.js","graphic/builtin-symbol/triangle-up.js","graphic/builtin-symbol/star.js","graphic/builtin-symbol/arrow.js","graphic/builtin-symbol/wedge.js","graphic/builtin-symbol/stroke.js","graphic/builtin-symbol/wye.js","graphic/builtin-symbol/triangle-left.js","graphic/builtin-symbol/triangle-right.js","graphic/builtin-symbol/triangle-down.js","graphic/builtin-symbol/thin-triangle.js","graphic/builtin-symbol/arrow2-left.js","graphic/builtin-symbol/arrow2-right.js","graphic/builtin-symbol/rect.js","graphic/builtin-symbol/utils.js","graphic/line.js","graphic/rect.js","graphic/rect3d.js","graphic/glyph.js","graphic/richtext.js","graphic/richtext/frame.js","graphic/richtext/utils.js","graphic/richtext/paragraph.js","graphic/richtext/wrapper.js","graphic/richtext/line.js","graphic/richtext/icon.js","graphic/image.js","graphic/path.js","graphic/area.js","graphic/arc.js","graphic/arc3d.js","graphic/polygon.js","graphic/pyramid3d.js","graphic/graphic-service/graphic-service.js","graphic/graphic-service/rect-contribution.js","graphic/graphic-service/common-contribution.js","graphic/graphic-service/symbol-contribution.js","graphic/graphic-service/circle-contribution.js","graphic/graphic-service/arc-contribution.js","graphic/graphic-service/path-contribution.js","allocator/matrix-allocate.js","graphic/graphic-creator.js","graphic/shadow-root.js","graphic/wrap-text.js","graphic/bounds.js","allocator/canvas-allocate.js","render/contributions/render/circle-render.js","render/contributions/render/contributions/circle-contribution-render.js","render/contributions/render/line-render.js","render/contributions/render/base-render.js","common/render-curve.js","render/contributions/render/area-render.js","render/contributions/render/contributions/area-contribution-render.js","common/render-area.js","render/contributions/render/path-render.js","render/contributions/render/contributions/path-contribution-render.js","render/contributions/render/rect-render.js","common/shape/rect.js","render/contributions/render/contributions/rect-contribution-render.js","render/contributions/render/symbol-render.js","render/contributions/render/contributions/symbol-contribution-render.js","render/contributions/render/text-render.js","render/contributions/render/graphic-render.js","render/contributions/render/polygon-render.js","common/polygon.js","render/contributions/render/contributions/polygon-contribution-render.js","render/contributions/render/image-render.js","render/contributions/render/contributions/image-contribution-render.js","render/contributions/render/symbol.js","render/contributions/render/contributions/index.js","render/contributions/render/contributions/group-contribution-render.js","picker/pick-modules.js","picker/picker-service.js","common/sort.js","picker/pick-interceptor.js","picker/global-picker-service.js","picker/canvas-picker-service.js","canvas/contributions/browser/index.js","canvas/contributions/browser/canvas.js","canvas/contributions/browser/context.js","core/camera.js","picker/contributions/constants.js","render/index.js","picker/math-picker-service.js","canvas/index.js","canvas/empty-context.js","graphic/graphic-service/graphic-module.js","plugins/plugin-modules.js","plugins/plugin-service.js","core/contributions/modules.js","core/contributions/env/modules.js","core/contributions/env/browser-contribution.js","core/contributions/env/base-contribution.js","core/contributions/env/feishu-contribution.js","kits/index.js","kits/env.js","picker/index.js","core/contributions/env/taro-contribution.js","core/contributions/env/lynx-contribution.js","core/contributions/env/node-contribution.js","core/contributions/window/modules.js","core/contributions/window/browser-contribution.js","core/contributions/window/base-contribution.js","core/contributions/window/feishu-contribution.js","canvas/contributions/feishu/index.js","canvas/contributions/feishu/canvas.js","canvas/contributions/feishu/context.js","core/contributions/window/taro-contribution.js","canvas/contributions/taro/index.js","canvas/contributions/taro/canvas.js","canvas/contributions/taro/context.js","core/contributions/window/lynx-contribution.js","canvas/contributions/lynx/index.js","canvas/contributions/lynx/canvas.js","canvas/contributions/lynx/context.js","core/contributions/window/node-contribution.js","canvas/contributions/node/index.js","canvas/contributions/node/canvas.js","canvas/contributions/node/context.js","core/contributions/textMeasure/modules.js","core/contributions/layerHandler/modules.js","core/contributions/layerHandler/canvas2d-contribution.js","core/contributions/layerHandler/offscreen2d-contribution.js","render/contributions/modules.js","render/contributions/render/module.js","render/contributions/render/draw-contribution.js","render/contributions/render/draw-interceptor.js","render/contributions/render/render-slector.js","render/contributions/render/group-render.js","render/contributions/render/incremental-draw-contribution.js","render/contributions/render/incremental-line-render.js","render/contributions/render/incremental-area-render.js","render/contributions/render/rect3d-render.js","render/contributions/render/richtext-render.js","render/contributions/render/glyph-render.js","render/contributions/render/arc3d-render.js","render/contributions/render/pyramid3d-render.js","picker/contributions/modules.js","picker/contributions/canvas-picker/module.js","picker/contributions/canvas-picker/circle-picker.js","picker/contributions/canvas-picker/rect-picker.js","picker/contributions/canvas-picker/arc-picker.js","picker/contributions/canvas-picker/area-picker.js","picker/contributions/canvas-picker/image-picker.js","picker/contributions/canvas-picker/line-picker.js","picker/contributions/canvas-picker/base-picker.js","picker/contributions/canvas-picker/path-picker.js","picker/contributions/canvas-picker/symbol-picker.js","picker/contributions/canvas-picker/text-picker.js","picker/contributions/canvas-picker/polygon-picker.js","picker/contributions/canvas-picker/richtext-picker.js","picker/contributions/canvas-picker/glyph-picker.js","picker/contributions/canvas-picker/rect3d-picker.js","picker/contributions/canvas-picker/pyramid3d-picker.js","picker/contributions/canvas-picker/arc3d-picker.js","picker/contributions/math-picker/module.js","picker/contributions/math-picker/path-picker.js","picker/contributions/math-picker/circle-picker.js","picker/contributions/math-picker/rect-picker.js","picker/contributions/math-picker/arc-picker.js","picker/contributions/math-picker/area-picker.js","picker/contributions/math-picker/line-picker.js","picker/contributions/math-picker/symbol-picker.js","picker/contributions/math-picker/text-picker.js","picker/contributions/math-picker/polygon-picker.js","picker/contributions/math-picker/glyph-picker.js","canvas/contributions/modules.js","canvas/contributions/browser/modules.js","canvas/contributions/taro/modules.js","canvas/contributions/feishu/modules.js","canvas/contributions/lynx/modules.js","canvas/contributions/node/modules.js","create.js","core/stage.js","plugins/builtin-plugin/auto-render-plugin.js","plugins/builtin-plugin/3dview-transform-plugin.js","plugins/builtin-plugin/incremental-auto-render-plugin.js","plugins/builtin-plugin/dirty-bounds-plugin.js","animate/default-ticker.js","core/light.js","interface/index.js","interface/global.js","interface/common.js","interface/node-tree.js","interface/graphic.js","interface/graphic/index.js","interface/graphic/creator.js","interface/graphic/theme.js","interface/graphic/arc.js","interface/graphic/arc3d.js","interface/graphic/area.js","interface/graphic/bounds.js","interface/graphic/circle.js","interface/graphic/ellipse.js","interface/graphic/face3d.js","interface/graphic/glyph.js","interface/graphic/group.js","interface/graphic/image.js","interface/graphic/isogon.js","interface/graphic/line.js","interface/graphic/path.js","interface/graphic/polygon.js","interface/graphic/polyline.js","interface/graphic/pyramid3d.js","interface/graphic/rect.js","interface/graphic/rect3d.js","interface/graphic/richText.js","interface/graphic/shadow-root.js","interface/graphic/svg.js","interface/graphic/symbol.js","interface/graphic/text.js","interface/graphic/util.js","interface/layer.js","interface/stage.js","interface/canvas.js","interface/context.js","interface/path.js","interface/color.js","interface/animate.js","interface/camera.js","interface/matrix.js","interface/light.js","interface/curve.js","interface/graphic-service.js","interface/sync-hook.js","interface/allocator.js","interface/core.js","interface/loader.js","interface/contribution.js","interface/render.js","interface/plugin.js","interface/picker.js","interface/text.js","interface/window.js","core/index.js","core/contributions/index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA,AIZA;ADIA,AFMA,ACHA,AHSA,ACHA,AIZA;ADIA,AFMA,ACHA,AHSA,ACHA,AIZA;ADIA,AFMA,ACHA,AHSA,ACHA,AKfA,ADGA;ADIA,AFMA,ACHA,AHSA,ACHA,AKfA,ADGA;ADIA,AFMA,ACHA,AHSA,ACHA,AKfA,ADGA;ADIA,AFMA,ACHA,AHSA,ACHA,AMlBA,ADGA,ADGA;ADIA,ADGA,AHSA,ACHA,AMlBA,ADGA,ADGA;ADIA,ADGA,AHSA,ACHA,AMlBA,ADGA,ADGA;ADIA,AIZA,ALeA,AHSA,ACHA,AMlBA,ADGA,ADGA;ADIA,AIZA,ALeA,AHSA,ACHA,AMlBA,ADGA,ADGA;ADIA,AIZA,ALeA,AHSA,ACHA,AMlBA,ADGA,ADGA;ADIA,AIZA,ALeA,AMlBA,AT2BA,ACHA,AMlBA,ADGA,ADGA;ADIA,AIZA,ALeA,AMlBA,AT2BA,AOrBA,ADGA,ADGA;ADIA,AIZA,ALeA,AMlBA,AT2BA,AOrBA,ADGA,ADGA;ADIA,AIZA,AENA,APqBA,AMlBA,AT2BA,AOrBA,ADGA,ADGA;ADIA,AMlBA,APqBA,AMlBA,AT2BA,AOrBA,ADGA,ADGA;ADIA,AMlBA,APqBA,AMlBA,AT2BA,AOrBA,ADGA,ADGA;ADIA,AOrBA,ADGA,APqBA,AMlBA,AT2BA,AOrBA,ADGA,ADGA;AMjBA,ADGA,APqBA,AMlBA,AT2BA,AOrBA,ADGA,ADGA;AMjBA,ADGA,APqBA,AMlBA,AT2BA,AOrBA,AFMA;AMjBA,ADGA,APqBA,AMlBA,AGTA,AZoCA,AOrBA,AFMA;AMjBA,ADGA,APqBA,AMlBA,AGTA,AZoCA,AOrBA;AIXA,ADGA,APqBA,AMlBA,AGTA,AZoCA,AOrBA;AMjBA,AFMA,ADGA,APqBA,AMlBA,AGTA,ALeA;AMjBA,AFMA,ADGA,APqBA,AMlBA,AGTA,ALeA;AMjBA,AFMA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AFMA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AFMA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AFMA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AENA,AJYA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AENA,AJYA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AENA,AJYA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AGTA,ADGA,AJYA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AGTA,ADGA,AJYA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AGTA,ADGA,AJYA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,ADGA,AJYA,ADGA,APqBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,ADGA,AJYA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,ADGA,AJYA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,ADGA,AGTA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,ADGA,AGTA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,ADGA,AGTA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AJYA,AGTA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AJYA,AGTA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AJYA,AGTA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AJYA,AKfA,AFMA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AJYA,AKfA,AFMA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AJYA,AKfA,AFMA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AJYA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AJYA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AJYA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AGTA,APqBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AGTA,APqBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AGTA,APqBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AGTA,ACHA,ARwBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AGTA,ACHA,ARwBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AGTA,ACHA,ARwBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AGTA,AENA,ADGA,ARwBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AGTA,AGTA,AENA,ADGA,ARwBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AOpBA,ADGA,AIZA,ADGA,AMlBA,AENA,ADGA,ARwBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AkBrDA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AENA,ADGA,ARwBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AkBrDA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AENA,ADGA,ARwBA,AKfA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AkBrDA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AENA,ADGA,AHSA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AkBrDA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AENA,ADGA,AGTA,ANkBA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AkBrDA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AENA,ADGA,AGTA,ANkBA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AkBrDA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AENA,ADGA,AGTA,ANkBA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AkBrDA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AKfA,AHSA,ADGA,AGTA,ANkBA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA,ALeA;AkBrDA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AKfA,AHSA,ADGA,AGTA,ANkBA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AKfA,AHSA,ADGA,AGTA,ANkBA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AHSA,ADGA,AGTA,ANkBA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AHSA,ADGA,AGTA,ANkBA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AHSA,ADGA,AGTA,ANkBA,ACHA,AHSA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AHSA,ADGA,AGTA,ANkBA,ACHA,AQxBA,AXiCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AJYA,AGTA,ANkBA,ACHA,AQxBA,AXiCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AJYA,AGTA,ANkBA,ACHA,AQxBA,AXiCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AJYA,AGTA,ANkBA,ACHA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AJYA,AGTA,ANkBA,ACHA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AJYA,AGTA,ANkBA,ACHA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ADGA,AJYA,AGTA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ALeA,AGTA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ALeA,AGTA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AatCA,AXiCA,ADGA,AIZA,ADGA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AqB9DA,ARwBA,AXiCA,ADGA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AqB9DA,ARwBA,AXiCA,ADGA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AqB9DA,ARwBA,AXiCA,ADGA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,APqBA,ARwBA,AMlBA,AGTA;AqB9DA,ARwBA,AZoCA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,AgBhDA,AvBqEA,ARwBA,AMlBA,AGTA;AqB9DA,ARwBA,AZoCA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,AgBhDA,AvBqEA,ARwBA,AMlBA,AGTA;AqB9DA,ARwBA,AZoCA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AZoCA,AgBhDA,AvBqEA,ARwBA,AMlBA,AGTA;AuBpEA,AFMA,ARwBA,AZoCA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AIZA,AvBqEA,ARwBA,AMlBA,AGTA;AuBpEA,AFMA,ARwBA,AZoCA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AIZA,AvBqEA,ARwBA,AMlBA,AGTA;AuBpEA,AFMA,ARwBA,AZoCA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AIZA,AvBqEA,ARwBA,AMlBA,AGTA;AuBpEA,ACHA,AHSA,ARwBA,AZoCA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AIZA,AvBqEA,ARwBA,AMlBA,AGTA;AuBpEA,ACHA,AHSA,ARwBA,AZoCA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AIZA,AvBqEA,ARwBA,AMlBA,AGTA;AuBpEA,ACHA,AHSA,ApB4DA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AIZA,AvBqEA,ARwBA,AMlBA,AGTA;AuBpEA,ACHA,AHSA,ApB4DA,AGTA,AMlBA,AMlBA,ALeA,AS3BA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AIZA,AvBqEA,ARwBA,AMlBA,A4BpFA,AzB2EA;AuBpEA,ACHA,AHSA,ApB4DA,AS3BA,AMlBA,AIZA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,AzB2EA;AuBpEA,ACHA,AHSA,ApB4DA,AS3BA,AMlBA,AIZA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,AzB2EA;AwBvEA,AHSA,ApB4DA,AS3BA,AMlBA,AIZA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA;AqB9DA,ApB4DA,AS3BA,AMlBA,AIZA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA;AqB9DA,ApB4DA,AS3BA,AMlBA,AIZA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA;AqB9DA,ApB4DA,AS3BA,AMlBA,AIZA,ANkBA,ANkBA,AWjCA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A2BjFA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ANkBA,AKfA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A2BjFA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ANkBA,AKfA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A2BjFA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A4BpFA,ADGA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A4BpFA,ADGA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AV8BA,AQxBA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A4BpFA,ADGA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A6BvFA,ADGA,ADGA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A6BvFA,ADGA,ADGA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A6BvFA,ADGA,ADGA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,ARwBA,AMlBA,A4BpFA,ACHA,A1B8EA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AMlBA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AMlBA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AMlBA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AOrBA,ADGA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AOrBA,ADGA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AOrBA,ADGA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,ADGA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,ADGA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,ADGA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,AENA,AHSA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,A8B1FA,ArB+DA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,AENA,AHSA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,AENA,AHSA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AIZA,ADGA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,AENA,ACHA,AJYA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AGTA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,AENA,ACHA,AJYA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AGTA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,AENA,ACHA,AJYA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AGTA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,AENA,ACHA,ACHA,ALeA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AGTA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,AENA,ACHA,ACHA,ALeA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AGTA,AFMA,ACHA,AnByDA,AFMA,A4BpFA,ACHA,AQxBA,ADGA,AENA,ACHA,ACHA,ALeA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AGTA,AFMA,ACHA,ArB+DA,A4BpFA,ACHA,AQxBA,AIZA,ALeA,AENA,ACHA,ACHA,ALeA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AGTA,AFMA,ACHA,ArB+DA,A4BpFA,ACHA,AQxBA,AIZA,ALeA,AENA,ACHA,ACHA,ALeA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AGTA,AFMA,ACHA,ArB+DA,A4BpFA,ACHA,AQxBA,AIZA,ALeA,AENA,ACHA,ACHA,ALeA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AMlBA,AGTA,AFMA,ACHA,AOrBA,ACHA,AavCA,ALeA,AIZA,ALeA,AENA,ACHA,ACHA,ALeA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AOrBA,ACHA,AOrBA,ACHA,AavCA,ALeA,AIZA,ALeA,AENA,ACHA,ACHA,ALeA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AOrBA,ACHA,AOrBA,ACHA,AavCA,ALeA,AIZA,ALeA,AENA,ACHA,ACHA,ALeA,AhCgGA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AOrBA,AQxBA,ACHA,Ac1CA,ADGA,ALeA,AIZA,ALeA,AENA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AOrBA,AQxBA,ACHA,Ac1CA,ADGA,ALeA,AIZA,ALeA,AENA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AOrBA,AQxBA,ACHA,Ac1CA,ADGA,ALeA,AIZA,ALeA,AENA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AOrBA,AQxBA,ACHA,Ac1CA,ADGA,ALeA,AIZA,AHSA,ACHA,ACHA,AIZA,AzC2HA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AS3BA,AOrBA,AQxBA,ACHA,Ac1CA,ADGA,ALeA,AIZA,AHSA,ACHA,ACHA,AIZA,AzC2HA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AQxBA,ACHA,Ac1CA,ADGA,ALeA,AIZA,AHSA,ACHA,ACHA,AIZA,AzC2HA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,Ac1CA,ADGA,AGTA,ARwBA,AIZA,AHSA,ACHA,ACHA,AIZA,AzC2HA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AGTA,ARwBA,AIZA,AHSA,ACHA,ACHA,AIZA,AzC2HA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AGTA,ARwBA,AIZA,AHSA,ACHA,ACHA,AIZA,AzC2HA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,ARwBA,AIZA,AHSA,ACHA,ACHA,AIZA,AzC2HA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,ARwBA,AIZA,AHSA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,ARwBA,ACHA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AENA,AV8BA,ACHA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AENA,AV8BA,ACHA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AENA,AV8BA,ACHA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ADGA,AV8BA,ACHA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ADGA,AV8BA,ACHA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ADGA,AV8BA,ACHA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,ACHA,ACHA,ArC+GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,ACHA,ApC4GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,ACHA,ApC4GA,A6BvFA,ADGA,AENA,AHSA;ANmBA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA,AoB5DA;A1B+EA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA,AoB5DA;A1B+EA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA,AoB5DA;ACFA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA,AoB5DA;ACFA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA,AoB5DA;ACFA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA,AoB5DA;AELA,ADGA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA,AoB5DA;AELA,ADGA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,ADGA,AGTA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AsBjEA,ADGA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,ADGA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,ADGA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,ADGA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AHSA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AHSA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AHSA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,ACHA,AJYA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AFMA,AV8BA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,ACHA,AJYA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,ACHA,AJYA,A3BiFA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,ACHA,AnCyGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,ACHA,AJYA,AKfA,AhCgGA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,ACHA,AJYA,AKfA,AhCgGA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,ACHA,AJYA,AKfA,AhCgGA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AGTA,AFMA,AJYA,AKfA,AhCgGA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AGTA,AFMA,AJYA,AKfA,AhCgGA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AGTA,AFMA,AJYA,AKfA,AhCgGA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AGTA,ACHA,AHSA,AJYA,AKfA,AhCgGA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AGTA,ACHA,AHSA,AJYA,AKfA,AhCgGA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AGTA,ACHA,AHSA,ACHA,AhCgGA,ApB4DA,AgBhDA,AS3BA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ADGA,AENA,AGTA,ACHA,AHSA,ACHA,AhCgGA,ApB4DA,AgBhDA,AuCrHA,A9B0FA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AGTA,ACHA,AHSA,ACHA,AhCgGA,ApB4DA,AgBhDA,AuCrHA,A9B0FA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AGTA,ACHA,AHSA,ACHA,AhCgGA,ApB4DA,AgBhDA,AuCrHA,A9B0FA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AGTA,ACHA,AHSA,AKfA,AJYA,AhCgGA,ApB4DA,AgBhDA,AuCrHA,A9B0FA,AavCA,AIZA,AENA,ACHA,AZoCA,AlCsGA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AGTA,ACHA,AHSA,AKfA,AJYA,AhCgGA,ApB4DA,AgBhDA,AuCrHA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AGTA,ACHA,AHSA,AKfA,AJYA,AhCgGA,ApB4DA,AgBhDA,AuCrHA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AGTA,ACHA,AHSA,AKfA,AJYA,AhCgGA,ApB4DA,AgBhDA,AyC3HA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,ApB4DA,AgBhDA,AyC3HA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,ApB4DA,AgBhDA,AyC3HA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,ApB4DA,A0D9KA,A1C8HA,AyC3HA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,ApB4DA,A0D9KA,A1C8HA,AyC3HA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,ApB4DA,A0D9KA,A1C8HA,AyC3HA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AuCrHA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AuCrHA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AuCrHA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AwCxHA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AwCxHA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AwCxHA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA;AuBpEA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AENA,ACHA,A9C0IA,A6BvFA,ADGA,AENA,AHSA,AoC5GA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AGTA,A9C0IA,A6BvFA,ADGA,AENA,AHSA,AoC5GA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AGTA,A9C0IA,A6BvFA,ADGA,AENA,AHSA,AoC5GA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AoC5GA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AoC5GA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AoC5GA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AFMA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AFMA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AavCA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AFMA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AwCxHA,A3BiFA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AFMA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AwCxHA,A3BiFA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AFMA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AwCxHA,A3BiFA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AFMA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AWjCA,AzC2HA,AwCxHA,A3BiFA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AFMA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AWjCA,AzC2HA,AwCxHA,A3BiFA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AFMA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AWjCA,AzC2HA,AwCxHA,A3BiFA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AFMA;AbwCA,ACHA,AIZA,AHSA,AKfA,AJYA,AhCgGA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AWjCA,AzC2HA,AwCxHA,A3BiFA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AGTA,ALeA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AWjCA,AzC2HA,AwCxHA,A3BiFA,AIZA,AGTA,A9C0IA,AgEhMA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AGTA,ALeA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AWjCA,AzC2HA,AwCxHA,A3BiFA,AIZA,AGTA,AkBtDA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AGTA,ALeA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AWjCA,AzC2HA,AwCxHA,A3BiFA,AIZA,AGTA,AkBtDA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AGTA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AWjCA,AzC2HA,AwCxHA,A3BiFA,AIZA,AGTA,AkBtDA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AGTA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AwCxHA,A3BiFA,AIZA,AGTA,AkBtDA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AGTA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,A9B0FA,AwCxHA,A3BiFA,AIZA,AGTA,AkBtDA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AKfA,AFMA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AkBtDA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AKfA,AFMA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AkBtDA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AKfA,AFMA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AkBtDA,AnCyGA,ADGA,AENA,AHSA,AsClHA,AMlBA,ADGA,AFMA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,ADGA,AFMA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,ADGA,AFMA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,ADGA,AENA,AJYA,ACHA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,ADGA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,ApC4GA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,ADGA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,ADGA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,ADGA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,ADGA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,AGTA,AJYA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,AGTA,AJYA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,A3DiLA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,AGTA,AJYA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,AGTA,AJYA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,AGTA,AJYA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,AGTA,AJYA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AENA,AmCzGA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AiDnJA,A/C6IA,AmCzGA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AiDnJA,A/C6IA,AmCzGA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AjBmDA,ADGA,AiDnJA,A/C6IA,AmCzGA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AmCzGA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AmCzGA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AmCzGA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AiDnJA,Ad0CA,AMlBA,AGTA,AENA,ANkBA,AENA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AiDnJA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AU9BA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AiDnJA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AU9BA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AiDnJA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AU9BA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AiDnJA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AU9BA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AiDnJA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AiDnJA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AiDnJA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AiDnJA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AgChGA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AqC/GA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AqC/GA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA,ANkBA;AbwCA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AqC/GA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ADGA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ADGA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ADGA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,AFMA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,AFMA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,AFMA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,ALeA,AjDmJA,ADGA,AiDnJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,ALeA,AjDmJA,AgDhJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,ALeA,AjDmJA,AgDhJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,AT2BA,AjDmJA,AgDhJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,AT2BA,AjDmJA,AgDhJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,AT2BA,AjDmJA,AgDhJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,ACHA,AV8BA,AjDmJA,AgDhJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA,AHSA;AnB0DA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,ACHA,AV8BA,AjDmJA,AgDhJA,A/C6IA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AsBlEA,AxBwEA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,ACHA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,AENA,ADGA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,AENA,ADGA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,AENA,ADGA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,AGTA,ADGA,ADGA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,AGTA,ADGA,ADGA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,AsClHA,ACHA,ACHA,AHSA,AIZA,AGTA,ADGA,ADGA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AHSA,AKfA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,AHSA,AIZA,AGTA,ADGA,ADGA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,Ad0CA,AMlBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,AHSA,AIZA,AGTA,ADGA,ADGA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,AHSA,AIZA,AGTA,ADGA,ADGA,AV8BA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,AHSA,AIZA,AGTA,ADGA,ADGA,AIZA,Ad0CA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,AHSA,AIZA,AGTA,ADGA,ADGA,AIZA,Ad0CA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,AHSA,AIZA,AGTA,ADGA,ADGA,AIZA,Ad0CA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,AHSA,AIZA,AGTA,AGTA,AJYA,ADGA,AIZA,Ad0CA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,AHSA,AIZA,AGTA,AGTA,AJYA,ADGA,AIZA,Ad0CA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,AHSA,AIZA,AGTA,AGTA,AJYA,ADGA,AIZA,Ad0CA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,ADGA,Ae7CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,ACHA,AGTA,AGTA,AJYA,ADGA,AIZA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,ACHA,AGTA,AGTA,AJYA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,ACHA,AGTA,AGTA,AJYA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,APqBA,ACHA,ACHA,ACHA,AGTA,AGTA,AENA,ANkBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,ACHA,ACHA,AGTA,AGTA,AENA,ANkBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,ACHA,ACHA,AGTA,AGTA,AENA,ANkBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,ACHA,ACHA,AGTA,AGTA,AENA,ACHA,APqBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,ACHA,ACHA,AGTA,AGTA,AENA,ACHA,APqBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,ACHA,ACHA,AGTA,AGTA,AENA,ACHA,APqBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,AKfA,AGTA,AIZA,AFMA,ACHA,APqBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,AKfA,AGTA,AIZA,AFMA,ACHA,APqBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,AKfA,AGTA,AIZA,AFMA,ACHA,APqBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,AKfA,AGTA,AKfA,ADGA,AFMA,ACHA,APqBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,AKfA,AGTA,AKfA,ADGA,AFMA,ACHA,APqBA,AGTA,AENA,AhBgDA,AjDmJA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,ANkBA,AKfA,AGTA,AKfA,ADGA,AFMA,ACHA,APqBA,AGTA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,Ac1CA,A1E8NA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,Ad0CA,AKfA,AGTA,AKfA,ADGA,AFMA,ACHA,APqBA,AGTA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,Ad0CA,AKfA,AGTA,AKfA,ADGA,AFMA,ACHA,APqBA,AGTA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,AT2BA,AGTA,AKfA,ADGA,AFMA,ACHA,APqBA,AGTA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,AV8BA,AGTA,AKfA,ADGA,AFMA,ACHA,APqBA,AGTA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AFMA,AyB3EA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,AV8BA,AGTA,AKfA,ADGA,AFMA,ACHA,APqBA,AGTA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,AV8BA,AGTA,AKfA,ADGA,AFMA,ACHA,APqBA,AGTA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,ACHA,AXiCA,AGTA,AKfA,ADGA,AFMA,ACHA,AJYA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,ACHA,AXiCA,AGTA,AKfA,ADGA,AFMA,ACHA,AJYA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,ACHA,AXiCA,AGTA,AKfA,ADGA,AFMA,ACHA,AJYA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,ACHA,AXiCA,AGTA,AKfA,ADGA,AFMA,ACHA,AMlBA,AV8BA,AENA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,ACHA,AXiCA,AGTA,AKfA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AGTA,AENA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,ACHA,AXiCA,AQxBA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,ACHA,AoD5JA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,A6CvIA,AQxBA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,A0E9NA,AzE2NA,AoD5JA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,A0E9NA,AzE2NA,AoD5JA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,A0E9NA,AzE2NA,AoD5JA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,A0E9NA,AzE2NA,A0E9NA,AtBkEA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,A0E9NA,AzE2NA,A0E9NA,AtBkEA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,Af6CA,A3BiFA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,A0E9NA,AzE2NA,A0E9NA,AtBkEA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,A0E9NA,AzE2NA,A0E9NA,ACHA,AvBqEA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,A0E9NA,AzE2NA,A0E9NA,ACHA,AvBqEA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AjEmMA,A0E9NA,AzE2NA,A0E9NA,ACHA,AvBqEA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AYpCA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AvBqEA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AGTA,AqD/JA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AYpCA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AvBqEA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AwDxKA,ACHA,ACHA,AHSA,ADGA,AFMA,ACHA,AMlBA,ARwBA,AYpCA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AvBqEA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AwDxKA,ACHA,ACHA,AHSA,ADGA,ADGA,AMlBA,ARwBA,AYpCA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,AzB2EA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AwDxKA,ACHA,ACHA,AHSA,ADGA,ADGA,AMlBA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,AzB2EA,AHSA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AwDxKA,ACHA,ACHA,AHSA,ADGA,ADGA,AMlBA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,A5BoFA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AwDxKA,ACHA,ACHA,AHSA,ADGA,AKfA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,A7BuFA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AwDxKA,ACHA,ACHA,AHSA,ADGA,AKfA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,A7BuFA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AwDxKA,ACHA,ACHA,AHSA,ADGA,AKfA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,A7BuFA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AwDxKA,ACHA,ACHA,AHSA,AIZA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,ACHA,A9B0FA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AyD3KA,ACHA,AHSA,AIZA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,ACHA,A9B0FA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AyD3KA,ACHA,AHSA,AIZA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,ACHA,A9B0FA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,AIZA,AyD3KA,ACHA,ACHA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AENA,ADGA,A9B0FA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,A8D1LA,ACHA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AENA,ADGA,A9B0FA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,A8D1LA,ACHA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AENA,ADGA,A9B0FA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,A8D1LA,ACHA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,A5DoLA,A0D9KA,ADGA,AuBrEA,A1C8HA,A8D1LA,ACHA,AIZA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,AFMA,ADGA,AnByDA,A8D1LA,AKfA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AENA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,AFMA,ADGA,AnByDA,A8D1LA,AKfA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AIZA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AIZA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AIZA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AyC3HA,ADGA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AwCxHA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,A0E9NA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AwCxHA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,AqF/PA,AXiCA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,AgBhDA,ApD4JA,AwCxHA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,AqF/PA,AXiCA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AwCxHA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,AqF/PA,AXiCA,AzE2NA,A0E9NA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AwCxHA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AwCxHA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AwCxHA,AFMA,ADGA,AnByDA,AmEzMA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AwCxHA,AFMA,ADGA,AnByDA,A6EvOA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A6EvOA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A6EvOA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AXiCA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,Af6CA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,Af6CA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,Af6CA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,ARwBA,AKfA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,A7EuOA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,AHSA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,Ae7CA,A5FoRA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,ACHA,AENA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,AHSA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,Ae7CA,A5FoRA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,AGTA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AhCgGA,AHSA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,Ae7CA,A5FoRA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,AGTA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,Ae7CA,ACHA,A7FuRA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,AGTA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA,AJYA;AtBmEA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,Ae7CA,ACHA,A7FuRA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,AGTA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,Ae7CA,ACHA,A7FuRA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,AGTA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AiBnDA,AFMA,ACHA,A7FuRA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,AGTA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AiBnDA,AFMA,ACHA,A7FuRA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AhBgDA,AGTA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AiBnDA,AFMA,ACHA,A7FuRA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AiBnDA,AFMA,ACHA,AENA,A/F6RA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AiBnDA,AFMA,ACHA,AENA,A/F6RA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AiBnDA,AFMA,ACHA,AENA,A/F6RA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AmBzDA,AFMA,AFMA,ACHA,AENA,A/F6RA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AmBzDA,AFMA,AFMA,ACHA,AENA,A/F6RA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AmBzDA,AFMA,AFMA,ACHA,AENA,A/F6RA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AoB5DA,ADGA,AFMA,AFMA,ACHA,AENA,A/F6RA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ACHA,AFMA,AV8BA,AoB5DA,ADGA,AFMA,AFMA,ACHA,AENA,A/F6RA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AoB5DA,ADGA,AFMA,AFMA,ACHA,AENA,A/F6RA,AqF/PA,AXiCA,AzE2NA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AoB5DA,ADGA,AFMA,AFMA,AMlBA,ALeA,AENA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AoB5DA,ADGA,AFMA,AFMA,AMlBA,ALeA,AENA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AKfA,ADGA,AFMA,ADGA,AENA,AnCyGA;A1B+EA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AoB5DA,ADGA,AFMA,AFMA,AMlBA,ALeA,AENA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AENA,AnCyGA;AoD3JA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AoB5DA,ADGA,AFMA,AFMA,AMlBA,ALeA,AENA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AENA,AnCyGA;AoD3JA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AoB5DA,ADGA,AFMA,AFMA,AMlBA,ALeA,AENA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AENA;AiBlDA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AoB5DA,ADGA,AFMA,AFMA,AMlBA,ALeA,AENA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AENA;AiBlDA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,ALeA,AENA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AENA;AiBlDA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AENA;AiBlDA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AENA;AiBlDA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AENA,AmBzDA;AFOA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA;AFOA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,AnByDA,A8E1OA,ADGA,AV8BA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA;AFOA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AV8BA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA;AHUA,A9E0OA,ACHA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AV8BA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA;AHUA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AV8BA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA;AHUA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,AHSA,ADGA,AFMA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA;AHUA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,AHSA,AHSA,AFMA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA;AHUA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,AHSA,ALeA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA;AELA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,AHSA,ALeA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA;AELA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA;AELA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA;AELA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,AMlBA,AHSA,A/F6RA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AGTA;ADIA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AGTA;ADIA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AGTA;ADIA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AGTA,ACHA;AFOA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AGTA,ACHA;AFOA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AGTA,ACHA;AFOA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AGTA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AGTA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AGTA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AMlBA,AHSA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AgBhDA,A1B8EA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AMlBA,AHSA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,ADGA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AFMA,ADGA,AqB/DA,ACHA,AMlBA,AHSA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A+E7OA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AMlBA,AHSA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A+E7OA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AMlBA,AHSA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A+E7OA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AMlBA,AHSA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A+E7OA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AqF/PA,AIZA,ACHA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A+E7OA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AyF3QA,ACHA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A+E7OA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AyF3QA,ACHA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,ACHA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A+E7OA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,AyF3QA,ACHA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A+E7OA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A+E7OA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,ACHA;AHUA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,ACHA,AMlBA;AT4BA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,ADGA,AV8BA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,ACHA,AMlBA;AT4BA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,ACHA,AMlBA;AT4BA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,APqBA,AMlBA;AT4BA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,APqBA,AMlBA;AT4BA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,APqBA,AMlBA;AT4BA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,APqBA,AMlBA,AENA;AXkCA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,APqBA,AMlBA,AENA;AXkCA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AhFgPA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,AqF/PA,ApF4PA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AqB/DA,ACHA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,APqBA,AMlBA,AENA;AXkCA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,ACHA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,APqBA,AMlBA,AENA;AXkCA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,ACHA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,APqBA,AMlBA,AENA;AXkCA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,ACHA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,APqBA,AMlBA,AENA;AXkCA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AXiCA,AuBrEA,ARwBA,A5FoRA,ACHA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AV8BA,AMlBA,AENA;AXkCA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AYpCA,ARwBA,A5FoRA,ACHA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AV8BA,AMlBA,AENA;AXkCA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AYpCA,ARwBA,A5FoRA,ACHA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AV8BA,AMlBA,AENA;AXkCA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AYpCA,ARwBA,A5FoRA,ACHA,A0F9QA,AbuCA,ACHA,AIZA,AHSA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AV8BA,AMlBA,AENA,AGTA;Ad2CA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AYpCA,ARwBA,A5FoRA,ACHA,A0F9QA,AbuCA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AV8BA,AMlBA,AENA,AGTA;Ad2CA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AYpCA,ARwBA,A5FoRA,ACHA,A0F9QA,AbuCA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AV8BA,AMlBA,AENA,AGTA;Ad2CA,ALeA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AYpCA,ARwBA,A5FoRA,A2FjRA,AbuCA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AZoCA,AMlBA,AENA,AGTA;AnB0DA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,AvFqQA,A2DjLA,AYpCA,ARwBA,A5FoRA,A2FjRA,AbuCA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AZoCA,AMlBA,AENA,AGTA;AnB0DA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A2FjRA,AbuCA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AZoCA,AMlBA,AENA,AGTA;AnB0DA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A2FjRA,AbuCA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AZoCA,AMlBA,AENA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A2FjRA,AbuCA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AZoCA,AMlBA,AENA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A2FjRA,AbuCA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AZoCA,AMlBA,AENA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AENA,Ad0CA,AMlBA,AENA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AENA,Ad0CA,AMlBA,AENA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AENA,Ad0CA,AMlBA,AENA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AENA,Ad0CA,AMlBA,AS3BA,APqBA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AENA,Ad0CA,AMlBA,AS3BA,APqBA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,AkFtPA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AENA,Ad0CA,AMlBA,AS3BA,APqBA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AENA,Ad0CA,AMlBA,AS3BA,APqBA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AENA,Ad0CA,AMlBA,AS3BA,APqBA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AGTA,AENA,AENA,Ad0CA,AMlBA,AS3BA,APqBA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AENA,ApC4GA,AsClHA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AU9BA,APqBA,AENA,AENA,Ad0CA,AMlBA,AS3BA,APqBA,AGTA,AENA;ArBgEA,A7EuOA,AIZA,AlCsGA,AsClHA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AU9BA,APqBA,AENA,AENA,Ad0CA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AlCsGA,AsClHA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AHSA,AMlBA,ALeA,AQxBA,AU9BA,APqBA,AENA,AENA,Ad0CA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AQxBA,AU9BA,APqBA,AENA,AENA,AIZA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AQxBA,AU9BA,APqBA,AENA,AENA,AIZA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AkBtDA,APqBA,AENA,AENA,AIZA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AoB5DA,AFMA,APqBA,AENA,AENA,AIZA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AoB5DA,AFMA,APqBA,AENA,AENA,AIZA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AoB5DA,AFMA,APqBA,AENA,AENA,AIZA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AoB5DA,AFMA,APqBA,AENA,AENA,AIZA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AoB5DA,AFMA,APqBA,AENA,AENA,AIZA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AoB5DA,AFMA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AIZA,A6FvRA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AoB5DA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AoB5DA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AoB5DA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,ACHA,ACHA,AsBlEA,AQxBA,AFMA,AGTA,ALeA,AuBrEA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,AQxBA,AFMA,AGTA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,AQxBA,AFMA,AGTA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A4BpFA,ApB4DA,AFMA,AGTA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A4BpFA,ApB4DA,AFMA,AGTA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A4BpFA,ApB4DA,AFMA,AGTA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A4BpFA,ACHA,ArB+DA,AFMA,AGTA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A4BpFA,ACHA,ArB+DA,AFMA,AGTA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,A5BoFA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A4BpFA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,AgBhDA,A5CoIA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A4BpFA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AHSA,AOrBA,AgBhDA,A5CoIA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A4BpFA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AIZA,AgBhDA,A5CoIA,AYpCA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A4BpFA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AS3BA,APqBA;AlGuSA,AIZA,AiGnSA,AXiCA,AIZA,AgBhDA,AhCgGA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A+B7FA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AiGnSA,AXiCA,AIZA,AgBhDA,AhCgGA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A+B7FA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,AMlBA,AS3BA,APqBA,AGTA,AENA;AlGuSA,AIZA,AiGnSA,AXiCA,AIZA,AgBhDA,AhCgGA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,A+B7FA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,Ae7CA,APqBA,AGTA,AENA;AlGuSA,AIZA,AiGnSA,AXiCA,AIZA,AgBhDA,AhCgGA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,AgChGA,ADGA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,Ae7CA,APqBA,AGTA,AENA;AlGuSA,AIZA,AiGnSA,AXiCA,AoB5DA,AhCgGA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,AgChGA,ADGA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,Ae7CA,APqBA,AGTA,AENA;AlGuSA,AIZA,AiGnSA,AXiCA,AoB5DA,AhCgGA,ARwBA,A5FoRA,A8E1OA,AENA,AsBlEA,AgChGA,ADGA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,Ae7CA,APqBA,AGTA,AENA;AlGuSA,AIZA,AiGnSA,AXiCA,AoB5DA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,Ae7CA,APqBA,AGTA,AENA;AlGuSA,AIZA,AiGnSA,AXiCA,AoB5DA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AJYA,APqBA,AENA,AMlBA,AlBsDA,Ae7CA,APqBA,AGTA,AENA;AlGuSA,AIZA,AiGnSA,AXiCA,AoB5DA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AXiCA,AENA,AMlBA,AlBsDA,Ae7CA,APqBA,AGTA,AENA;AlGuSA,AIZA,A8G1UA,AbuCA,AXiCA,AoB5DA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AENA,AXiCA,AENA,AMlBA,AlBsDA,Ae7CA,APqBA,AGTA,AENA;AlGuSA,AIZA,A8G1UA,AbuCA,AXiCA,AoB5DA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AHSA,ACHA,ArB+DA,ACHA,AkBtDA,AHSA,AT2BA,AENA,AMlBA,AlBsDA,Ae7CA,APqBA,AGTA,AENA;AlGuSA,AIZA,A8G1UA,AbuCA,AXiCA,AoB5DA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,ACHA,AkBtDA,AHSA,AT2BA,AENA,AMlBA,AHSA,APqBA,AGTA,AENA;AlGuSA,AIZA,A+G7UA,ADGA,AJYA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,ACHA,AkBtDA,AHSA,AT2BA,AENA,AMlBA,AHSA,APqBA,AGTA,AENA;AlGuSA,AIZA,A+G7UA,ADGA,AJYA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,ACHA,AkBtDA,AHSA,AT2BA,AENA,AMlBA,AHSA,APqBA,AGTA,AENA;AlGuSA,AIZA,A+G7UA,ADGA,AJYA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,APqBA,AGTA,AENA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AxCwHA,A5FoRA,A8E1OA,AENA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,AJYA,AENA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AxCwHA,A5FoRA,AgFhPA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,AJYA,AENA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AxCwHA,A5FoRA,AgFhPA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,AJYA,AENA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,AJYA,AENA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,AJYA,AENA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,ADGA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,AJYA,AENA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,AKfA,ANkBA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,AJYA,AENA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,AKfA,ANkBA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,AFMA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,AKfA,ANkBA,ADGA,AFMA,ArB+DA,AmBzDA,AHSA,AT2BA,AENA,AMlBA,AHSA,AFMA;AlGuSA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,AKfA,ANkBA,ADGA,AFMA,ArB+DA,AmBzDA,AZoCA,AENA,AMlBA,AHSA,AFMA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,AKfA,ANkBA,ADGA,AFMA,ArB+DA,AmBzDA,AZoCA,AENA,AMlBA,AHSA,AFMA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,AKfA,ANkBA,ADGA,AFMA,ArB+DA,AOrBA,AENA,AMlBA,AHSA,AFMA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AENA,AMlBA,AHSA,AFMA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,AHSA,AFMA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AFMA,AJYA,AOrBA,A/C6IA,A5FoRA,AgFhPA,AuDrKA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,AHSA,AFMA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AFMA,AOrBA,AXiCA,AOrBA,A/C6IA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AFMA,AOrBA,AXiCA,AOrBA,A/C6IA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AKfA,AXiCA,AOrBA,A/C6IA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,A/C6IA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,A/C6IA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,A/C6IA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AMlBA,ArD+JA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AMlBA,ArD+JA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AMlBA,ArD+JA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,ArB+DA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AMlBA,ArD+JA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,Ae7CA,ApC4GA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AMlBA,ArD+JA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,Ae7CA,ApC4GA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AMlBA,ArD+JA,A5FoRA,AuIrZA,AKfA,ANkBA,AQxBA,AT2BA,AFMA,Ae7CA,ApC4GA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AMlBA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AMlBA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AMlBA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AS3BA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AQxBA,ALeA,AqB/DA;AvHsWA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AS3BA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AQxBA,ALeA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AS3BA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AU9BA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AU9BA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AU9BA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,ADGA,AXiCA,AOrBA,AWjCA,ADGA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,Ae7CA,ACHA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AWjCA,ADGA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AWjCA,ADGA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,ADGA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,ADGA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,ADGA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;AlGuSA,AIZA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AHSA,ArD+JA,A5FoRA,AuIrZA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AHSA,ArD+JA,A5FoRA,AyJ3cA,AlBsDA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AHSA,ArD+JA,A5FoRA,AyJ3cA,AlBsDA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AHSA,ArD+JA,A5FoRA,AyJ3cA,AlBsDA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AOrBA,AGTA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AHSA,ArD+JA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AU9BA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AHSA,ArD+JA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AU9BA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AxDwKA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AQxBA,AT2BA,AFMA,AgBhDA,ArC+GA,AU9BA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AHSA,ADGA,AxDwKA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA,AU9BA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,A5DoLA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA,AU9BA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,A5DoLA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA,AU9BA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AIZA,AhEgMA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA,AU9BA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AIZA,AhEgMA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA,AU9BA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AIZA,AhEgMA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA,AU9BA;A9F2RA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ADGA,AhEgMA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ADGA,AhEgMA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ADGA,AhEgMA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AhEgMA,A5FoRA,A0J9cA,ADGA,AlBsDA,ADGA,AqB/DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AhEgMA,A5FoRA,A0J9cA,ADGA,AlBsDA,AoB5DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AhEgMA,A5FoRA,A0J9cA,ADGA,AlBsDA,AoB5DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AGTA,AnEyMA,A5FoRA,A0J9cA,ADGA,AlBsDA,AoB5DA,AbuCA,AT2BA,AFMA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AGTA,AnEyMA,A5FoRA,A0J9cA,ADGA,AlBsDA,AoB5DA,AtBkEA,AFMA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AGTA,AnEyMA,A5FoRA,A0J9cA,ADGA,AlBsDA,AoB5DA,AtBkEA,AFMA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AIZA,ADGA,AnEyMA,A5FoRA,A0J9cA,ADGA,AENA,AxBwEA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AIZA,ADGA,AnEyMA,A5FoRA,A2JjdA,AxBwEA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AIZA,ADGA,AnEyMA,A5FoRA,A2JjdA,AxBwEA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,ADGA,AnEyMA,A5FoRA,A2JjdA,AxBwEA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,ADGA,AnEyMA,A5FoRA,A2JjdA,AxBwEA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,ADGA,AnEyMA,A5FoRA,A2JjdA,AxBwEA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AHSA,AnEyMA,A5FoRA,A2JjdA,AxBwEA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AHSA,AnEyMA,A5FoRA,A2JjdA,AxBwEA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AMlBA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AHSA,AnEyMA,A5FoRA,AmIzYA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AyB3EA,AnByDA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AHSA,AnEyMA,A5FoRA,AmIzYA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AyB3EA,AnByDA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AHSA,AnEyMA,A5FoRA,AmIzYA,AgBhDA,ArC+GA;ApF6PA,A+G7UA,ACHA,AyB3EA,AnByDA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AHSA,AnEyMA,A5FoRA,AmIzYA,ArB+DA;ApF6PA,A+G7UA,ACHA,A0B9EA,ADGA,AnByDA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AHSA,AnEyMA,A5FoRA,AmIzYA,ArB+DA;ApF6PA,A+G7UA,ACHA,A0B9EA,ADGA,AnByDA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AHSA,AnEyMA,A5FoRA,AmIzYA,ArB+DA;ApF6PA,A+G7UA,ACHA,A0B9EA,ADGA,AnByDA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AtEkNA,A5FoRA,AmIzYA,ArB+DA;ApF6PA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AnByDA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AtEkNA,A5FoRA,AmIzYA,ArB+DA;ApF6PA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AnByDA,AZoCA,AOrBA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AtEkNA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AnByDA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AtEkNA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AnByDA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AnByDA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AnByDA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AIZA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AIZA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AIZA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AKfA,ADGA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AKfA,ADGA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AKfA,ADGA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA,AmIzYA;AzG4TA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AKfA,ACHA,AFMA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AKfA,ACHA,AFMA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AKfA,ACHA,AFMA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AIZA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AFMA,AKfA,ACHA,AFMA,AvBqEA,ALeA,AYpCA,ADGA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AGTA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AGTA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AMlBA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AMlBA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AMlBA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ADGA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ADGA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AKfA,ADGA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ADGA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AJYA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AHSA,ACHA,AFMA,AvBqEA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AHSA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AHSA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AIZA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AIZA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AIZA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AKfA,ADGA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AKfA,ADGA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AKfA,ADGA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AKfA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AKfA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AKfA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AIZA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AFMA,AKfA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AsBlEA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AsBlEA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AsBlEA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AuBrEA,ADGA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AuBrEA,ADGA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AuBrEA,ADGA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,ADGA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,ALeA,AWjCA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,ADGA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,ADGA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,AENA,AHSA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,AENA,AHSA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,AENA,AHSA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA;A0B7EA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AFMA,APqBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,AENA,AHSA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A5FoRA,AsLliBA;A5JqdA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,AENA,AHSA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA;A5JqdA,A+G7UA,ACHA,A0B9EA,ACHA,AOrBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,AENA,AHSA,AlBsDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA;A5JqdA,A+G7UA,ACHA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,AENA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,ACHA;A7JwdA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ADGA,AENA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,ACHA;A7JwdA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,ACHA;A7JwdA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ADGA;A7JwdA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ADGA;A7JwdA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ADGA;A7JwdA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AFMA;A7JwdA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AFMA;A7JwdA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AFMA;A7JwdA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AFMA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AFMA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AFMA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,ACHA,AGTA,ACHA,AT2BA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AENA,AJYA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AENA,AJYA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ACHA,AFMA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AENA,AJYA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AENA,ACHA,ALeA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AENA,ACHA,ALeA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0F9QA,AENA,ACHA,AENA,ACHA,ALeA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AENA,AKfA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,ACHA,ACHA,ANkBA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,ACHA,ACHA,ANkBA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,ACHA,ACHA,ANkBA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,AGTA,AFMA,ACHA,ANkBA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,AGTA,AFMA,ACHA,ANkBA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,ACHA,AzB2EA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,AGTA,AFMA,ACHA,ANkBA,AGTA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ALeA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ALeA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ALeA;AhKieA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ALeA,AMlBA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AOrBA,ADGA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ALeA,AMlBA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AMlBA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AENA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ALeA,AMlBA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AMlBA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ALeA,AMlBA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AMlBA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ALeA,AMlBA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AMlBA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4FpRA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ALeA,AMlBA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AMlBA,AMlBA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AsGlTA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AsGlTA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AsGlTA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AQxBA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AsGlTA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AsGlTA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AsGlTA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AwGxTA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AwGxTA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AwGxTA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AyG3TA,ADGA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AyG3TA,ADGA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,AyG3TA,ADGA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,A0B9EA,AQxBA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0G9TA,ADGA,ADGA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0G9TA,ADGA,ADGA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0G9TA,ADGA,ADGA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0G9TA,ADGA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0G9TA,ADGA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A0G9TA,ADGA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,AFMA,ADGA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,AFMA,ADGA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,AFMA,ADGA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,ADGA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AYpCA,AwBxEA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,ADGA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,ADGA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,ARwBA,AxBwEA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,AIZA,ALeA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,AIZA,ALeA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,AIZA,ALeA,AENA,AHSA,AFMA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,AIZA,ACHA,ANkBA,AENA,ALeA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,AIZA,ACHA,ANkBA,AENA,ALeA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,AIZA,ACHA,ANkBA,AENA,ALeA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ACHA,ANkBA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AENA,ALeA,AV8BA,ACHA,AQxBA,ANkBA,AGTA,AFMA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AENA,ALeA,AV8BA,ACHA,AQxBA,ANkBA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AENA,ALeA,AV8BA,ACHA,AQxBA,ANkBA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,ANkBA,ALeA,AV8BA,ACHA,AQxBA,ANkBA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,ANkBA,ALeA,AV8BA,ACHA,AQxBA,ANkBA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,ANkBA,ALeA,AV8BA,ACHA,AQxBA,ANkBA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AkCtGA,AIZA,AhCgGA,AoC5GA,ACHA,ArB+DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,ANkBA,AOrBA,AZoCA,AV8BA,ACHA,AQxBA,ANkBA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AoC5GA,ApB4DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,ANkBA,AOrBA,AZoCA,AV8BA,ACHA,AQxBA,ANkBA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AoC5GA,ApB4DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,ANkBA,AOrBA,AZoCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AoC5GA,ApB4DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,ANkBA,AOrBA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AoC5GA,ApB4DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,ANkBA,AOrBA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AoC5GA,ApB4DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,ANkBA,AOrBA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AoC5GA,ApB4DA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AOrBA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AgBhDA,AENA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AOrBA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AkBtDA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AOrBA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AkBtDA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AU9BA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AkBtDA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AU9BA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AkBtDA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AIZA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AU9BA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AkBtDA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AGTA,ANkBA,AYpCA,ARwBA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AU9BA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AkBtDA,AQxBA,AIZA,ARwBA,A1E8NA,A4GpUA,ACHA,AHSA,AYpCA,ARwBA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AU9BA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AkBtDA,AQxBA,AJYA,A1E8NA,A4GpUA,ACHA,AHSA,AYpCA,ARwBA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AU9BA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA,ACHA;AtKmfA,AgHhVA,AsClHA,AhCgGA,AkBtDA,AQxBA,AJYA,A1E8NA,A4GpUA,ACHA,AHSA,AYpCA,ARwBA,ACHA,ANkBA,AQxBA,AGTA,AT2BA,AYpCA,AFMA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AMlBA,AkBtDA,AQxBA,AJYA,A1E8NA,A4GpUA,ACHA,AHSA,AYpCA,APqBA,ANkBA,AQxBA,AGTA,AT2BA,AYpCA,AFMA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AMlBA,AkBtDA,AQxBA,AJYA,A1E8NA,A4GpUA,ACHA,AHSA,AYpCA,APqBA,ANkBA,AQxBA,AGTA,AT2BA,AYpCA,AFMA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AMlBA,AkBtDA,AQxBA,AJYA,A1E8NA,A4GpUA,ACHA,AHSA,AYpCA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AMlBA,AkBtDA,AQxBA,AJYA,A1E8NA,A4GpUA,ACHA,AHSA,AYpCA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AMlBA,AkBtDA,AQxBA,AJYA,A1E8NA,A4GpUA,ACHA,AHSA,AYpCA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AMlBA,AkBtDA,AQxBA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AHSA,AYpCA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AMlBA,AkBtDA,AQxBA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AHSA,AYpCA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AwBxEA,AQxBA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AHSA,AYpCA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AbuCA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AwBxEA,AQxBA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AHSA,AYpCA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AOrBA,ApB4DA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AwBxEA,AQxBA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AHSA,AYpCA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AOrBA,ApB4DA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AHSA,AYpCA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AOrBA,ApB4DA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AS3BA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AOrBA,ACHA,ArB+DA,AV8BA,ACHA,AENA,ACHA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AS3BA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AOrBA,ACHA,ArB+DA,AV8BA,ACHA,AGTA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AS3BA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AOrBA,ACHA,ArB+DA,AV8BA,ACHA,AGTA,ALeA,AYpCA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,A4GpUA,AavCA,AZoCA,AS3BA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AS3BA,AFMA,ACHA,ArB+DA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,A4GpUA,AavCA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AS3BA,AFMA,ACHA,ArB+DA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,A4GpUA,AavCA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AS3BA,AFMA,ACHA,ArB+DA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,A4GpUA,AavCA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AS3BA,AFMA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AS3BA,AFMA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AS3BA,AFMA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AWjCA,AFMA,AFMA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AWjCA,AFMA,AFMA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AWjCA,AFMA,AFMA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AWjCA,ACHA,AHSA,AFMA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AWjCA,ACHA,AHSA,AFMA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,AbuCA,AYpCA,AFMA,AHSA,ACHA,AWjCA,ACHA,AHSA,AFMA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,ADGA,AFMA,AHSA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,AJYA,A1E8NA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AENA,AvBqEA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,A9E0OA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AENA,AIZA,A3BiFA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,A9E0OA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AENA,AIZA,A3BiFA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,A9E0OA,AyH3WA,AHSA,APqBA,AENA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AENA,AIZA,A3BiFA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,A9E0OA,AyH3WA,AHSA,ALeA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AENA,AIZA,ACHA,A5BoFA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,AgChGA,A9E0OA,AyH3WA,AHSA,ALeA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AENA,AIZA,ACHA,A5BoFA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,A9C0IA,AyH3WA,AHSA,ALeA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AENA,AIZA,ACHA,A5BoFA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,A9C0IA,AyH3WA,AHSA,ALeA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,A9C0IA,AyH3WA,AHSA,ALeA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,ACHA,AGTA,AOrBA,AJYA;ArKgfA,AgHhVA,A9C0IA,AyH3WA,AHSA,ALeA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AIZA,ANkBA,ACHA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,ACHA,AGTA,AOrBA;AzK4fA,AgHhVA,A9C0IA,AyH3WA,AHSA,ALeA,AGTA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AQxBA,AJYA,ANkBA,ACHA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,A9C0IA,AyH3WA,AHSA,AFMA,AIZA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AQxBA,AJYA,ANkBA,ACHA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,A9C0IA,AyH3WA,AHSA,AENA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AQxBA,AJYA,ANkBA,ACHA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AuFrQA,ArI+YA,AyH3WA,ADGA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AuFrQA,ArI+YA,AyH3WA,ADGA,ADGA,ALeA,ACHA,AWjCA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AuFrQA,ArI+YA,AyH3WA,ADGA,ADGA,AJYA,AWjCA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AwFxQA,ADGA,ArI+YA,AyH3WA,ADGA,ADGA,AJYA,AWjCA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AwFxQA,ADGA,ArI+YA,AyH3WA,ADGA,ADGA,AOrBA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AwFxQA,ADGA,ArI+YA,AyH3WA,ADGA,ADGA,AOrBA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AwFxQA,ADGA,AENA,AvIqZA,AyH3WA,ADGA,ADGA,AOrBA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AwFxQA,ADGA,AENA,AvIqZA,AyH3WA,ADGA,ADGA,AOrBA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AwFxQA,ADGA,AENA,AvIqZA,AyH3WA,ADGA,ADGA,AOrBA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA,AOrBA;AzK4fA,AgHhVA,AwFxQA,AENA,AHSA,AENA,AvIqZA,AyH3WA,ADGA,AMlBA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA;AlKueA,AgHhVA,AwFxQA,AENA,AHSA,AENA,AvIqZA,AyH3WA,ADGA,AMlBA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA;AlKueA,AgHhVA,AwFxQA,AENA,AHSA,AENA,AvIqZA,AyH3WA,ADGA,AMlBA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA;AlKueA,AgHhVA,AwFxQA,AENA,ACHA,AJYA,AENA,AvIqZA,AyH3WA,ADGA,AMlBA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA;AlKueA,AgHhVA,AwFxQA,AENA,ACHA,AJYA,AENA,AvIqZA,AyH3WA,AKfA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA;AlKueA,AgHhVA,AwFxQA,AENA,ACHA,AJYA,AENA,AvIqZA,AyH3WA,AKfA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA;AlKueA,AgHhVA,AwFxQA,AENA,ACHA,AJYA,AKfA,AHSA,AvIqZA,A8H1XA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA;AlKueA,AgHhVA,AwFxQA,AENA,ACHA,AJYA,AKfA,AHSA,AvIqZA,A8H1XA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA;AlKueA,AgHhVA,A0F9QA,ACHA,AJYA,AKfA,AHSA,AvIqZA,A8H1XA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,ACHA,A5BoFA,AV8BA,AIZA;AlKueA,AgHhVA,A0F9QA,ACHA,AJYA,AKfA,AHSA,AIZA,A3IiaA,A8H1XA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,A3BiFA,AV8BA,AIZA;AlKueA,AgHhVA,A0F9QA,ACHA,AJYA,AKfA,AHSA,AIZA,A3IiaA,A8H1XA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,A3BiFA,AV8BA,AIZA;AlKueA,AgHhVA,A0F9QA,ACHA,AJYA,AKfA,ACHA,A3IiaA,A8H1XA,ACHA,AHSA,AQxBA,AJYA,ALeA,AQxBA,ANkBA,AIZA,A3BiFA,AV8BA,AIZA;AlKueA,AgHhVA,A0F9QA,ACHA,AJYA,AKfA,AENA,ADGA,A3IiaA,A8H1XA,ACHA,AHSA,AQxBA,AJYA,AGTA,ANkBA,AIZA,A3BiFA,AV8BA,AIZA;AlKueA,AgHhVA,A0F9QA,ACHA,ACHA,AENA,ADGA,A3IiaA,A8H1XA,ACHA,AHSA,AQxBA,AJYA,AGTA,ANkBA,AIZA,A3BiFA,AV8BA,AIZA;AlKueA,AgHhVA,A2FjRA,ACHA,AENA,ADGA,A3IiaA,A8H1XA,ACHA,AHSA,AQxBA,AJYA,AGTA,ANkBA,AIZA,ArC+GA,AIZA;AlKueA,AgHhVA,A2FjRA,ACHA,AENA,ADGA,A3IiaA,A8H1XA,ACHA,AKfA,AJYA,AGTA,ANkBA,AIZA,AYpCA,AjDmJA,AIZA;AlKueA,AgHhVA,A2FjRA,ACHA,AENA,ADGA,A3IiaA,A8H1XA,ACHA,AKfA,AJYA,AGTA,ANkBA,AIZA,AYpCA,AjDmJA,AIZA;AlKueA,AgHhVA,A4FpRA,AENA,ADGA,A3IiaA,A8H1XA,ACHA,AKfA,AJYA,AGTA,ANkBA,AIZA,AYpCA,AjDmJA,AIZA;AlKueA,AgHhVA,A4FpRA,AENA,ADGA,A3IiaA,A8H1XA,ACHA,AKfA,AJYA,AGTA,ANkBA,AIZA,AavCA,ADGA,AjDmJA,AIZA;AlKueA,AgHhVA,A4FpRA,AENA,ADGA,A3IiaA,A8H1XA,AMlBA,AJYA,AGTA,ANkBA,AIZA,AavCA,ADGA,AjDmJA,AIZA;AlKueA,AgHhVA,A8F1RA,ADGA,A3IiaA,A8H1XA,AMlBA,AJYA,AGTA,ANkBA,AIZA,AavCA,ADGA,AjDmJA,AIZA;AlKueA,AgHhVA,A8F1RA,ADGA,A3IiaA,A8H1XA,AMlBA,AJYA,AGTA,ANkBA,AIZA,AavCA,ADGA,AENA,AnDyJA,AIZA;AlKueA,AgHhVA,A8F1RA,ADGA,A3IiaA,AoI5YA,AJYA,AGTA,ANkBA,AIZA,AavCA,ADGA,AENA,AnDyJA,AIZA;AlKueA,AgHhVA,A8F1RA,A5IoaA,AoI5YA,AJYA,AGTA,ANkBA,AIZA,AavCA,ADGA,AENA,AnDyJA,AIZA;AlKueA,AgHhVA,A8F1RA,A5IoaA,AoI5YA,AJYA,AGTA,ANkBA,AIZA,AavCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AgHhVA,A8F1RA,A5IoaA,AoI5YA,AJYA,AGTA,ANkBA,AIZA,AavCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AgHhVA,A8F1RA,A5IoaA,AoI5YA,AJYA,AGTA,ANkBA,AIZA,AavCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,A8F1RA,A5IoaA,AoI5YA,ADGA,ANkBA,AIZA,AavCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,A8F1RA,A5IoaA,AoI5YA,ADGA,ANkBA,AIZA,AavCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,A8F1RA,A5IoaA,AoI5YA,ADGA,ANkBA,AIZA,AavCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,AoG5SA,ANkBA,A5IoaA,AoI5YA,ADGA,AWjCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,AoG5SA,ANkBA,A5IoaA,AoI5YA,ADGA,AWjCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,AoG5SA,ANkBA,A5IoaA,AoI5YA,ADGA,AWjCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,AoG5SA,ANkBA,A5IoaA,AmJzbA,AhBgDA,AWjCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,AoG5SA,ANkBA,A5IoaA,AmJzbA,AhBgDA,AWjCA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,AoG5SA,ANkBA,A5IoaA,AmJzbA,ALeA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlKueA,AmNznBA,AnGySA,AoG5SA,ANkBA,A5IoaA,AoJ5bA,ADGA,ALeA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AiDlJA,AnGySA,AoG5SA,ANkBA,A5IoaA,AoJ5bA,ADGA,ALeA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AiDlJA,AnGySA,AoG5SA,ANkBA,A5IoaA,AoJ5bA,ADGA,ALeA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AiDlJA,AnGySA,AoG5SA,ANkBA,A5IoaA,AqJ/bA,ADGA,ADGA,ALeA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AqJ/bA,ADGA,ADGA,ALeA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AqJ/bA,ADGA,ADGA,ALeA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AqJ/bA,ADGA,ADGA,AGTA,ARwBA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AqJ/bA,AFMA,AGTA,ARwBA,ADGA,AGTA,ADGA,AnDyJA,AIZA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AqJ/bA,AFMA,AGTA,ARwBA,AENA,ADGA,A/C6IA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AqJ/bA,AENA,AJYA,AGTA,ARwBA,AENA,ADGA,A/C6IA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AuJrcA,AJYA,AGTA,ARwBA,AENA,ADGA,A/C6IA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AuJrcA,AJYA,AGTA,ARwBA,AENA,ADGA,A/C6IA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AuJrcA,ACHA,ALeA,AGTA,ARwBA,AENA,ADGA,A/C6IA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AuJrcA,ACHA,ALeA,ALeA,AENA,ADGA,A/C6IA;AlDuJA,AoG5SA,ANkBA,A5IoaA,AuJrcA,ACHA,ALeA,ALeA,AENA,ADGA;AjGoSA,AoG5SA,ANkBA,A5IoaA,AuJrcA,AENA,ADGA,ALeA,ALeA,AENA,ADGA;AjGoSA,AoG5SA,ANkBA,A5IoaA,AyJ3cA,ADGA,ALeA,ALeA,AENA,ADGA;AjGoSA,AoG5SA,ANkBA,A5IoaA,AyJ3cA,ADGA,ALeA,ALeA,AENA,ADGA;AjGoSA,AoG5SA,ANkBA,A5IoaA,AyJ3cA,ADGA,AENA,APqBA,ALeA,AENA,ADGA;AjGoSA,AoG5SA,ANkBA,A5IoaA,AyJ3cA,ADGA,AENA,APqBA,ALeA,AENA,ADGA;AjGoSA,AoG5SA,ANkBA,A5IoaA,AyJ3cA,ADGA,AENA,APqBA,ALeA,AENA,ADGA;AjGoSA,AoG5SA,ANkBA,A5IoaA,A2JjdA,AFMA,ADGA,AENA,APqBA,ALeA,AENA,ADGA;AjGoSA,AoG5SA,ANkBA,A5IoaA,A2JjdA,AHSA,AENA,APqBA,ALeA,AENA,ADGA;AjGoSA,A8F1RA,A5IoaA,A2JjdA,AHSA,AENA,APqBA,ALeA,AENA,ADGA;AjGoSA,A8F1RA,A5IoaA,A2JjdA,ACHA,AJYA,AENA,APqBA,ALeA,AENA,ADGA;AjGoSA,A8F1RA,A5IoaA,A2JjdA,ACHA,AJYA,ALeA,ALeA,ACHA;AjGoSA,A8F1RA,A5IoaA,A2JjdA,ACHA,AJYA,ALeA,ALeA,ACHA;AjGoSA,A8F1RA,A5IoaA,A2JjdA,ACHA,ACHA,ALeA,ALeA,AJYA;AjGoSA,A8F1RA,A5IoaA,A4JpdA,ACHA,ALeA,ALeA,AJYA;AjGoSA,A8F1RA,A5IoaA,A4JpdA,ACHA,ALeA,ALeA,AJYA;AjGoSA,A8F1RA,A5IoaA,A4JpdA,ACHA,ACHA,ANkBA,ALeA,AJYA;AjGoSA,A8F1RA,A5IoaA,A6JvdA,ACHA,ANkBA,ALeA,AJYA;AjGoSA,A8F1RA,A5IoaA,A6JvdA,ACHA,ANkBA,ALeA,AJYA;AjGoSA,A8F1RA,A5IoaA,A6JvdA,ACHA,ACHA,APqBA,AT2BA;AjGoSA,A8F1RA,A5IoaA,A8J1dA,ACHA,APqBA,AT2BA;AjGoSA,A8F1RA,A5IoaA,A8J1dA,ACHA,APqBA,AT2BA;AjGoSA,A8F1RA,A5IoaA,A8J1dA,ACHA,ACHA,ARwBA,AT2BA;AjGoSA,A8F1RA,A5IoaA,A8J1dA,ACHA,ACHA,ARwBA,AT2BA;AjGoSA,A8F1RA,A5IoaA,A8J1dA,ACHA,ACHA,ARwBA,AT2BA;AjGoSA,A8F1RA,A5IoaA,A8J1dA,ACHA,ACHA,ACHA,AT2BA,AT2BA;AjGoSA,A8F1RA,A5IoaA,A8J1dA,AENA,ACHA,AT2BA,AT2BA;AjGoSA,A8F1RA,A5IoaA,AgKheA,ACHA,AT2BA,AT2BA;AjGoSA,A8F1RA,A5IoaA,AgKheA,ACHA,ACHA,AV8BA,AT2BA;AjGoSA,A8F1RA,A5IoaA,AiKneA,ACHA,AV8BA,AT2BA;AjGoSA,A8F1RA,A5IoaA,AiKneA,ACHA,AV8BA;A1G+TA,A8F1RA,A5IoaA,AiKneA,ACHA,ACHA,AXiCA;A1G+TA,A8F1RA,A5IoaA,AkKteA,ACHA;ArHgWA,A8F1RA,A5IoaA,AkKteA,ACHA;ArHgWA,A8F1RA,A5IoaA,AkKteA,ACHA,ACHA;AtHmWA,A8F1RA,A5IoaA,AmKzeA,ACHA;AtHmWA,A8F1RA,A5IoaA,AmKzeA,ACHA;AtHmWA,A8F1RA,A5IoaA,AmKzeA,ACHA,ACHA;AvHsWA,A8F1RA,A5IoaA,AoK5eA,ACHA;AvHsWA,A8F1RA,A5IoaA,AoK5eA,ACHA;AvHsWA,A8F1RA,A5IoaA,AoK5eA,ACHA,ACHA;AxHyWA,A8F1RA,A5IoaA,AqK/eA,ACHA;AxHyWA,A8F1RA,A5IoaA,AqK/eA,ACHA;AxHyWA,A8F1RA,A5IoaA,AqK/eA,ACHA,ACHA;AzH4WA,A8F1RA,A5IoaA,AsKlfA,ACHA;AzH4WA,A8F1RA,A5IoaA,AsKlfA,ACHA;AzH4WA,A8F1RA,A5IoaA,AsKlfA,ACHA,ACHA;A1H+WA,A8F1RA,A5IoaA,AuKrfA,ACHA;A1H+WA,A8F1RA,A5IoaA,AuKrfA,ACHA;A1H+WA,A8F1RA,A5IoaA,AuKrfA,ACHA,ACHA;A3HkXA,A8F1RA,A5IoaA,AwKxfA,ACHA;A3HkXA,A8F1RA,A5IoaA,AwKxfA,ACHA;A3HkXA,A8F1RA,A5IoaA,AwKxfA,ACHA,ACHA;A5HqXA,A8F1RA,A5IoaA,AyK3fA,ACHA;A5HqXA,A8F1RA,A5IoaA,AyK3fA,ACHA;A5HqXA,A8F1RA,A5IoaA,AyK3fA,ACHA,ACHA;A7HwXA,A8F1RA,A5IoaA,A0K9fA,ACHA;A7HwXA,A8F1RA,A5IoaA,A0K9fA,ACHA;A7HwXA,A8F1RA,A5IoaA,A0K9fA,ACHA,ACHA;A9H2XA,A8F1RA,A+B7FA,ACHA;A9H2XA,A8F1RA,A+B7FA,ACHA;A9H2XA,A8F1RA,A+B7FA,ACHA,ACHA;A/H8XA,A8F1RA,AgChGA,ACHA;A/H8XA,A8F1RA,AgChGA,ACHA;A/H8XA,A8F1RA,AgChGA,ACHA,ACHA;AhIiYA,A8F1RA,AiCnGA,ACHA;AhIiYA,A8F1RA,AiCnGA,ACHA;AhIiYA,A8F1RA,AiCnGA,ACHA,ACHA;AjIoYA,A8F1RA,AkCtGA,ACHA;AjIoYA,A8F1RA,AkCtGA,ACHA;AjIoYA,A8F1RA,AkCtGA,ACHA,ACHA;AlIuYA,A8F1RA,AmCzGA,ACHA;AlIuYA,A8F1RA,AmCzGA,ACHA;AlIuYA,A8F1RA,AmCzGA,ACHA,ACHA;AnI0YA,A8F1RA,AoC5GA,ACHA;AnI0YA,A8F1RA,AoC5GA,ACHA;AnI0YA,A8F1RA,AoC5GA,ACHA,ACHA;ApI6YA,A8F1RA,AqC/GA,ACHA;ApI6YA,A8F1RA,AqC/GA,ACHA;ApI6YA,A8F1RA,AqC/GA,ACHA,ACHA;ArIgZA,A8F1RA,AsClHA,ACHA;ArIgZA,A8F1RA,AsClHA,ACHA;ArIgZA,A8F1RA,AsClHA,ACHA,ACHA;AtImZA,A8F1RA,AuCrHA,ACHA;AtImZA,A8F1RA,AuCrHA,ACHA;AtImZA,A8F1RA,AyC3HA,AFMA,ACHA;AtImZA,A8F1RA,AyC3HA,ADGA;AtImZA,A8F1RA,AyC3HA,ADGA;AtImZA,A8F1RA,AyC3HA,ACHA,AFMA;AtImZA,A8F1RA,AyC3HA,ACHA;AxIyZA,A8F1RA,AyC3HA,ACHA;AxIyZA,A8F1RA,AyC3HA,ACHA,ACHA;AzI4ZA,A8F1RA,A0C9HA,ACHA;AzI4ZA,A8F1RA,A0C9HA,ACHA;AzI4ZA,A8F1RA,A4CpIA,AFMA,ACHA;AzI4ZA,A8F1RA,A4CpIA,ADGA;AzI4ZA,A8F1RA,A4CpIA,ADGA;AzI4ZA,A8F1RA,A6CvIA,ADGA,ADGA;AzI4ZA,A8F1RA,A6CvIA,ADGA;A1I+ZA,A8F1RA,A6CvIA,ADGA;A1I+ZA,A8F1RA,A6CvIA,ACHA,AFMA;A1I+ZA,A8F1RA,A6CvIA,ACHA;A5IqaA,A8F1RA,A6CvIA,ACHA;A5IqaA,A8F1RA,A6CvIA,ACHA,ACHA;A7IwaA,A8F1RA,A8C1IA,ACHA;A7IwaA,A8F1RA,A8C1IA,ACHA;A7IwaA,A8F1RA,A8C1IA,AENA,ADGA;A7IwaA,A8F1RA,AgDhJA,ADGA;A7IwaA,A8F1RA,AgDhJA,ADGA;A7IwaA,A8F1RA,AiDnJA,ADGA,ADGA;A7IwaA,A8F1RA,AiDnJA,ADGA;A9I2aA,A8F1RA,AiDnJA,ADGA;A9I2aA,A8F1RA,AiDnJA,ACHA,AFMA;A9I2aA,A8F1RA,AiDnJA,ACHA;AhJibA,A8F1RA,AiDnJA,ACHA;AhJibA,A8F1RA,AiDnJA,ACHA,ACHA;AjJobA,A8F1RA,AkDtJA,ACHA;AjJobA,A8F1RA,AkDtJA,ACHA;AjJobA,A8F1RA,AoD5JA,AFMA,ACHA;AjJobA,A8F1RA,AoD5JA,ADGA;AjJobA,A8F1RA,AoD5JA,ADGA;AjJobA,A8F1RA,AoD5JA,ACHA,AFMA;AjJobA,A8F1RA,AoD5JA,ACHA;AnJ0bA,A8F1RA,AoD5JA,ACHA;AnJ0bA,A8F1RA,AoD5JA,ACHA,ACHA;ApJ6bA,A8F1RA,AqD/JA,ACHA;ApJ6bA,A8F1RA,AqD/JA,ACHA;ApJ6bA,A8F1RA,AuDrKA,AFMA,ACHA;ApJ6bA,A8F1RA,AuDrKA,ADGA;ApJ6bA,A8F1RA,AuDrKA,ADGA;ApJ6bA,A8F1RA,AuDrKA,ADGA,AENA;AtJmcA,A8F1RA,AuDrKA,ACHA;AtJmcA,A8F1RA,AuDrKA,ACHA;AtJmcA,A8F1RA,AuDrKA,AENA,ADGA;AtJmcA,A8F1RA,AyD3KA,ADGA;AtJmcA,A8F1RA,AyD3KA,ADGA;AtJmcA,A8F1RA,A0D9KA,ADGA,ADGA;AtJmcA,A8F1RA,A0D9KA,ADGA;AvJscA,A8F1RA,A0D9KA,ADGA;AvJscA,A8F1RA,A0D9KA,ADGA,AENA;AzJ4cA,A8F1RA,A0D9KA,ACHA;AzJ4cA,A8F1RA,A0D9KA,ACHA;AzJ4cA,A8F1RA,A0D9KA,ACHA,ACHA;A1J+cA,A8F1RA,A2DjLA,ACHA;A1J+cA,A8F1RA,A2DjLA,ACHA;A1J+cA,A2JjdA,A7DuLA,A2DjLA,ACHA;A1J+cA,A2JjdA,A7DuLA,A4DpLA;A1J+cA,A2JjdA,A7DuLA,A4DpLA;A1J+cA,A4JpdA,ADGA,A7DuLA,A4DpLA;A1J+cA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,ADGA,A7DuLA;A9F2RA,A4JpdA,A9D0LA;A9F2RA,A4JpdA,A9D0LA;A9F2RA,A4JpdA,A9D0LA;A9F2RA,A4JpdA,A9D0LA;A8DzLA,A9D0LA;A8DzLA,A9D0LA;A8DzLA,A9D0LA;A8DzLA,A9D0LA;A8DzLA,A9D0LA;A8DzLA,A9D0LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.version = void 0, require(\"reflect-metadata\"), require(\"./modules\"), \nexports.version = \"0.12.1\", __exportStar(require(\"./container\"), exports), __exportStar(require(\"./core/global\"), exports), \n__exportStar(require(\"./graphic\"), exports), __exportStar(require(\"./modules\"), exports), \n__exportStar(require(\"./create\"), exports), __exportStar(require(\"./event\"), exports), \n__exportStar(require(\"./interface\"), exports), __exportStar(require(\"./render\"), exports), \n__exportStar(require(\"./canvas\"), exports), __exportStar(require(\"./core\"), exports), \n__exportStar(require(\"./picker\"), exports), __exportStar(require(\"./kits\"), exports), \n__exportStar(require(\"./animate\"), exports), __exportStar(require(\"./resource-loader/loader\"), exports), \n__exportStar(require(\"./common/text\"), exports), __exportStar(require(\"./common/bezier-utils\"), exports), \n__exportStar(require(\"./common/bounds-context\"), exports), __exportStar(require(\"./common/seg-context\"), exports), \n__exportStar(require(\"./common/custom-path2d\"), exports), __exportStar(require(\"./common/segment\"), exports), \n__exportStar(require(\"./common/canvas-utils\"), exports), __exportStar(require(\"./common/contribution-provider\"), exports), \n__exportStar(require(\"./common/generator\"), exports), __exportStar(require(\"./common/utils\"), exports), \n__exportStar(require(\"./common/shape/arc\"), exports), __exportStar(require(\"./common/shape/rect\"), exports), \n__exportStar(require(\"./common/path-svg\"), exports), __exportStar(require(\"./common/render-curve\"), exports), \n__exportStar(require(\"./common/render-area\"), exports), __exportStar(require(\"./common/render-command-list\"), exports), \n__exportStar(require(\"./common/sort\"), exports), __exportStar(require(\"./common/morphing-utils\"), exports), \n__exportStar(require(\"./common/split-path\"), exports), __exportStar(require(\"./common/enums\"), exports), \n__exportStar(require(\"./animate/default-ticker\"), exports);\n//# sourceMappingURL=index.js.map","\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.layerService = exports.pickerService = exports.graphicService = exports.transformUtil = exports.graphicUtil = exports.global = void 0;\n\nconst core_modules_1 = __importDefault(require(\"./core/core-modules\")), render_modules_1 = __importDefault(require(\"./render/render-modules\")), pick_modules_1 = __importDefault(require(\"./picker/pick-modules\")), graphic_module_1 = __importDefault(require(\"./graphic/graphic-service/graphic-module\")), plugin_modules_1 = __importDefault(require(\"./plugins/plugin-modules\")), modules_1 = __importDefault(require(\"./core/contributions/modules\")), modules_2 = __importDefault(require(\"./render/contributions/modules\")), modules_3 = __importDefault(require(\"./picker/contributions/modules\")), modules_4 = __importDefault(require(\"./canvas/contributions/modules\")), constants_1 = require(\"./core/constants\"), global_picker_service_1 = require(\"./picker/global-picker-service\"), application_1 = require(\"./application\"), constants_2 = require(\"./graphic/constants\"), constants_3 = require(\"./core/constants\"), container_1 = require(\"./container\"), constants_4 = require(\"./constants\");\n\ncontainer_1.container.load(core_modules_1.default), container_1.container.load(graphic_module_1.default), \ncontainer_1.container.load(render_modules_1.default), container_1.container.load(pick_modules_1.default), \ncontainer_1.container.load(plugin_modules_1.default), (0, modules_1.default)(container_1.container), \n(0, modules_2.default)(container_1.container), (0, modules_3.default)(container_1.container), \n(0, modules_4.default)(container_1.container), exports.global = container_1.container.get(constants_4.Global), \napplication_1.application.global = exports.global, exports.graphicUtil = container_1.container.get(constants_3.GraphicUtil), \napplication_1.application.graphicUtil = exports.graphicUtil, exports.transformUtil = container_1.container.get(constants_3.TransformUtil), \napplication_1.application.transformUtil = exports.transformUtil, exports.graphicService = container_1.container.get(constants_2.GraphicService), \napplication_1.application.graphicService = exports.graphicService, exports.pickerService = container_1.container.get(global_picker_service_1.GlobalPickerService), \nexports.layerService = container_1.container.get(constants_1.LayerService), application_1.application.layerService = exports.layerService;\n//# sourceMappingURL=modules.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), global_1 = require(\"./global\"), graphic_utils_1 = require(\"./graphic-utils\"), layer_service_1 = require(\"./layer-service\"), window_1 = require(\"./window\"), constants_1 = require(\"./constants\"), constants_2 = require(\"../constants\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(global_1.DefaultGlobal).toSelf().inSingletonScope(), bind(constants_2.Global).toService(global_1.DefaultGlobal), \n    bind(window_1.DefaultWindow).to(window_1.DefaultWindow), bind(window_1.Window).toService(window_1.DefaultWindow), \n    bind(graphic_utils_1.DefaultGraphicUtil).toSelf().inSingletonScope(), bind(constants_1.GraphicUtil).toService(graphic_utils_1.DefaultGraphicUtil), \n    bind(graphic_utils_1.DefaultTransformUtil).toSelf().inSingletonScope(), bind(constants_1.TransformUtil).toService(graphic_utils_1.DefaultTransformUtil), \n    bind(layer_service_1.DefaultLayerService).toSelf().inSingletonScope(), bind(constants_1.LayerService).toService(layer_service_1.DefaultLayerService);\n}));\n//# sourceMappingURL=core-modules.js.map","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultGlobal = void 0;\n\nconst inversify_1 = require(\"inversify\"), contribution_provider_1 = require(\"../common/contribution-provider\"), tapable_1 = require(\"../tapable\"), constants_1 = require(\"../constants\"), defaultEnv = \"browser\";\n\nlet DefaultGlobal = class {\n    get env() {\n        return this._env;\n    }\n    get devicePixelRatio() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.getDevicePixelRatio();\n    }\n    get supportEvent() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.supportEvent;\n    }\n    get supportsTouchEvents() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.supportsTouchEvents;\n    }\n    get supportsPointerEvents() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.supportsPointerEvents;\n    }\n    get supportsMouseEvents() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.supportsMouseEvents;\n    }\n    get applyStyles() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.applyStyles;\n    }\n    constructor(contributions) {\n        this.contributions = contributions, this.hooks = {\n            onSetEnv: new tapable_1.SyncHook([ \"lastEnv\", \"env\", \"global\" ])\n        }, this.measureTextMethod = \"native\";\n    }\n    bindContribution(params) {\n        this.contributions.getContributions().forEach((contribution => {\n            contribution.configure(this, params);\n        }));\n    }\n    setEnv(env, params) {\n        (params && !0 === params.force || this._env !== env) && (this.deactiveCurrentEnv(), \n        this.activeEnv(env, params));\n    }\n    deactiveCurrentEnv() {\n        this.envContribution && this.envContribution.release();\n    }\n    activeEnv(env, params) {\n        const lastEnv = this._env;\n        this._env = env, this.bindContribution(params), this.envParams = params, this.hooks.onSetEnv.call(lastEnv, env, this);\n    }\n    setActiveEnvContribution(contribution) {\n        this.envContribution = contribution;\n    }\n    createCanvas(params) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.createCanvas(params);\n    }\n    createOffscreenCanvas(params) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.createOffscreenCanvas(params);\n    }\n    releaseCanvas(canvas) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.releaseCanvas(canvas);\n    }\n    addEventListener(type, listener, options) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.addEventListener(type, listener, options);\n    }\n    removeEventListener(type, listener, options) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.removeEventListener(type, listener, options);\n    }\n    dispatchEvent(event) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.dispatchEvent(event);\n    }\n    getRequestAnimationFrame() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.getRequestAnimationFrame();\n    }\n    getCancelAnimationFrame() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.getCancelAnimationFrame();\n    }\n    getElementById(str) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.getElementById ? this.envContribution.getElementById(str) : null;\n    }\n    getRootElement() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;\n    }\n    getDocument() {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;\n    }\n    mapToCanvasPoint(event, domElement) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event, domElement) : null;\n    }\n    loadImage(url) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.loadImage(url);\n    }\n    loadSvg(str) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.loadSvg(str);\n    }\n    loadJson(url) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.loadJson(url);\n    }\n    loadArrayBuffer(url) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.loadArrayBuffer(url);\n    }\n    loadBlob(url) {\n        return this._env || this.setEnv(\"browser\"), this.envContribution.loadBlob(url);\n    }\n};\n\nDefaultGlobal = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(constants_1.EnvContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultGlobal), \nexports.DefaultGlobal = DefaultGlobal;\n//# sourceMappingURL=global.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.bindContributionProvider = exports.ContributionProvider = void 0, exports.ContributionProvider = Symbol(\"ContributionProvider\");\n\nclass ContributionProviderCache {\n    constructor(serviceIdentifier, container) {\n        this.serviceIdentifier = serviceIdentifier, this.container = container;\n    }\n    getContributions() {\n        return this.caches || (this.caches = [], this.container && this.caches.push(...this.container.getAll(this.serviceIdentifier))), \n        this.caches;\n    }\n}\n\nfunction bindContributionProvider(bind, id) {\n    bind(exports.ContributionProvider).toDynamicValue((({container: container}) => new ContributionProviderCache(id, container))).inSingletonScope().whenTargetNamed(id);\n}\n\nexports.bindContributionProvider = bindContributionProvider;\n//# sourceMappingURL=contribution-provider.js.map","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./SyncHook\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.SyncHook = void 0;\n\nconst Hook_1 = require(\"./Hook\");\n\nclass SyncHook extends Hook_1.Hook {\n    call(...args) {\n        this.taps.map((t => t.fn)).forEach((cb => cb(...args)));\n    }\n}\n\nexports.SyncHook = SyncHook;\n//# sourceMappingURL=SyncHook.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Hook = void 0;\n\nclass Hook {\n    constructor(args, name) {\n        this._args = args, this.name = name, this.taps = [];\n    }\n    tap(options, fn) {\n        this._tap(\"sync\", options, fn);\n    }\n    unTap(options, fn) {\n        const name = \"string\" == typeof options ? options.trim() : options.name;\n        name && (this.taps = this.taps.filter((tap => tap.name !== name && (!fn || tap.fn === fn))));\n    }\n    _parseOptions(type, options, fn) {\n        let _options;\n        if (\"string\" == typeof options) _options = {\n            name: options.trim()\n        }; else if (\"object\" != typeof options || null === options) throw new Error(\"Invalid tap options\");\n        if (\"string\" != typeof _options.name || \"\" === _options.name) throw new Error(\"Missing name for tap\");\n        return _options = Object.assign({\n            type: type,\n            fn: fn\n        }, _options), _options;\n    }\n    _tap(type, options, fn) {\n        this._insert(this._parseOptions(type, options, fn));\n    }\n    _insert(item) {\n        let before;\n        \"string\" == typeof item.before ? before = new Set([ item.before ]) : Array.isArray(item.before) && (before = new Set(item.before));\n        let stage = 0;\n        \"number\" == typeof item.stage && (stage = item.stage);\n        let i = this.taps.length;\n        for (;i > 0; ) {\n            i--;\n            const x = this.taps[i];\n            this.taps[i + 1] = x;\n            const xStage = x.stage || 0;\n            if (before) {\n                if (before.has(x.name)) {\n                    before.delete(x.name);\n                    continue;\n                }\n                if (before.size > 0) continue;\n            }\n            if (!(xStage > stage)) {\n                i++;\n                break;\n            }\n        }\n        this.taps[i] = item;\n    }\n}\n\nexports.Hook = Hook;\n//# sourceMappingURL=Hook.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Global = exports.EnvContribution = void 0, exports.EnvContribution = Symbol.for(\"EnvContribution\"), \nexports.Global = Symbol.for(\"Global\");\n//# sourceMappingURL=constants.js.map","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultTransformUtil = exports.DefaultGraphicUtil = void 0;\n\nconst inversify_1 = require(\"inversify\"), textMeasure_contribution_1 = require(\"./contributions/textMeasure/textMeasure-contribution\"), contribution_provider_1 = require(\"../common/contribution-provider\"), util_1 = require(\"../canvas/util\"), config_1 = require(\"../graphic/config\"), vutils_1 = require(\"@visactor/vutils\"), constants_1 = require(\"../constants\");\n\nlet DefaultGraphicUtil = class {\n    constructor(contributions, global) {\n        this.contributions = contributions, this.global = global, this.configured = !1, \n        this.global.hooks.onSetEnv.tap(\"graphic-util\", ((lastEnv, env, global) => {\n            this.configured = !1, this.configure(global, env);\n        }));\n    }\n    get textMeasure() {\n        return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;\n    }\n    configure(global, env) {\n        if (this.configured) return;\n        const canvas = (0, util_1.wrapCanvas)({\n            nativeCanvas: global.createCanvas({\n                width: 100,\n                height: 100\n            })\n        });\n        this.canvas = canvas, this.context = canvas.getContext(\"2d\"), this.contributions.getContributions().forEach((contribution => {\n            contribution.configure(this, env);\n        })), this.configured = !0;\n    }\n    bindTextMeasure(tm) {\n        this._textMeasure = tm;\n    }\n    measureText(text, tc, method = \"native\") {\n        var _a;\n        this.configure(this.global, this.global.env);\n        const m = this.global.measureTextMethod;\n        this.global.measureTextMethod = method;\n        const data = {\n            width: this._textMeasure.measureTextWidth(text, tc),\n            height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : config_1.DefaultTextStyle.fontSize\n        };\n        return this.global.measureTextMethod = m, data;\n    }\n    createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {\n        return this.configure(this.global, this.global.env), new vutils_1.TextMeasure(Object.assign({\n            defaultFontParams: {\n                fontFamily: config_1.DefaultTextStyle.fontFamily,\n                fontSize: config_1.DefaultTextStyle.fontSize\n            },\n            getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),\n            getTextBounds: void 0,\n            specialCharSet: \"-/: .,@%'\\\"~\" + vutils_1.TextMeasure.ALPHABET_CHAR_SET + vutils_1.TextMeasure.ALPHABET_CHAR_SET.toUpperCase()\n        }, null != option ? option : {}), textSpec);\n    }\n};\n\nvar TransformMode;\n\nDefaultGraphicUtil = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(textMeasure_contribution_1.TextMeasureContribution)), __param(1, (0, \ninversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object, Object ]) ], DefaultGraphicUtil), \nexports.DefaultGraphicUtil = DefaultGraphicUtil, function(TransformMode) {\n    TransformMode[TransformMode.transform = 0] = \"transform\", TransformMode[TransformMode.matrix = 1] = \"matrix\";\n}(TransformMode || (TransformMode = {}));\n\nconst _matrix = new vutils_1.Matrix;\n\nlet DefaultTransformUtil = class {\n    constructor() {\n        this.matrix = new vutils_1.Matrix;\n    }\n    init(origin) {\n        return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), \n        this;\n    }\n    fromMatrix(source, target) {\n        return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, \n        this;\n    }\n    scaleMatrix(sx, sy, center) {\n        const sMatrix = this.outSourceMatrix;\n        if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), \n        this.outTargetMatrix.reset(), center) {\n            const {x: x, y: y} = center;\n            this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);\n        } else this.outTargetMatrix.scale(sx, sy);\n        return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), \n        this;\n    }\n    scale(sx, sy, center) {\n        return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center) : this;\n    }\n    translateMatrix(dx, dy) {\n        const sMatrix = this.outSourceMatrix;\n        return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), \n        this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), \n        this;\n    }\n    translate(dx, dy) {\n        return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;\n    }\n    simplify(target) {\n        return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;\n    }\n    simplifyMatrix(target) {\n        return this;\n    }\n};\n\nDefaultTransformUtil = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", []) ], DefaultTransformUtil), \nexports.DefaultTransformUtil = DefaultTransformUtil;\n//# sourceMappingURL=graphic-utils.js.map","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultTextMeasureContribution = exports.TextMeasureContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), AtextMeasure_1 = require(\"./AtextMeasure\");\n\nexports.TextMeasureContribution = Symbol.for(\"TextMeasureContribution\");\n\nlet DefaultTextMeasureContribution = class extends AtextMeasure_1.ATextMeasure {};\n\nDefaultTextMeasureContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultTextMeasureContribution), \nexports.DefaultTextMeasureContribution = DefaultTextMeasureContribution;\n//# sourceMappingURL=textMeasure-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.ATextMeasure = void 0;\n\nconst inversify_1 = require(\"inversify\"), config_1 = require(\"../../../graphic/config\");\n\nlet ATextMeasure = class {\n    configure(service, env) {\n        this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);\n    }\n    measureTextWidth(text, options) {\n        if (!this.context) return this.estimate(text, options).width;\n        this.context.setTextStyleWithoutAlignBaseline(options);\n        return this.context.measureText(text).width;\n    }\n    estimate(text, {fontSize: fontSize = config_1.DefaultTextAttribute.fontSize}) {\n        let eCharLen = 0, cCharLen = 0;\n        for (let i = 0; i < text.length; i++) text.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;\n        return {\n            width: ~~(.8 * eCharLen * fontSize + cCharLen * fontSize),\n            height: fontSize\n        };\n    }\n    measureTextPixelHeight(text, options) {\n        var _a;\n        if (!this.context) return null !== (_a = options.fontSize) && void 0 !== _a ? _a : config_1.DefaultTextStyle.fontSize;\n        this.context.setTextStyleWithoutAlignBaseline(options);\n        const textMeasure = this.context.measureText(text);\n        return Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent);\n    }\n    measureTextBoundHieght(text, options) {\n        var _a;\n        if (!this.context) return null !== (_a = options.fontSize) && void 0 !== _a ? _a : config_1.DefaultTextStyle.fontSize;\n        this.context.setTextStyleWithoutAlignBaseline(options);\n        const textMeasure = this.context.measureText(text);\n        return Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent);\n    }\n    measureText(text, options) {\n        return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text)) : this.estimate(text, options);\n    }\n    clipText(text, options, width) {\n        if (0 === text.length) return {\n            str: \"\",\n            width: 0\n        };\n        let length = this.measureTextWidth(text, options);\n        return length <= width ? {\n            str: text,\n            width: length\n        } : (length = this.measureTextWidth(text[0], options), length > width ? {\n            str: \"\",\n            width: 0\n        } : this._clipText(text, options, width, 0, text.length - 1));\n    }\n    _clipText(text, options, width, leftIdx, rightIdx) {\n        const middleIdx = Math.floor((leftIdx + rightIdx) / 2), subText = text.substring(0, middleIdx + 1), strWidth = this.measureTextWidth(subText, options);\n        let length;\n        if (strWidth > width) {\n            if (subText.length <= 1) return {\n                str: \"\",\n                width: 0\n            };\n            const str = text.substring(0, middleIdx);\n            return length = this.measureTextWidth(str, options), length <= width ? {\n                str: str,\n                width: length\n            } : this._clipText(text, options, width, leftIdx, middleIdx);\n        }\n        if (strWidth < width) {\n            if (middleIdx >= text.length - 1) return {\n                str: text,\n                width: this.measureTextWidth(text, options)\n            };\n            const str = text.substring(0, middleIdx + 2);\n            return length = this.measureTextWidth(str, options), length >= width ? {\n                str: subText,\n                width: strWidth\n            } : this._clipText(text, options, width, middleIdx, rightIdx);\n        }\n        return {\n            str: subText,\n            width: strWidth\n        };\n    }\n    clipTextWithSuffix(text, options, width, suffix) {\n        if (\"\" === suffix) return this.clipText(text, options, width);\n        if (0 === text.length) return {\n            str: \"\",\n            width: 0\n        };\n        const length = this.measureTextWidth(text, options);\n        if (length <= width) return {\n            str: text,\n            width: length\n        };\n        const suffixWidth = this.measureTextWidth(suffix, options);\n        if (suffixWidth > width) return {\n            str: \"\",\n            width: 0\n        };\n        width -= suffixWidth;\n        const data = this._clipText(text, options, width, 0, text.length - 1);\n        return data.str += suffix, data.width += suffixWidth, data;\n    }\n};\n\nATextMeasure = __decorate([ (0, inversify_1.injectable)() ], ATextMeasure), exports.ATextMeasure = ATextMeasure;\n//# sourceMappingURL=AtextMeasure.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultRichTextIconAttribute = exports.DefaultImageAttribute = exports.DefaultRichTextAttribute = exports.DefaultTextAttribute = exports.DefaultSymbolAttribute = exports.DefaultRect3dAttribute = exports.DefaultRectAttribute = exports.DefaultPolygonAttribute = exports.DefaultPathAttribute = exports.DefaultLineAttribute = exports.DefaultGlyphAttribute = exports.DefaultGroupAttribute = exports.DefaultCircleAttribute = exports.DefaultAreaAttribute = exports.DefaultArcAttribute = exports.rewriteProto = exports.addAttributeToPrototype = exports.DefaultAttribute = exports.DefaultStyle = exports.DefaultTextStyle = exports.DefaultStrokeStyle = exports.DefaultFillStyle = exports.DefaultTransform = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), custom_path2d_1 = require(\"../common/custom-path2d\");\n\nexports.DefaultTransform = {\n    x: 0,\n    y: 0,\n    z: 0,\n    dx: 0,\n    dy: 0,\n    dz: 0,\n    scrollX: 0,\n    scrollY: 0,\n    scaleX: 1,\n    scaleY: 1,\n    scaleZ: 1,\n    angle: 0,\n    alpha: 0,\n    beta: 0,\n    anchor: [ 0, 0 ],\n    anchor3d: [ 0, 0 ],\n    postMatrix: new vutils_1.Matrix\n}, exports.DefaultFillStyle = {\n    fillOpacity: 1,\n    fill: !1,\n    shadowBlur: 0,\n    shadowColor: \"black\",\n    shadowOffsetX: 0,\n    shadowOffsetY: 0\n};\n\nconst commonStroke = {\n    strokeOpacity: 1,\n    lineDash: [],\n    lineDashOffset: 0,\n    lineWidth: 1,\n    lineCap: \"butt\",\n    lineJoin: \"miter\",\n    miterLimit: 10,\n    strokeBoundsBuffer: 2,\n    stroke: !1\n};\n\nfunction addAttributeToPrototype(obj, c, keys) {\n    keys.forEach((key => {\n        c.prototype[key] = obj[key];\n    }));\n}\n\nfunction rewriteProto(obj, c) {\n    Object.setPrototypeOf(obj, c);\n}\n\nexports.DefaultStrokeStyle = Object.assign({\n    outerBorder: Object.assign(Object.assign({}, commonStroke), {\n        distance: 0\n    }),\n    innerBorder: Object.assign(Object.assign({}, commonStroke), {\n        distance: 0\n    })\n}, commonStroke), exports.DefaultTextStyle = {\n    text: \"\",\n    maxLineWidth: 1 / 0,\n    textAlign: \"left\",\n    textBaseline: \"alphabetic\",\n    fontSize: 16,\n    fontFamily: \"PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol\",\n    fontWeight: \"\",\n    ellipsis: \"\",\n    fontVariant: \"\",\n    fontStyle: \"\",\n    lineHeight: void 0,\n    underline: 0,\n    lineThrough: 0,\n    scaleIn3d: !1\n}, exports.DefaultStyle = Object.assign(Object.assign({\n    opacity: 1,\n    background: null,\n    texture: null,\n    textureColor: \"black\",\n    textureSize: 10,\n    texturePadding: 2,\n    backgroundMode: 0,\n    blur: 0,\n    cursor: null\n}, exports.DefaultFillStyle), exports.DefaultStrokeStyle), exports.DefaultAttribute = Object.assign(Object.assign({\n    strokeSeg: null,\n    pickable: !0,\n    childrenPickable: !0,\n    visible: !0,\n    zIndex: 0,\n    layout: null,\n    boundsPadding: 0,\n    pickMode: \"accurate\",\n    customPickShape: null,\n    boundsMode: \"accurate\",\n    keepDirIn3d: !0\n}, exports.DefaultStyle), exports.DefaultTransform), exports.addAttributeToPrototype = addAttributeToPrototype, \nexports.rewriteProto = rewriteProto, exports.DefaultArcAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    startAngle: 0,\n    endAngle: vutils_1.pi2,\n    innerRadius: 0,\n    outerRadius: 1,\n    cornerRadius: 0,\n    padRadius: 0,\n    padAngle: 0,\n    cap: !1,\n    forceShowCap: !1\n}), exports.DefaultAreaAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    points: [],\n    segments: [],\n    curveType: \"linear\",\n    clipRange: 1\n}), exports.DefaultCircleAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    radius: 1,\n    startAngle: 0,\n    endAngle: vutils_1.pi2\n}), exports.DefaultGroupAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    width: 0,\n    height: 0,\n    cornerRadius: 0,\n    path: [],\n    clip: !1,\n    visibleAll: !0\n}), exports.DefaultGlyphAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    path: \"\",\n    width: 0,\n    height: 0,\n    cornerRadius: 0,\n    clip: !1\n}), exports.DefaultLineAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    points: [],\n    segments: [],\n    curveType: \"linear\",\n    clipRange: 1,\n    clipRangeByDimension: \"default\"\n}), exports.DefaultPathAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    path: new custom_path2d_1.CustomPath2D,\n    customPath: () => {\n        console.warn(\"\");\n    }\n}), exports.DefaultPolygonAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    points: [],\n    cornerRadius: 0\n}), exports.DefaultRectAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    width: 0,\n    height: 0,\n    strokeBoundsBuffer: 0,\n    cornerRadius: 0\n}), exports.DefaultRect3dAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    width: 0,\n    height: 0,\n    cornerRadius: 0,\n    length: 0\n}), exports.DefaultSymbolAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    symbolType: \"circle\",\n    size: 10,\n    keepDirIn3d: !0\n}), exports.DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, exports.DefaultAttribute), exports.DefaultTextStyle), {\n    strokeBoundsBuffer: 0,\n    keepDirIn3d: !0\n}), exports.DefaultRichTextAttribute = Object.assign(Object.assign({}, exports.DefaultAttribute), {\n    width: 300,\n    height: 300,\n    ellipsis: !0,\n    wordBreak: \"break-word\",\n    verticalDirection: \"top\",\n    textAlign: \"left\",\n    textBaseline: \"top\",\n    layoutDirection: \"horizontal\",\n    textConfig: [],\n    maxHeight: void 0,\n    maxWidth: void 0,\n    singleLine: !1\n}), exports.DefaultImageAttribute = Object.assign(Object.assign({\n    repeatX: \"no-repeat\",\n    repeatY: \"no-repeat\",\n    image: \"\",\n    width: 0,\n    height: 0\n}, exports.DefaultAttribute), {\n    fill: !0\n}), exports.DefaultRichTextIconAttribute = Object.assign(Object.assign({}, exports.DefaultImageAttribute), {\n    backgroundShowMode: \"never\",\n    backgroundWidth: 0,\n    backgroundHeight: 0,\n    textAlign: \"left\",\n    textBaseline: \"middle\",\n    direction: \"horizontal\",\n    margin: 0,\n    id: \"\",\n    width: 20,\n    height: 20,\n    backgroundFill: \"rgba(101, 117, 168, 0.1)\",\n    backgroundFillOpacity: 1,\n    backgroundStroke: !1,\n    backgroundStrokeOpacity: 1,\n    backgroundRadius: 4,\n    opacity: 1\n});\n//# sourceMappingURL=config.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CustomPath2D = void 0;\n\nconst bounds_context_1 = require(\"./bounds-context\"), path_1 = require(\"./segment/curve/path\"), path_svg_1 = require(\"./path-svg\"), vutils_1 = require(\"@visactor/vutils\"), enums_1 = require(\"./enums\"), arc_1 = require(\"./shape/arc\"), render_command_list_1 = require(\"./render-command-list\"), segment_1 = require(\"./segment\");\n\nclass CustomPath2D extends path_1.CurvePath {\n    constructor(ctx) {\n        super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new bounds_context_1.BoundsContext(this.bounds);\n    }\n    setCtx(ctx) {\n        this._ctx = ctx;\n    }\n    moveTo(x, y) {\n        return this.commandList.push([ path_svg_1.enumCommandMap.M, x, y ]), this._ctx && this._ctx.moveTo(x, y), \n        this;\n    }\n    lineTo(x, y) {\n        return this.commandList.push([ path_svg_1.enumCommandMap.L, x, y ]), this._ctx && this._ctx.lineTo(x, y), \n        this;\n    }\n    quadraticCurveTo(aCPx, aCPy, aX, aY) {\n        return this.commandList.push([ path_svg_1.enumCommandMap.Q, aCPx, aCPy, aX, aY ]), \n        this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;\n    }\n    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n        return this.commandList.push([ path_svg_1.enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ]), \n        this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;\n    }\n    arcTo(aX1, aY1, aX2, aY2, aRadius) {\n        return this.commandList.push([ path_svg_1.enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius ]), \n        this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;\n    }\n    ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {\n        return this.commandList.push([ path_svg_1.enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise ]), \n        this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), \n        this;\n    }\n    rect(x, y, w, h) {\n        return this.commandList.push([ path_svg_1.enumCommandMap.R, x, y, w, h ]), this._ctx && this._ctx.rect(x, y, w, h), \n        this;\n    }\n    arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        return this.commandList.push([ path_svg_1.enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise ]), \n        this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), \n        this;\n    }\n    closePath() {\n        return this.commandList.push([ path_svg_1.enumCommandMap.Z ]), this._ctx && this._ctx.closePath(), \n        this;\n    }\n    addCurve(curve) {\n        this.curves.push(curve);\n    }\n    clear() {\n        this.transformCbList = null, this.commandList.length = 0, this.curves.length = 0;\n    }\n    toString() {\n        if (!this.toStringCbList) {\n            const list = [];\n            list[path_svg_1.enumCommandMap.M] = cmd => `M${cmd[1]} ${cmd[2]}`, list[path_svg_1.enumCommandMap.L] = cmd => `L${cmd[1]} ${cmd[2]}`, \n            list[path_svg_1.enumCommandMap.Q] = cmd => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, \n            list[path_svg_1.enumCommandMap.C] = cmd => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, \n            list[path_svg_1.enumCommandMap.A] = cmd => {\n                const bezierPathList = [];\n                (0, arc_1.addArcToBezierPath)(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);\n                let path = \"\";\n                for (let i = 0; i < bezierPathList.length; i += 6) path += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;\n                return path;\n            }, list[path_svg_1.enumCommandMap.Z] = cmd => \"Z\", this.toStringCbList = list;\n        }\n        const list = this.toStringCbList;\n        let path = \"\";\n        return this.commandList.forEach((c => {\n            path += list[c[0]](c);\n        })), path;\n    }\n    fromString(str, x, y, sX, sY) {\n        this.clear();\n        const commandStrList = (0, path_svg_1.parseSvgPath)(str);\n        return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), \n        this;\n    }\n    fromLine(line) {\n        const {points: points, curveType: curveType, clipRangeByDimension: clipRangeByDimension} = line.attribute;\n        if (!points) return;\n        const cache = (0, segment_1.calcLineCache)(points, curveType);\n        \"x\" === clipRangeByDimension ? this.direction = enums_1.Direction.ROW : \"y\" === clipRangeByDimension ? this.direction = enums_1.Direction.COLUMN : \"auto\" === clipRangeByDimension && (this.direction = cache.direction), \n        this.curves = cache.curves;\n    }\n    fromCustomPath2D(path, x, y, sX, sY) {\n        return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), \n        this;\n    }\n    transform(x, y, sx, sy) {\n        const commandList = this.commandList;\n        if (!this.transformCbList) {\n            const list = [];\n            list[path_svg_1.enumCommandMap.M] = this.moveToTransform, list[path_svg_1.enumCommandMap.L] = this.lineToTransform, \n            list[path_svg_1.enumCommandMap.Q] = this.quadraticCurveToTransform, list[path_svg_1.enumCommandMap.C] = this.bezierCurveToTransform, \n            list[path_svg_1.enumCommandMap.AT] = this.arcToTransform, list[path_svg_1.enumCommandMap.E] = this.ellipseTransform, \n            list[path_svg_1.enumCommandMap.R] = this.rectTransform, list[path_svg_1.enumCommandMap.A] = this.arcTransform, \n            list[path_svg_1.enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;\n        }\n        commandList.forEach((cmd => {\n            this.transformCbList[cmd[0]](cmd, x, y, sx, sy);\n        })), this._updateBounds();\n    }\n    moveToTransform(cmd, x, y, sx, sy) {\n        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;\n    }\n    lineToTransform(cmd, x, y, sx, sy) {\n        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;\n    }\n    quadraticCurveToTransform(cmd, x, y, sx, sy) {\n        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;\n    }\n    bezierCurveToTransform(cmd, x, y, sx, sy) {\n        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, \n        cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;\n    }\n    arcToTransform(cmd, x, y, sx, sy) {\n        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, \n        cmd[5] = cmd[5] * (sx + sy) / 2;\n    }\n    ellipseTransform(cmd, x, y, sx, sy) {\n        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;\n    }\n    rectTransform(cmd, x, y, sx, sy) {\n        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;\n    }\n    arcTransform(cmd, x, y, sx, sy) {\n        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;\n    }\n    closePathTransform() {}\n    _runCommandStrList(commandStrList, l = 0, t = 0, sX = 1, sY = 1) {\n        let current, tempX, tempY, tempControlX, tempControlY, previous = null, x = 0, y = 0, controlX = 0, controlY = 0;\n        for (let i = 0, len = commandStrList.length; i < len; ++i) {\n            switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale(current, sX, sY)), \n            current[0]) {\n              case \"l\":\n                x += current[1], y += current[2], this.lineTo(x + l, y + t);\n                break;\n\n              case \"L\":\n                x = current[1], y = current[2], this.lineTo(x + l, y + t);\n                break;\n\n              case \"h\":\n                x += current[1], this.lineTo(x + l, y + t);\n                break;\n\n              case \"H\":\n                x = current[1], this.lineTo(x + l, y + t);\n                break;\n\n              case \"v\":\n                y += current[1], this.lineTo(x + l, y + t);\n                break;\n\n              case \"V\":\n                y = current[1], this.lineTo(x + l, y + t);\n                break;\n\n              case \"m\":\n                x += current[1], y += current[2], this.moveTo(x + l, y + t);\n                break;\n\n              case \"M\":\n                x = current[1], y = current[2], this.moveTo(x + l, y + t);\n                break;\n\n              case \"c\":\n                tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], \n                this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), \n                x = tempX, y = tempY;\n                break;\n\n              case \"C\":\n                x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n                break;\n\n              case \"s\":\n                tempX = x + current[3], tempY = y + current[4], controlX = 2 * x - controlX, controlY = 2 * y - controlY, \n                this.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t), \n                controlX = x + current[1], controlY = y + current[2], x = tempX, y = tempY;\n                break;\n\n              case \"S\":\n                tempX = current[3], tempY = current[4], controlX = 2 * x - controlX, controlY = 2 * y - controlY, \n                this.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t), \n                x = tempX, y = tempY, controlX = current[1], controlY = current[2];\n                break;\n\n              case \"q\":\n                tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], \n                this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, \n                y = tempY;\n                break;\n\n              case \"Q\":\n                tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), \n                x = tempX, y = tempY, controlX = current[1], controlY = current[2];\n                break;\n\n              case \"t\":\n                tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, \n                controlY = y) : \"t\" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : \"q\" === previous[0] && (controlX = 2 * x - controlX, \n                controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, \n                this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, \n                y = tempY, controlX = x + current[1], controlY = y + current[2];\n                break;\n\n              case \"T\":\n                tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, \n                this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, \n                y = tempY;\n                break;\n\n              case \"a\":\n                (0, arc_1.drawArc)(this, x + l, y + t, [ current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t ]), \n                x += current[6], y += current[7];\n                break;\n\n              case \"A\":\n                (0, arc_1.drawArc)(this, x + l, y + t, [ current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t ]), \n                x = current[6], y = current[7];\n                break;\n\n              case \"z\":\n              case \"Z\":\n                this.closePath();\n            }\n            previous = current;\n        }\n    }\n    _runCommandList(commandList, l = 0, t = 0, sX = 1, sY = 1) {\n        if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY) for (let i = 0, len = commandList.length; i < len; ++i) {\n            const current = commandList[i].slice();\n            switch (current[0]) {\n              case path_svg_1.enumCommandMap.L:\n                this.lineToTransform(current, l, t, sX, sY);\n                break;\n\n              case path_svg_1.enumCommandMap.M:\n                this.moveToTransform(current, l, t, sX, sY);\n                break;\n\n              case path_svg_1.enumCommandMap.C:\n                this.bezierCurveToTransform(current, l, t, sX, sY);\n                break;\n\n              case path_svg_1.enumCommandMap.Q:\n                this.quadraticCurveToTransform(current, l, t, sX, sY);\n                break;\n\n              case path_svg_1.enumCommandMap.A:\n                this.arcToTransform(current, l, t, sX, sY);\n                break;\n\n              case path_svg_1.enumCommandMap.E:\n                this.ellipseTransform(current, l, t, sX, sY);\n                break;\n\n              case path_svg_1.enumCommandMap.R:\n                this.rectTransform(current, l, t, sX, sY);\n                break;\n\n              case path_svg_1.enumCommandMap.AT:\n                this.arcToTransform(current, l, t, sX, sY);\n                break;\n\n              case path_svg_1.enumCommandMap.Z:\n                this.closePath();\n            }\n        } else this.commandList = commandList.map((entry => entry.slice()));\n    }\n    _updateBounds() {\n        this.bounds.clear(), (0, render_command_list_1.renderCommandList)(this.commandList, this._boundsContext);\n    }\n    release() {\n        this.commandList = [], this._boundsContext = null, this._ctx = null;\n    }\n    getLength() {\n        if (this.direction === enums_1.Direction.COLUMN) {\n            if (!this.curves.length) return 0;\n            const sc = this.curves[0], ec = this.curves[this.curves.length - 1];\n            return (0, vutils_1.abs)(sc.p0.y - ec.p1.y);\n        }\n        if (this.direction === enums_1.Direction.ROW) {\n            if (!this.curves.length) return 0;\n            const sc = this.curves[0], ec = this.curves[this.curves.length - 1];\n            return (0, vutils_1.abs)(sc.p0.x - ec.p1.x);\n        }\n        return this.curves.reduce(((l, c) => l + c.getLength()), 0);\n    }\n    getAttrAt(distance) {\n        if (!this.curves) return {\n            pos: {\n                x: 0,\n                y: 0\n            },\n            angle: 0\n        };\n        let curve, _dis = 0;\n        for (let i = 0; i < this.curves.length; i++) {\n            curve = this.curves[i];\n            const cl = curve.getLength(this.direction);\n            if (_dis + cl >= distance) break;\n            _dis += cl;\n        }\n        const t = (distance - _dis) / curve.getLength(this.direction);\n        return {\n            pos: curve.getPointAt(t),\n            angle: curve.getAngleAt(t)\n        };\n    }\n}\n\nexports.CustomPath2D = CustomPath2D;\n\nconst temp = [ \"l\", 0, 0, 0, 0, 0, 0, 0 ];\n\nfunction scale(current, sX, sY) {\n    const c = temp[0] = current[0];\n    if (\"a\" === c || \"A\" === c) temp[1] = sX * current[1], temp[2] = sY * current[2], \n    temp[3] = current[3], temp[4] = current[4], temp[5] = current[5], temp[6] = sX * current[6], \n    temp[7] = sY * current[7]; else if (\"h\" === c || \"H\" === c) temp[1] = sX * current[1]; else if (\"v\" === c || \"V\" === c) temp[1] = sY * current[1]; else for (let i = 1, n = current.length; i < n; ++i) temp[i] = (i % 2 == 1 ? sX : sY) * current[i];\n    return temp;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BoundsContext = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), circleThreshold = vutils_1.tau - 1e-8;\n\nclass BoundsContext {\n    constructor(bounds) {\n        this.init(bounds);\n    }\n    init(bounds) {\n        this.bounds = bounds;\n    }\n    arc(cx, cy, r, sa, ea, ccw) {\n        if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r, cy - r), \n        void this.bounds.add(cx + r, cy + r);\n        let s, i, x, y, xmin = 1 / 0, xmax = -1 / 0, ymin = 1 / 0, ymax = -1 / 0;\n        function update(a) {\n            x = r * Math.cos(a), y = r * Math.sin(a), x < xmin && (xmin = x), x > xmax && (xmax = x), \n            y < ymin && (ymin = y), y > ymax && (ymax = y);\n        }\n        if (update(sa), update(ea), ea !== sa) if ((sa %= vutils_1.tau) < 0 && (sa += vutils_1.tau), \n        (ea %= vutils_1.tau) < 0 && (ea += vutils_1.tau), ea < sa && (ccw = !ccw, s = sa, \n        sa = ea, ea = s), ccw) for (ea -= vutils_1.tau, s = sa - sa % vutils_1.halfPi, i = 0; i < 4 && s > ea; ++i, \n        s -= vutils_1.halfPi) update(s); else for (s = sa - sa % vutils_1.halfPi + vutils_1.halfPi, \n        i = 0; i < 4 && s < ea; ++i, s += vutils_1.halfPi) update(s);\n        this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);\n    }\n    arcTo(x1, y1, x2, y2, radius) {\n        throw new Error(\"arcTo\");\n    }\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n        this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);\n    }\n    closePath() {}\n    ellipse() {\n        throw new Error(\"ellipse\");\n    }\n    lineTo(x, y) {\n        this.bounds.add(x, y);\n    }\n    moveTo(x, y) {\n        this.bounds.add(x, y);\n    }\n    quadraticCurveTo(cpx, cpy, x, y) {\n        this.bounds.add(cpx, cpy), this.bounds.add(x, y);\n    }\n    rect(x, y, w, h) {\n        this.bounds.add(x, y), this.bounds.add(x + w, y + h);\n    }\n    clear() {\n        this.bounds.clear();\n    }\n    release(...params) {}\n}\n\nexports.BoundsContext = BoundsContext;\n//# sourceMappingURL=bounds-context.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CurvePath = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nclass CurvePath {\n    constructor() {\n        this.curves = [], this.bounds = new vutils_1.AABBBounds;\n    }\n    getCurveLengths() {\n        return this.curves.map((curve => curve.getLength()));\n    }\n    getPointAt(t) {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    getLength() {\n        return 0;\n    }\n    getBounds() {\n        return this.bounds;\n    }\n}\n\nexports.CurvePath = CurvePath;\n//# sourceMappingURL=path.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.parseSvgPath = exports.enumCommandMap = void 0;\n\nconst rePathCommand = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:[eE][-+]?\\d+)?)/gi, commandLengths = {\n    m: 2,\n    l: 2,\n    h: 1,\n    v: 1,\n    c: 6,\n    s: 4,\n    q: 4,\n    t: 2,\n    a: 7,\n    M: 2,\n    L: 2,\n    H: 1,\n    V: 1,\n    C: 6,\n    S: 4,\n    Q: 4,\n    T: 2,\n    A: 7\n};\n\nlet currPath, coordsStr, commandChar, coordStr, coordNumber, standardCommandLen;\n\nfunction parseSvgPath(str) {\n    if (!str) return [];\n    const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);\n    if (null === paths) return [];\n    let currCommandData, coordsStrArr;\n    const result = [];\n    for (let i = 0, len = paths.length; i < len; i++) if (currPath = paths[i], coordsStr = currPath.slice(1), \n    commandChar = currPath[0], currCommandData = [ commandChar ], coordsStrArr = coordsStr.match(rePathCommand), \n    null !== coordsStrArr) {\n        for (let i = 0, len = coordsStrArr.length; i < len; i++) coordStr = coordsStrArr[i], \n        coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);\n        if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {\n            let subCommand;\n            for (let i = 1, len = currCommandData.length; i < len; i += standardCommandLen) {\n                subCommand = [ commandChar ];\n                for (let j = i, subLen = i + standardCommandLen; j < subLen; j++) subCommand.push(currCommandData[j]);\n                result.push(subCommand);\n            }\n        } else result.push(currCommandData);\n    } else result.push(currCommandData);\n    return result;\n}\n\nexports.enumCommandMap = {\n    A: 0,\n    AT: 1,\n    C: 2,\n    Z: 3,\n    E: 4,\n    L: 5,\n    M: 6,\n    Q: 7,\n    R: 8\n}, exports.parseSvgPath = parseSvgPath;\n//# sourceMappingURL=path-svg.js.map","\n\nvar UpdateTag, IContainPointMode, AttributeUpdateType, AnimateStatus, AnimateMode, AnimateStepType, Direction, CurveTypeEnum, BaseRenderContributionTime;\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BaseRenderContributionTime = exports.CurveTypeEnum = exports.Direction = exports.AnimateStepType = exports.AnimateMode = exports.AnimateStatus = exports.AttributeUpdateType = exports.IContainPointMode = exports.UpdateTag = void 0, \nfunction(UpdateTag) {\n    UpdateTag[UpdateTag.NONE = 0] = \"NONE\", UpdateTag[UpdateTag.UPDATE_BOUNDS = 1] = \"UPDATE_BOUNDS\", \n    UpdateTag[UpdateTag.UPDATE_SHAPE = 2] = \"UPDATE_SHAPE\", UpdateTag[UpdateTag.CLEAR_SHAPE = 253] = \"CLEAR_SHAPE\", \n    UpdateTag[UpdateTag.UPDATE_SHAPE_AND_BOUNDS = 3] = \"UPDATE_SHAPE_AND_BOUNDS\", UpdateTag[UpdateTag.INIT = 51] = \"INIT\", \n    UpdateTag[UpdateTag.CLEAR_BOUNDS = 254] = \"CLEAR_BOUNDS\", UpdateTag[UpdateTag.UPDATE_GLOBAL_MATRIX = 32] = \"UPDATE_GLOBAL_MATRIX\", \n    UpdateTag[UpdateTag.CLEAR_GLOBAL_MATRIX = 223] = \"CLEAR_GLOBAL_MATRIX\", UpdateTag[UpdateTag.UPDATE_LOCAL_MATRIX = 16] = \"UPDATE_LOCAL_MATRIX\", \n    UpdateTag[UpdateTag.CLEAR_LOCAL_MATRIX = 239] = \"CLEAR_LOCAL_MATRIX\", UpdateTag[UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = \"UPDATE_GLOBAL_LOCAL_MATRIX\";\n}(UpdateTag = exports.UpdateTag || (exports.UpdateTag = {})), function(IContainPointMode) {\n    IContainPointMode[IContainPointMode.GLOBAL = 1] = \"GLOBAL\", IContainPointMode[IContainPointMode.LOCAL = 16] = \"LOCAL\", \n    IContainPointMode[IContainPointMode.GLOBAL_ACCURATE = 3] = \"GLOBAL_ACCURATE\", IContainPointMode[IContainPointMode.LOCAL_ACCURATE = 48] = \"LOCAL_ACCURATE\";\n}(IContainPointMode = exports.IContainPointMode || (exports.IContainPointMode = {})), \nfunction(AttributeUpdateType) {\n    AttributeUpdateType[AttributeUpdateType.INIT = 0] = \"INIT\", AttributeUpdateType[AttributeUpdateType.DEFAULT = 1] = \"DEFAULT\", \n    AttributeUpdateType[AttributeUpdateType.STATE = 2] = \"STATE\", AttributeUpdateType[AttributeUpdateType.ANIMATE_BIND = 10] = \"ANIMATE_BIND\", \n    AttributeUpdateType[AttributeUpdateType.ANIMATE_PLAY = 11] = \"ANIMATE_PLAY\", AttributeUpdateType[AttributeUpdateType.ANIMATE_START = 12] = \"ANIMATE_START\", \n    AttributeUpdateType[AttributeUpdateType.ANIMATE_UPDATE = 13] = \"ANIMATE_UPDATE\", \n    AttributeUpdateType[AttributeUpdateType.ANIMATE_END = 14] = \"ANIMATE_END\", AttributeUpdateType[AttributeUpdateType.TRANSLATE = 20] = \"TRANSLATE\", \n    AttributeUpdateType[AttributeUpdateType.TRANSLATE_TO = 21] = \"TRANSLATE_TO\", AttributeUpdateType[AttributeUpdateType.SCALE = 22] = \"SCALE\", \n    AttributeUpdateType[AttributeUpdateType.SCALE_TO = 23] = \"SCALE_TO\", AttributeUpdateType[AttributeUpdateType.ROTATE = 24] = \"ROTATE\", \n    AttributeUpdateType[AttributeUpdateType.ROTATE_TO = 25] = \"ROTATE_TO\";\n}(AttributeUpdateType = exports.AttributeUpdateType || (exports.AttributeUpdateType = {})), \nfunction(AnimateStatus) {\n    AnimateStatus[AnimateStatus.INITIAL = 0] = \"INITIAL\", AnimateStatus[AnimateStatus.RUNNING = 1] = \"RUNNING\", \n    AnimateStatus[AnimateStatus.PAUSED = 2] = \"PAUSED\", AnimateStatus[AnimateStatus.END = 3] = \"END\";\n}(AnimateStatus = exports.AnimateStatus || (exports.AnimateStatus = {})), function(AnimateMode) {\n    AnimateMode[AnimateMode.NORMAL = 0] = \"NORMAL\", AnimateMode[AnimateMode.SET_ATTR_IMMEDIATELY = 1] = \"SET_ATTR_IMMEDIATELY\";\n}(AnimateMode = exports.AnimateMode || (exports.AnimateMode = {})), function(AnimateStepType) {\n    AnimateStepType.wait = \"wait\", AnimateStepType.from = \"from\", AnimateStepType.to = \"to\", \n    AnimateStepType.customAnimate = \"customAnimate\";\n}(AnimateStepType = exports.AnimateStepType || (exports.AnimateStepType = {})), \nfunction(Direction) {\n    Direction[Direction.ROW = 1] = \"ROW\", Direction[Direction.COLUMN = 2] = \"COLUMN\";\n}(Direction = exports.Direction || (exports.Direction = {})), function(CurveTypeEnum) {\n    CurveTypeEnum[CurveTypeEnum.CubicBezierCurve = 0] = \"CubicBezierCurve\", CurveTypeEnum[CurveTypeEnum.QuadraticBezierCurve = 1] = \"QuadraticBezierCurve\", \n    CurveTypeEnum[CurveTypeEnum.ArcCurve = 2] = \"ArcCurve\", CurveTypeEnum[CurveTypeEnum.LineCurve = 3] = \"LineCurve\", \n    CurveTypeEnum[CurveTypeEnum.EllipseCurve = 4] = \"EllipseCurve\", CurveTypeEnum[CurveTypeEnum.MoveCurve = 5] = \"MoveCurve\";\n}(CurveTypeEnum = exports.CurveTypeEnum || (exports.CurveTypeEnum = {})), function(BaseRenderContributionTime) {\n    BaseRenderContributionTime[BaseRenderContributionTime.beforeFillStroke = 0] = \"beforeFillStroke\", \n    BaseRenderContributionTime[BaseRenderContributionTime.afterFillStroke = 1] = \"afterFillStroke\";\n}(BaseRenderContributionTime = exports.BaseRenderContributionTime || (exports.BaseRenderContributionTime = {}));\n//# sourceMappingURL=enums.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.addArcToBezierPath = exports.drawArc = exports.bezier = exports.segments = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nfunction segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n    const th = (0, vutils_1.degreeToRadian)(rotateX), sin_th = Math.sin(th), cos_th = Math.cos(th), px = cos_th * (ox - x) * .5 + sin_th * (oy - y) * .5, py = cos_th * (oy - y) * .5 - sin_th * (ox - x) * .5;\n    let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);\n    pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);\n    const a00 = cos_th / rx, a01 = sin_th / rx, a10 = -sin_th / ry, a11 = cos_th / ry, x0 = a00 * ox + a01 * oy, y0 = a10 * ox + a11 * oy, x1 = a00 * x + a01 * y, y1 = a10 * x + a11 * y;\n    let sfactor_sq = 1 / ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) - .25;\n    sfactor_sq < 0 && (sfactor_sq = 0);\n    let sfactor = Math.sqrt(sfactor_sq);\n    sweep === large && (sfactor = -sfactor);\n    const xc = .5 * (x0 + x1) - sfactor * (y1 - y0), yc = .5 * (y0 + y1) + sfactor * (x1 - x0), th0 = Math.atan2(y0 - yc, x0 - xc);\n    let th_arc = Math.atan2(y1 - yc, x1 - xc) - th0;\n    th_arc < 0 && 1 === sweep ? th_arc += vutils_1.tau : th_arc > 0 && 0 === sweep && (th_arc -= vutils_1.tau);\n    const segs = Math.ceil(Math.abs(th_arc / (vutils_1.halfPi + .001))), result = [];\n    for (let i = 0; i < segs; ++i) {\n        const th2 = th0 + i * th_arc / segs, th3 = th0 + (i + 1) * th_arc / segs;\n        result[i] = [ xc, yc, th2, th3, rx, ry, sin_th, cos_th ];\n    }\n    return result;\n}\n\nfunction bezier(params) {\n    const cx = params[0], cy = params[1], th0 = params[2], th1 = params[3], rx = params[4], ry = params[5], sin_th = params[6], cos_th = params[7], a00 = cos_th * rx, a01 = -sin_th * ry, a10 = sin_th * rx, a11 = cos_th * ry, cos_th0 = Math.cos(th0), sin_th0 = Math.sin(th0), cos_th1 = Math.cos(th1), sin_th1 = Math.sin(th1), th_half = .5 * (th1 - th0), sin_th_h2 = Math.sin(.5 * th_half), t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half), x1 = cx + cos_th0 - t * sin_th0, y1 = cy + sin_th0 + t * cos_th0, x3 = cx + cos_th1, y3 = cy + sin_th1, x2 = x3 + t * sin_th1, y2 = y3 - t * cos_th1;\n    return [ a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3 ];\n}\n\nfunction drawArc(context, x, y, coords) {\n    const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);\n    for (let i = 0; i < seg.length; ++i) {\n        const bez = bezier(seg[i]);\n        context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n    }\n}\n\nexports.segments = segments, exports.bezier = bezier, exports.drawArc = drawArc;\n\nconst addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry) => {\n    const delta = Math.abs(endAngle - startAngle), len = 4 * Math.tan(delta / 4) / 3, dir = endAngle < startAngle ? -1 : 1, c1 = Math.cos(startAngle), s1 = Math.sin(startAngle), c2 = Math.cos(endAngle), s2 = Math.sin(endAngle), x1 = c1 * rx + cx, y1 = s1 * ry + cy, x4 = c2 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;\n    bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n};\n\nexports.addArcToBezierPath = addArcToBezierPath;\n//# sourceMappingURL=arc.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.renderCommandList = void 0;\n\nconst commandFuncs = [ (command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z), (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z), (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z), (command, context, x, y) => context.closePath(), (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z), (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z) ];\n\nfunction renderCommandList(commandList, context, x = 0, y = 0, sx = 1, sy = 1, z) {\n    for (let i = 0; i < commandList.length; i++) {\n        const command = commandList[i];\n        commandFuncs[command[0]](command, context, x, y, sx, sy, z);\n    }\n}\n\nexports.renderCommandList = renderCommandList;\n//# sourceMappingURL=render-command-list.js.map","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.calcLineCache = void 0;\n\nconst linear_1 = require(\"./linear\"), basis_1 = require(\"./basis\"), monotone_1 = require(\"./monotone\"), step_1 = require(\"./step\"), linear_closed_1 = require(\"./linear-closed\");\n\nfunction calcLineCache(points, curveType, params) {\n    switch (curveType) {\n      case \"linear\":\n      default:\n        return (0, linear_1.genLinearSegments)(points, params);\n\n      case \"basis\":\n        return (0, basis_1.genBasisSegments)(points, params);\n\n      case \"monotoneX\":\n        return (0, monotone_1.genMonotoneXSegments)(points, params);\n\n      case \"monotoneY\":\n        return (0, monotone_1.genMonotoneYSegments)(points, params);\n\n      case \"step\":\n        return (0, step_1.genStepSegments)(points, .5, params);\n\n      case \"stepBefore\":\n        return (0, step_1.genStepSegments)(points, 0, params);\n\n      case \"stepAfter\":\n        return (0, step_1.genStepSegments)(points, 1, params);\n\n      case \"linearClosed\":\n        return (0, linear_closed_1.genLinearClosedSegments)(points, params);\n    }\n}\n\n__exportStar(require(\"./linear\"), exports), __exportStar(require(\"./linear-closed\"), exports), \n__exportStar(require(\"./basis\"), exports), __exportStar(require(\"./monotone\"), exports), \n__exportStar(require(\"./step\"), exports), __exportStar(require(\"./curve/curve-context\"), exports), \nexports.calcLineCache = calcLineCache;\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.genLinearTypeSegments = exports.genLinearSegments = exports.Linear = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), seg_context_1 = require(\"../seg-context\"), common_1 = require(\"./common\"), enums_1 = require(\"../enums\");\n\nclass Linear {\n    constructor(context, startPoint) {\n        this.context = context, startPoint && (this.startPoint = startPoint);\n    }\n    areaStart() {\n        this._line = 0;\n    }\n    areaEnd() {\n        this._line = NaN;\n    }\n    lineStart() {\n        this._point = 0, this.startPoint && this.point(this.startPoint);\n    }\n    lineEnd() {\n        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), \n        this._line = 1 - this._line;\n    }\n    point(p) {\n        const x = p.x, y = p.y;\n        switch (this._point) {\n          case 0:\n            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined) : this.context.moveTo(x, y);\n            break;\n\n          case 1:\n            this._point = 2;\n\n          default:\n            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined);\n        }\n        this._lastDefined = p.defined;\n    }\n    tryUpdateLength() {\n        return this.context.tryUpdateLength();\n    }\n}\n\nfunction genLinearSegments(points, params = {}) {\n    const {direction: direction, startPoint: startPoint} = params;\n    if (points.length < 2 - Number(!!startPoint)) return null;\n    const segContext = new seg_context_1.SegContext(\"linear\", null != direction ? direction : (0, \n    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);\n    return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;\n}\n\nfunction genLinearTypeSegments(path, points) {\n    return (0, common_1.genCurveSegments)(path, points, 1);\n}\n\nexports.Linear = Linear, exports.genLinearSegments = genLinearSegments, exports.genLinearTypeSegments = genLinearTypeSegments;\n//# sourceMappingURL=linear.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.ReflectSegContext = exports.SegContext = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), enums_1 = require(\"./enums\"), cubic_bezier_1 = require(\"./segment/curve/cubic-bezier\"), line_1 = require(\"./segment/curve/line\");\n\nclass SegContext {\n    get endX() {\n        return this._lastX;\n    }\n    get endY() {\n        return this._lastY;\n    }\n    constructor(curveType, direction) {\n        this.init(curveType, direction);\n    }\n    init(curveType, direction) {\n        this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, \n        this.direction = direction, this.curves = [];\n    }\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined) {\n        const curve = new cubic_bezier_1.CubicBezierCurve(new vutils_1.Point(this._lastX, this._lastY), new vutils_1.Point(cp1x, cp1y), new vutils_1.Point(cp2x, cp2y), new vutils_1.Point(x, y));\n        curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y;\n    }\n    closePath() {\n        if (this.curves.length < 2) return;\n        const lastCurve = this.curves[this.curves.length - 1];\n        this.lineTo(this._startX, this._startY, lastCurve.defined);\n    }\n    ellipse() {\n        throw new Error(\"SegContextellipse\");\n    }\n    lineTo(x, y, defined) {\n        const curve = this.addLinearCurve(x, y, defined);\n        this.curves.push(curve), this._lastX = x, this._lastY = y;\n    }\n    moveTo(x, y) {\n        return this._lastX = this._startX = x, this._lastY = this._startY = y, this;\n    }\n    quadraticCurveTo(cpx, cpy, x, y) {\n        throw new Error(\"SegContextquadraticCurveTo\");\n    }\n    clear() {\n        this.curves = [], this.length = NaN;\n    }\n    tryUpdateLength(direction) {\n        return this.getLength(direction);\n    }\n    addLinearCurve(x, y, defined) {\n        const curve = new line_1.LineCurve(new vutils_1.Point(this._lastX, this._lastY), new vutils_1.Point(x, y));\n        return curve.defined = defined, curve;\n    }\n    getPointAt(t) {\n        throw new Error(\"\");\n    }\n    getCurveLengths() {\n        return [];\n    }\n    getLength(direction) {\n        if (direction === enums_1.Direction.COLUMN) {\n            if (!this.curves.length) return 0;\n            const sc = this.curves[0], ec = this.curves[this.curves.length - 1];\n            return (0, vutils_1.abs)(sc.p0.y - ec.p1.y);\n        }\n        if (direction === enums_1.Direction.ROW) {\n            if (!this.curves.length) return 0;\n            const sc = this.curves[0], ec = this.curves[this.curves.length - 1];\n            return (0, vutils_1.abs)(sc.p0.x - ec.p1.x);\n        }\n        return Number.isFinite(this.length) || (this.length = this.curves.reduce(((l, c) => l + c.getLength()), 0)), \n        this.length;\n    }\n}\n\nexports.SegContext = SegContext;\n\nclass ReflectSegContext extends SegContext {\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined) {\n        return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined);\n    }\n    lineTo(x, y, defined) {\n        return super.lineTo(y, x, defined);\n    }\n    moveTo(x, y) {\n        return super.moveTo(y, x);\n    }\n    clear() {\n        return super.clear();\n    }\n}\n\nexports.ReflectSegContext = ReflectSegContext;\n//# sourceMappingURL=seg-context.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CubicBezierCurve = exports.divideCubic = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), base_1 = require(\"./base\"), enums_1 = require(\"../../enums\"), bezier_utils_1 = require(\"../../bezier-utils\");\n\nfunction divideCubic(curve, t) {\n    const {p0: p0, p1: p1, p2: p2, p3: p3} = curve, pt = (0, bezier_utils_1.cubicPointAt)(p0, p1, p2, p3, t), c1 = vutils_1.PointService.pointAtPP(p0, p1, t), c2 = vutils_1.PointService.pointAtPP(p1, p2, t), c3 = vutils_1.PointService.pointAtPP(p2, p3, t), c12 = vutils_1.PointService.pointAtPP(c1, c2, t), c23 = vutils_1.PointService.pointAtPP(c2, c3, t);\n    return [ new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3) ];\n}\n\nexports.divideCubic = divideCubic;\n\nclass CubicBezierCurve extends base_1.Curve {\n    constructor(p0, p1, p2, p3) {\n        super(), this.type = enums_1.CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, \n        this.p2 = p2, this.p3 = p3;\n    }\n    _validPoint() {\n        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);\n    }\n    getPointAt(t) {\n        if (!1 !== this.defined) return (0, bezier_utils_1.cubicPointAt)(this.p0, this.p1, this.p2, this.p3, t);\n        throw new Error(\"definedfalsegetPointAt\");\n    }\n    calcLength() {\n        return this._validPoint() ? (0, bezier_utils_1.cubicLength)(this.p0, this.p1, this.p2, this.p3, 0) : 60;\n    }\n    calcProjLength(direction) {\n        return direction === enums_1.Direction.ROW ? (0, vutils_1.abs)(this.p0.x - this.p3.x) : direction === enums_1.Direction.COLUMN ? (0, \n        vutils_1.abs)(this.p0.y - this.p3.y) : 0;\n    }\n    getAngleAt(t) {\n        const minT = (0, vutils_1.max)(t - .01, 0), maxT = (0, vutils_1.min)(t + .01, 1), minP = this.getPointAt(minT), maxP = this.getPointAt(maxT);\n        return (0, vutils_1.atan2)(maxP.y - minP.y, maxP.x - minP.x);\n    }\n}\n\nexports.CubicBezierCurve = CubicBezierCurve;\n//# sourceMappingURL=cubic-bezier.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Curve = void 0;\n\nclass Curve {\n    getLength(direction) {\n        return null != direction ? this.calcProjLength(direction) : (Number.isFinite(this.length) || (this.length = this.calcLength()), \n        this.length);\n    }\n}\n\nexports.Curve = Curve;\n//# sourceMappingURL=base.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.cubicPointAt = exports.cubicCalc = exports.cubicLength = exports.snapLength = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nfunction snapLength(xArr, yArr) {\n    let totalLength = 0;\n    const count = xArr.length;\n    for (let i = 0; i < count; i++) {\n        const x = xArr[i], y = yArr[i], nextX = xArr[(i + 1) % count], nextY = yArr[(i + 1) % count];\n        totalLength += vutils_1.PointService.distanceNN(x, y, nextX, nextY);\n    }\n    return totalLength / 2;\n}\n\nfunction cubicLength(p0, p1, p2, p3, iterationCount) {\n    return snapLength([ p0.x, p1.x, p2.x, p3.x ], [ p0.y, p1.y, p2.y, p3.y ]);\n}\n\nfunction cubicCalc(p0, p1, p2, p3, t) {\n    const one = 1 - t;\n    return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;\n}\n\nfunction cubicPointAt(p0, p1, p2, p3, t) {\n    const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t), y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);\n    return new vutils_1.Point(x, y);\n}\n\nexports.snapLength = snapLength, exports.cubicLength = cubicLength, exports.cubicCalc = cubicCalc, \nexports.cubicPointAt = cubicPointAt;\n//# sourceMappingURL=bezier-utils.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.LineCurve = exports.divideLinear = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), base_1 = require(\"./base\"), enums_1 = require(\"../../enums\");\n\nfunction divideLinear(curve, t) {\n    const {p0: p0, p1: p1} = curve, c1 = vutils_1.PointService.pointAtPP(p0, p1, t);\n    return [ new LineCurve(p0, c1), new LineCurve(c1, p1) ];\n}\n\nexports.divideLinear = divideLinear;\n\nclass LineCurve extends base_1.Curve {\n    constructor(p0, p1) {\n        super(), this.type = enums_1.CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;\n    }\n    getPointAt(t) {\n        if (!1 !== this.defined) return vutils_1.PointService.pointAtPP(this.p0, this.p1, t);\n        throw new Error(\"definedfalsegetPointAt\");\n    }\n    getAngleAt(t) {\n        return null == this.angle && (this.angle = (0, vutils_1.atan2)(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), \n        this.angle;\n    }\n    _validPoint() {\n        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);\n    }\n    calcLength() {\n        return this._validPoint() ? vutils_1.PointService.distancePP(this.p0, this.p1) : 60;\n    }\n    calcProjLength(direction) {\n        return direction === enums_1.Direction.ROW ? (0, vutils_1.abs)(this.p0.x - this.p1.x) : direction === enums_1.Direction.COLUMN ? (0, \n        vutils_1.abs)(this.p0.y - this.p1.y) : 0;\n    }\n}\n\nexports.LineCurve = LineCurve;\n//# sourceMappingURL=line.js.map\n","\n\nfunction genCurveSegments(path, points, step = 1) {\n    let defined0 = !1;\n    for (let i = 0, n = points.length; i <= n; i++) i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), \n    defined0 && path.point(points[i]);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.genCurveSegments = void 0, exports.genCurveSegments = genCurveSegments;\n//# sourceMappingURL=common.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.genBasisSegments = exports.genBasisTypeSegments = exports.Basis = exports.point = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), linear_1 = require(\"./linear\"), common_1 = require(\"./common\"), seg_context_1 = require(\"../seg-context\"), enums_1 = require(\"../enums\");\n\nfunction point(curveClass, x, y, defined) {\n    curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined);\n}\n\nexports.point = point;\n\nclass Basis {\n    constructor(context, startPoint) {\n        this.context = context, this.startPoint = startPoint;\n    }\n    areaStart() {\n        this._line = 0;\n    }\n    areaEnd() {\n        this._line = NaN;\n    }\n    lineStart() {\n        this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);\n    }\n    lineEnd() {\n        if (2 === this._point) point(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);\n        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), \n        this._line = 1 - this._line;\n    }\n    point(p) {\n        const x = p.x, y = p.y;\n        switch (this._point) {\n          case 0:\n            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2) : this.context.moveTo(x, y);\n            break;\n\n          case 1:\n            this._point = 2;\n            break;\n\n          default:\n            point(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);\n        }\n        this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, \n        this._lastDefined2 = p.defined;\n    }\n    tryUpdateLength() {\n        return this.context.tryUpdateLength();\n    }\n}\n\nfunction genBasisTypeSegments(path, points) {\n    return (0, common_1.genCurveSegments)(path, points, 2);\n}\n\nfunction genBasisSegments(points, params = {}) {\n    const {direction: direction, startPoint: startPoint} = params;\n    if (points.length < 2 - Number(!!startPoint)) return null;\n    if (points.length < 3 - Number(!!startPoint)) return (0, linear_1.genLinearSegments)(points, params);\n    const segContext = new seg_context_1.SegContext(\"basis\", null != direction ? direction : (0, \n    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);\n    return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;\n}\n\nexports.Basis = Basis, exports.genBasisTypeSegments = genBasisTypeSegments, exports.genBasisSegments = genBasisSegments;\n//# sourceMappingURL=basis.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.genMonotoneYSegments = exports.genMonotpneYTypeSegments = exports.genMonotoneXSegments = exports.genMonotpneXTypeSegments = exports.MonotoneY = exports.MonotoneX = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), linear_1 = require(\"./linear\"), common_1 = require(\"./common\"), seg_context_1 = require(\"../seg-context\"), enums_1 = require(\"../enums\");\n\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction slope3(curveClass, x2, y2) {\n    const h0 = curveClass._x1 - curveClass._x0, h1 = x2 - curveClass._x1, s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)), s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)), p = (s0 * h1 + s1 * h0) / (h0 + h1);\n    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;\n}\n\nfunction slope2(curveClass, t) {\n    const h = curveClass._x1 - curveClass._x0;\n    return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;\n}\n\nfunction point(curveClass, t0, t1, defined) {\n    const x0 = curveClass._x0, y0 = curveClass._y0, x1 = curveClass._x1, y1 = curveClass._y1, dx = (x1 - x0) / 3;\n    curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined);\n}\n\nclass MonotoneX {\n    constructor(context, startPoint) {\n        this.context = context, this.startPoint = startPoint;\n    }\n    areaStart() {\n        this._line = 0;\n    }\n    areaEnd() {\n        this._line = NaN;\n    }\n    lineStart() {\n        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);\n    }\n    lineEnd() {\n        switch (this._point) {\n          case 2:\n            this.context.lineTo(this._x1, this._y1, !1 !== this._lastDefined2);\n            break;\n\n          case 3:\n            point(this, this._t0, slope2(this, this._t0), !1 !== this._lastDefined2);\n        }\n        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), \n        this._line = 1 - this._line;\n    }\n    point(p) {\n        let t1 = NaN;\n        const x = p.x, y = p.y;\n        if (x !== this._x1 || y !== this._y1) {\n            switch (this._point) {\n              case 0:\n                this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2) : this.context.moveTo(x, y);\n                break;\n\n              case 1:\n                this._point = 2;\n                break;\n\n              case 2:\n                this._point = 3, point(this, slope2(this, t1 = slope3(this, x, y)), t1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);\n                break;\n\n              default:\n                point(this, this._t0, t1 = slope3(this, x, y), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);\n            }\n            this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, \n            this._lastDefined1 = this._lastDefined2, this._lastDefined2 = !1 !== p.defined;\n        }\n    }\n    tryUpdateLength() {\n        return this.context.tryUpdateLength();\n    }\n}\n\nexports.MonotoneX = MonotoneX;\n\nclass MonotoneY extends MonotoneX {\n    constructor(context, startPoint) {\n        super(context, startPoint);\n    }\n    point(p) {\n        return super.point({\n            y: p.x,\n            x: p.y,\n            defined: p.defined\n        });\n    }\n}\n\nfunction genMonotpneXTypeSegments(path, points) {\n    return (0, common_1.genCurveSegments)(path, points, 2);\n}\n\nfunction genMonotoneXSegments(points, params = {}) {\n    const {direction: direction, startPoint: startPoint} = params;\n    if (points.length < 2 - Number(!!startPoint)) return null;\n    if (points.length < 3 - Number(!!startPoint)) return (0, linear_1.genLinearSegments)(points, params);\n    const segContext = new seg_context_1.SegContext(\"monotoneX\", null != direction ? direction : (0, \n    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);\n    return genMonotpneXTypeSegments(new MonotoneX(segContext, startPoint), points), \n    segContext;\n}\n\nfunction genMonotpneYTypeSegments(path, points) {\n    return (0, common_1.genCurveSegments)(path, points, 2);\n}\n\nfunction genMonotoneYSegments(points, params = {}) {\n    const {direction: direction, startPoint: startPoint} = params;\n    if (points.length < 2 - Number(!!startPoint)) return null;\n    if (points.length < 3 - Number(!!startPoint)) return (0, linear_1.genLinearSegments)(points, params);\n    const segContext = new seg_context_1.ReflectSegContext(\"monotoneY\", null != direction ? direction : (0, \n    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);\n    return genMonotpneYTypeSegments(new MonotoneY(segContext, startPoint), points), \n    segContext;\n}\n\nexports.MonotoneY = MonotoneY, exports.genMonotpneXTypeSegments = genMonotpneXTypeSegments, \nexports.genMonotoneXSegments = genMonotoneXSegments, exports.genMonotpneYTypeSegments = genMonotpneYTypeSegments, \nexports.genMonotoneYSegments = genMonotoneYSegments;\n//# sourceMappingURL=monotone.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.genStepTypeSegments = exports.genStepSegments = exports.Step = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), seg_context_1 = require(\"../seg-context\"), common_1 = require(\"./common\"), enums_1 = require(\"../enums\");\n\nclass Step {\n    constructor(context, t = .5, startPoint) {\n        this.context = context, this._t = t, this.startPoint = startPoint;\n    }\n    areaStart() {\n        this._line = 0;\n    }\n    areaEnd() {\n        this._line = NaN;\n    }\n    lineStart() {\n        this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);\n    }\n    lineEnd() {\n        0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, !1 !== this._lastDefined), \n        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), \n        this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);\n    }\n    point(p) {\n        const x = p.x, y = p.y;\n        switch (this._point) {\n          case 0:\n            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined) : this.context.moveTo(x, y);\n            break;\n\n          case 1:\n            this._point = 2;\n\n          default:\n            if (this._t <= 0) this.context.lineTo(this._x, y, !1 !== this._lastDefined && !1 !== p.defined), \n            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined); else {\n                const x1 = this._x * (1 - this._t) + x * this._t;\n                this.context.lineTo(x1, this._y, !1 !== this._lastDefined && !1 !== p.defined), \n                this.context.lineTo(x1, y, !1 !== this._lastDefined && !1 !== p.defined);\n            }\n        }\n        this._lastDefined = p.defined, this._x = x, this._y = y;\n    }\n    tryUpdateLength() {\n        return this.context.tryUpdateLength();\n    }\n}\n\nfunction genStepSegments(points, t, params = {}) {\n    const {direction: direction, startPoint: startPoint} = params;\n    if (points.length < 2 - Number(!!startPoint)) return null;\n    const segContext = new seg_context_1.SegContext(\"step\", null != direction ? direction : (0, \n    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);\n    return genStepTypeSegments(new Step(segContext, t, startPoint), points), segContext;\n}\n\nfunction genStepTypeSegments(path, points) {\n    return (0, common_1.genCurveSegments)(path, points, 1);\n}\n\nexports.Step = Step, exports.genStepSegments = genStepSegments, exports.genStepTypeSegments = genStepTypeSegments;\n//# sourceMappingURL=step.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.genLinearClosedTypeSegments = exports.genLinearClosedSegments = exports.LinearClosed = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), seg_context_1 = require(\"../seg-context\"), common_1 = require(\"./common\"), enums_1 = require(\"../enums\");\n\nclass LinearClosed {\n    constructor(context, startPoint) {\n        this.context = context, startPoint && (this.startPoint = startPoint);\n    }\n    areaStart() {\n        this._line = 0;\n    }\n    areaEnd() {\n        this._line = NaN;\n    }\n    lineStart() {\n        this._point = 0, this.startPoint && this.point(this.startPoint);\n    }\n    lineEnd() {\n        this.context.closePath();\n    }\n    point(p) {\n        const x = p.x, y = p.y;\n        switch (this._point) {\n          case 0:\n            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined) : this.context.moveTo(x, y);\n            break;\n\n          case 1:\n            this._point = 2;\n\n          default:\n            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined);\n        }\n        this._lastDefined = p.defined;\n    }\n    tryUpdateLength() {\n        return this.context.tryUpdateLength();\n    }\n}\n\nfunction genLinearClosedSegments(points, params = {}) {\n    const {direction: direction, startPoint: startPoint} = params;\n    if (points.length < 2 - Number(!!startPoint)) return null;\n    const segContext = new seg_context_1.SegContext(\"linear\", null != direction ? direction : (0, \n    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);\n    return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), \n    segContext;\n}\n\nfunction genLinearClosedTypeSegments(path, points) {\n    return (0, common_1.genCurveSegments)(path, points, 1);\n}\n\nexports.LinearClosed = LinearClosed, exports.genLinearClosedSegments = genLinearClosedSegments, \nexports.genLinearClosedTypeSegments = genLinearClosedTypeSegments;\n//# sourceMappingURL=linear-closed.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CurveContext = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), line_1 = require(\"./line\"), cubic_bezier_1 = require(\"./cubic-bezier\");\n\nclass CurveContext {\n    constructor(path) {\n        this.path = path, this._lastX = this._lastY = this._startX = this._startY = 0;\n    }\n    moveTo(x, y) {\n        return this._lastX = this._startX = x, this._lastY = this._startY = y, this;\n    }\n    lineTo(x, y) {\n        const curve = this.addLinearCurve(x, y);\n        this.path.curves.push(curve), this._lastX = x, this._lastY = y;\n    }\n    addLinearCurve(x, y) {\n        return new line_1.LineCurve(new vutils_1.Point(this._lastX, this._lastY), new vutils_1.Point(x, y));\n    }\n    quadraticCurveTo(aCPx, aCPy, aX, aY) {\n        throw new Error(\"CurveContextquadraticCurveTo\");\n    }\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n        const curve = new cubic_bezier_1.CubicBezierCurve(new vutils_1.Point(this._lastX, this._lastY), new vutils_1.Point(cp1x, cp1y), new vutils_1.Point(cp2x, cp2y), new vutils_1.Point(x, y));\n        this.path.curves.push(curve), this._lastX = x, this._lastY = y;\n    }\n    arcTo(aX1, aY1, aX2, aY2, aRadius) {\n        throw new Error(\"CurveContextarcTo\");\n    }\n    ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {\n        throw new Error(\"CurveContextellipse\");\n    }\n    rect(x, y, w, h) {\n        throw new Error(\"CurveContextrect\");\n    }\n    arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n        throw new Error(\"CurveContextarc\");\n    }\n    closePath() {\n        this.path.curves.length < 2 || this.lineTo(this._startX, this._startY);\n    }\n}\n\nexports.CurveContext = CurveContext;\n//# sourceMappingURL=curve-context.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.containStroke = exports.contain = exports.cubicExtrema = exports.cubicRootAt = exports.transformPoint = exports.containLineStroke = exports.containArcStroke = exports.containCubicStroke = exports.containQuadStroke = exports.normalizeRadian = exports.cubicProjectPoint = exports.quadraticProjectPoint = exports.quadraticExtremum = exports.quadraticRootAt = exports.cubicAt = exports.quadraticAt = exports.isNumber = exports.vec2Equals = exports.wrapContext = exports.wrapCanvas = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), path_svg_1 = require(\"../common/path-svg\"), container_1 = require(\"../container\"), application_1 = require(\"../application\"), constants_1 = require(\"./constants\");\n\nfunction wrapCanvas(params) {\n    return container_1.container.getNamed(constants_1.CanvasFactory, application_1.application.global.env)(params);\n}\n\nfunction wrapContext(canvas, dpr) {\n    return container_1.container.getNamed(constants_1.Context2dFactory, application_1.application.global.env)(canvas, dpr);\n}\n\nexports.wrapCanvas = wrapCanvas, exports.wrapContext = wrapContext;\n\nconst EPSILON_NUMERIC = 1e-4, THREE_SQRT = Math.sqrt(3), ONE_THIRD = 1 / 3;\n\nfunction isAroundZero(val) {\n    return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n    return val > EPSILON || val < -EPSILON;\n}\n\nfunction vec2Equals(d1, d2) {\n    return Math.abs(d1[0] - d2[0]) + Math.abs(d1[1] - d2[1]) < 1e-10;\n}\n\nfunction isNumber(data) {\n    return \"number\" == typeof data && Number.isFinite(data);\n}\n\nexports.vec2Equals = vec2Equals, exports.isNumber = isNumber;\n\nconst _v0 = [ 0, 0 ], _v1 = [ 0, 0 ], _v2 = [ 0, 0 ];\n\nfunction distanceSquare(v1, v2) {\n    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nfunction quadraticAt(p0, p1, p2, t) {\n    const onet = 1 - t;\n    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n    const onet = 1 - t;\n    return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n    const a = p0 - 2 * p1 + p2, b = 2 * (p1 - p0), c = p0 - val;\n    let n = 0;\n    if (isAroundZero(a)) {\n        if (isNotAroundZero(b)) {\n            const t1 = -c / b;\n            t1 >= 0 && t1 <= 1 && (roots[n++] = t1);\n        }\n    } else {\n        const disc = b * b - 4 * a * c;\n        if (isAroundZero(disc)) {\n            const t1 = -b / (2 * a);\n            t1 >= 0 && t1 <= 1 && (roots[n++] = t1);\n        } else if (disc > 0) {\n            const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a), t2 = (-b - discSqrt) / (2 * a);\n            t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);\n        }\n    }\n    return n;\n}\n\nfunction quadraticExtremum(p0, p1, p2) {\n    const divider = p0 + p2 - 2 * p1;\n    return 0 === divider ? .5 : (p0 - p1) / divider;\n}\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n    let t = 0, interval = .005, d = 1 / 0;\n    _v0[0] = x, _v0[1] = y;\n    for (let _t = 0; _t < 1; _t += .05) {\n        _v1[0] = quadraticAt(x0, x1, x2, _t), _v1[1] = quadraticAt(y0, y1, y2, _t);\n        const d1 = distanceSquare(_v0, _v1);\n        d1 < d && (t = _t, d = d1);\n    }\n    d = 1 / 0;\n    for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {\n        const prev = t - interval, next = t + interval;\n        _v1[0] = quadraticAt(x0, x1, x2, prev), _v1[1] = quadraticAt(y0, y1, y2, prev);\n        const d1 = distanceSquare(_v1, _v0);\n        if (prev >= 0 && d1 < d) t = prev, d = d1; else {\n            _v2[0] = quadraticAt(x0, x1, x2, next), _v2[1] = quadraticAt(y0, y1, y2, next);\n            const d2 = distanceSquare(_v2, _v0);\n            next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5;\n        }\n    }\n    return out && (out[0] = quadraticAt(x0, x1, x2, t), out[1] = quadraticAt(y0, y1, y2, t)), \n    Math.sqrt(d);\n}\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n    let prev, next, d1, d2, t = 0, interval = .005, d = 1 / 0;\n    _v0[0] = x, _v0[1] = y;\n    for (let _t = 0; _t < 1; _t += .05) _v1[0] = cubicAt(x0, x1, x2, x3, _t), _v1[1] = cubicAt(y0, y1, y2, y3, _t), \n    d1 = distanceSquare(_v0, _v1), d1 < d && (t = _t, d = d1);\n    d = 1 / 0;\n    for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) prev = t - interval, \n    next = t + interval, _v1[0] = cubicAt(x0, x1, x2, x3, prev), _v1[1] = cubicAt(y0, y1, y2, y3, prev), \n    d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x0, x1, x2, x3, next), \n    _v2[1] = cubicAt(y0, y1, y2, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, \n    d = d2) : interval *= .5);\n    return out && (out[0] = cubicAt(x0, x1, x2, x3, t), out[1] = cubicAt(y0, y1, y2, y3, t)), \n    Math.sqrt(d);\n}\n\nfunction normalizeRadian(angle) {\n    return (angle %= vutils_1.pi2) < 0 && (angle += vutils_1.pi2), angle;\n}\n\nfunction windingLine(x0, y0, x1, y1, x, y) {\n    if (y > y0 && y > y1 || y < y0 && y < y1) return 0;\n    if (y1 === y0) return 0;\n    const t = (y - y0) / (y1 - y0);\n    let dir = y1 < y0 ? 1 : -1;\n    1 !== t && 0 !== t || (dir = y1 < y0 ? .5 : -.5);\n    const x_ = t * (x1 - x0) + x0;\n    return x_ === x ? 1 / 0 : x_ > x ? dir : 0;\n}\n\nfunction containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n    if (0 === lineWidth) return !1;\n    const _l = lineWidth;\n    if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) return !1;\n    return quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;\n}\n\nfunction containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n    if (0 === lineWidth) return !1;\n    const _l = lineWidth;\n    if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) return !1;\n    return cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;\n}\n\nfunction containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n    if (0 === lineWidth) return !1;\n    const _l = lineWidth;\n    x -= cx, y -= cy;\n    const d = Math.sqrt(x * x + y * y);\n    if (d - _l > r || d + _l < r) return !1;\n    if (Math.abs(startAngle - endAngle) % vutils_1.pi2 < 1e-4) return !0;\n    if (anticlockwise) {\n        const tmp = startAngle;\n        startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);\n    } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);\n    startAngle > endAngle && (endAngle += vutils_1.pi2);\n    let angle = Math.atan2(y, x);\n    return angle < 0 && (angle += vutils_1.pi2), angle >= startAngle && angle <= endAngle || angle + vutils_1.pi2 >= startAngle && angle + vutils_1.pi2 <= endAngle;\n}\n\nfunction containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {\n    if (0 === lineWidth) return !1;\n    const _l = lineWidth, _halfL = lineWidth / 2;\n    let _a = 0, _b = x0;\n    if (y > y0 + _halfL && y > y1 + _halfL || y < y0 - _halfL && y < y1 - _halfL || x > x0 + _halfL && x > x1 + _halfL || x < x0 - _halfL && x < x1 - _halfL) return !1;\n    if (x0 === x1) return Math.abs(x - x0) <= _l / 2;\n    _a = (y0 - y1) / (x0 - x1), _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n    const tmp = _a * x - y + _b;\n    return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;\n}\n\nexports.quadraticAt = quadraticAt, exports.cubicAt = cubicAt, exports.quadraticRootAt = quadraticRootAt, \nexports.quadraticExtremum = quadraticExtremum, exports.quadraticProjectPoint = quadraticProjectPoint, \nexports.cubicProjectPoint = cubicProjectPoint, exports.normalizeRadian = normalizeRadian, \nexports.default = windingLine, exports.containQuadStroke = containQuadStroke, exports.containCubicStroke = containCubicStroke, \nexports.containArcStroke = containArcStroke, exports.containLineStroke = containLineStroke;\n\nconst globalPoint = {\n    x: 0,\n    y: 0\n};\n\nfunction transformPoint(pos, ctx, out) {\n    const matrix = ctx.currentMatrix.getInverse();\n    return (out = out || globalPoint).x = pos.x * matrix.a + pos.y * matrix.c + matrix.e, \n    out.y = pos.x * matrix.b + pos.y * matrix.d + matrix.f, out;\n}\n\nexports.transformPoint = transformPoint;\n\nconst EPSILON = 1e-4;\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n    const a = p3 + 3 * (p1 - p2) - p0, b = 3 * (p2 - 2 * p1 + p0), c = 3 * (p1 - p0), d = p0 - val, A = b * b - 3 * a * c, B = b * c - 9 * a * d, C = c * c - 3 * b * d;\n    let n = 0;\n    if (isAroundZero(A) && isAroundZero(B)) if (isAroundZero(b)) roots[0] = 0; else {\n        const t1 = -c / b;\n        t1 >= 0 && t1 <= 1 && (roots[n++] = t1);\n    } else {\n        const disc = B * B - 4 * A * C;\n        if (isAroundZero(disc)) {\n            const K = B / A, t1 = -b / a + K, t2 = -K / 2;\n            t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);\n        } else if (disc > 0) {\n            const discSqrt = Math.sqrt(disc);\n            let Y1 = A * b + 1.5 * a * (-B + discSqrt), Y2 = A * b + 1.5 * a * (-B - discSqrt);\n            Y1 = Y1 < 0 ? -Math.pow(-Y1, ONE_THIRD) : Math.pow(Y1, ONE_THIRD), Y2 = Y2 < 0 ? -Math.pow(-Y2, ONE_THIRD) : Math.pow(Y2, ONE_THIRD);\n            const t1 = (-b - (Y1 + Y2)) / (3 * a);\n            t1 >= 0 && t1 <= 1 && (roots[n++] = t1);\n        } else {\n            const T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A)), theta = Math.acos(T) / 3, ASqrt = Math.sqrt(A), tmp = Math.cos(theta), t1 = (-b - 2 * ASqrt * tmp) / (3 * a), t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a), t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n            t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2), \n            t3 >= 0 && t3 <= 1 && (roots[n++] = t3);\n        }\n    }\n    return n;\n}\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n    const b = 6 * p2 - 12 * p1 + 6 * p0, a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2, c = 3 * p1 - 3 * p0;\n    let n = 0;\n    if (isAroundZero(a)) {\n        if (isNotAroundZero(b)) {\n            const t1 = -c / b;\n            t1 >= 0 && t1 <= 1 && (extrema[n++] = t1);\n        }\n    } else {\n        const disc = b * b - 4 * a * c;\n        if (isAroundZero(disc)) extrema[0] = -b / (2 * a); else if (disc > 0) {\n            const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a), t2 = (-b - discSqrt) / (2 * a);\n            t1 >= 0 && t1 <= 1 && (extrema[n++] = t1), t2 >= 0 && t2 <= 1 && (extrema[n++] = t2);\n        }\n    }\n    return n;\n}\n\nfunction isAroundEqual(a, b) {\n    return Math.abs(a - b) < EPSILON;\n}\n\nexports.cubicRootAt = cubicRootAt, exports.cubicExtrema = cubicExtrema;\n\nconst roots = [ -1, -1, -1 ], extrema = [ -1, -1 ];\n\nfunction swapExtrema() {\n    const tmp = extrema[0];\n    extrema[0] = extrema[1], extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n    if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;\n    const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);\n    if (0 === nRoots) return 0;\n    let w = 0, nExtrema = -1, y0_ = 0, y1_ = 0;\n    for (let i = 0; i < nRoots; i++) {\n        const t = roots[i], unit = 0 === t || 1 === t ? .5 : 1;\n        cubicAt(x0, x1, x2, x3, t) < x || (nExtrema < 0 && (nExtrema = cubicExtrema(y0, y1, y2, y3, extrema), \n        extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y0, y1, y2, y3, extrema[0]), \n        nExtrema > 1 && (y1_ = cubicAt(y0, y1, y2, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y0 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y0 ? unit : -unit : w += y3 < y0_ ? unit : -unit);\n    }\n    return w;\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n    if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;\n    const nRoots = quadraticRootAt(y0, y1, y2, y, roots);\n    if (0 === nRoots) return 0;\n    const t = quadraticExtremum(y0, y1, y2);\n    if (t >= 0 && t <= 1) {\n        let w = 0;\n        const y_ = quadraticAt(y0, y1, y2, t);\n        for (let i = 0; i < nRoots; i++) {\n            const unit = 0 === roots[i] || 1 === roots[i] ? .5 : 1;\n            quadraticAt(x0, x1, x2, roots[i]) < x || (roots[i] < t ? w += y_ < y0 ? unit : -unit : w += y2 < y_ ? unit : -unit);\n        }\n        return w;\n    }\n    const unit = 0 === roots[0] || 1 === roots[0] ? .5 : 1;\n    return quadraticAt(x0, x1, x2, roots[0]) < x ? 0 : y2 < y0 ? unit : -unit;\n}\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n    if ((y -= cy) > r || y < -r) return 0;\n    const tmp = Math.sqrt(r * r - y * y);\n    roots[0] = -tmp, roots[1] = tmp;\n    const dTheta = Math.abs(startAngle - endAngle);\n    if (dTheta < 1e-4) return 0;\n    if (dTheta >= vutils_1.pi2 - 1e-4) {\n        startAngle = 0, endAngle = vutils_1.pi2;\n        const dir = anticlockwise ? 1 : -1;\n        return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;\n    }\n    if (startAngle > endAngle) {\n        const tmp = startAngle;\n        startAngle = endAngle, endAngle = tmp;\n    }\n    startAngle < 0 && (startAngle += vutils_1.pi2, endAngle += vutils_1.pi2);\n    let w = 0;\n    for (let i = 0; i < 2; i++) {\n        const x_ = roots[i];\n        if (x_ + cx > x) {\n            let angle = Math.atan2(y, x_), dir = anticlockwise ? 1 : -1;\n            angle < 0 && (angle = vutils_1.pi2 + angle), (angle >= startAngle && angle <= endAngle || angle + vutils_1.pi2 >= startAngle && angle + vutils_1.pi2 <= endAngle) && (angle > vutils_1.pi / 2 && angle < 1.5 * vutils_1.pi && (dir = -dir), \n            w += dir);\n        }\n    }\n    return w;\n}\n\nfunction modpi2(radian) {\n    return Math.round(radian / vutils_1.pi * 1e8) / 1e8 % 2 * vutils_1.pi;\n}\n\nfunction normalizeArcAngles(angles, anticlockwise) {\n    let newStartAngle = modpi2(angles[0]);\n    newStartAngle < 0 && (newStartAngle += vutils_1.pi2);\n    const delta = newStartAngle - angles[0];\n    let newEndAngle = angles[1];\n    newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= vutils_1.pi2 ? newEndAngle = newStartAngle + vutils_1.pi2 : anticlockwise && newStartAngle - newEndAngle >= vutils_1.pi2 ? newEndAngle = newStartAngle - vutils_1.pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (vutils_1.pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (vutils_1.pi2 - modpi2(newEndAngle - newStartAngle))), \n    angles[0] = newStartAngle, angles[1] = newEndAngle;\n}\n\nconst tmpAngles = [ 0, 0 ];\n\nfunction containPath(commands, lineWidth, isStroke, x, y) {\n    const data = commands, len = commands.length;\n    let x1, y1, w = 0, xi = 0, yi = 0, x0 = 0, y0 = 0;\n    for (let i = 0; i < len; i++) {\n        const command = data[i], isFirst = 0 === i;\n        command[0] === path_svg_1.enumCommandMap.M && i > 1 && (isStroke || (w += windingLine(xi, yi, x0, y0, x, y))), \n        isFirst && (xi = command[1], yi = command[2], x0 = xi, y0 = yi);\n        const c0 = command[0], c1 = command[1], c2 = command[2], c3 = command[3], c4 = command[4], c5 = command[5], c6 = command[6];\n        let startAngle = c4, endAngle = c5;\n        tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), \n        startAngle = tmpAngles[0], endAngle = tmpAngles[1];\n        const theta = startAngle, dTheta = endAngle - startAngle, anticlockwise = !!(1 - (command[6] ? 0 : 1)), _x = (x - c1) * c3 / c3 + c1;\n        switch (c0) {\n          case path_svg_1.enumCommandMap.M:\n            x0 = c1, y0 = c2, xi = x0, yi = y0;\n            break;\n\n          case path_svg_1.enumCommandMap.L:\n            if (isStroke) {\n                if (containLineStroke(xi, yi, c1, c2, lineWidth, x, y)) return !0;\n            } else w += windingLine(xi, yi, c1, c2, x, y) || 0;\n            xi = c1, yi = c2;\n            break;\n\n          case path_svg_1.enumCommandMap.C:\n            if (isStroke) {\n                if (containCubicStroke(xi, yi, c1, c2, c3, c4, c5, c6, lineWidth, x, y)) return !0;\n            } else w += windingCubic(xi, yi, c1, c2, c3, c4, c5, c6, x, y) || 0;\n            xi = c5, yi = c6;\n            break;\n\n          case path_svg_1.enumCommandMap.Q:\n            if (isStroke) {\n                if (containQuadStroke(xi, yi, c1, c2, c3, c4, lineWidth, x, y)) return !0;\n            } else w += windingQuadratic(xi, yi, c1, c2, c3, c4, x, y) || 0;\n            xi = c3, yi = c4;\n            break;\n\n          case path_svg_1.enumCommandMap.A:\n            if (x1 = Math.cos(theta) * c3 + c1, y1 = Math.sin(theta) * c3 + c2, isFirst ? (x0 = x1, \n            y0 = y1) : w += windingLine(xi, yi, x1, y1, x, y), isStroke) {\n                if (containArcStroke(c1, c2, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return !0;\n            } else w += windingArc(c1, c2, c3, theta, theta + dTheta, anticlockwise, _x, y);\n            xi = Math.cos(theta + dTheta) * c3 + c1, yi = Math.sin(theta + dTheta) * c3 + c2;\n            break;\n\n          case path_svg_1.enumCommandMap.R:\n            if (x0 = xi = c1, y0 = yi = c2, x1 = x0 + c3, y1 = y0 + c4, isStroke) {\n                if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) || containLineStroke(x1, y0, x1, y1, lineWidth, x, y) || containLineStroke(x1, y1, x0, y1, lineWidth, x, y) || containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) return !0;\n            } else w += windingLine(x1, y0, x1, y1, x, y), w += windingLine(x0, y1, x0, y0, x, y);\n            break;\n\n          case path_svg_1.enumCommandMap.Z:\n            if (isStroke) {\n                if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) return !0;\n            } else w += windingLine(xi, yi, x0, y0, x, y);\n            xi = x0, yi = y0;\n        }\n    }\n    return isStroke || isAroundEqual(yi, y0) || (w += windingLine(xi, yi, x0, y0, x, y) || 0), \n    0 !== w;\n}\n\nfunction contain(commands, x, y) {\n    return containPath(commands, 0, !1, x, y);\n}\n\nfunction containStroke(commands, lineWidth, x, y) {\n    return containPath(commands, lineWidth, !0, x, y);\n}\n\nexports.contain = contain, exports.containStroke = containStroke;\n//# sourceMappingURL=util.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.container = void 0;\n\nconst inversify_1 = require(\"inversify\");\n\nexports.container = new inversify_1.Container;\n//# sourceMappingURL=container.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.application = exports.Application = void 0;\n\nclass Application {}\n\nexports.Application = Application, exports.application = new Application;","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Context2dFactory = exports.CanvasFactory = void 0, exports.CanvasFactory = Symbol.for(\"CanvasFactory\"), \nexports.Context2dFactory = Symbol.for(\"Context2dFactory\");\n//# sourceMappingURL=constants.js.map","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultLayerService = void 0;\n\nconst inversify_1 = require(\"inversify\"), layer_1 = require(\"./layer\"), constants_1 = require(\"../constants\");\n\nlet DefaultLayerService = class {\n    constructor(global) {\n        this.global = global, this.layerMap = new Map;\n    }\n    getStageLayer(stage) {\n        return this.layerMap.get(stage);\n    }\n    createLayer(stage) {\n        const layer = new layer_1.Layer(stage, this.global, stage.window, {\n            main: !1\n        }), stageLayers = this.layerMap.get(stage) || [];\n        return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), layer;\n    }\n    releaseLayer(stage, layer) {\n        layer.release();\n        const stageLayers = this.layerMap.get(stage) || [];\n        this.layerMap.set(stage, stageLayers.filter((l => l !== layer)));\n    }\n    layerCount(stage) {\n        return (this.layerMap.get(stage) || []).length;\n    }\n    restLayerCount(stage) {\n        return \"browser\" === this.global.env ? 10 : 0;\n    }\n};\n\nDefaultLayerService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultLayerService), \nexports.DefaultLayerService = DefaultLayerService;\n//# sourceMappingURL=layer-service.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Layer = exports.LayerHandlerContribution = void 0;\n\nconst application_1 = require(\"../application\"), container_1 = require(\"../container\"), theme_1 = require(\"../graphic/theme\"), group_1 = require(\"../graphic/group\");\n\nexports.LayerHandlerContribution = Symbol.for(\"LayerHandlerContribution\");\n\nclass Layer extends group_1.Group {\n    get offscreen() {\n        return this.layerHandler.offscreen;\n    }\n    get width() {\n        return this.stage ? this.stage.width : 0;\n    }\n    get height() {\n        return this.stage ? this.stage.height : 0;\n    }\n    get viewWidth() {\n        return this.stage ? this.stage.viewWidth : 0;\n    }\n    get viewHeight() {\n        return this.stage ? this.stage.viewHeight : 0;\n    }\n    get dirtyBound() {\n        throw new Error(\"\");\n    }\n    get dpr() {\n        return this._dpr;\n    }\n    constructor(stage, global, window, params) {\n        var _a;\n        super({}), this.stage = stage, this.global = global, this.window = window, this.main = params.main, \n        this.layerHandler = container_1.container.get(exports.LayerHandlerContribution), \n        this.layerHandler.init(this, window, {\n            main: params.main,\n            canvasId: params.canvasId,\n            width: this.viewWidth,\n            height: this.viewHeight,\n            zIndex: null !== (_a = params.zIndex) && void 0 !== _a ? _a : 0\n        }), this.layer = this, this.subLayers = new Map, this.theme = new theme_1.Theme, \n        this.background = \"rgba(0, 0, 0, 0)\";\n    }\n    combineSubLayer(removeIncrementalKey = !0) {\n        const subLayers = Array.from(this.subLayers.values()).sort(((a, b) => a.zIndex - b.zIndex));\n        this.layerHandler.merge(subLayers.map((l => (l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), \n        l.layer.getNativeHandler())))), removeIncrementalKey && subLayers.forEach((l => {\n            l.group && (l.group.incremental = 0);\n        })), subLayers.forEach((l => {\n            application_1.application.layerService.releaseLayer(this.stage, l.layer);\n        })), this.subLayers.clear();\n    }\n    getNativeHandler() {\n        return this.layerHandler;\n    }\n    setStage(stage, layer) {\n        super.setStage(stage, this);\n    }\n    pick(x, y) {\n        throw new Error(\"\");\n    }\n    render(params, userParams) {\n        var _a;\n        const stage = this.stage;\n        this.layerHandler.render([ this ], {\n            renderService: params.renderService,\n            x: stage.x,\n            y: stage.y,\n            width: this.viewWidth,\n            height: this.viewHeight,\n            stage: this.stage,\n            layer: this,\n            background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,\n            updateBounds: params.updateBounds\n        }, userParams);\n    }\n    resize(w, h) {\n        this.layerHandler.resize(w, h);\n    }\n    resizeView(w, h) {\n        this.layerHandler.resizeView(w, h);\n    }\n    setDpr(dpr) {\n        throw new Error(\"\");\n    }\n    afterDraw(cb) {\n        throw new Error(\"\");\n    }\n    startAnimate(t) {\n        throw new Error(\"\");\n    }\n    setToFrame(t) {\n        throw new Error(\"\");\n    }\n    prepare(dirtyBounds, params) {}\n    combineTo(target, params) {\n        var _a;\n        this.offscreen && this.layerHandler.drawTo(target, [ this ], Object.assign({\n            background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,\n            renderService: params.renderService,\n            x: this.stage.x,\n            y: this.stage.y,\n            width: this.viewWidth,\n            height: this.viewHeight,\n            stage: this.stage,\n            layer: this\n        }, params));\n    }\n    release() {\n        super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach((l => {\n            application_1.application.layerService.releaseLayer(this.stage, l.layer);\n        }));\n    }\n    drawTo(target, params) {\n        var _a;\n        this.layerHandler.drawTo(target, [ this ], Object.assign({\n            background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,\n            renderService: params.renderService,\n            x: this.stage.x,\n            y: this.stage.y,\n            width: this.viewWidth,\n            height: this.viewHeight,\n            stage: this.stage,\n            layer: this\n        }, params));\n    }\n}\n\nexports.Layer = Layer;\n//# sourceMappingURL=layer.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.getThemeFromGroup = exports.getTheme = exports.globalTheme = exports.Theme = exports.newThemeObj = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), config_1 = require(\"./config\"), defaultThemeObj = {\n    arc: config_1.DefaultArcAttribute,\n    area: config_1.DefaultAreaAttribute,\n    circle: config_1.DefaultCircleAttribute,\n    line: config_1.DefaultLineAttribute,\n    path: config_1.DefaultPathAttribute,\n    symbol: config_1.DefaultSymbolAttribute,\n    text: config_1.DefaultTextAttribute,\n    rect: config_1.DefaultRectAttribute,\n    rect3d: config_1.DefaultRect3dAttribute,\n    polygon: config_1.DefaultPolygonAttribute,\n    richtext: config_1.DefaultRichTextAttribute,\n    richtextIcon: config_1.DefaultRichTextIconAttribute,\n    image: config_1.DefaultImageAttribute,\n    group: config_1.DefaultGroupAttribute,\n    glyph: config_1.DefaultGlyphAttribute\n}, themeKeys = Object.keys(defaultThemeObj);\n\nfunction newThemeObj() {\n    return {\n        arc: Object.assign({}, defaultThemeObj.arc),\n        area: Object.assign({}, defaultThemeObj.area),\n        circle: Object.assign({}, defaultThemeObj.circle),\n        line: Object.assign({}, defaultThemeObj.line),\n        path: Object.assign({}, defaultThemeObj.path),\n        symbol: Object.assign({}, defaultThemeObj.symbol),\n        text: Object.assign({}, defaultThemeObj.text),\n        rect: Object.assign({}, defaultThemeObj.rect),\n        rect3d: Object.assign({}, defaultThemeObj.rect3d),\n        polygon: Object.assign({}, defaultThemeObj.polygon),\n        richtext: Object.assign({}, defaultThemeObj.richtext),\n        richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),\n        image: Object.assign({}, defaultThemeObj.image),\n        group: Object.assign({}, defaultThemeObj.group),\n        glyph: Object.assign({}, defaultThemeObj.glyph)\n    };\n}\n\nfunction combineTheme(out, t, rewrite = !0) {\n    t && (rewrite ? Object.keys(t).forEach((k => {\n        out[k] ? Object.assign(out[k], t[k]) : out[k] = t[k];\n    })) : Object.keys(t).forEach((k => {\n        if (out[k]) {\n            const outItem = out[k], tItem = t[k];\n            Object.keys(t[k]).forEach((kItem => {\n                void 0 === outItem[kItem] && (outItem[kItem] = tItem[kItem]);\n            }));\n        } else out[k] = t[k];\n    })));\n}\n\nexports.newThemeObj = newThemeObj;\n\nconst staticThemePools = new Array(60).fill(0).map((() => newThemeObj()));\n\nclass Theme {\n    constructor() {\n        this._defaultTheme = staticThemePools.pop() || newThemeObj(), this.combinedTheme = this._defaultTheme, \n        this.dirty = !1;\n    }\n    getTheme(group) {\n        if (!group) return this.combinedTheme;\n        if (!this.dirty) return this.combinedTheme;\n        let parentTheme = {};\n        const parentGroup = this.getParentWithTheme(group);\n        return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), \n        this.combinedTheme;\n    }\n    getParentWithTheme(group) {\n        for (;group.parent; ) if ((group = group.parent).theme) return group;\n        return null;\n    }\n    applyTheme(group, pt, force = !1) {\n        if (this.dirty) {\n            const parentGroup = this.getParentWithTheme(group);\n            if (parentGroup) {\n                const parentTheme = parentGroup.theme;\n                (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, !0), this.userTheme ? combineTheme(this.userTheme, parentTheme.userTheme, !1) : this.userTheme = (0, \n                vutils_1.clone)(parentTheme.userTheme), combineTheme(pt, parentTheme.userTheme);\n            }\n            this.userTheme ? this.doCombine(pt) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, \n            console.warn(\"\")), this.dirty = !1);\n        }\n        return this.combinedTheme;\n    }\n    doCombine(parentTheme) {\n        const userTheme = this.userTheme, defaultTheme = this._defaultTheme, combinedTheme = this.combinedTheme, parentCommonTheme = parentTheme.common || {}, commonTheme = Object.assign(parentCommonTheme, this.commonTheme);\n        themeKeys.forEach((k => {\n            var _a, _b;\n            userTheme[k] || commonTheme || parentTheme[k] ? combinedTheme[k] = Object.assign({}, defaultTheme[k], null != commonTheme ? commonTheme : {}, null !== (_a = parentTheme[k]) && void 0 !== _a ? _a : {}, null !== (_b = userTheme[k]) && void 0 !== _b ? _b : {}) : combinedTheme[k] = defaultTheme[k];\n        })), this.dirty = !1;\n    }\n    resetTheme(t, g) {\n        this.userTheme = t, this.dirty = !0, this.dirtyChildren(g);\n    }\n    setTheme(t, g) {\n        let userTheme = this.userTheme;\n        userTheme ? Object.keys(t).forEach((k => {\n            userTheme[k] ? Object.assign(userTheme[k], t[k]) : userTheme[k] = Object.assign({}, t[k]);\n        })) : userTheme = t, t.common && (this.commonTheme ? Object.assign(this.commonTheme, t.common) : this.commonTheme = t.common), \n        this.userTheme = userTheme, this.dirty = !0, this.dirtyChildren(g);\n    }\n    dirtyChildren(g) {\n        g.forEachChildren((item => {\n            item.isContainer && (item.theme && (item.theme.dirty = !0), this.dirtyChildren(item));\n        }));\n    }\n}\n\nfunction getTheme(graphic, theme) {\n    return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme ? (graphic.isContainer, \n    theme) : getThemeFromGroup(graphic) || exports.globalTheme.getTheme();\n}\n\nfunction getThemeFromGroup(graphic) {\n    let g;\n    if (g = graphic.isContainer ? graphic : graphic.parent, g) {\n        for (;g && !g.theme; ) g = g.parent;\n        return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : exports.globalTheme.getTheme();\n    }\n    return null;\n}\n\nexports.Theme = Theme, exports.globalTheme = new Theme, exports.getTheme = getTheme, \nexports.getThemeFromGroup = getThemeFromGroup;\n//# sourceMappingURL=theme.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Group = exports.GroupUpdateAABBBoundsMode = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), application_1 = require(\"../application\"), graphic_1 = require(\"./graphic\"), theme_1 = require(\"./theme\"), utils_1 = require(\"../common/utils\"), enums_1 = require(\"../common/enums\"), constants_1 = require(\"./constants\");\n\nvar GroupUpdateAABBBoundsMode;\n\n!function(GroupUpdateAABBBoundsMode) {\n    GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.LESS_GROUP = 0] = \"LESS_GROUP\", \n    GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.MORE_GROUP = 1] = \"MORE_GROUP\";\n}(GroupUpdateAABBBoundsMode = exports.GroupUpdateAABBBoundsMode || (exports.GroupUpdateAABBBoundsMode = {}));\n\nclass Group extends graphic_1.Graphic {\n    constructor(params) {\n        super(params), this.type = \"group\", this.parent = null, this.isContainer = !0, this.numberType = constants_1.GROUP_NUMBER_TYPE, \n        this._childUpdateTag = enums_1.UpdateTag.UPDATE_BOUNDS;\n    }\n    setMode(mode) {\n        \"3d\" === mode ? this.set3dMode() : this.set2dMode();\n    }\n    set3dMode() {\n        this.in3dMode = !0;\n    }\n    set2dMode() {\n        this.in3dMode = !1;\n    }\n    setTheme(t) {\n        return this.theme || (this.theme = new theme_1.Theme), this.theme.setTheme(t, this);\n    }\n    createTheme() {\n        this.theme || (this.theme = new theme_1.Theme);\n    }\n    hideAll() {\n        this.setAttribute(\"visible\", !1), this.forEachChildren((item => {\n            item.isContainer && item.hideAll ? item.hideAll() : item.setAttribute(\"visible\", !1);\n        }));\n    }\n    showAll() {\n        this.setAttribute(\"visible\", !0), this.forEachChildren((item => {\n            item.isContainer && item.showAll ? item.showAll() : item.setAttribute(\"visible\", !0);\n        }));\n    }\n    containsPoint(x, y, mode) {\n        if (mode === enums_1.IContainPointMode.GLOBAL) {\n            const point = new vutils_1.Point(x, y);\n            return this.parent && this.parent.globalTransMatrix.transformPoint(point, point), \n            this.AABBBounds.contains(point.x, point.y);\n        }\n        return this.AABBBounds.contains(x, y);\n    }\n    shouldUpdateAABBBounds() {\n        return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & enums_1.UpdateTag.UPDATE_BOUNDS);\n    }\n    tryUpdateAABBBounds() {\n        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;\n        application_1.application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);\n        const selfChange = this.shouldSelfChangeUpdateAABBBounds(), bounds = this.doUpdateAABBBounds();\n        return application_1.application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), \n        bounds;\n    }\n    doUpdateAABBBounds() {\n        const attribute = this.attribute, groupTheme = (0, theme_1.getTheme)(this).group;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const bounds = application_1.application.graphicService.updateGroupAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).group, this._AABBBounds, this), {boundsPadding: boundsPadding = groupTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.parent && this.parent.addChildUpdateBoundTag(), \n        this.clearUpdateBoundTag(), this._emitCustomEvent(\"AAABBBoundsChange\"), bounds;\n    }\n    clearUpdateBoundTag() {\n        this._updateTag &= enums_1.UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= enums_1.UpdateTag.CLEAR_BOUNDS;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    addUpdateBoundTag() {\n        this._updateTag |= enums_1.UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();\n    }\n    addChildUpdateBoundTag() {\n        this._childUpdateTag & enums_1.UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= enums_1.UpdateTag.UPDATE_BOUNDS, \n        this.parent && this.parent.addChildUpdateBoundTag());\n    }\n    getTheme() {\n        return this.theme.getTheme(this);\n    }\n    incrementalAppendChild(node) {\n        const data = super.appendChild(node);\n        return this.stage && data && (data.stage = this.stage, data.layer = this.layer), \n        this.addUpdateBoundTag(), application_1.application.graphicService.onAddIncremental(node, this, this.stage), \n        data;\n    }\n    incrementalClearChild() {\n        super.removeAllChild(), this.addUpdateBoundTag(), application_1.application.graphicService.onClearIncremental(this, this.stage);\n    }\n    appendChild(node, addStage = !0) {\n        const data = super.appendChild(node);\n        return addStage && this.stage && data && data.setStage(this.stage, this.layer), \n        this.addUpdateBoundTag(), data;\n    }\n    insertBefore(newNode, referenceNode) {\n        const data = super.insertBefore(newNode, referenceNode);\n        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), \n        data;\n    }\n    insertAfter(newNode, referenceNode) {\n        const data = super.insertAfter(newNode, referenceNode);\n        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), \n        data;\n    }\n    insertInto(newNode, idx) {\n        const data = super.insertInto(newNode, idx);\n        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), \n        data;\n    }\n    removeChild(child) {\n        const data = super.removeChild(child);\n        return child.stage = null, application_1.application.graphicService.onRemove(child), \n        this.addUpdateBoundTag(), data;\n    }\n    removeAllChild() {\n        this.forEachChildren((child => {\n            application_1.application.graphicService.onRemove(child);\n        })), super.removeAllChild(), this.addUpdateBoundTag();\n    }\n    setStage(stage, layer) {\n        this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), \n        this._onSetStage && this._onSetStage(this, stage, layer), application_1.application.graphicService.onSetStage(this, stage), \n        this.forEachChildren((item => {\n            item.setStage(stage, this.layer);\n        })));\n    }\n    addUpdatePositionTag() {\n        super.addUpdatePositionTag(), this.forEachChildren((g => {\n            g.isContainer && g.addUpdateGlobalPositionTag();\n        }));\n    }\n    addUpdateGlobalPositionTag() {\n        super.addUpdateGlobalPositionTag(), this.forEachChildren((g => {\n            g.isContainer && g.addUpdateGlobalPositionTag();\n        }));\n    }\n    tryUpdateGlobalTransMatrix(clearTag = !0) {\n        if (this.shouldUpdateGlobalMatrix()) {\n            if (this._globalTransMatrix) {\n                if (this.parent) {\n                    const m = this.parent.globalTransMatrix;\n                    this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);\n                }\n            } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();\n            this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();\n        }\n        return this._globalTransMatrix;\n    }\n    shouldUpdateGlobalMatrix() {\n        return !!(this._updateTag & enums_1.UpdateTag.UPDATE_GLOBAL_MATRIX);\n    }\n    _getChildByName(name, deep) {\n        return this.find((node => node.name === name), deep);\n    }\n    createOrUpdateChild(graphicName, attributes, graphicType) {\n        let graphic = this._getChildByName(graphicName);\n        return graphic ? graphic.setAttributes(attributes) : (graphic = application_1.application.graphicService.creator[graphicType](attributes), \n        graphic.name = graphicName, this.add(graphic)), graphic;\n    }\n    clone() {\n        return new Group(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Group = Group;\n//# sourceMappingURL=group.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Graphic = exports.GRAPHIC_UPDATE_TAG_KEY = exports.PURE_STYLE_KEY = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), node_tree_1 = require(\"./node-tree\"), event_1 = require(\"../event\"), config_1 = require(\"./config\"), application_1 = require(\"../application\"), animate_1 = require(\"../animate\"), interpolate_1 = require(\"../color-string/interpolate\"), custom_path2d_1 = require(\"../common/custom-path2d\"), theme_1 = require(\"./theme\"), loader_1 = require(\"../resource-loader/loader\"), enums_1 = require(\"../common/enums\"), tempMatrix = new vutils_1.Matrix;\n\nexports.PURE_STYLE_KEY = [ \"stroke\", \"opacity\", \"strokeOpacity\", \"lineDash\", \"lineDashOffset\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"fill\", \"fillOpacity\" ], \nexports.GRAPHIC_UPDATE_TAG_KEY = [ \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"scaleX\", \"scaleY\", \"angle\", \"anchor\" ];\n\nconst tempConstantXYKey = [ \"x\", \"y\" ], tempConstantScaleXYKey = [ \"scaleX\", \"scaleY\" ], tempConstantAngleKey = [ \"angle\" ], point = new vutils_1.Point;\n\nclass Graphic extends node_tree_1.Node {\n    static mixin(source) {\n        const keys = Object.keys(source);\n        for (let i = 0; i < keys.length; ++i) {\n            const propertyName = keys[i];\n            Object.defineProperty(Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));\n        }\n    }\n    get AABBBounds() {\n        return this.tryUpdateAABBBounds(\"imprecise\" === this.attribute.boundsMode);\n    }\n    get OBBBounds() {\n        return this.tryUpdateOBBBounds();\n    }\n    get globalAABBBounds() {\n        return this.tryUpdateGlobalAABBBounds();\n    }\n    get transMatrix() {\n        return this.tryUpdateLocalTransMatrix(!0);\n    }\n    get globalTransMatrix() {\n        return this.tryUpdateGlobalTransMatrix(!0);\n    }\n    constructor(params = {}) {\n        super(), this._AABBBounds = new vutils_1.AABBBounds, this._updateTag = enums_1.UpdateTag.INIT, \n        this.attribute = params, this.valid = this.isValid(), params.background && this.loadImage(params.background, !0);\n    }\n    setMode(mode) {\n        \"3d\" === mode ? this.set3dMode() : this.set2dMode();\n    }\n    set3dMode() {\n        this.in3dMode = !0;\n    }\n    set2dMode() {\n        this.in3dMode = !1;\n    }\n    getOffsetXY(attr, includeScroll = !1) {\n        const {dx: dx = attr.dx, dy: dy = attr.dy} = this.attribute;\n        if (includeScroll && this.parent) {\n            const groupTheme = (0, theme_1.getTheme)(this.parent).group, {scrollX: scrollX = groupTheme.scrollX, scrollY: scrollY = groupTheme.scrollY} = this.parent.attribute;\n            point.x = dx + scrollX, point.y = dy + scrollY;\n        } else point.x = dx, point.y = dy;\n        return point;\n    }\n    tryUpdateAABBBounds(full) {\n        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;\n        if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;\n        application_1.application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);\n        const bounds = this.doUpdateAABBBounds(full);\n        return application_1.application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, !0), \n        bounds;\n    }\n    combindShadowAABBBounds(bounds) {\n        if (this.shadowRoot) {\n            const b = this.shadowRoot.AABBBounds.clone();\n            bounds.union(b);\n        }\n    }\n    tryUpdateGlobalAABBBounds() {\n        return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this.AABBBounds.clone(), \n        this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), \n        this._globalAABBBounds;\n    }\n    tryUpdateGlobalTransMatrix(clearTag = !0) {\n        if (this._globalTransMatrix) {\n            if (this.parent) {\n                const m = this.parent.globalTransMatrix;\n                this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);\n            }\n        } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();\n        return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;\n    }\n    shouldUpdateGlobalMatrix() {\n        return !0;\n    }\n    tryUpdateLocalTransMatrix(clearTag = !0) {\n        return this._transMatrix || (this._transMatrix = new vutils_1.Matrix), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), \n        clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;\n    }\n    shouldUpdateAABBBounds() {\n        return this.shadowRoot ? !!(this._updateTag & enums_1.UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & enums_1.UpdateTag.UPDATE_BOUNDS);\n    }\n    shouldSelfChangeUpdateAABBBounds() {\n        return this.shadowRoot ? !!(this._updateTag & enums_1.UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & enums_1.UpdateTag.UPDATE_BOUNDS);\n    }\n    shouldUpdateLocalMatrix() {\n        return !!(this._updateTag & enums_1.UpdateTag.UPDATE_LOCAL_MATRIX);\n    }\n    isValid() {\n        var _a, _b;\n        const attribute = this.attribute;\n        return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));\n    }\n    _validNumber(num) {\n        return null == num || Number.isFinite(num);\n    }\n    shouldUpdateShape() {\n        return !!(this._updateTag & enums_1.UpdateTag.UPDATE_SHAPE);\n    }\n    clearUpdateShapeTag() {\n        this._updateTag &= enums_1.UpdateTag.CLEAR_SHAPE;\n    }\n    containsPoint(x, y, mode, picker) {\n        if (!picker) return !1;\n        if (mode === enums_1.IContainPointMode.GLOBAL) {\n            const point = new vutils_1.Point(x, y);\n            this.parent && this.parent.globalTransMatrix.transformPoint(point, point), x = point.x, \n            y = point.y;\n        }\n        return picker.containsPoint(this, {\n            x: x,\n            y: y\n        });\n    }\n    setAttributes(params, forceUpdateTag = !1, context) {\n        (params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params).background && this.loadImage(params.background, !0), \n        this._setAttributes(params, forceUpdateTag, context);\n    }\n    _setAttributes(params, forceUpdateTag = !1, context) {\n        const keys = Object.keys(params);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            this.attribute[key] = params[key];\n        }\n        this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), \n        this.addUpdatePositionTag(), this.onAttributeUpdate(context);\n    }\n    setAttribute(key, value, forceUpdateTag, context) {\n        var _a;\n        const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({\n            [key]: value\n        }, this.attribute, key, context);\n        params ? this._setAttributes(params, forceUpdateTag, context) : (0, vutils_1.isNil)(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, \n        this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), \n        this.addUpdatePositionTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, \n        \"background\" === key && this.loadImage(value, !0);\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < exports.GRAPHIC_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = exports.GRAPHIC_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < exports.GRAPHIC_UPDATE_TAG_KEY.length; i++) {\n            if (key === exports.GRAPHIC_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    initAttributes(params) {\n        const context = {\n            type: enums_1.AttributeUpdateType.INIT\n        };\n        params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params, \n        this.attribute = params, params.background && this.loadImage(params.background, !0), \n        this._updateTag = enums_1.UpdateTag.INIT, this.onAttributeUpdate(context);\n    }\n    translate(x, y) {\n        var _a, _b;\n        if (0 === x && 0 === y) return this;\n        const context = {\n            type: enums_1.AttributeUpdateType.TRANSLATE\n        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({\n            x: x,\n            y: y\n        }, this.attribute, tempConstantXYKey, context);\n        params && (x = params.x, y = params.y, delete params.x, delete params.y, this._setAttributes(params));\n        const attribute = this.attribute, postMatrix = attribute.postMatrix;\n        return postMatrix ? application_1.application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : config_1.DefaultTransform.x) + x, \n        attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : config_1.DefaultTransform.y) + y), \n        this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), \n        this;\n    }\n    translateTo(x, y) {\n        const attribute = this.attribute;\n        if (attribute.x === x && attribute.y === y) return this;\n        const context = {\n            type: enums_1.AttributeUpdateType.TRANSLATE_TO\n        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({\n            x: x,\n            y: y\n        }, this.attribute, tempConstantXYKey, context);\n        return params ? (this._setAttributes(params, !1, context), this) : (attribute.x = x, \n        attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), \n        this);\n    }\n    scale(scaleX, scaleY, scaleCenter) {\n        var _a, _b;\n        if (1 === scaleX && 1 === scaleY) return this;\n        const context = {\n            type: enums_1.AttributeUpdateType.SCALE\n        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({\n            scaleX: scaleX,\n            scaleY: scaleY,\n            scaleCenter: scaleCenter\n        }, this.attribute, tempConstantScaleXYKey, context);\n        params && (scaleX = params.scaleX, scaleY = params.scaleY, delete params.scaleX, \n        delete params.scaleY, this._setAttributes(params));\n        const attribute = this.attribute;\n        if (scaleCenter) {\n            let {postMatrix: postMatrix} = this.attribute;\n            postMatrix || (postMatrix = new vutils_1.Matrix, attribute.postMatrix = postMatrix), \n            application_1.application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);\n        } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : config_1.DefaultTransform.scaleX) * scaleX, \n        attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : config_1.DefaultTransform.scaleY) * scaleY;\n        return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), \n        this;\n    }\n    scaleTo(scaleX, scaleY) {\n        const attribute = this.attribute;\n        if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;\n        const context = {\n            type: enums_1.AttributeUpdateType.SCALE_TO\n        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({\n            scaleX: scaleX,\n            scaleY: scaleY\n        }, this.attribute, tempConstantScaleXYKey, context);\n        return params ? (this._setAttributes(params, !1, context), this) : (attribute.scaleX = scaleX, \n        attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), \n        this.onAttributeUpdate(context), this);\n    }\n    rotate(angle) {\n        var _a;\n        if (0 === angle) return this;\n        const context = {\n            type: enums_1.AttributeUpdateType.ROTATE\n        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);\n        if (params) return this._setAttributes(params, !1, context), this;\n        const attribute = this.attribute;\n        return attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : config_1.DefaultTransform.angle) + angle, \n        this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), \n        this;\n    }\n    rotateTo(angle) {\n        const attribute = this.attribute;\n        if (attribute.angle === angle) return this;\n        const context = {\n            type: enums_1.AttributeUpdateType.ROTATE_TO\n        }, params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);\n        return params ? (this._setAttributes(params, !1, context), this) : (attribute.angle = angle, \n        this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.onAttributeUpdate(context), \n        this);\n    }\n    skewTo(b, c) {\n        return this;\n    }\n    animate(params) {\n        this.animates || (this.animates = new Map);\n        const animate = new animate_1.Animate(null == params ? void 0 : params.id).bind(this);\n        if (params) {\n            const {onStart: onStart, onFrame: onFrame, onEnd: onEnd, onRemove: onRemove} = params;\n            null != onStart && animate.onStart(onStart), null != onFrame && animate.onFrame(onFrame), \n            null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove), \n            animate.interpolateFunc = params.interpolate;\n        }\n        return this.animates.set(animate.id, animate), animate.onRemove((() => {\n            this.animates.delete(animate.id);\n        })), animate;\n    }\n    onAttributeUpdate(context) {\n        application_1.application.graphicService.onAttributeUpdate(this), this._emitCustomEvent(\"afterAttributeUpdate\", context);\n    }\n    update(d) {\n        d ? (d.bounds && this.tryUpdateAABBBounds(\"imprecise\" === this.attribute.boundsMode), \n        d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds(\"imprecise\" === this.attribute.boundsMode), \n        this.tryUpdateLocalTransMatrix());\n    }\n    hasState(stateName) {\n        return !(!this.currentStates || !this.currentStates.length) && (!!(0, vutils_1.isNil)(stateName) || this.currentStates.includes(stateName));\n    }\n    getState(stateName) {\n        var _a;\n        return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];\n    }\n    applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {\n        var _a, _b, _c, _d;\n        if (hasAnimation) {\n            const keys = Object.keys(attrs), animateAttrs = isClear ? keys.reduce(((res, key) => (res[key] = void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key], \n            res)), {}) : attrs, animate = this.animate();\n            animate.stateNames = stateNames, animate.to(animateAttrs, null !== (_b = null === (_a = this.stateAnimateConfig) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : animate_1.DefaultStateAnimateConfig.duration, null !== (_d = null === (_c = this.stateAnimateConfig) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : animate_1.DefaultStateAnimateConfig.easing);\n        } else this.setAttributes(attrs, !1, {\n            type: enums_1.AttributeUpdateType.STATE\n        });\n    }\n    updateNormalAttrs(stateAttrs) {\n        const newNormalAttrs = {};\n        this.normalAttrs ? (Object.keys(stateAttrs).forEach((key => {\n            key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);\n        })), Object.keys(this.normalAttrs).forEach((key => {\n            stateAttrs[key] = this.normalAttrs[key];\n        }))) : Object.keys(stateAttrs).forEach((key => {\n            newNormalAttrs[key] = this.getNormalAttribute(key);\n        })), this.normalAttrs = newNormalAttrs;\n    }\n    getNormalAttribute(key) {\n        let value = this.attribute[key];\n        return this.animates && this.animates.forEach((animate => {\n            if (animate.stateNames) {\n                const endProps = animate.getEndProps();\n                (0, vutils_1.has)(endProps, key) && (value = endProps[key]);\n            }\n        })), value;\n    }\n    clearStates(hasAnimation) {\n        this.hasState() && this.normalAttrs && this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0), \n        this.normalAttrs = null, this.currentStates = [];\n    }\n    removeState(stateName, hasAnimation) {\n        if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) >= 0) {\n            const currentStates = this.currentStates.filter((state => state !== stateName));\n            this.useStates(currentStates, hasAnimation);\n        }\n    }\n    toggleState(stateName, hasAnimation) {\n        if (this.hasState(stateName)) this.removeState(stateName, hasAnimation); else {\n            if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {\n                const nextStates = this.currentStates ? this.currentStates.slice() : [];\n                nextStates.push(stateName), this.useStates(nextStates, hasAnimation);\n            }\n        }\n    }\n    addState(stateName, keepCurrentStates, hasAnimation) {\n        var _a;\n        if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;\n        const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([ stateName ]) : [ stateName ];\n        this.useStates(newStates, hasAnimation);\n    }\n    useStates(states, hasAnimation) {\n        var _a;\n        if (!states.length) return void this.clearStates(hasAnimation);\n        if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some(((stateName, index) => this.currentStates[index] !== stateName)))) return;\n        const stateAttrs = {};\n        states.forEach((stateName => {\n            var _a;\n            const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];\n            attrs && Object.assign(stateAttrs, attrs);\n        })), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);\n    }\n    addUpdateBoundTag() {\n        this._updateTag |= enums_1.UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), \n        this.glyphHost && this.glyphHost.addUpdateBoundTag();\n    }\n    addUpdateShapeTag() {\n        this._updateTag |= enums_1.UpdateTag.UPDATE_SHAPE;\n    }\n    addUpdateShapeAndBoundsTag() {\n        this._updateTag |= enums_1.UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), \n        this.glyphHost && this.glyphHost.addUpdateBoundTag();\n    }\n    updateShapeAndBoundsTagSetted() {\n        return (this._updateTag & enums_1.UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === enums_1.UpdateTag.UPDATE_SHAPE_AND_BOUNDS;\n    }\n    clearUpdateBoundTag() {\n        this._updateTag &= enums_1.UpdateTag.CLEAR_BOUNDS;\n    }\n    addUpdatePositionTag() {\n        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= enums_1.UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;\n    }\n    addUpdateGlobalPositionTag() {\n        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= enums_1.UpdateTag.UPDATE_GLOBAL_MATRIX;\n    }\n    clearUpdateLocalPositionTag() {\n        this._updateTag &= enums_1.UpdateTag.CLEAR_LOCAL_MATRIX;\n    }\n    clearUpdateGlobalPositionTag() {\n        this._updateTag &= enums_1.UpdateTag.CLEAR_GLOBAL_MATRIX;\n    }\n    doUpdateLocalMatrix() {\n        const {x: x = config_1.DefaultTransform.x, y: y = config_1.DefaultTransform.y, scaleX: scaleX = config_1.DefaultTransform.scaleX, scaleY: scaleY = config_1.DefaultTransform.scaleY, angle: angle = config_1.DefaultTransform.angle, anchor: anchor, postMatrix: postMatrix} = this.attribute, _anchor = [ 0, 0 ];\n        if (anchor) {\n            if (\"string\" == typeof anchor[0]) {\n                const ratio = parseFloat(anchor[0]) / 100, bounds = this.AABBBounds;\n                _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;\n            } else _anchor[0] = anchor[0];\n            if (\"string\" == typeof anchor[1]) {\n                const ratio = parseFloat(anchor[1]) / 100, bounds = this.AABBBounds;\n                _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;\n            } else _anchor[1] = anchor[1];\n        }\n        (0, vutils_1.normalTransform)(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle, anchor && _anchor);\n        const p = this.getOffsetXY(config_1.DefaultTransform);\n        if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {\n            const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f), m2 = this._transMatrix;\n            m1.multiply(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f), m2.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);\n        }\n    }\n    doUpdateGlobalMatrix() {\n        if (this.parent) {\n            this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);\n            const {scrollX: scrollX = 0, scrollY: scrollY = 0} = this.parent.attribute;\n            this._globalTransMatrix.translate(scrollX, scrollY);\n        }\n    }\n    setStage(stage, layer) {\n        this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), \n        this._onSetStage && this._onSetStage(this, stage, layer), application_1.application.graphicService.onSetStage(this, stage));\n    }\n    setStageToShadowRoot(stage, layer) {\n        this.shadowRoot && this.shadowRoot.setStage(stage, layer);\n    }\n    onAddStep(step) {}\n    onStop(props) {\n        props && this.setAttributes(props, !1, {\n            type: enums_1.AttributeUpdateType.ANIMATE_END\n        });\n    }\n    onStep(subAnimate, animate, step, ratio, end) {\n        const nextAttributes = {};\n        if (step.customAnimate) step.customAnimate.update(end, ratio, nextAttributes); else {\n            const nextProps = step.props, nextParsedProps = step.parsedProps, propKeys = step.propKeys;\n            this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, void 0, nextParsedProps, propKeys);\n        }\n        this.setAttributes(nextAttributes, !1, {\n            type: enums_1.AttributeUpdateType.ANIMATE_UPDATE,\n            animationState: {\n                ratio: ratio,\n                end: end,\n                step: step,\n                isFirstFrameOfStep: subAnimate.getLastStep() !== step\n            }\n        }), this.stage && this.stage.renderNextFrame();\n    }\n    stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {\n        propKeys || (propKeys = Object.keys(nextProps), step.propKeys = propKeys), end ? step.propKeys.forEach((key => {\n            animate.validAttr(key) && (nextAttributes[key] = nextProps[key]);\n        })) : propKeys.forEach((key => {\n            var _a;\n            if (!animate.validAttr(key)) return;\n            const nextStepVal = nextProps[key], lastStepVal = null !== (_a = lastProps && lastProps[key]) && void 0 !== _a ? _a : subAnimate.getLastPropByName(key, step);\n            let match;\n            match = animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes), \n            match || (match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, this, nextAttributes), \n            match || this.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) || this._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes));\n        })), step.parsedProps = nextParsedProps;\n    }\n    defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {\n        if (Number.isFinite(nextStepVal)) return nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio, \n        !0;\n        if (\"fill\" === key) {\n            nextParsedProps || (nextParsedProps = {});\n            const fillColorArray = nextParsedProps.fillColorArray, color = (0, interpolate_1.interpolateColor)(lastStepVal, null != fillColorArray ? fillColorArray : nextStepVal, ratio, !1, ((fArray, tArray) => {\n                nextParsedProps.fillColorArray = tArray;\n            }));\n            return color && (nextAttributes[key] = color), !0;\n        }\n        if (\"stroke\" === key) {\n            nextParsedProps || (nextParsedProps = {});\n            const strokeColorArray = nextParsedProps.strokeColorArray, color = (0, interpolate_1.interpolateColor)(lastStepVal, null != strokeColorArray ? strokeColorArray : nextStepVal, ratio, !1, ((fArray, tArray) => {\n                nextParsedProps.strokeColorArray = tArray;\n            }));\n            return color && (nextAttributes[key] = color), !0;\n        }\n        if (\"shadowColor\" === key) {\n            nextParsedProps || (nextParsedProps = {});\n            const shadowColorArray = nextParsedProps.shadowColorArray, color = (0, interpolate_1.interpolateColor)(lastStepVal, null != shadowColorArray ? shadowColorArray : nextStepVal, ratio, !0, ((fArray, tArray) => {\n                nextParsedProps.shadowColorArray = tArray;\n            }));\n            return color && (nextAttributes[key] = color), !0;\n        }\n        return !1;\n    }\n    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {}\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this)[this.type][name];\n    }\n    getComputedAttribute(name) {\n        var _a;\n        return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);\n    }\n    onSetStage(cb, immediate = !1) {\n        this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);\n    }\n    attachShadow(shadowRoot) {\n        return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application_1.application.graphicService.creator.shadowRoot(this), \n        this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;\n    }\n    detachShadow() {\n        this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot = null);\n    }\n    toJson() {\n        return {\n            attribute: this.attribute,\n            _uid: this._uid,\n            type: this.type,\n            name: this.name,\n            children: this.children.map((item => item.toJson()))\n        };\n    }\n    createPathProxy(path) {\n        return (0, vutils_1.isString)(path, !0) ? this.pathProxy = (new custom_path2d_1.CustomPath2D).fromString(path) : this.pathProxy = new custom_path2d_1.CustomPath2D, \n        this.pathProxy;\n    }\n    loadImage(image, background = !1) {\n        if (!image) return;\n        const url = image;\n        this.resources || (this.resources = new Map);\n        const cache = {\n            data: \"init\",\n            state: null\n        };\n        this.resources.set(url, cache), \"string\" == typeof image ? (cache.state = \"loading\", \n        (0, vutils_1.isValidUrl)(image) || (0, vutils_1.isBase64)(image) ? (loader_1.ResourceLoader.GetImage(image, this), \n        this.backgroundImg = this.backgroundImg || background) : image.startsWith(\"<svg\") && (loader_1.ResourceLoader.GetSvg(image, this), \n        this.backgroundImg = this.backgroundImg || background)) : (cache.state = \"success\", \n        cache.data = image, this.backgroundImg = this.backgroundImg || background);\n    }\n    imageLoadSuccess(url, image, cb) {\n        if (!this.resources) return;\n        const res = this.resources.get(url);\n        res && (res.state = \"success\", res.data = image, cb && cb(), this.addUpdateBoundTag(), \n        this.stage && this.stage.renderNextFrame());\n    }\n    imageLoadFail(url, cb) {\n        if (!this.resources) return;\n        const res = this.resources.get(url);\n        res && (res.state = \"fail\", cb && cb());\n    }\n    release() {\n        this.releaseStatus = \"released\";\n    }\n    _emitCustomEvent(type, context) {\n        var _a, _b;\n        if (this._events && type in this._events) {\n            const changeEvent = new event_1.CustomEvent(type, context);\n            changeEvent.bubbles = !1, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, \n            this.dispatchEvent(changeEvent);\n        }\n    }\n}\n\nexports.Graphic = Graphic, Graphic.mixin(event_1.EventTarget);\n//# sourceMappingURL=graphic.js.map\n","\n\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))((function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            var value;\n            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {\n                resolve(value);\n            }))).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    }));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Node = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), generator_1 = require(\"../common/generator\");\n\nclass Node extends vutils_1.EventEmitter {\n    get previousSibling() {\n        return this._prev;\n    }\n    get nextSibling() {\n        return this._next;\n    }\n    get children() {\n        return this.getChildren();\n    }\n    get firstChild() {\n        return this._firstChild;\n    }\n    get lastChild() {\n        return this._lastChild;\n    }\n    get count() {\n        return this._count;\n    }\n    get childrenCount() {\n        return this._idMap ? this._idMap.size : 0;\n    }\n    constructor() {\n        super(), this._uid = generator_1.Generator.GenAutoIncrementId(), this._firstChild = null, \n        this._lastChild = null, this.parent = null, this._count = 1;\n    }\n    forEachChildren(cb, reverse = !1) {\n        if (reverse) {\n            let child = this._lastChild, i = 0;\n            for (;child; ) {\n                if (cb(child, i++)) return;\n                child = child._prev;\n            }\n        } else {\n            let child = this._firstChild, i = 0;\n            for (;child; ) {\n                if (cb(child, i++)) return;\n                child = child._next;\n            }\n        }\n    }\n    forEachChildrenAsync(cb, reverse = !1) {\n        return __awaiter(this, void 0, void 0, (function*() {\n            if (reverse) {\n                let child = this._lastChild, i = 0;\n                for (;child; ) {\n                    let breakTag = cb(child, i++);\n                    if (breakTag.then && (breakTag = yield breakTag), breakTag) return;\n                    child = child._prev;\n                }\n            } else {\n                let child = this._firstChild, i = 0;\n                for (;child; ) {\n                    let breakTag = cb(child, i++);\n                    if (breakTag.then && (breakTag = yield breakTag), breakTag) return;\n                    child = child._next;\n                }\n            }\n        }));\n    }\n    forEach(cb) {\n        return this.forEachChildren(cb);\n    }\n    appendChild(node) {\n        if (this._uid === node._uid) return null;\n        if (node.isAncestorsOf(this)) throw new Error(\"Node::appendChildappend\");\n        return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, \n        node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, \n        node._prev = node._next = null), this._idMap || (this._idMap = new Map), this._idMap.set(node._uid, node), \n        this.setCount(node.count), this._structEdit = !0, node;\n    }\n    appendChildArrHighPerformance(nodes, replace = !1) {\n        return console.error(\"\"), nodes;\n    }\n    insertBefore(newNode, referenceNode) {\n        if (this._uid === newNode._uid) return null;\n        if (newNode.isAncestorsOf(this)) throw new Error(\"Node::insertBeforeinsert\");\n        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), \n        newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, \n        referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = new Map), \n        this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), \n        newNode);\n    }\n    insertAfter(newNode, referenceNode) {\n        if (this._uid === newNode._uid) return null;\n        if (newNode.isAncestorsOf(this)) throw new Error(\"Node::insertAfterinsert\");\n        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), \n        newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, \n        newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, \n        newNode._prev = referenceNode, this._idMap || (this._idMap = new Map), this._idMap.set(newNode._uid, newNode), \n        this._structEdit = !0, this.setCount(newNode.count), newNode);\n    }\n    insertInto(newNode, idx) {\n        if (this._nodeList && console.warn(\"insertIntoKeepIdxinsertInto\"), idx >= this.childrenCount) return this.appendChild(newNode);\n        if (this._uid === newNode._uid) return null;\n        if (newNode.isAncestorsOf(this)) throw new Error(\"Node::insertBeforeinsert\");\n        if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, \n        0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), \n        newNode._prev = null, this._firstChild = newNode; else {\n            let child = this._firstChild;\n            for (let i = 0; i < idx; i++) {\n                if (!child) return null;\n                i > 0 && (child = child._next);\n            }\n            if (!child) return null;\n            newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);\n        }\n        return this._idMap || (this._idMap = new Map), this._idMap.set(newNode._uid, newNode), \n        this._structEdit = !0, this.setCount(newNode.count), newNode;\n    }\n    insertIntoKeepIdx(newNode, idx) {\n        if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {\n            const node = this._nodeList[idx];\n            return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node);\n        }\n        let node;\n        this._nodeList[idx] = newNode;\n        for (let i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--) ;\n        return node ? node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode) : this.insertInto(newNode, 0);\n    }\n    removeChild(child) {\n        if (!this._idMap) return null;\n        if (!this._idMap.has(child._uid)) return null;\n        if (this._idMap.delete(child._uid), this._nodeList) {\n            const idx = this._nodeList.findIndex((n => n === child));\n            idx > 0 && this._nodeList.splice(idx, 1);\n        }\n        return child._prev ? child._prev._next = child._next : this._firstChild = child._next, \n        child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, \n        child._prev = null, child._next = null, this._structEdit = !0, this.setCount(-child.count), \n        child;\n    }\n    delete() {\n        this.parent && this.parent.removeChild(this);\n    }\n    removeAllChild() {\n        if (!this._idMap) return;\n        let child = this._firstChild;\n        for (;child; ) child.parent = null, child._prev = null, child._next = null, child = child._next;\n        this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = !0, \n        this.setCount(1 - this._count);\n    }\n    replaceChild(newChild, oldChild) {\n        throw new Error(\"\");\n    }\n    find(callback, deep = !1) {\n        let target = null;\n        return this.forEachChildren(((node, index) => !(node === this || !callback(node, index)) && (target = node, \n        !0))), deep && this.forEachChildren((child => {\n            if (child.isContainer) {\n                const node = child.find(callback, !0);\n                if (node) return target = node, !0;\n            }\n            return !1;\n        })), target;\n    }\n    findAll(callback, deep = !1) {\n        let nodes = [];\n        return this.forEachChildren(((node, index) => {\n            node !== this && callback(node, index) && nodes.push(node);\n        })), deep && this.forEachChildren((child => {\n            if (child.isContainer) {\n                const targets = child.findAll(callback, !0);\n                targets.length && (nodes = nodes.concat(targets));\n            }\n        })), nodes;\n    }\n    getElementById(id) {\n        return this.find((node => node.id === id), !0);\n    }\n    findChildById(id) {\n        return this.getElementById(id);\n    }\n    findChildByUid(uid) {\n        return this._idMap && this._idMap.get(uid) || null;\n    }\n    getElementsByName(name) {\n        return this.findAll((node => node.name === name), !0);\n    }\n    findChildrenByName(name) {\n        return this.getElementsByName(name);\n    }\n    getElementsByType(type) {\n        return this.findAll((node => node.type === type), !0);\n    }\n    getChildByName(name, deep = !1) {\n        return this.find((node => node.name === name), deep);\n    }\n    getChildAt(idx) {\n        let c = this._firstChild;\n        if (!c) return null;\n        for (let i = 0; i < idx; i++) {\n            if (!c._next) return null;\n            c = c._next;\n        }\n        return c;\n    }\n    at(idx) {\n        return this.getChildAt(idx);\n    }\n    containNode(node) {\n        if (!this._idMap) return !1;\n        if (this._idMap.has(node._uid)) return !0;\n        let child = this._firstChild;\n        for (;child; ) {\n            if (child.containNode(node)) return !0;\n            child = child._next;\n        }\n        return !1;\n    }\n    getRootNode() {\n        let parent = this.parent;\n        for (;null == parent ? void 0 : parent.parent; ) parent = parent.parent;\n        return parent || this;\n    }\n    hasChildNodes() {\n        return null !== this._firstChild;\n    }\n    addChild(node) {\n        return this.appendChild(node);\n    }\n    add(node) {\n        return this.appendChild(node);\n    }\n    getChildren() {\n        const nodes = [];\n        let child = this._firstChild;\n        for (;child; ) nodes.push(child), child = child._next;\n        return nodes;\n    }\n    isChildOf(node) {\n        return !!this.parent && this.parent._uid === node._uid;\n    }\n    isParentOf(node) {\n        return node.isChildOf(this);\n    }\n    isDescendantsOf(node) {\n        let parent = this.parent;\n        if (!parent) return !1;\n        do {\n            if (parent._uid === node._uid) return !0;\n            parent = parent.parent;\n        } while (null !== parent);\n        return !1;\n    }\n    isAncestorsOf(node) {\n        return node.isDescendantsOf(this);\n    }\n    getAncestor(idx) {\n        throw new Error(\"\");\n    }\n    setAllDescendantsProps(propsName, propsValue) {\n        let child = this._firstChild;\n        for (;child; ) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), \n        child = child._next;\n    }\n    setCount(deltaCount) {\n        this._count += deltaCount;\n        let parent = this.parent;\n        if (parent) do {\n            parent._count += deltaCount, parent = parent.parent;\n        } while (null !== parent);\n    }\n    clone() {\n        throw new Error(\"\");\n    }\n    cloneTo(node) {\n        throw new Error(\"\");\n    }\n    getParent() {\n        return this.parent;\n    }\n    del(child) {\n        return this.removeChild(child);\n    }\n    addEventListener(type, listener, options) {\n        const capture = (0, vutils_1.isBoolean)(options, !0) && options || (0, vutils_1.isObject)(options) && options.capture, once = (0, \n        vutils_1.isObject)(options) && options.once, context = (0, vutils_1.isFunction)(listener) ? void 0 : listener;\n        return type = capture ? `${type}capture` : type, listener = (0, vutils_1.isFunction)(listener) ? listener : listener.handleEvent, \n        once ? super.once(type, listener, context) : super.on(type, listener, context), \n        this;\n    }\n    on(type, listener, options) {\n        return this.addEventListener(type, listener, options);\n    }\n    removeEventListener(type, listener, options) {\n        const capture = (0, vutils_1.isBoolean)(options, !0) && options || (0, vutils_1.isObject)(options) && options.capture, context = (0, \n        vutils_1.isFunction)(listener) ? void 0 : listener;\n        type = capture ? `${type}capture` : type, listener = (0, vutils_1.isFunction)(listener) ? listener : listener.handleEvent;\n        const once = (0, vutils_1.isObject)(options) && options.once;\n        return super.off(type, listener, context, once), this;\n    }\n    off(type, listener, options) {\n        return this.removeEventListener(type, listener, options);\n    }\n    once(type, listener, options) {\n        return (0, vutils_1.isObject)(options) ? (options.once = !0, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {\n            once: !0\n        });\n    }\n    removeAllEventListeners() {\n        return super.removeAllListeners(), this;\n    }\n    removeAllListeners() {\n        return this.removeAllEventListeners();\n    }\n    dispatchEvent(event, ...args) {\n        return super.emit(event.type, event, ...args), !event.defaultPrevented;\n    }\n    emit(event, data) {\n        return this.dispatchEvent(event, data);\n    }\n    release() {\n        this.removeAllListeners();\n    }\n}\n\nexports.Node = Node;\n//# sourceMappingURL=node-tree.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Generator = void 0;\n\nclass Generator {\n    static GenAutoIncrementId() {\n        return Generator.auto_increment_id++;\n    }\n}\n\nexports.Generator = Generator, Generator.auto_increment_id = 0;\n//# sourceMappingURL=generator.js.map","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./federated-event\"), exports), __exportStar(require(\"./event-manager\"), exports), \n__exportStar(require(\"./event-target\"), exports), __exportStar(require(\"./event-system\"), exports), \n__exportStar(require(\"./extension\"), exports), __exportStar(require(\"../interface/event\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./base-event\"), exports), __exportStar(require(\"./mouse-event\"), exports), \n__exportStar(require(\"./pointer-event\"), exports), __exportStar(require(\"./wheel-event\"), exports), \n__exportStar(require(\"./custom-event\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.FederatedEvent = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nclass FederatedEvent {\n    get layerX() {\n        return this.layer.x;\n    }\n    get layerY() {\n        return this.layer.y;\n    }\n    get pageX() {\n        return this.page.x;\n    }\n    get pageY() {\n        return this.page.y;\n    }\n    get x() {\n        return this.canvas.x;\n    }\n    get y() {\n        return this.canvas.y;\n    }\n    get canvasX() {\n        return this.canvas.x;\n    }\n    get canvasY() {\n        return this.canvas.y;\n    }\n    get viewX() {\n        return this.viewport.x;\n    }\n    get viewY() {\n        return this.viewport.y;\n    }\n    constructor(manager) {\n        this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, \n        this.defaultPrevented = !1, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = !1, \n        this.propagationImmediatelyStopped = !1, this.layer = new vutils_1.Point, this.page = new vutils_1.Point, \n        this.canvas = new vutils_1.Point, this.viewport = new vutils_1.Point, this.NONE = 0, \n        this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;\n    }\n    composedPath() {\n        return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), \n        this.path;\n    }\n    preventDefault() {\n        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), \n        this.defaultPrevented = !0;\n    }\n    stopImmediatePropagation() {\n        this.propagationImmediatelyStopped = !0;\n    }\n    stopPropagation() {\n        this.propagationStopped = !0;\n    }\n    initEvent() {}\n    initUIEvent() {}\n    clone() {\n        throw new Error(\"Method not implemented.\");\n    }\n}\n\nexports.FederatedEvent = FederatedEvent;\n//# sourceMappingURL=base-event.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.FederatedMouseEvent = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), base_event_1 = require(\"./base-event\");\n\nclass FederatedMouseEvent extends base_event_1.FederatedEvent {\n    constructor() {\n        super(...arguments), this.client = new vutils_1.Point, this.movement = new vutils_1.Point, \n        this.offset = new vutils_1.Point, this.global = new vutils_1.Point, this.screen = new vutils_1.Point;\n    }\n    get clientX() {\n        return this.client.x;\n    }\n    get clientY() {\n        return this.client.y;\n    }\n    get movementX() {\n        return this.movement.x;\n    }\n    get movementY() {\n        return this.movement.y;\n    }\n    get offsetX() {\n        return this.offset.x;\n    }\n    get offsetY() {\n        return this.offset.y;\n    }\n    get globalX() {\n        return this.global.x;\n    }\n    get globalY() {\n        return this.global.y;\n    }\n    get screenX() {\n        return this.screen.x;\n    }\n    get screenY() {\n        return this.screen.y;\n    }\n    getModifierState(key) {\n        return \"getModifierState\" in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n    initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {\n        throw new Error(\"Method not implemented.\");\n    }\n}\n\nexports.FederatedMouseEvent = FederatedMouseEvent;\n//# sourceMappingURL=mouse-event.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.FederatedPointerEvent = void 0;\n\nconst mouse_event_1 = require(\"./mouse-event\");\n\nclass FederatedPointerEvent extends mouse_event_1.FederatedMouseEvent {\n    constructor() {\n        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1;\n    }\n    getCoalescedEvents() {\n        return \"pointermove\" === this.type || \"mousemove\" === this.type || \"touchmove\" === this.type ? [ this ] : [];\n    }\n    getPredictedEvents() {\n        throw new Error(\"getPredictedEvents is not supported!\");\n    }\n    clone() {\n        var _a, _b, _c;\n        const event = new FederatedPointerEvent(this.manager);\n        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], \n        event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, \n        null === (_a = this.manager) || void 0 === _a || _a.copyPointerData(this, event), \n        null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), \n        null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, \n        event.path = this.composedPath().slice(), event.type = this.type, event;\n    }\n}\n\nexports.FederatedPointerEvent = FederatedPointerEvent;\n//# sourceMappingURL=pointer-event.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.FederatedWheelEvent = void 0;\n\nconst mouse_event_1 = require(\"./mouse-event\");\n\nclass FederatedWheelEvent extends mouse_event_1.FederatedMouseEvent {\n    constructor() {\n        super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;\n    }\n    clone() {\n        var _a, _b, _c;\n        const event = new FederatedWheelEvent(this.manager);\n        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], \n        event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, \n        null === (_a = this.manager) || void 0 === _a || _a.copyWheelData(this, event), \n        null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), \n        null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, \n        event.path = this.composedPath().slice(), event.type = this.type, event;\n    }\n}\n\nexports.FederatedWheelEvent = FederatedWheelEvent, FederatedWheelEvent.DOM_DELTA_PIXEL = 0, \nFederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;\n//# sourceMappingURL=wheel-event.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CustomEvent = void 0;\n\nconst base_event_1 = require(\"./base-event\");\n\nclass CustomEvent extends base_event_1.FederatedEvent {\n    constructor(eventName, object) {\n        super(), this.type = eventName, this.detail = object;\n    }\n}\n\nexports.CustomEvent = CustomEvent;\n//# sourceMappingURL=custom-event.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.EventManager = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), federated_event_1 = require(\"./federated-event\"), constant_1 = require(\"./constant\"), util_1 = require(\"./util\"), PROPAGATION_LIMIT = 2048;\n\nfunction isMouseLike(pointerType) {\n    return \"mouse\" === pointerType || \"pen\" === pointerType;\n}\n\nclass EventManager {\n    constructor(root) {\n        this.dispatch = new vutils_1.EventEmitter, this.mappingState = {\n            trackingData: {}\n        }, this.eventPool = new Map, this.onPointerDown = (from, target) => {\n            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn(\"EventManager cannot map a non-pointer event as a pointer event\");\n            const e = this.createPointerEvent(from, from.type, target);\n            if (this.dispatchEvent(e, \"pointerdown\"), \"touch\" === e.pointerType) this.dispatchEvent(e, \"touchstart\"); else if (isMouseLike(e.pointerType)) {\n                const isRightButton = 2 === e.button;\n                this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n            }\n            this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e.composedPath(), \n            this.freeEvent(e);\n        }, this.onPointerMove = (from, target) => {\n            var _a, _b;\n            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn(\"EventManager cannot map a non-pointer event as a pointer event\");\n            const e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType), trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);\n            if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e.target) {\n                const outType = \"mousemove\" === from.type ? \"mouseout\" : \"pointerout\", outEvent = this.createPointerEvent(from, outType, outTarget || void 0);\n                if (this.dispatchEvent(outEvent, \"pointerout\"), isMouse && this.dispatchEvent(outEvent, \"mouseout\"), \n                !e.composedPath().includes(outTarget)) {\n                    const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget || void 0);\n                    for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target); ) leaveEvent.currentTarget = leaveEvent.target, \n                    this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, \"mouseleave\"), \n                    leaveEvent.target = leaveEvent.target.parent;\n                    this.freeEvent(leaveEvent);\n                }\n                this.freeEvent(outEvent);\n            }\n            if (outTarget !== e.target) {\n                const overType = \"mousemove\" === from.type ? \"mouseover\" : \"pointerover\", overEvent = this.clonePointerEvent(e, overType);\n                this.dispatchEvent(overEvent, \"pointerover\"), isMouse && this.dispatchEvent(overEvent, \"mouseover\");\n                let overTargetAncestor = null == outTarget ? void 0 : outTarget.parent;\n                for (;overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target; ) overTargetAncestor = overTargetAncestor.parent;\n                if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {\n                    const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n                    for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent; ) enterEvent.currentTarget = enterEvent.target, \n                    this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, \"mouseenter\"), \n                    enterEvent.target = enterEvent.target.parent;\n                    this.freeEvent(enterEvent);\n                }\n                this.freeEvent(overEvent);\n            }\n            this.dispatchEvent(e, \"pointermove\"), \"touch\" === e.pointerType && this.dispatchEvent(e, \"touchmove\"), \n            isMouse && (this.dispatchEvent(e, \"mousemove\"), this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor()), \n            trackingData.overTargets = e.composedPath(), this.freeEvent(e);\n        }, this.onPointerOver = (from, target) => {\n            var _a, _b;\n            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn(\"EventManager cannot map a non-pointer event as a pointer event\");\n            const trackingData = this.trackingData(from.pointerId), e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType);\n            this.dispatchEvent(e, \"pointerover\"), isMouse && this.dispatchEvent(e, \"mouseover\"), \n            \"mouse\" === e.pointerType && (this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor());\n            const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n            for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; ) enterEvent.currentTarget = enterEvent.target, \n            this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, \"mouseenter\"), \n            enterEvent.target = enterEvent.target.parent;\n            trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);\n        }, this.onPointerOut = (from, target) => {\n            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn(\"EventManager cannot map a non-pointer event as a pointer event\");\n            const trackingData = this.trackingData(from.pointerId);\n            if (trackingData.overTargets) {\n                const isMouse = isMouseLike(from.pointerType), outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, \"pointerout\", outTarget || void 0);\n                this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, \"mouseout\");\n                const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget || void 0);\n                for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; ) leaveEvent.currentTarget = leaveEvent.target, \n                this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, \"mouseleave\"), \n                leaveEvent.target = leaveEvent.target.parent;\n                trackingData.overTargets = [], this.freeEvent(outEvent), this.freeEvent(leaveEvent);\n            }\n            this.cursor = \"\";\n        }, this.onPointerUp = (from, target) => {\n            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn(\"EventManager cannot map a non-pointer event as a pointer event\");\n            const now = util_1.clock.now(), e = this.createPointerEvent(from, from.type, target);\n            if (this.dispatchEvent(e, \"pointerup\"), \"touch\" === e.pointerType) this.dispatchEvent(e, \"touchend\"); else if (isMouseLike(e.pointerType)) {\n                const isRightButton = 2 === e.button;\n                this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n            }\n            const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n            let clickTarget = pressTarget;\n            if (pressTarget && !e.composedPath().includes(pressTarget)) {\n                let currentTarget = pressTarget;\n                for (;currentTarget && !e.composedPath().includes(currentTarget); ) {\n                    if (e.currentTarget = currentTarget, this.notifyTarget(e, \"pointerupoutside\"), \"touch\" === e.pointerType) this.notifyTarget(e, \"touchendoutside\"); else if (isMouseLike(e.pointerType)) {\n                        const isRightButton = 2 === e.button;\n                        this.notifyTarget(e, isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n                    }\n                    currentTarget = currentTarget.parent;\n                }\n                delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;\n            }\n            if (clickTarget) {\n                const clickEvent = this.clonePointerEvent(e, \"click\");\n                clickEvent.target = clickTarget, clickEvent.path = [], trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now\n                });\n                const clickHistory = trackingData.clicksByButton[from.button];\n                clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200 ? ++clickHistory.clickCount : clickHistory.clickCount = 1, \n                clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, \n                isMouseLike(clickEvent.pointerType) ? (this.dispatchEvent(clickEvent, \"click\"), \n                2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, \"dblclick\")) : \"touch\" === clickEvent.pointerType && this.dispatchEvent(clickEvent, \"tap\"), \n                this.dispatchEvent(clickEvent, \"pointertap\"), this.freeEvent(clickEvent);\n            }\n            this.freeEvent(e);\n        }, this.onPointerUpOutside = (from, target) => {\n            if (!(from instanceof federated_event_1.FederatedPointerEvent)) return void console.warn(\"EventManager cannot map a non-pointer event as a pointer event\");\n            const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from, from.type, target);\n            if (pressTarget) {\n                let currentTarget = pressTarget;\n                for (;currentTarget; ) e.currentTarget = currentTarget, this.notifyTarget(e, \"pointerupoutside\"), \n                \"touch\" === e.pointerType ? this.notifyTarget(e, \"touchendoutside\") : isMouseLike(e.pointerType) && this.notifyTarget(e, 2 === e.button ? \"rightupoutside\" : \"mouseupoutside\"), \n                currentTarget = currentTarget.parent;\n                delete trackingData.pressTargetsByButton[from.button];\n            }\n            this.freeEvent(e);\n        }, this.onWheel = (from, target) => {\n            if (!(from instanceof federated_event_1.FederatedWheelEvent)) return void console.warn(\"EventManager cannot map a non-wheel event as a wheel event\");\n            const wheelEvent = this.createWheelEvent(from, target);\n            this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);\n        }, this.rootTarget = root, this.mappingTable = {}, this.addEventMapping(\"pointerdown\", this.onPointerDown), \n        this.addEventMapping(\"pointermove\", this.onPointerMove), this.addEventMapping(\"pointerout\", this.onPointerOut), \n        this.addEventMapping(\"pointerleave\", this.onPointerOut), this.addEventMapping(\"pointerover\", this.onPointerOver), \n        this.addEventMapping(\"pointerup\", this.onPointerUp), this.addEventMapping(\"pointerupoutside\", this.onPointerUpOutside), \n        this.addEventMapping(\"wheel\", this.onWheel);\n    }\n    addEventMapping(type, fn) {\n        this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({\n            fn: fn,\n            priority: 0\n        }), this.mappingTable[type].sort(((a, b) => a.priority - b.priority));\n    }\n    dispatchEvent(e, type) {\n        e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, type), \n        this.dispatch.emit(type || e.type, e);\n    }\n    mapEvent(e) {\n        var _a;\n        if (!this.rootTarget) return;\n        const mappers = this.mappingTable[e.type];\n        let target;\n        const cacheKey = `${e.canvasX}-${e.canvasY}`;\n        if ((null === (_a = this._prePointTargetCache) || void 0 === _a ? void 0 : _a[cacheKey]) ? target = this._prePointTargetCache[cacheKey] : (target = this.pickTarget(e.canvasX, e.canvasY), \n        this._prePointTargetCache = {\n            [cacheKey]: target\n        }), mappers) for (let i = 0, j = mappers.length; i < j; i++) mappers[i].fn(e, target); else console.warn(`[EventManager]: Event mapping not defined for ${e.type}`);\n    }\n    propagate(e, type) {\n        if (!e.target) return;\n        const composedPath = e.composedPath();\n        e.eventPhase = e.CAPTURING_PHASE;\n        for (let i = 0, j = composedPath.length - 1; i < j; i++) if (e.currentTarget = composedPath[i], \n        this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;\n        if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), \n        !e.propagationStopped && !e.propagationImmediatelyStopped) {\n            e.eventPhase = e.BUBBLING_PHASE;\n            for (let i = composedPath.length - 2; i >= 0; i--) if (e.currentTarget = composedPath[i], \n            this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n    propagationPath(target) {\n        const propagationPath = [ target ];\n        for (let i = 0; i < 2048 && target !== this.rootTarget && target.parent; i++) {\n            if (!target.parent) throw new Error(\"Cannot find propagation path to disconnected target\");\n            propagationPath.push(target.parent), target = target.parent;\n        }\n        return propagationPath.reverse(), propagationPath;\n    }\n    notifyTarget(e, type) {\n        type = null != type ? type : e.type;\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n        this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);\n    }\n    findMountedTarget(propagationPath) {\n        if (!propagationPath) return null;\n        let currentTarget = propagationPath[0];\n        for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++) currentTarget = propagationPath[i];\n        return currentTarget;\n    }\n    createPointerEvent(from, type, target) {\n        const event = this.allocateEvent(federated_event_1.FederatedPointerEvent);\n        return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), \n        event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(event.global.x, event.global.y), \n        \"string\" == typeof type && (event.type = type), event;\n    }\n    createWheelEvent(from, target) {\n        const event = this.allocateEvent(federated_event_1.FederatedWheelEvent);\n        return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), \n        event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(event.global.x, event.global.y), \n        event;\n    }\n    clonePointerEvent(from, type) {\n        const event = this.allocateEvent(federated_event_1.FederatedPointerEvent);\n        return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, \n        this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), \n        event.target = from.target, event.path = from.composedPath().slice(), event.type = null != type ? type : event.type, \n        event;\n    }\n    copyWheelData(from, to) {\n        to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, \n        to.deltaZ = from.deltaZ;\n    }\n    copyPointerData(from, to) {\n        from instanceof federated_event_1.FederatedPointerEvent && to instanceof federated_event_1.FederatedPointerEvent && (to.pointerId = from.pointerId, \n        to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, \n        to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, \n        to.tiltY = from.tiltY, to.twist = from.twist);\n    }\n    copyMouseData(from, to) {\n        from instanceof federated_event_1.FederatedMouseEvent && to instanceof federated_event_1.FederatedMouseEvent && (to.altKey = from.altKey, \n        to.button = from.button, to.buttons = from.buttons, to.client.copyFrom(from.client), \n        to.ctrlKey = from.ctrlKey, to.shiftKey = from.shiftKey, to.metaKey = from.metaKey, \n        to.movement.copyFrom(from.movement), to.canvas.copyFrom(from.canvas), to.screen.copyFrom(from.screen), \n        to.global.copyFrom(from.global), to.offset.copyFrom(from.offset), to.viewport.copyFrom(from.viewport));\n    }\n    copyData(from, to) {\n        to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = util_1.clock.now(), \n        to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, \n        to.layer.copyFrom(from.layer), to.page.copyFrom(from.page);\n    }\n    trackingData(id) {\n        return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {\n            pressTargetsByButton: {},\n            clicksByButton: {},\n            overTarget: null\n        }), this.mappingState.trackingData[id];\n    }\n    allocateEvent(constructor) {\n        var _a;\n        this.eventPool.has(constructor) || this.eventPool.set(constructor, []);\n        const event = (null === (_a = this.eventPool.get(constructor)) || void 0 === _a ? void 0 : _a.pop()) || new constructor(this);\n        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], \n        event.target = null, event;\n    }\n    freeEvent(event) {\n        var _a;\n        if (event.manager !== this) throw new Error(\"It is illegal to free an event not managed by this EventManager!\");\n        const constructor = event.constructor;\n        this.eventPool.has(constructor) || this.eventPool.set(constructor, []), null === (_a = this.eventPool.get(constructor)) || void 0 === _a || _a.push(event);\n    }\n    notifyListeners(e, type) {\n        const listeners = e.currentTarget._events[type];\n        if (listeners) if (\"fn\" in listeners) listeners.once && e.currentTarget.removeEventListener(type, listeners.fn, {\n            once: !0\n        }), listeners.fn.call(listeners.context, e); else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].once && e.currentTarget.removeEventListener(type, listeners[i].fn, {\n            once: !0\n        }), listeners[i].fn.call(listeners[i].context, e); else this.emitDelegation(e, type);\n    }\n    emitDelegation(e, type) {\n        const listeners = e.currentTarget._events[constant_1.WILDCARD];\n        if (listeners) if (\"fn\" in listeners) listeners.fn.call(listeners.context, e, type); else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);\n    }\n    pickTarget(x, y) {\n        let target;\n        const pickResult = this.rootTarget.pick(x, y);\n        return target = pickResult && pickResult.graphic ? pickResult.graphic : pickResult && pickResult.group ? pickResult.group : x >= 0 && x <= (0, \n        vutils_1.get)(this.rootTarget, \"width\") && y >= 0 && y <= (0, vutils_1.get)(this.rootTarget, \"height\") ? this.rootTarget : null, \n        target;\n    }\n}\n\nexports.EventManager = EventManager;\n//# sourceMappingURL=event-manager.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.WILDCARD = void 0, exports.WILDCARD = \"*\";\n//# sourceMappingURL=constant.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.clock = void 0, exports.clock = \"object\" == typeof performance && performance.now ? performance : Date;\n//# sourceMappingURL=util.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.EventTarget = void 0;\n\nconst federated_event_1 = require(\"./federated-event\");\n\nexports.EventTarget = {\n    pickable: !0,\n    visible: !0,\n    dispatchEvent(e) {\n        var _a;\n        if (!(e instanceof federated_event_1.FederatedEvent)) throw new Error(\"DisplayObject cannot propagate events outside of the Federated Events API\");\n        return e.defaultPrevented = !1, e.path = [], e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), \n        !e.defaultPrevented;\n    },\n    emit(eventName, object) {\n        return this.dispatchEvent(new federated_event_1.CustomEvent(eventName, object));\n    }\n};\n//# sourceMappingURL=event-target.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.EventSystem = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), event_manager_1 = require(\"./event-manager\"), federated_event_1 = require(\"./federated-event\"), util_1 = require(\"./util\"), MOUSE_POINTER_ID = 1, TOUCH_TO_POINTER = {\n    touchstart: \"pointerdown\",\n    touchend: \"pointerup\",\n    touchendoutside: \"pointerupoutside\",\n    touchmove: \"pointermove\",\n    touchcancel: \"pointercancel\"\n};\n\nclass EventSystem {\n    constructor(params) {\n        this.resolution = 1, this.onPointerDown = nativeEvent => {\n            if (this.supportsTouchEvents && \"touch\" === nativeEvent.pointerType) return;\n            const events = this.normalizeToPointerData(nativeEvent);\n            if (this.autoPreventDefault && events[0].isNormalized) {\n                (nativeEvent.cancelable || !(\"cancelable\" in nativeEvent)) && nativeEvent.preventDefault();\n            }\n            for (let i = 0, j = events.length; i < j; i++) {\n                const nativeEvent = events[i], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);\n                this.manager.mapEvent(federatedEvent);\n            }\n            this.setCursor(this.manager.cursor);\n        }, this.onPointerMove = nativeEvent => {\n            if (this.supportsTouchEvents && \"touch\" === nativeEvent.pointerType) return;\n            if (this.isEventOutsideOfTargetElement(nativeEvent)) return;\n            const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n            for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n                const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n                this.manager.mapEvent(event);\n            }\n            this.setCursor(this.manager.cursor);\n        }, this.onPointerUp = nativeEvent => {\n            if (this.supportsTouchEvents && \"touch\" === nativeEvent.pointerType) return;\n            const outside = this.isEventOutsideOfTargetElement(nativeEvent) ? \"outside\" : \"\", normalizedEvents = this.normalizeToPointerData(nativeEvent);\n            for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n                const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n                event.type += outside, this.manager.mapEvent(event);\n            }\n            this.setCursor(this.manager.cursor);\n        }, this.onPointerOverOut = nativeEvent => {\n            if (this.supportsTouchEvents && \"touch\" === nativeEvent.pointerType) return;\n            const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n            for (let i = 0, j = normalizedEvents.length; i < j; i++) {\n                const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n                this.manager.mapEvent(event);\n            }\n            this.setCursor(this.manager.cursor);\n        }, this.onWheel = nativeEvent => {\n            const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n            this.manager.mapEvent(wheelEvent);\n        };\n        const {targetElement: targetElement, resolution: resolution, rootNode: rootNode, global: global, viewport: viewport, autoPreventDefault: autoPreventDefault = !1} = params;\n        this.manager = new event_manager_1.EventManager(rootNode), this.globalObj = global, \n        this.supportsPointerEvents = global.supportsPointerEvents, this.supportsTouchEvents = global.supportsTouchEvents, \n        this.supportsMouseEvents = global.supportsMouseEvents, this.applyStyles = global.applyStyles, \n        this.autoPreventDefault = autoPreventDefault, this.eventsAdded = !1, this.viewport = viewport, \n        this.rootPointerEvent = new federated_event_1.FederatedPointerEvent, this.rootWheelEvent = new federated_event_1.FederatedWheelEvent, \n        this.cursorStyles = {\n            default: \"inherit\",\n            pointer: \"pointer\"\n        }, this.resolution = resolution, this.setTargetElement(targetElement);\n    }\n    release() {\n        this.setTargetElement(null);\n    }\n    setCursor(mode = \"default\") {\n        const {applyStyles: applyStyles, domElement: domElement} = this;\n        if (this.currentCursor === mode) return;\n        this.currentCursor = mode;\n        const style = this.cursorStyles[mode];\n        style ? \"string\" == typeof style && applyStyles ? domElement.style.cursor = style : \"function\" == typeof style ? style(mode) : \"object\" == typeof style && applyStyles && Object.assign(domElement.style, style) : applyStyles && (0, \n        vutils_1.isString)(mode) && !(0, vutils_1.has)(this.cursorStyles, mode) && (domElement.style.cursor = mode);\n    }\n    setTargetElement(element) {\n        this.removeEvents(), this.domElement = element, this.addEvents();\n    }\n    addEvents() {\n        if (this.eventsAdded || !this.domElement) return;\n        const {globalObj: globalObj, domElement: domElement} = this;\n        this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().addEventListener(\"pointermove\", this.onPointerMove, !0), \n        globalObj.getDocument().addEventListener(\"pointerup\", this.onPointerUp, !0)) : (domElement.addEventListener(\"pointermove\", this.onPointerMove, !0), \n        domElement.addEventListener(\"pointerup\", this.onPointerUp, !0)), domElement.addEventListener(\"pointerdown\", this.onPointerDown, !0), \n        domElement.addEventListener(\"pointerleave\", this.onPointerOverOut, !0), domElement.addEventListener(\"pointerover\", this.onPointerOverOut, !0)) : (globalObj.getDocument() ? (globalObj.getDocument().addEventListener(\"mousemove\", this.onPointerMove, !0), \n        globalObj.getDocument().addEventListener(\"mouseup\", this.onPointerUp, !0)) : (domElement.addEventListener(\"mousemove\", this.onPointerMove, !0), \n        domElement.addEventListener(\"mouseup\", this.onPointerUp, !0)), domElement.addEventListener(\"mousedown\", this.onPointerDown, !0), \n        domElement.addEventListener(\"mouseout\", this.onPointerOverOut, !0), domElement.addEventListener(\"mouseover\", this.onPointerOverOut, !0)), \n        this.supportsTouchEvents && (domElement.addEventListener(\"touchstart\", this.onPointerDown, !0), \n        domElement.addEventListener(\"touchend\", this.onPointerUp, !0), domElement.addEventListener(\"touchmove\", this.onPointerMove, !0)), \n        domElement.addEventListener(\"wheel\", this.onWheel, {\n            capture: !0\n        }), this.eventsAdded = !0;\n    }\n    removeEvents() {\n        if (!this.eventsAdded || !this.domElement) return;\n        const {globalObj: globalObj, domElement: domElement} = this;\n        this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener(\"pointermove\", this.onPointerMove, !0), \n        globalObj.getDocument().removeEventListener(\"pointerup\", this.onPointerUp, !0)) : (domElement.removeEventListener(\"pointermove\", this.onPointerMove, !0), \n        domElement.removeEventListener(\"pointerup\", this.onPointerUp, !0)), domElement.removeEventListener(\"pointerdown\", this.onPointerDown, !0), \n        domElement.removeEventListener(\"pointerleave\", this.onPointerOverOut, !0), domElement.removeEventListener(\"pointerover\", this.onPointerOverOut, !0)) : (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener(\"mousemove\", this.onPointerMove, !0), \n        globalObj.getDocument().removeEventListener(\"mouseup\", this.onPointerUp, !0)) : (domElement.removeEventListener(\"mousemove\", this.onPointerMove, !0), \n        domElement.removeEventListener(\"mouseup\", this.onPointerUp, !0)), domElement.removeEventListener(\"mousedown\", this.onPointerDown, !0), \n        domElement.removeEventListener(\"mouseout\", this.onPointerOverOut, !0), domElement.removeEventListener(\"mouseover\", this.onPointerOverOut, !0)), \n        this.supportsTouchEvents && (domElement.removeEventListener(\"touchstart\", this.onPointerDown, !0), \n        domElement.removeEventListener(\"touchend\", this.onPointerUp, !0), domElement.removeEventListener(\"touchmove\", this.onPointerMove, !0)), \n        domElement.removeEventListener(\"wheel\", this.onWheel, !0), this.domElement = null, \n        this.eventsAdded = !1;\n    }\n    mapToViewportPoint(event) {\n        const viewport = this.viewport, {x: x, y: y} = event;\n        return {\n            x: x - viewport.x,\n            y: y - viewport.y\n        };\n    }\n    mapToCanvasPoint(nativeEvent) {\n        var _a;\n        const point = null === (_a = this.globalObj) || void 0 === _a ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);\n        if (point) return point;\n        const {clientX: x, clientY: y} = nativeEvent, rect = this.domElement.getBoundingClientRect();\n        return {\n            x: x - rect.left,\n            y: y - rect.top\n        };\n    }\n    normalizeToPointerData(event) {\n        const normalizedEvents = [];\n        if (this.supportsTouchEvents && event.changedTouches && event.changedTouches.length) for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n            const touch = event.changedTouches[i];\n            (0, vutils_1.isUndefined)(touch.button) && (touch.button = 0), (0, vutils_1.isUndefined)(touch.buttons) && (touch.buttons = 1), \n            (0, vutils_1.isUndefined)(touch.isPrimary) && (touch.isPrimary = 1 === event.touches.length && \"touchstart\" === event.type), \n            (0, vutils_1.isUndefined)(touch.width) && (touch.width = touch.radiusX || 1), (0, \n            vutils_1.isUndefined)(touch.height) && (touch.height = touch.radiusY || 1), (0, \n            vutils_1.isUndefined)(touch.tiltX) && (touch.tiltX = 0), (0, vutils_1.isUndefined)(touch.tiltY) && (touch.tiltY = 0), \n            (0, vutils_1.isUndefined)(touch.pointerType) && (touch.pointerType = \"touch\"), (0, \n            vutils_1.isUndefined)(touch.pointerId) && (touch.pointerId = touch.identifier || 0), \n            (0, vutils_1.isUndefined)(touch.pressure) && (touch.pressure = touch.force || .5), \n            (0, vutils_1.isUndefined)(touch.twist) && (touch.twist = 0), (0, vutils_1.isUndefined)(touch.tangentialPressure) && (touch.tangentialPressure = 0), \n            (0, vutils_1.isUndefined)(touch.layerX) && (touch.layerX = touch.offsetX = touch.clientX), \n            (0, vutils_1.isUndefined)(touch.layerY) && (touch.layerY = touch.offsetY = touch.clientY), \n            touch.isNormalized = !0, touch.type = event.type, normalizedEvents.push(touch);\n        } else if (this.globalObj.supportsMouseEvents && (!(event instanceof MouseEvent) || this.supportsPointerEvents && event instanceof PointerEvent)) normalizedEvents.push(event); else {\n            const tempEvent = event;\n            (0, vutils_1.isUndefined)(tempEvent.isPrimary) && (tempEvent.isPrimary = !0), (0, \n            vutils_1.isUndefined)(tempEvent.width) && (tempEvent.width = 1), (0, vutils_1.isUndefined)(tempEvent.height) && (tempEvent.height = 1), \n            (0, vutils_1.isUndefined)(tempEvent.tiltX) && (tempEvent.tiltX = 0), (0, vutils_1.isUndefined)(tempEvent.tiltY) && (tempEvent.tiltY = 0), \n            (0, vutils_1.isUndefined)(tempEvent.pointerType) && (tempEvent.pointerType = \"mouse\"), \n            (0, vutils_1.isUndefined)(tempEvent.pointerId) && (tempEvent.pointerId = 1), (0, \n            vutils_1.isUndefined)(tempEvent.pressure) && (tempEvent.pressure = .5), (0, vutils_1.isUndefined)(tempEvent.twist) && (tempEvent.twist = 0), \n            (0, vutils_1.isUndefined)(tempEvent.tangentialPressure) && (tempEvent.tangentialPressure = 0), \n            tempEvent.isNormalized = !0, normalizedEvents.push(tempEvent);\n        }\n        return normalizedEvents;\n    }\n    normalizeWheelEvent(nativeEvent) {\n        const event = this.rootWheelEvent;\n        this.transferMouseData(event, nativeEvent), event.deltaMode = nativeEvent.deltaMode, \n        event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ;\n        const {x: canvasX, y: canvasY} = this.mapToCanvasPoint(nativeEvent);\n        event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.copyFrom(event.canvas), \n        event.offset.copyFrom(event.canvas);\n        const {x: viewX, y: viewY} = this.mapToViewportPoint(event);\n        return event.viewport.x = viewX, event.viewport.y = viewY, event.nativeEvent = nativeEvent, \n        event.type = nativeEvent.type, event;\n    }\n    bootstrapEvent(event, nativeEvent) {\n        event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, \n        event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, \n        event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, \n        event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, \n        event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent);\n        const {x: canvasX, y: canvasY} = this.mapToCanvasPoint(nativeEvent);\n        event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.copyFrom(event.canvas), \n        event.offset.copyFrom(event.canvas);\n        const {x: viewX, y: viewY} = this.mapToViewportPoint(event);\n        return event.viewport.x = viewX, event.viewport.y = viewY, event.isTrusted = nativeEvent.isTrusted, \n        \"pointerleave\" === event.type && (event.type = \"pointerout\"), event.type.startsWith(\"mouse\") && (event.type = event.type.replace(\"mouse\", \"pointer\")), \n        event.type.startsWith(\"touch\") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), \n        event;\n    }\n    transferMouseData(event, nativeEvent) {\n        event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, \n        event.timeStamp = util_1.clock.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, \n        event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, \n        event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.shiftKey = nativeEvent.shiftKey, \n        event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, \n        event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null;\n    }\n    isEventOutsideOfTargetElement(nativeEvent) {\n        let target = nativeEvent.target;\n        nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);\n        return target !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement);\n    }\n}\n\nexports.EventSystem = EventSystem;\n//# sourceMappingURL=event-system.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Gesture = exports.DragNDrop = void 0;\n\nconst drag_1 = require(\"./drag\");\n\nObject.defineProperty(exports, \"DragNDrop\", {\n    enumerable: !0,\n    get: function() {\n        return drag_1.DragNDrop;\n    }\n});\n\nconst gesture_1 = require(\"./gesture\");\n\nObject.defineProperty(exports, \"Gesture\", {\n    enumerable: !0,\n    get: function() {\n        return gesture_1.Gesture;\n    }\n});\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DragNDrop = void 0;\n\nclass DragNDrop {\n    constructor(rootNode) {\n        this.onPointerDown = event => {\n            const target = event.target, rootNode = this.rootNode, isRoot = target === rootNode;\n            if (target && !isRoot) {\n                let currentDroppable, dragstartTriggered = !1;\n                function handlePointerMove(moveEvent) {\n                    if (dragstartTriggered || (moveEvent.type = \"dragstart\", null == target || target.dispatchEvent(moveEvent), \n                    dragstartTriggered = !0), moveEvent.type = \"drag\", null == target || target.dispatchEvent(moveEvent), \n                    !isRoot) {\n                        target.pickable = !1;\n                        const elemBelow = (null == rootNode ? void 0 : rootNode.pick(moveEvent.global.x, moveEvent.global.y)).graphic;\n                        target.pickable = !0, currentDroppable !== elemBelow && (currentDroppable && (moveEvent.type = \"dragleave\", \n                        moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)), \n                        elemBelow && (moveEvent.type = \"dragenter\", moveEvent.target = elemBelow, elemBelow.dispatchEvent(moveEvent)), \n                        currentDroppable = elemBelow, currentDroppable && (moveEvent.type = \"dragover\", \n                        moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)));\n                    }\n                }\n                null == rootNode || rootNode.addEventListener(\"pointermove\", handlePointerMove);\n                const stopDragging = function() {\n                    dragstartTriggered && (currentDroppable && (event.type = \"drop\", event.target = currentDroppable, \n                    currentDroppable.dispatchEvent(event)), event.type = \"dragend\", target.dispatchEvent(event), \n                    dragstartTriggered = !1), null == rootNode || rootNode.removeEventListener(\"pointermove\", handlePointerMove);\n                };\n                target.addEventListener(\"pointerup\", stopDragging, {\n                    once: !0\n                }), target.addEventListener(\"pointerupoutside\", stopDragging, {\n                    once: !0\n                });\n            }\n        }, this.rootNode = rootNode, this.initEvents();\n    }\n    initEvents() {\n        var _a;\n        null === (_a = this.rootNode) || void 0 === _a || _a.addEventListener(\"pointerdown\", this.onPointerDown);\n    }\n    removeEvents() {\n        var _a;\n        null === (_a = this.rootNode) || void 0 === _a || _a.removeEventListener(\"pointerdown\", this.onPointerDown);\n    }\n    release() {\n        this.removeEvents(), this.rootNode = null;\n    }\n}\n\nexports.DragNDrop = DragNDrop;\n//# sourceMappingURL=drag.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Gesture = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), util_1 = require(\"../util\"), constant_1 = require(\"../constant\"), application_1 = require(\"../../application\"), PRESS_TIME = 251, PRESS_THRESHOLD = 9, SWIPE_VELOCITY = .3, SWIPE_THRESHOLD = 10, calcDirection = (start, end) => {\n    const xDistance = end.x - start.x, yDistance = end.y - start.y;\n    return Math.abs(xDistance) > Math.abs(yDistance) ? xDistance > 0 ? \"right\" : \"left\" : yDistance > 0 ? \"down\" : \"up\";\n}, calcDistance = (point1, point2) => {\n    const xDistance = Math.abs(point2.x - point1.x), yDistance = Math.abs(point2.y - point1.y);\n    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}, getCenter = points => {\n    const pointersLength = points.length;\n    if (1 === pointersLength) return {\n        x: Math.round(points[0].x),\n        y: Math.round(points[0].y)\n    };\n    let x = 0, y = 0, i = 0;\n    for (;i < pointersLength; ) x += points[i].x, y += points[i].y, i++;\n    return {\n        x: Math.round(x / pointersLength),\n        y: Math.round(y / pointersLength)\n    };\n};\n\nclass Gesture extends vutils_1.EventEmitter {\n    constructor(element, config = {}) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        super(), this.cachedEvents = [], this.startPoints = [], this.processEvent = {}, \n        this.throttleTimer = 0, this.emitThrottles = [], this.onStart = ev => {\n            this.reset(), this.startTime = util_1.clock.now();\n            const {cachedEvents: cachedEvents, startPoints: startPoints} = this;\n            ev && cachedEvents.push(ev.clone()), startPoints.length = cachedEvents.length;\n            for (let i = 0; i < cachedEvents.length; i++) {\n                const {x: x, y: y} = cachedEvents[i], point = {\n                    x: x,\n                    y: y\n                };\n                startPoints[i] = point;\n            }\n            if (1 !== startPoints.length) this.startDistance = calcDistance(startPoints[0], startPoints[1]), \n            this.center = getCenter([ startPoints[0], startPoints[1] ]); else {\n                const event = cachedEvents[0];\n                this.pressTimeout = setTimeout((() => {\n                    event.direction = \"none\", event.deltaX = 0, event.deltaY = 0, event.points = startPoints, \n                    this.triggerStartEvent(\"press\", event), this.triggerEvent(\"press\", event), this.eventType = \"press\", \n                    this.direction = \"none\";\n                }), this.config.press.time);\n            }\n        }, this.onMove = ev => {\n            this.clearPressTimeout();\n            const {startPoints: startPoints, cachedEvents: cachedEvents} = this;\n            if (!startPoints.length) return;\n            const moveEvent = ev.clone(), {x: x, y: y, pointerId: pointerId} = moveEvent;\n            for (let i = 0, len = cachedEvents.length; i < len; i++) if (pointerId === cachedEvents[i].pointerId) {\n                cachedEvents[i] = moveEvent;\n                break;\n            }\n            const point = {\n                x: x,\n                y: y\n            }, points = cachedEvents.map((cachedEvent => ({\n                x: cachedEvent.x,\n                y: cachedEvent.y\n            }))), now = util_1.clock.now();\n            if (this.prevMoveTime = this.lastMoveTime, this.prevMovePoint = this.lastMovePoint, \n            this.lastMoveTime = now, this.lastMovePoint = point, 1 === startPoints.length) {\n                const startPoint = startPoints[0], deltaX = x - startPoint.x, deltaY = y - startPoint.y, direction = this.direction || calcDirection(startPoint, point);\n                this.direction = direction;\n                const eventType = this.getEventType(point);\n                return moveEvent.direction = direction, moveEvent.deltaX = deltaX, moveEvent.deltaY = deltaY, \n                moveEvent.points = points, this.triggerStartEvent(eventType, moveEvent), void this.triggerEvent(eventType, moveEvent);\n            }\n            const {startDistance: startDistance} = this, currentDistance = calcDistance(points[0], points[1]);\n            moveEvent.scale = currentDistance / startDistance, moveEvent.center = this.center, \n            moveEvent.points = points, this.triggerStartEvent(\"pinch\", moveEvent), this.triggerEvent(\"pinch\", moveEvent);\n        }, this.onEnd = ev => {\n            const endEvent = ev.clone(), {cachedEvents: cachedEvents, startPoints: startPoints} = this, points = cachedEvents.map((ev => ({\n                x: ev.x,\n                y: ev.y\n            })));\n            if (endEvent.points = points, this.triggerEndEvent(endEvent), 1 === cachedEvents.length) {\n                const now = util_1.clock.now(), lastMoveTime = this.lastMoveTime;\n                if (now - lastMoveTime < 100) {\n                    const intervalTime = lastMoveTime - (this.prevMoveTime || this.startTime);\n                    if (intervalTime > 0) {\n                        const prevMovePoint = this.prevMovePoint || startPoints[0], lastMovePoint = this.lastMovePoint || startPoints[0], distance = calcDistance(prevMovePoint, lastMovePoint), velocity = distance / intervalTime;\n                        velocity > this.config.swipe.velocity && distance > this.config.swipe.threshold && (endEvent.velocity = velocity, \n                        endEvent.direction = calcDirection(prevMovePoint, lastMovePoint), this.triggerEvent(\"swipe\", endEvent));\n                    }\n                }\n            }\n            for (let i = 0, len = cachedEvents.length; i < len; i++) if (cachedEvents[i].pointerId === endEvent.pointerId) {\n                cachedEvents.splice(i, 1), startPoints.splice(i, 1);\n                break;\n            }\n            this.reset(), cachedEvents.length > 0 && this.onStart();\n        }, this.element = element, this.config = {\n            press: {\n                time: null !== (_b = null === (_a = null == config ? void 0 : config.press) || void 0 === _a ? void 0 : _a.time) && void 0 !== _b ? _b : 251,\n                threshold: null !== (_d = null === (_c = null == config ? void 0 : config.press) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 9\n            },\n            swipe: {\n                threshold: null !== (_f = null === (_e = null == config ? void 0 : config.swipe) || void 0 === _e ? void 0 : _e.threshold) && void 0 !== _f ? _f : 10,\n                velocity: null !== (_h = null === (_g = null == config ? void 0 : config.swipe) || void 0 === _g ? void 0 : _g.velocity) && void 0 !== _h ? _h : .3\n            }\n        }, this.initEvents();\n    }\n    initEvents() {\n        const {element: element} = this;\n        element && (element.addEventListener(\"pointerdown\", this.onStart), element.addEventListener(\"pointermove\", this.onMove), \n        element.addEventListener(\"pointerup\", this.onEnd), element.addEventListener(\"pointerupoutside\", this.onEnd));\n    }\n    removeEvents() {\n        const {element: element} = this;\n        element && (element.removeEventListener(\"pointerdown\", this.onStart), element.removeEventListener(\"pointermove\", this.onMove), \n        element.removeEventListener(\"pointerup\", this.onEnd), element.removeEventListener(\"pointerupoutside\", this.onEnd));\n    }\n    release() {\n        this.removeEvents(), this.element = null;\n    }\n    getEventType(point) {\n        const {eventType: eventType, startTime: startTime, startPoints: startPoints} = this;\n        if (eventType) return eventType;\n        let type;\n        return type = util_1.clock.now() - startTime > this.config.press.time && calcDistance(startPoints[0], point) < this.config.press.threshold ? \"press\" : \"pan\", \n        this.eventType = type, type;\n    }\n    enable(eventType) {\n        this.processEvent[eventType] = !0;\n    }\n    isProcess(eventType) {\n        return this.processEvent[eventType];\n    }\n    pushEvent(type, ev) {\n        const {emitThrottles: emitThrottles} = this, newEvent = {\n            type: type,\n            ev: ev\n        };\n        for (let i = 0, len = emitThrottles.length; i < len; i++) if (emitThrottles[i].type === type) return void emitThrottles.splice(i, 1, newEvent);\n        emitThrottles.push(newEvent);\n    }\n    clearPressTimeout() {\n        this.pressTimeout && (clearTimeout(this.pressTimeout), this.pressTimeout = null);\n    }\n    reset() {\n        this.clearPressTimeout(), this.startTime = 0, this.startDistance = 0, this.direction = null, \n        this.eventType = null, this.prevMoveTime = 0, this.prevMovePoint = null, this.lastMoveTime = 0, \n        this.lastMovePoint = null;\n    }\n    triggerEvent(type, ev) {\n        this.pushEvent(type, ev);\n        const {throttleTimer: throttleTimer, emitThrottles: emitThrottles} = this;\n        throttleTimer || (this.throttleTimer = application_1.application.global.getRequestAnimationFrame()((() => {\n            for (let i = 0, len = emitThrottles.length; i < len; i++) {\n                const {type: type, ev: ev} = emitThrottles[i];\n                this.emitEvent(type, ev);\n            }\n            this.throttleTimer = 0, this.emitThrottles.length = 0;\n        })));\n    }\n    triggerStartEvent(type, ev) {\n        this.isProcess(type) || (this.enable(type), this.triggerEvent(`${type}start`, ev));\n    }\n    triggerEndEvent(ev) {\n        const processEvent = this.processEvent;\n        Object.keys(processEvent).forEach((type => {\n            this.triggerEvent(`${type}end`, ev), \"press\" === type && this.triggerEvent(`${type}up`, ev), \n            delete processEvent[type];\n        }));\n    }\n    emitEvent(type, e) {\n        const listeners = this.element._events[constant_1.WILDCARD];\n        if (listeners) if (\"fn\" in listeners) listeners.fn.call(listeners.context, e, type); else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);\n        this.emit(type, e);\n    }\n}\n\nexports.Gesture = Gesture;\n//# sourceMappingURL=gesture.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=event.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./Ticker\"), exports), __exportStar(require(\"./animate\"), exports), \n__exportStar(require(\"./config\"), exports), __exportStar(require(\"./custom-animate\"), exports), \n__exportStar(require(\"./morphing\"), exports), __exportStar(require(\"./timeline\"), exports);\n//# sourceMappingURL=index.js.map","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./default-ticker\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.ManualTicker = exports.DefaultTicker = exports.RAFTickHandler = exports.TimeOutTickHandler = exports.ManualTickHandler = void 0;\n\nconst application_1 = require(\"../../application\");\n\nclass ManualTickHandler {\n    constructor() {\n        this.time = 0;\n    }\n    static Avaliable() {\n        return !0;\n    }\n    avaliable() {\n        return ManualTickHandler.Avaliable();\n    }\n    tick(interval, cb) {\n        this.time = Math.max(0, interval + this.time), cb(this, {\n            once: !0\n        });\n    }\n    tickTo(t, cb) {\n        this.time = Math.max(0, t), cb(this, {\n            once: !0\n        });\n    }\n    release() {\n        this.timerId > 0 && (this.timerId = -1);\n    }\n    getTime() {\n        return this.time;\n    }\n}\n\nexports.ManualTickHandler = ManualTickHandler;\n\nclass TimeOutTickHandler {\n    static Avaliable() {\n        return !0;\n    }\n    avaliable() {\n        return TimeOutTickHandler.Avaliable();\n    }\n    tick(interval, cb) {\n        this.timerId = setTimeout((() => {\n            cb(this);\n        }), interval);\n    }\n    release() {\n        this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);\n    }\n    getTime() {\n        return Date.now();\n    }\n}\n\nexports.TimeOutTickHandler = TimeOutTickHandler;\n\nclass RAFTickHandler {\n    static Avaliable() {\n        return !!application_1.application.global.getRequestAnimationFrame();\n    }\n    avaliable() {\n        return RAFTickHandler.Avaliable();\n    }\n    tick(interval, cb) {\n        application_1.application.global.getRequestAnimationFrame()((() => {\n            this.released || cb(this);\n        }));\n    }\n    release() {\n        this.released = !0;\n    }\n    getTime() {\n        return Date.now();\n    }\n}\n\nvar STATUS;\n\nexports.RAFTickHandler = RAFTickHandler, function(STATUS) {\n    STATUS[STATUS.INITIAL = 0] = \"INITIAL\", STATUS[STATUS.RUNNING = 1] = \"RUNNING\", \n    STATUS[STATUS.PAUSE = 2] = \"PAUSE\";\n}(STATUS || (STATUS = {}));\n\nclass DefaultTicker {\n    set mode(m) {\n        this._mode !== m && (this._mode = m, this.setupTickHandler());\n    }\n    get mode() {\n        return this._mode;\n    }\n    constructor(timelines = []) {\n        this.handleTick = (handler, params) => {\n            const {once: once = !1} = null != params ? params : {};\n            this.ifCanStop() ? this.stop() : (this._handlerTick(handler), once || handler.tick(this.interval, this.handleTick));\n        }, this._handlerTick = handler => {\n            const time = this.tickerHandler.getTime();\n            let delta = 0;\n            this.lastFrameTime >= 0 && (delta = time - this.lastFrameTime), this.lastFrameTime = time, \n            this.status === STATUS.RUNNING && (this.tickCounts++, this.timelines.forEach((t => {\n                t.tick(delta);\n            })));\n        }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, \n        this.autoStop = !0;\n    }\n    init() {\n        this.interval = NaN, this.status = STATUS.INITIAL, application_1.application.global.hooks.onSetEnv.tap(\"window\", (() => {\n            this.initHandler();\n        })), application_1.application.global.env && this.initHandler();\n    }\n    addTimeline(timeline) {\n        this.timelines.push(timeline);\n    }\n    remTimeline(timeline) {\n        this.timelines = this.timelines.filter((t => t !== timeline));\n    }\n    initHandler() {\n        if (this._mode) return null;\n        const ticks = [ {\n            mode: \"raf\",\n            cons: RAFTickHandler\n        }, {\n            mode: \"timeout\",\n            cons: TimeOutTickHandler\n        }, {\n            mode: \"manual\",\n            cons: ManualTickHandler\n        } ];\n        for (let i = 0; i < ticks.length; i++) if (ticks[i].cons.Avaliable()) {\n            this.mode = ticks[i].mode;\n            break;\n        }\n        return null;\n    }\n    setupTickHandler() {\n        let handler;\n        switch (this._mode) {\n          case \"raf\":\n            handler = new RAFTickHandler;\n            break;\n\n          case \"timeout\":\n            handler = new TimeOutTickHandler;\n            break;\n\n          case \"manual\":\n            handler = new ManualTickHandler;\n            break;\n\n          default:\n            console.warn(\"\"), handler = new RAFTickHandler;\n        }\n        return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), \n        this.tickerHandler = handler, !0);\n    }\n    setInterval(interval) {\n        this.interval = interval;\n    }\n    getInterval() {\n        return this.interval;\n    }\n    setFPS(fps) {\n        this.setInterval(1e3 / fps);\n    }\n    getFPS() {\n        return 1e3 / this.interval;\n    }\n    tick(interval) {\n        this.tickerHandler.tick(interval, (handler => {\n            this.handleTick(handler, {\n                once: !0\n            });\n        }));\n    }\n    tickTo(t) {\n        this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, (handler => {\n            this.handleTick(handler, {\n                once: !0\n            });\n        }));\n    }\n    pause() {\n        return this.status !== STATUS.INITIAL && (this.status = STATUS.PAUSE, !0);\n    }\n    resume() {\n        return this.status !== STATUS.INITIAL && (this.status = STATUS.RUNNING, !0);\n    }\n    ifCanStop() {\n        if (this.autoStop) {\n            if (!this.timelines.length) return !0;\n            if (0 === this.timelines.reduce(((a, b) => a + b.animateCount), 0)) return !0;\n        }\n        return !1;\n    }\n    start(force = !1) {\n        if (this.status === STATUS.RUNNING) return !1;\n        if (!this.tickerHandler) return !1;\n        if (!force) {\n            if (this.status === STATUS.PAUSE) return !1;\n            if (!this.timelines.length) return !1;\n            if (0 === this.timelines.reduce(((a, b) => a + b.animateCount), 0)) return !1;\n        }\n        return this.status = STATUS.RUNNING, this.tickerHandler.tick(0, this.handleTick), \n        !0;\n    }\n    stop() {\n        this.status = STATUS.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;\n    }\n}\n\nexports.DefaultTicker = DefaultTicker;\n\nclass ManualTicker extends DefaultTicker {\n    set mode(m) {\n        this.setupTickHandler();\n    }\n    get mode() {\n        return this._mode;\n    }\n    initHandler() {\n        return this.mode = \"manual\", null;\n    }\n    setupTickHandler() {\n        const handler = new ManualTickHandler;\n        return this._mode = \"manual\", this.tickerHandler && this.tickerHandler.release(), \n        this.tickerHandler = handler, !0;\n    }\n    tickAt(time) {\n        this.tickerHandler.tick(time - this.lastFrameTime, (handler => {\n            this.handleTick(handler, {\n                once: !0\n            });\n        }));\n    }\n    ifCanStop() {\n        return !1;\n    }\n}\n\nexports.ManualTicker = ManualTicker;\n//# sourceMappingURL=default-ticker.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.SubAnimate = exports.Animate = exports.CbAnimate = exports.ACustomAnimate = void 0;\n\nconst enums_1 = require(\"../common/enums\"), easing_1 = require(\"./easing\"), vutils_1 = require(\"@visactor/vutils\"), timeline_1 = require(\"./timeline\"), generator_1 = require(\"../common/generator\");\n\nclass ACustomAnimate {\n    constructor(from, to, duration, easing, params) {\n        this.from = from, this.to = to, this.duration = duration, this.easing = easing, \n        this.params = params, this.updateCount = 0;\n    }\n    bind(target, subAni) {\n        this.target = target, this.subAnimate = subAni, this.onBind();\n    }\n    onBind() {}\n    onFirstRun() {}\n    onStart() {}\n    onEnd() {}\n    getEndProps() {}\n    getFromProps() {\n        return this.from;\n    }\n    getMergedEndProps() {\n        var _a;\n        const thisEndProps = this.getEndProps();\n        return thisEndProps ? this._endProps === thisEndProps ? this._mergedEndProps : (this._endProps = thisEndProps, \n        void (this._mergedEndProps = Object.assign({}, null !== (_a = this.step.prev.getLastProps()) && void 0 !== _a ? _a : {}, thisEndProps))) : this.step.prev ? this.step.prev.getLastProps() : thisEndProps;\n    }\n    update(end, ratio, out) {\n        0 === this.updateCount && this.onFirstRun(), this.updateCount += 1, Object.assign(out, this.step.getLastProps()), \n        this.onUpdate(end, ratio, out), end && this.onEnd();\n    }\n}\n\nexports.ACustomAnimate = ACustomAnimate;\n\nclass CbAnimate extends ACustomAnimate {\n    constructor(cb) {\n        super(null, null, 0, \"linear\"), this.cb = cb;\n    }\n    onUpdate(end, ratio, out) {}\n    onStart() {\n        this.cb();\n    }\n}\n\nexports.CbAnimate = CbAnimate;\n\nclass Animate {\n    constructor(id = generator_1.Generator.GenAutoIncrementId(), timeline = timeline_1.defaultTimeline) {\n        this.id = id, this.timeline = timeline, this.status = enums_1.AnimateStatus.INITIAL, \n        this.tailAnimate = new SubAnimate(this), this.subAnimates = [ this.tailAnimate ], \n        this.timeScale = 1, this.rawPosition = -1, this._startTime = 0, this._duringTime = 0, \n        this.timeline.addAnimate(this);\n    }\n    getStartTime() {\n        return this._startTime;\n    }\n    getDuration() {\n        return this.subAnimates.reduce(((t, subAnimate) => t + subAnimate.totalDuration), 0);\n    }\n    after(animate) {\n        const t = animate.getDuration();\n        return this._startTime = t, this;\n    }\n    afterAll(list) {\n        let maxT = -1 / 0;\n        return list.forEach((a => {\n            maxT = (0, vutils_1.max)(a.getDuration(), maxT);\n        })), this._startTime = maxT, this;\n    }\n    parallel(animate) {\n        return this._startTime = animate.getStartTime(), this;\n    }\n    static AddInterpolate(name, cb) {\n        Animate.interpolateMap.set(name, cb);\n    }\n    play(customAnimate) {\n        if (this.tailAnimate.play(customAnimate), this.target) {\n            const stage = this.target.stage;\n            stage && stage.renderNextFrame();\n        }\n        return 1 === this.subAnimates.length && this.tailAnimate.duration === customAnimate.duration && this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode), \n        this;\n    }\n    trySetAttribute(attr, mode = Animate.mode) {\n        attr && mode & enums_1.AnimateMode.SET_ATTR_IMMEDIATELY && this.target.setAttributes && this.target.setAttributes(attr, !1, {\n            type: enums_1.AttributeUpdateType.ANIMATE_PLAY\n        });\n    }\n    runCb(cb) {\n        const customAnimate = new CbAnimate((() => {\n            cb(this, customAnimate.step.prev);\n        }));\n        return this.tailAnimate.play(customAnimate), this;\n    }\n    customInterpolate(key, ratio, from, to, target, ret) {\n        const func = Animate.interpolateMap.get(key) || Animate.interpolateMap.get(\"\");\n        return !!func && func(key, ratio, from, to, target, ret);\n    }\n    pause() {\n        this.status === enums_1.AnimateStatus.RUNNING && (this.status = enums_1.AnimateStatus.PAUSED);\n    }\n    resume() {\n        this.status === enums_1.AnimateStatus.PAUSED && (this.status = enums_1.AnimateStatus.RUNNING);\n    }\n    to(props, duration, easing, params) {\n        if (this.tailAnimate.to(props, duration, easing, params), this.target) {\n            const stage = this.target.stage;\n            stage && stage.renderNextFrame();\n        }\n        return this;\n    }\n    from(props, duration, easing, params) {\n        if (this.tailAnimate.from(props, duration, easing, params), this.target) {\n            const stage = this.target.stage;\n            stage && stage.renderNextFrame();\n        }\n        return this;\n    }\n    wait(duration) {\n        if (this.tailAnimate.wait(duration), this.target) {\n            const stage = this.target.stage;\n            stage && stage.renderNextFrame();\n        }\n        return this;\n    }\n    startAt(t) {\n        if (this.tailAnimate.startAt(t), this.target) {\n            const stage = this.target.stage;\n            stage && stage.renderNextFrame();\n        }\n        return this;\n    }\n    loop(l) {\n        if (this.tailAnimate.loop = l, this.target) {\n            const stage = this.target.stage;\n            stage && stage.renderNextFrame();\n        }\n        return this;\n    }\n    reversed(r) {\n        if (this.tailAnimate.reversed = r, this.target) {\n            const stage = this.target.stage;\n            stage && stage.renderNextFrame();\n        }\n        return this;\n    }\n    bounce(b) {\n        if (this.tailAnimate.bounce = b, this.target) {\n            const stage = this.target.stage;\n            stage && stage.renderNextFrame();\n        }\n        return this;\n    }\n    subAnimate() {\n        const sa = new SubAnimate(this, this.tailAnimate);\n        return this.tailAnimate = sa, this.subAnimates.push(sa), sa.bind(this.target), this;\n    }\n    getStartProps() {\n        return this.subAnimates[0].getStartProps();\n    }\n    getEndProps() {\n        return this.tailAnimate.getEndProps();\n    }\n    depreventAttr(key) {\n        this._preventAttrs && this._preventAttrs.delete(key);\n    }\n    preventAttr(key) {\n        this._preventAttrs || (this._preventAttrs = new Set), this._preventAttrs.add(key);\n    }\n    preventAttrs(keys) {\n        keys.forEach((key => this.preventAttr(key)));\n    }\n    validAttr(key) {\n        return !this._preventAttrs || !this._preventAttrs.has(key);\n    }\n    bind(target) {\n        return this.target = target, this.target.onAnimateBind && this.target.onAnimateBind(this), \n        this.subAnimates.forEach((sa => {\n            sa.bind(target);\n        })), this;\n    }\n    advance(delta) {\n        if (this._duringTime < this._startTime) {\n            if (this._duringTime + delta * this.timeScale < this._startTime) return void (this._duringTime += delta * this.timeScale);\n            delta = this._duringTime + delta * this.timeScale - this._startTime, this._duringTime = this._startTime;\n        }\n        this.status === enums_1.AnimateStatus.INITIAL && (this.status = enums_1.AnimateStatus.RUNNING, \n        this._onStart && this._onStart.forEach((cb => cb())));\n        this.setPosition(this.rawPosition + delta * this.timeScale) && this.status === enums_1.AnimateStatus.RUNNING && (this.status = enums_1.AnimateStatus.END, \n        this._onEnd && this._onEnd.forEach((cb => cb())));\n    }\n    setPosition(rawPosition) {\n        let sa, d = 0;\n        const prevRawPos = this.rawPosition, maxRawPos = this.subAnimates.reduce(((a, b) => a + b.totalDuration), 0);\n        rawPosition < 0 && (rawPosition = 0);\n        const end = rawPosition >= maxRawPos;\n        if (end && (rawPosition = maxRawPos), rawPosition === prevRawPos) return end;\n        for (let i = 0; i < this.subAnimates.length && (sa = this.subAnimates[i], !(d + sa.totalDuration >= rawPosition)); i++) d += sa.totalDuration, \n        sa = void 0;\n        return this.rawPosition = rawPosition, sa.setPosition(rawPosition - d), end;\n    }\n    onStart(cb) {\n        this._onStart || (this._onStart = []), this._onStart.push(cb);\n    }\n    onEnd(cb) {\n        this._onEnd || (this._onEnd = []), this._onEnd.push(cb);\n    }\n    onRemove(cb) {\n        this._onRemove || (this._onRemove = []), this._onRemove.push(cb);\n    }\n    onFrame(cb) {\n        this._onFrame || (this._onFrame = []), this._onFrame.push(cb);\n    }\n    release() {\n        this.status = enums_1.AnimateStatus.END;\n    }\n    stop(nextVal) {\n        nextVal || this.target.onStop(), \"start\" === nextVal ? this.target.onStop(this.getStartProps()) : \"end\" === nextVal ? this.target.onStop(this.getEndProps()) : this.target.onStop(nextVal), \n        this.release();\n    }\n}\n\nexports.Animate = Animate, Animate.mode = enums_1.AnimateMode.NORMAL, Animate.interpolateMap = new Map;\n\nclass SubAnimate {\n    get totalDuration() {\n        return this.calcAttr(), this._totalDuration + this._startAt;\n    }\n    constructor(animate, lastSubAnimate) {\n        this.rawPosition = -1, this.position = 0, this.loop = 0, this.duration = 0, this.animate = animate, \n        this.stepHead = new Step(0, 0, lastSubAnimate ? Object.assign({}, lastSubAnimate.stepTail.props) : {}), \n        this.stepTail = this.stepHead, this.dirty = !0, this._startAt = 0;\n    }\n    calcAttr() {\n        this.dirty && (this._totalDuration = this.duration * (this.loop + 1));\n    }\n    bind(target) {\n        return this.target = target, this;\n    }\n    play(customAnimate) {\n        let duration = customAnimate.duration;\n        (null == duration || duration < 0) && (duration = 0);\n        const easing = customAnimate.easing, easingFunc = \"string\" == typeof easing ? easing_1.Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);\n        return step.type = enums_1.AnimateStepType.customAnimate, this._appendProps(customAnimate.getEndProps(), step, !1), \n        this._appendCustomAnimate(customAnimate, step), this;\n    }\n    to(props, duration, easing, params) {\n        (null == duration || duration < 0) && (duration = 0);\n        const easingFunc = \"string\" == typeof easing ? easing_1.Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);\n        return step.type = enums_1.AnimateStepType.to, this._appendProps(props, step, !!params && params.tempProps), \n        step.propKeys || (step.propKeys = Object.keys(step.props)), params && params.noPreventAttrs || this.target.animates.forEach((a => {\n            a.id !== this.animate.id && a.preventAttrs(step.propKeys);\n        })), this;\n    }\n    from(props, duration, easing, params) {\n        this.to(props, 0, easing, params);\n        const toProps = {};\n        this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)), \n        this.stepTail.propKeys.forEach((k => {\n            toProps[k] = this.getLastPropByName(k, this.stepTail);\n        })), this.to(toProps, duration, easing, params), this.stepTail.type = enums_1.AnimateStepType.from;\n    }\n    startAt(t) {\n        return t < 0 && (t = 0), this._startAt = t, this;\n    }\n    getStartProps() {\n        var _a;\n        return null === (_a = this.stepHead) || void 0 === _a ? void 0 : _a.props;\n    }\n    getEndProps() {\n        return this.stepTail.props;\n    }\n    getLastStep() {\n        return this._lastStep;\n    }\n    wait(duration) {\n        if (duration > 0) {\n            const step = this._addStep(+duration, null);\n            step.type = enums_1.AnimateStepType.wait, step.prev.customAnimate ? step.props = step.prev.customAnimate.getEndProps() : step.props = step.prev.props, \n            this.target.onAddStep && this.target.onAddStep(step);\n        }\n        return this;\n    }\n    _addStep(duration, props, easingFunc) {\n        const step = new Step(this.duration, duration, props, easingFunc);\n        return this.duration += duration, this.stepTail.append(step), this.stepTail = step, \n        step;\n    }\n    _appendProps(props, step, tempProps) {\n        step.props = tempProps ? props : Object.assign({}, props);\n        let lastStep = step.prev;\n        const _props = step.props;\n        for (step.propKeys || (step.propKeys = Object.keys(step.props)), step.propKeys.forEach((k => {\n            void 0 === step.props[k] && (step.props[k] = this.target.getDefaultAttribute(k));\n        })); lastStep.prev; ) lastStep.props && (lastStep.propKeys || (lastStep.propKeys = Object.keys(lastStep.props)), \n        lastStep.propKeys.forEach((key => {\n            void 0 === _props[key] && (_props[key] = lastStep.props[key]);\n        }))), lastStep = lastStep.prev;\n        const initProps = this.stepHead.props;\n        step.propKeys || (step.propKeys = Object.keys(_props)), step.propKeys.forEach((key => {\n            if (void 0 === initProps[key]) {\n                const parentAnimateInitProps = this.animate.getStartProps();\n                initProps[key] = parentAnimateInitProps[key] = this.target.getComputedAttribute(key);\n            }\n        })), this.target.onAddStep && this.target.onAddStep(step);\n    }\n    _appendCustomAnimate(customAnimate, step) {\n        step.customAnimate = customAnimate, customAnimate.step = step, customAnimate.bind(this.target, this);\n    }\n    setPosition(rawPosition) {\n        var _a;\n        const d = this.duration, loopCount = this.loop, prevRawPos = this.rawPosition;\n        let loop, position, end = !1;\n        const startAt = null !== (_a = this._startAt) && void 0 !== _a ? _a : 0;\n        if (rawPosition < 0 && (rawPosition = 0), rawPosition < startAt) return this.rawPosition = rawPosition, \n        !1;\n        if (rawPosition -= startAt, d <= 0) return end = !0, end;\n        if (loop = Math.floor(rawPosition / d), position = rawPosition - loop * d, end = rawPosition >= loopCount * d + d, \n        end && (position = d, loop = loopCount, rawPosition = position * loop + d), rawPosition === prevRawPos) return end;\n        const rev = !this.reversed != !(this.bounce && loop % 2);\n        return rev && (position = d - position), this._deltaPosition = position - this.position, \n        this.position = position, this.rawPosition = rawPosition + startAt, this.updatePosition(end, rev), \n        end;\n    }\n    updatePosition(end, rev) {\n        if (!this.stepHead) return;\n        let step = this.stepHead.next;\n        const position = this.position, duration = this.duration;\n        if (this.target && step) {\n            let stepNext = step.next;\n            for (;stepNext && stepNext.position <= position; ) step = stepNext, stepNext = step.next;\n            let ratio = end ? 0 === duration ? 1 : position / duration : (position - step.position) / step.duration;\n            step.easing && (ratio = step.easing(ratio)), this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev), \n            this.updateTarget(step, ratio, end), this._lastStep = step, this.animate._onFrame && this.animate._onFrame.forEach((cb => cb(step, ratio)));\n        }\n    }\n    tryCallCustomAnimateLifeCycle(step, lastStep, rev) {\n        if (step !== lastStep) if (rev) {\n            let _step = lastStep.prev;\n            for (;_step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), \n            _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = step.prev;\n            lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), \n            step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();\n        } else {\n            let _step = lastStep.next;\n            for (;_step && _step !== step; ) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), \n            _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = _step.next;\n            lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), \n            step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();\n        }\n    }\n    getLastPropByName(name, step) {\n        let lastStep = step.prev;\n        for (;lastStep; ) {\n            if (lastStep.props && void 0 !== lastStep.props[name]) return lastStep.props[name];\n            if (lastStep.customAnimate) {\n                const val = lastStep.customAnimate.getEndProps()[name];\n                if (void 0 !== val) return val;\n            }\n            lastStep = lastStep.prev;\n        }\n        return console.warn(\"step\"), step.props[name];\n    }\n    updateTarget(step, ratio, end) {\n        null == step.props && null == step.customAnimate || this.target.onStep(this, this.animate, step, ratio, end);\n    }\n}\n\nexports.SubAnimate = SubAnimate;\n\nclass Step {\n    constructor(position, duration, props, easing) {\n        this.duration = duration, this.position = position, this.props = props, this.easing = easing;\n    }\n    append(step) {\n        step.prev = this, step.next = this.next, this.next = step;\n    }\n    getLastProps() {\n        let step = this.prev;\n        for (;step; ) {\n            if (step.props) return step.props;\n            if (step.customAnimate) return step.customAnimate.getMergedEndProps();\n            step = step.prev;\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=animate.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Easing = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nclass Easing {\n    constructor() {}\n    static linear(t) {\n        return t;\n    }\n    static none() {\n        return this.linear;\n    }\n    static get(amount) {\n        return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function(t) {\n            return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));\n        };\n    }\n    static getPowIn(pow) {\n        return function(t) {\n            return Math.pow(t, pow);\n        };\n    }\n    static getPowOut(pow) {\n        return function(t) {\n            return 1 - Math.pow(1 - t, pow);\n        };\n    }\n    static getPowInOut(pow) {\n        return function(t) {\n            return (t *= 2) < 1 ? .5 * Math.pow(t, pow) : 1 - .5 * Math.abs(Math.pow(2 - t, pow));\n        };\n    }\n    static getBackIn(amount) {\n        return function(t) {\n            return t * t * ((amount + 1) * t - amount);\n        };\n    }\n    static getBackOut(amount) {\n        return function(t) {\n            return --t * t * ((amount + 1) * t + amount) + 1;\n        };\n    }\n    static getBackInOut(amount) {\n        return amount *= 1.525, function(t) {\n            return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * .5 : .5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);\n        };\n    }\n    static sineIn(t) {\n        return 1 - Math.cos(t * Math.PI / 2);\n    }\n    static sineOut(t) {\n        return Math.sin(t * Math.PI / 2);\n    }\n    static sineInOut(t) {\n        return -(Math.cos(Math.PI * t) - 1) / 2;\n    }\n    static expoIn(t) {\n        return 0 === t ? 0 : Math.pow(2, 10 * t - 10);\n    }\n    static expoOut(t) {\n        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);\n    }\n    static expoInOut(t) {\n        return 0 === t ? 0 : 1 === t ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;\n    }\n    static circIn(t) {\n        return -(Math.sqrt(1 - t * t) - 1);\n    }\n    static circOut(t) {\n        return Math.sqrt(1 - --t * t);\n    }\n    static circInOut(t) {\n        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n    }\n    static bounceOut(t) {\n        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n    }\n    static bounceIn(t) {\n        return 1 - Easing.bounceOut(1 - t);\n    }\n    static bounceInOut(t) {\n        return t < .5 ? .5 * Easing.bounceIn(2 * t) : .5 * Easing.bounceOut(2 * t - 1) + .5;\n    }\n    static getElasticIn(amplitude, period) {\n        return function(t) {\n            if (0 === t || 1 === t) return t;\n            const s = period / vutils_1.pi2 * Math.asin(1 / amplitude);\n            return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * vutils_1.pi2 / period);\n        };\n    }\n    static getElasticOut(amplitude, period) {\n        return function(t) {\n            if (0 === t || 1 === t) return t;\n            const s = period / vutils_1.pi2 * Math.asin(1 / amplitude);\n            return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * vutils_1.pi2 / period) + 1;\n        };\n    }\n    static getElasticInOut(amplitude, period) {\n        return function(t) {\n            const s = period / vutils_1.pi2 * Math.asin(1 / amplitude);\n            return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * vutils_1.pi2 / period) * -.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * vutils_1.pi2 / period) * .5 + 1;\n        };\n    }\n}\n\nexports.Easing = Easing, Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), \nEasing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), \nEasing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), \nEasing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), \nEasing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), \nEasing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), \nEasing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, .3), \nEasing.elasticOut = Easing.getElasticOut(1, .3), Easing.elasticInOut = Easing.getElasticInOut(1, .3 * 1.5);\n//# sourceMappingURL=easing.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.defaultTimeline = exports.DefaultTimeline = void 0;\n\nconst enums_1 = require(\"../common/enums\"), generator_1 = require(\"../common/generator\");\n\nclass DefaultTimeline {\n    constructor() {\n        this.id = generator_1.Generator.GenAutoIncrementId(), this.animateHead = null, this.animateTail = null, \n        this.animateCount = 0, this.paused = !1;\n    }\n    addAnimate(animate) {\n        this.animateTail ? (this.animateTail.nextAnimate = animate, animate.prevAnimate = this.animateTail, \n        this.animateTail = animate, animate.nextAnimate = null) : (this.animateHead = animate, \n        this.animateTail = animate), this.animateCount++;\n    }\n    pause() {\n        this.paused = !0;\n    }\n    resume() {\n        this.paused = !1;\n    }\n    tick(delta) {\n        if (this.paused) return;\n        let animate = this.animateHead;\n        for (this.animateCount = 0; animate; ) animate.status === enums_1.AnimateStatus.END ? this.removeAnimate(animate) : animate.status === enums_1.AnimateStatus.RUNNING || animate.status === enums_1.AnimateStatus.INITIAL ? (this.animateCount++, \n        animate.advance(delta)) : animate.status === enums_1.AnimateStatus.PAUSED && this.animateCount++, \n        animate = animate.nextAnimate;\n    }\n    clear() {\n        let animate = this.animateHead;\n        for (;animate; ) animate.release(), animate = animate.nextAnimate;\n        this.animateHead = null, this.animateTail = null, this.animateCount = 0;\n    }\n    removeAnimate(animate) {\n        animate._onRemove && animate._onRemove.forEach((cb => cb())), animate === this.animateHead ? (this.animateHead = animate.nextAnimate, \n        animate === this.animateTail ? this.animateTail = null : this.animateHead.prevAnimate = null) : animate === this.animateTail ? (this.animateTail = animate.prevAnimate, \n        this.animateTail.nextAnimate = null) : (animate.prevAnimate.nextAnimate = animate.nextAnimate, \n        animate.nextAnimate.prevAnimate = animate.prevAnimate), animate.release();\n    }\n}\n\nexports.DefaultTimeline = DefaultTimeline, exports.defaultTimeline = new DefaultTimeline;\n//# sourceMappingURL=timeline.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMorphingAnimateConfig = exports.DefaultStateAnimateConfig = void 0, \nexports.DefaultStateAnimateConfig = {\n    duration: 200,\n    easing: \"cubicOut\"\n}, exports.DefaultMorphingAnimateConfig = {\n    duration: 1e3,\n    easing: \"quadInOut\"\n};\n//# sourceMappingURL=config.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.AnimateGroup1 = exports.AnimateGroup = exports.AttributeAnimate = exports.GroupFadeOut = exports.GroupFadeIn = exports.RotateBySphereAnimate = exports.ClipDirectionAnimate = exports.ClipRadiusAnimate = exports.ClipAngleAnimate = exports.ClipGraphicAnimate = exports.GraphicAnimate = exports.TagPointsUpdate = exports.MotionPath = exports.Meteor = exports.StreamLight = exports.InputText = exports.FadeInPlus = exports.IncreaseCount = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), application_1 = require(\"../application\"), enums_1 = require(\"../common/enums\"), animate_1 = require(\"./animate\"), easing_1 = require(\"./easing\"), utils_1 = require(\"../common/utils\");\n\nclass IncreaseCount extends animate_1.ACustomAnimate {\n    constructor(from, to, duration, easing, params) {\n        super(from, to, duration, easing, params);\n    }\n    getEndProps() {\n        return !1 === this.valid ? {} : {\n            text: this.to\n        };\n    }\n    onBind() {\n        var _a, _b, _c, _d, _e, _f;\n        this.fromNumber = (0, vutils_1.isNumber)(null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) ? null === (_b = this.from) || void 0 === _b ? void 0 : _b.text : Number.parseFloat(null === (_c = this.from) || void 0 === _c ? void 0 : _c.text), \n        this.toNumber = (0, vutils_1.isNumber)(null === (_d = this.to) || void 0 === _d ? void 0 : _d.text) ? null === (_e = this.to) || void 0 === _e ? void 0 : _e.text : Number.parseFloat(null === (_f = this.to) || void 0 === _f ? void 0 : _f.text), \n        Number.isFinite(this.toNumber) || (this.fromNumber = 0), Number.isFinite(this.toNumber) || (this.valid = !1);\n    }\n    onEnd() {}\n    onUpdate(end, ratio, out) {\n        var _a, _b;\n        !1 !== this.valid && (out.text = end ? this.toNumber.toFixed() : (this.fromNumber + (this.toNumber - this.fromNumber) * ratio).toFixed(null !== (_b = null === (_a = this.params) || void 0 === _a ? void 0 : _a.fixed) && void 0 !== _b ? _b : 0));\n    }\n}\n\nvar Direction;\n\nexports.IncreaseCount = IncreaseCount, function(Direction) {\n    Direction[Direction.LEFT_TO_RIGHT = 0] = \"LEFT_TO_RIGHT\", Direction[Direction.RIGHT_TO_LEFT = 1] = \"RIGHT_TO_LEFT\", \n    Direction[Direction.TOP_TO_BOTTOM = 2] = \"TOP_TO_BOTTOM\", Direction[Direction.BOTTOM_TO_TOP = 3] = \"BOTTOM_TO_TOP\", \n    Direction[Direction.STROKE = 4] = \"STROKE\";\n}(Direction || (Direction = {}));\n\nclass FadeInPlus extends animate_1.ACustomAnimate {\n    constructor(from, to, duration, easing, params) {\n        super(from, to, duration, easing, params);\n        const {direction: direction = Direction.LEFT_TO_RIGHT, fill: fill = !0, stroke: stroke = !0} = params || {};\n        this.direction = direction, this.fill = fill, this.stroke = stroke, this.fillGradient = {\n            gradient: \"linear\",\n            stops: []\n        }, this.strokeGradient = {\n            gradient: \"linear\",\n            stops: []\n        };\n    }\n    getEndProps() {\n        return {\n            fill: this.toFill,\n            stroke: this.toStroke\n        };\n    }\n    onBind() {\n        this.toFill = this.target.getComputedAttribute(\"fill\"), this.toStroke = this.target.getComputedAttribute(\"stroke\");\n    }\n    onEnd() {}\n    onUpdate(end, ratio, out) {\n        if (this.toFill && this.toStroke) switch (this.direction) {\n          case Direction.RIGHT_TO_LEFT:\n            this.rightToLeft(end, ratio, out);\n            break;\n\n          case Direction.TOP_TO_BOTTOM:\n            this.topToBottom(end, ratio, out);\n            break;\n\n          case Direction.BOTTOM_TO_TOP:\n            this.bottomToTop(end, ratio, out);\n            break;\n\n          case Direction.STROKE:\n            this.strokePath(end, ratio, out);\n            break;\n\n          default:\n            this.leftToRight(end, ratio, out);\n        }\n    }\n    leftToRight(end, ratio, out) {\n        if (this.fill) {\n            const toFillColor = this.toFill;\n            this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, \n            this.fillGradient.stops = [ {\n                offset: 0,\n                color: toFillColor\n            }, {\n                offset: ratio,\n                color: toFillColor\n            }, {\n                offset: Math.min(1, 2 * ratio),\n                color: \"transparent\"\n            } ], out.fill = this.fillGradient;\n        }\n        if (this.stroke) {\n            const toStrokeColor = this.toStroke;\n            this.strokeGradient.x0 = 0, this.strokeGradient.y0 = 0, this.strokeGradient.x1 = 1, \n            this.strokeGradient.y1 = 0, this.strokeGradient.stops = [ {\n                offset: 0,\n                color: toStrokeColor\n            }, {\n                offset: ratio,\n                color: toStrokeColor\n            }, {\n                offset: Math.min(1, 6 * ratio),\n                color: \"transparent\"\n            } ], out.stroke = this.strokeGradient;\n        }\n    }\n    strokePath(end, ratio, out) {\n        if (this.fill) {\n            const toFillColor = this.toFill;\n            this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, \n            this.fillGradient.stops = [ {\n                offset: 0,\n                color: toFillColor\n            }, {\n                offset: ratio,\n                color: toFillColor\n            }, {\n                offset: Math.min(1, 2 * ratio),\n                color: \"transparent\"\n            } ], out.fill = this.fillGradient;\n        }\n        if (this.stroke) {\n            const dashLen = 300, offset = ratio * dashLen;\n            out.lineDash = [ offset, dashLen - offset ];\n        }\n    }\n    rightToLeft(end, ratio, out) {}\n    topToBottom(end, ratio, out) {}\n    bottomToTop(end, ratio, out) {}\n}\n\nexports.FadeInPlus = FadeInPlus;\n\nclass InputText extends animate_1.ACustomAnimate {\n    constructor() {\n        super(...arguments), this.fromText = \"\", this.toText = \"\";\n    }\n    getEndProps() {\n        return !1 === this.valid ? {} : {\n            text: this.to\n        };\n    }\n    onBind() {\n        var _a, _b, _c, _d;\n        if (this.fromText = null !== (_b = null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) && void 0 !== _b ? _b : \"\", \n        this.toText = null !== (_d = null === (_c = this.to) || void 0 === _c ? void 0 : _c.text) && void 0 !== _d ? _d : \"\", \n        !this.toText || (0, vutils_1.isArray)(this.toText)) this.valid = !1; else {\n            this.toText = this.toText.toString();\n            const root = this.target.attachShadow(), line = application_1.application.graphicService.creator.line({\n                x: 0,\n                y: 0,\n                points: [ {\n                    x: 0,\n                    y: 0\n                }, {\n                    x: 0,\n                    y: this.target.getComputedAttribute(\"fontSize\")\n                } ],\n                stroke: \"black\",\n                lineWidth: 1\n            });\n            root.add(line);\n        }\n    }\n    onEnd() {\n        this.target.detachShadow();\n    }\n    onUpdate(end, ratio, out) {\n        var _a;\n        if (!1 === this.valid) return;\n        const fromCount = this.fromText.length, toCount = this.toText.length, count = Math.ceil(fromCount + (toCount - fromCount) * ratio);\n        out.text = this.toText.substr(0, count);\n        const line = null === (_a = this.target.shadowRoot) || void 0 === _a ? void 0 : _a.at(0), endX = this.target.clipedWidth + 2;\n        line.setAttribute(\"x\", endX);\n    }\n}\n\nexports.InputText = InputText;\n\nclass StreamLight extends animate_1.ACustomAnimate {\n    constructor(from, to, duration, easing, params) {\n        super(from, to, duration, easing, params);\n    }\n    getEndProps() {\n        return {};\n    }\n    onStart() {\n        var _a;\n        const root = this.target.attachShadow(), height = this.target.AABBBounds.height(), rect = application_1.application.graphicService.creator.rect(Object.assign(Object.assign({\n            height: height,\n            fill: \"#bcdeff\",\n            shadowBlur: 30,\n            shadowColor: \"#bcdeff\"\n        }, null === (_a = this.params) || void 0 === _a ? void 0 : _a.attribute), {\n            x: 0,\n            y: 0,\n            width: 0\n        }));\n        this.rect = rect, root.add(rect);\n    }\n    onBind() {}\n    onEnd() {\n        this.target.detachShadow();\n    }\n    onUpdate(end, ratio, out) {\n        var _a, _b, _c, _d, _e, _f;\n        const parentWidth = null !== (_a = this.target.attribute.width) && void 0 !== _a ? _a : 250, streamLength = null !== (_c = null === (_b = this.params) || void 0 === _b ? void 0 : _b.streamLength) && void 0 !== _c ? _c : parentWidth, maxLength = null !== (_f = null === (_e = null === (_d = this.params) || void 0 === _d ? void 0 : _d.attribute) || void 0 === _e ? void 0 : _e.width) && void 0 !== _f ? _f : 60, startX = -maxLength, currentX = startX + (streamLength - startX) * ratio, x = Math.max(currentX, 0), w = Math.min(Math.min(currentX + maxLength, maxLength), streamLength - currentX), width = w + x > parentWidth ? Math.max(parentWidth - x, 0) : w;\n        this.rect.setAttributes({\n            x: x,\n            width: width\n        }, !1, {\n            type: enums_1.AttributeUpdateType.ANIMATE_PLAY,\n            animationState: {\n                ratio: ratio,\n                end: end\n            }\n        });\n    }\n}\n\nexports.StreamLight = StreamLight;\n\nclass Meteor extends animate_1.ACustomAnimate {\n    get lastPos() {\n        return this.posList[this.posList.length - 1];\n    }\n    constructor(size, duration, easing, params) {\n        super(null, null, duration, easing, params), this.size = size, this.posList = [];\n    }\n    onBind() {\n        const root = this.target.attachShadow();\n        this.root = root;\n        for (let i = 0; i < this.size; i++) {\n            const g = this.target.clone(), scale = Math.min((this.size - i) / this.size * 3, 1), opacity = Math.min(.2 + .7 / this.size);\n            g.setAttributes({\n                x: 0,\n                y: 0,\n                dx: 0,\n                dy: 0,\n                scaleX: scale,\n                scaleY: scale,\n                opacity: opacity\n            }, !1, {\n                type: enums_1.AttributeUpdateType.ANIMATE_BIND\n            }), root.add(g);\n        }\n    }\n    onUpdate(end, ratio, out) {\n        if (end) return this.target.detachShadow(), void (this.posList.length = 0);\n        const x = this.target.getComputedAttribute(\"x\"), y = this.target.getComputedAttribute(\"y\"), nextPos = new vutils_1.Point(x, y);\n        this.posList.length ? (this.target.shadowRoot.forEachChildren(((g, i) => {\n            const pos = this.posList[Math.max(this.posList.length - i - 1, 0)];\n            g.setAttributes({\n                x: pos.x - x,\n                y: pos.y - y\n            }, !1);\n        })), this.posList.push(nextPos)) : this.posList.push(nextPos);\n    }\n}\n\nexports.Meteor = Meteor;\n\nclass MotionPath extends animate_1.ACustomAnimate {\n    constructor(from, to, duration, easing, params) {\n        var _a;\n        super(from, to, duration, easing, params), params && (this.pathLength = params.path.getLength(), \n        this.path = params.path, this.distance = params.distance, this.to = params.distance * this.pathLength, \n        this.initAngle = null !== (_a = params.initAngle) && void 0 !== _a ? _a : 0, this.changeAngle = !!params.changeAngle, \n        this.cb = params.cb);\n    }\n    onUpdate(end, ratio, out) {\n        const at = this.to * ratio, {pos: pos, angle: angle} = this.path.getAttrAt(at);\n        out.x = pos.x, out.y = pos.y, this.changeAngle && (out.angle = angle + this.initAngle), \n        this.cb && this.cb(this.from, this.to, ratio, this.target);\n    }\n}\n\nexports.MotionPath = MotionPath;\n\nclass TagPointsUpdate extends animate_1.ACustomAnimate {\n    constructor(from, to, duration, easing, params) {\n        super(from, to, duration, easing, params), this.newPointAnimateType = \"appear\" === (null == params ? void 0 : params.newPointAnimateType) ? \"appear\" : \"grow\";\n    }\n    onBind() {\n        var _a, _b;\n        const originFromPoints = null === (_a = this.from) || void 0 === _a ? void 0 : _a.points, originToPoints = null === (_b = this.to) || void 0 === _b ? void 0 : _b.points;\n        this.fromPoints = originFromPoints ? Array.isArray(originFromPoints) ? originFromPoints : [ originFromPoints ] : [], \n        this.toPoints = originToPoints ? Array.isArray(originToPoints) ? originToPoints : [ originToPoints ] : [];\n        const tagMap = new Map;\n        this.fromPoints.forEach((point => {\n            point.context && tagMap.set(point.context, point);\n        }));\n        let firstMatchedPoint, lastMatchedPoint, firstMatchedIndex = 1 / 0, lastMatchedIndex = -1 / 0;\n        for (let i = 0; i < this.toPoints.length; i += 1) if (tagMap.has(this.toPoints[i].context)) {\n            firstMatchedIndex = i, firstMatchedPoint = tagMap.get(this.toPoints[i].context);\n            break;\n        }\n        for (let i = this.toPoints.length - 1; i >= 0; i -= 1) if (tagMap.has(this.toPoints[i].context)) {\n            lastMatchedIndex = i, lastMatchedPoint = tagMap.get(this.toPoints[i].context);\n            break;\n        }\n        let prevMatchedPoint = this.toPoints[0];\n        this.interpolatePoints = this.toPoints.map(((point, index) => {\n            const matchedPoint = tagMap.get(point.context);\n            return matchedPoint ? (prevMatchedPoint = matchedPoint, [ matchedPoint, point ]) : \"appear\" === this.newPointAnimateType ? [ point, point ] : index < firstMatchedIndex && firstMatchedPoint ? [ firstMatchedPoint, point ] : index > lastMatchedIndex && lastMatchedPoint ? [ lastMatchedPoint, point ] : [ prevMatchedPoint, point ];\n        })), this.points = this.interpolatePoints.map((interpolate => {\n            const fromPoint = interpolate[0], toPoint = interpolate[1], newPoint = new vutils_1.Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);\n            return newPoint.defined = toPoint.defined, newPoint.context = toPoint.context, newPoint;\n        }));\n    }\n    onUpdate(end, ratio, out) {\n        this.points = this.points.map(((point, index) => {\n            const newPoint = (0, utils_1.pointInterpolation)(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);\n            return newPoint.context = point.context, newPoint;\n        })), out.points = this.points;\n    }\n}\n\nexports.TagPointsUpdate = TagPointsUpdate;\n\nclass GraphicAnimate extends animate_1.ACustomAnimate {\n    constructor(from, to, duration, easing, params) {\n        super(from, to, duration, easing, params), this.graphic = null == params ? void 0 : params.graphic;\n    }\n    onUpdate(end, ratio, out) {\n        this.graphic && Object.keys(this.from).forEach((k => {\n            out[k] = this.from[k] + (this.to[k] - this.from[k]) * ratio;\n        }));\n    }\n}\n\nexports.GraphicAnimate = GraphicAnimate;\n\nclass ClipGraphicAnimate extends animate_1.ACustomAnimate {\n    constructor(from, to, duration, easing, params) {\n        super(null, null, duration, easing, params), this.clipFromAttribute = from, this.clipToAttribute = to, \n        this._group = null == params ? void 0 : params.group, this._clipGraphic = null == params ? void 0 : params.clipGraphic;\n    }\n    onBind() {\n        this._group && this._clipGraphic && (this._lastClip = this._group.attribute.clip, \n        this._lastPath = this._group.attribute.path, this._group.setAttributes({\n            clip: !0,\n            path: [ this._clipGraphic ]\n        }, !1, {\n            type: enums_1.AttributeUpdateType.ANIMATE_BIND\n        }));\n    }\n    onEnd() {\n        this._group && this._group.setAttributes({\n            clip: this._lastClip,\n            path: this._lastPath\n        }, !1, {\n            type: enums_1.AttributeUpdateType.ANIMATE_END\n        });\n    }\n    onUpdate(end, ratio, out) {\n        if (!this._clipGraphic) return;\n        const res = {};\n        Object.keys(this.clipFromAttribute).forEach((k => {\n            res[k] = this.clipFromAttribute[k] + (this.clipToAttribute[k] - this.clipFromAttribute[k]) * ratio;\n        })), this._clipGraphic.setAttributes(res, !1, {\n            type: enums_1.AttributeUpdateType.ANIMATE_UPDATE,\n            animationState: {\n                ratio: ratio,\n                end: end\n            }\n        });\n    }\n}\n\nexports.ClipGraphicAnimate = ClipGraphicAnimate;\n\nclass ClipAngleAnimate extends ClipGraphicAnimate {\n    constructor(from, to, duration, easing, params) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0, height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0, animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : \"in\", startAngle = null !== (_f = null == params ? void 0 : params.startAngle) && void 0 !== _f ? _f : 0, orient = null !== (_g = null == params ? void 0 : params.orient) && void 0 !== _g ? _g : \"clockwise\";\n        let arcStartAngle = 0, arcEndAngle = 0;\n        \"anticlockwise\" === orient ? (arcEndAngle = \"in\" === animationType ? startAngle + 2 * Math.PI : startAngle, \n        arcEndAngle = startAngle + 2 * Math.PI) : (arcStartAngle = startAngle, arcEndAngle = \"out\" === animationType ? startAngle + 2 * Math.PI : startAngle);\n        const arc = application_1.application.graphicService.creator.arc({\n            x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,\n            y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,\n            outerRadius: null !== (_m = null == params ? void 0 : params.radius) && void 0 !== _m ? _m : (width + height) / 2,\n            innerRadius: 0,\n            startAngle: arcStartAngle,\n            endAngle: arcEndAngle,\n            fill: !0\n        });\n        let fromAttributes, toAttributes;\n        \"anticlockwise\" === orient ? (fromAttributes = {\n            startAngle: startAngle + 2 * Math.PI\n        }, toAttributes = {\n            startAngle: startAngle\n        }) : (fromAttributes = {\n            endAngle: startAngle\n        }, toAttributes = {\n            endAngle: startAngle + 2 * Math.PI\n        }), super(\"in\" === animationType ? fromAttributes : toAttributes, \"in\" === animationType ? toAttributes : fromAttributes, duration, easing, {\n            group: null == params ? void 0 : params.group,\n            clipGraphic: arc\n        });\n    }\n}\n\nexports.ClipAngleAnimate = ClipAngleAnimate;\n\nclass ClipRadiusAnimate extends ClipGraphicAnimate {\n    constructor(from, to, duration, easing, params) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0, height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0, animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : \"in\", startRadius = null !== (_f = null == params ? void 0 : params.startRadius) && void 0 !== _f ? _f : 0, endRadius = null !== (_g = null == params ? void 0 : params.endRadius) && void 0 !== _g ? _g : Math.sqrt((width / 2) ** 2 + (height / 2) ** 2), arc = application_1.application.graphicService.creator.arc({\n            x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,\n            y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,\n            outerRadius: \"out\" === animationType ? endRadius : startRadius,\n            innerRadius: 0,\n            startAngle: 0,\n            endAngle: 2 * Math.PI,\n            fill: !0\n        }), fromAttributes = {\n            outerRadius: startRadius\n        }, toAttributes = {\n            outerRadius: endRadius\n        };\n        super(\"in\" === animationType ? fromAttributes : toAttributes, \"in\" === animationType ? toAttributes : fromAttributes, duration, easing, {\n            group: null == params ? void 0 : params.group,\n            clipGraphic: arc\n        });\n    }\n}\n\nexports.ClipRadiusAnimate = ClipRadiusAnimate;\n\nclass ClipDirectionAnimate extends ClipGraphicAnimate {\n    constructor(from, to, duration, easing, params) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {}, width = null !== (_d = null !== (_c = null == params ? void 0 : params.width) && void 0 !== _c ? _c : groupAttribute.width) && void 0 !== _d ? _d : 0, height = null !== (_f = null !== (_e = null == params ? void 0 : params.height) && void 0 !== _e ? _e : groupAttribute.height) && void 0 !== _f ? _f : 0, animationType = null !== (_g = null == params ? void 0 : params.animationType) && void 0 !== _g ? _g : \"in\", direction = null !== (_h = null == params ? void 0 : params.direction) && void 0 !== _h ? _h : \"x\", orient = null !== (_j = null == params ? void 0 : params.orient) && void 0 !== _j ? _j : \"positive\", rect = application_1.application.graphicService.creator.rect({\n            x: 0,\n            y: 0,\n            width: \"in\" === animationType && \"x\" === direction ? 0 : width,\n            height: \"in\" === animationType && \"y\" === direction ? 0 : height,\n            fill: !0\n        });\n        let fromAttributes = {}, toAttributes = {};\n        \"y\" === direction ? \"negative\" === orient ? (fromAttributes = {\n            y: height,\n            height: 0\n        }, toAttributes = {\n            y: 0,\n            height: height\n        }) : (fromAttributes = {\n            height: 0\n        }, toAttributes = {\n            height: height\n        }) : \"negative\" === orient ? (fromAttributes = {\n            x: width,\n            width: 0\n        }, toAttributes = {\n            x: 0,\n            width: width\n        }) : (fromAttributes = {\n            width: 0\n        }, toAttributes = {\n            width: width\n        }), super(\"in\" === animationType ? fromAttributes : toAttributes, \"in\" === animationType ? toAttributes : fromAttributes, duration, easing, {\n            group: null == params ? void 0 : params.group,\n            clipGraphic: rect\n        });\n    }\n}\n\nexports.ClipDirectionAnimate = ClipDirectionAnimate;\n\nclass RotateBySphereAnimate extends animate_1.ACustomAnimate {\n    onStart() {\n        const {center: center, r: r} = \"function\" == typeof this.params ? this.params() : this.params, startX = this.target.getComputedAttribute(\"x\"), startY = this.target.getComputedAttribute(\"y\"), startZ = this.target.getComputedAttribute(\"z\"), phi = Math.acos((startY - center.y) / r);\n        let theta = Math.acos((startX - center.x) / r / Math.sin(phi));\n        startZ - center.z < 0 && (theta = vutils_1.pi2 - theta), this.theta = theta, this.phi = phi;\n    }\n    onBind() {}\n    onEnd() {}\n    onUpdate(end, ratio, out) {\n        if (null == this.phi || null == this.theta) return;\n        const {center: center, r: r} = \"function\" == typeof this.params ? this.params() : this.params, deltaAngle = 2 * Math.PI * ratio, theta = this.theta + deltaAngle, phi = this.phi, x = r * Math.sin(phi) * Math.cos(theta) + center.x, y = r * Math.cos(phi) + center.y, z = r * Math.sin(phi) * Math.sin(theta) + center.z;\n        for (out.x = x, out.y = y, out.z = z, out.alpha = theta + vutils_1.pi / 2; out.alpha > vutils_1.pi2; ) out.alpha -= vutils_1.pi2;\n        out.alpha = vutils_1.pi2 - out.alpha, out.zIndex = -1e4 * out.z;\n    }\n}\n\nexports.RotateBySphereAnimate = RotateBySphereAnimate;\n\nclass GroupFadeIn extends animate_1.ACustomAnimate {\n    getEndProps() {\n        return {};\n    }\n    onBind() {\n        this.target.setTheme({\n            common: {\n                opacity: 0\n            }\n        });\n    }\n    onEnd() {\n        this.target.setTheme({\n            common: {\n                opacity: 1\n            }\n        });\n    }\n    onUpdate(end, ratio, out) {\n        this.target.setTheme({\n            common: {\n                opacity: ratio\n            }\n        });\n    }\n}\n\nexports.GroupFadeIn = GroupFadeIn;\n\nclass GroupFadeOut extends animate_1.ACustomAnimate {\n    getEndProps() {\n        return {};\n    }\n    onBind() {\n        this.target.setTheme({\n            common: {\n                opacity: 1\n            }\n        });\n    }\n    onEnd() {\n        this.target.setTheme({\n            common: {\n                opacity: 0\n            }\n        });\n    }\n    onUpdate(end, ratio, out) {\n        this.target.setTheme({\n            common: {\n                opacity: 1 - ratio\n            }\n        });\n    }\n}\n\nexports.GroupFadeOut = GroupFadeOut;\n\nclass AttributeAnimate extends animate_1.ACustomAnimate {\n    constructor(to, duration, easing) {\n        super({}, to, duration, easing);\n    }\n    getEndProps() {\n        return this.to;\n    }\n    onBind() {\n        Object.keys(this.to).forEach((k => {\n            this.from[k] = this.target.getComputedAttribute(k);\n        }));\n    }\n    onEnd() {}\n    onUpdate(end, ratio, out) {\n        this.target.stepInterpolate(this.subAnimate, this.subAnimate.animate, out, this.step, ratio, end, this.to, this.from);\n    }\n}\n\nexports.AttributeAnimate = AttributeAnimate;\n\nclass AnimateGroup extends animate_1.ACustomAnimate {\n    constructor(duration, customAnimates) {\n        super(null, null, duration, \"linear\"), this.customAnimates = customAnimates;\n    }\n    initAnimates() {\n        this.customAnimates.forEach((a => {\n            a.step = this.step, a.subAnimate = this.subAnimate, a.target = this.target;\n        }));\n    }\n    getEndProps() {\n        const props = {};\n        return this.customAnimates.forEach((a => {\n            Object.assign(props, a.getEndProps());\n        })), props;\n    }\n    onBind() {\n        this.initAnimates(), this.customAnimates.forEach((a => {\n            a.onBind();\n        }));\n    }\n    onEnd() {\n        this.customAnimates.forEach((a => {\n            a.onEnd();\n        }));\n    }\n    onUpdate(end, ratio, out) {\n        this.updating || (this.updating = !0, this.customAnimates.forEach((a => {\n            const easing = a.easing, easingFunc = \"string\" == typeof easing ? easing_1.Easing[easing] : easing;\n            ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);\n        })), this.updating = !1);\n    }\n}\n\nexports.AnimateGroup = AnimateGroup;\n\nclass AnimateGroup1 extends animate_1.ACustomAnimate {\n    constructor(duration, customAnimates) {\n        super(null, null, duration, \"linear\"), this.customAnimates = customAnimates;\n    }\n    initAnimates() {\n        this.customAnimates.forEach((a => {\n            a.step = this.step, a.subAnimate = this.subAnimate, a.target = this.target;\n        }));\n    }\n    getEndProps() {\n        const props = {};\n        return this.customAnimates.forEach((a => {\n            Object.assign(props, a.getEndProps());\n        })), props;\n    }\n    onBind() {\n        this.initAnimates(), this.customAnimates.forEach((a => {\n            a.onBind();\n        }));\n    }\n    onEnd() {\n        this.customAnimates.forEach((a => {\n            a.onEnd();\n        }));\n    }\n    onUpdate(end, ratio, out) {\n        this.updating || (this.updating = !0, this.customAnimates.forEach((a => {\n            const easing = a.easing, easingFunc = \"string\" == typeof easing ? easing_1.Easing[easing] : easing;\n            ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);\n        })), this.updating = !1);\n    }\n}\n\nexports.AnimateGroup1 = AnimateGroup1;\n//# sourceMappingURL=custom-animate.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.getAttributeFromDefaultAttrList = exports.isTransformKey = exports.transformKeys = exports.pointsInterpolation = exports.pointInterpolationHighPerformance = exports.pointInterpolation = exports.pointEqual = exports.pointsEqual = exports.circleBounds = exports.parsePadding = exports.parseStroke = exports.Edge = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nvar Edge;\n\n!function(Edge) {\n    Edge[Edge.Top = 1] = \"Top\", Edge[Edge.Right = 2] = \"Right\", Edge[Edge.Bottom = 4] = \"Bottom\", \n    Edge[Edge.Left = 8] = \"Left\", Edge[Edge.ALL = 15] = \"ALL\";\n}(Edge = exports.Edge || (exports.Edge = {}));\n\nconst _strokeVec4 = [ !1, !1, !1, !1 ], parseStroke = stroke => {\n    var _a;\n    let isFullStroke = !0;\n    if ((0, vutils_1.isBoolean)(stroke, !0)) {\n        for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));\n        isFullStroke = stroke;\n    } else if (Array.isArray(stroke)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke[i], \n    isFullStroke && (isFullStroke = !!_strokeVec4[i]); else _strokeVec4[0] = !1, _strokeVec4[1] = !1, \n    _strokeVec4[2] = !1, _strokeVec4[3] = !1;\n    return {\n        isFullStroke: isFullStroke,\n        stroke: _strokeVec4\n    };\n};\n\nexports.parseStroke = parseStroke;\n\nconst _paddingVec4 = [ 0, 0, 0, 0 ], parsePadding = padding => padding ? (0, vutils_1.isArray)(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], \n_paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], \n_paddingVec4) : padding : padding : 0;\n\nexports.parsePadding = parsePadding;\n\nconst _coords = [ {\n    x: 0,\n    y: 0\n}, {\n    x: 0,\n    y: 0\n}, {\n    x: 0,\n    y: 0\n}, {\n    x: 0,\n    y: 0\n} ], indexList = [ 1, 2, 3, 0, 1, 2, 3, 0 ];\n\nfunction circleBounds(startAngle, endAngle, radius, bounds) {\n    for (;startAngle >= vutils_1.pi2; ) startAngle -= vutils_1.pi2;\n    for (;startAngle < 0; ) startAngle += vutils_1.pi2;\n    for (;startAngle > endAngle; ) endAngle += vutils_1.pi2;\n    _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;\n    const startIdx = Math.ceil(startAngle / vutils_1.halfPi) % 4, endIdx = Math.ceil(endAngle / vutils_1.halfPi) % 4;\n    if (bounds.add((0, vutils_1.cos)(startAngle) * radius, (0, vutils_1.sin)(startAngle) * radius), \n    bounds.add((0, vutils_1.cos)(endAngle) * radius, (0, vutils_1.sin)(endAngle) * radius), \n    startIdx !== endIdx || endAngle - startAngle > vutils_1.pi) {\n        let match = !1;\n        for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {\n            if (match && endIdx === indexList[i]) break;\n            if (match) {\n                const p = _coords[indexList[i]];\n                bounds.add(p.x, p.y);\n            }\n        } else {\n            match = !0;\n            const p = _coords[startIdx];\n            bounds.add(p.x, p.y);\n        }\n    }\n}\n\nfunction pointsEqual(pointsA, pointsB) {\n    return !(!pointsA || !pointsB) && (Array.isArray(pointsA) && Array.isArray(pointsB) ? pointsA.length === pointsB.length && pointsA.every(((point, index) => pointEqual(point, pointsB[index]))) : !Number.isNaN(pointsA.x + pointsA.y) && pointEqual(pointsA, pointsB));\n}\n\nfunction pointEqual(pointA, pointB) {\n    return pointA.x === pointB.x && pointA.y === pointB.y && pointA.x1 === pointB.x1 && pointA.y1 === pointB.y1 && pointA.defined === pointB.defined;\n}\n\nfunction pointInterpolation(pointA, pointB, ratio) {\n    const {x: x, y: y} = (0, vutils_1.pointAt)(pointA.x, pointA.y, pointB.x, pointB.y, ratio), {x: x1, y: y1} = (0, \n    vutils_1.pointAt)(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio), point = new vutils_1.Point(x, y, x1, y1);\n    return point.defined = pointB.defined, point;\n}\n\nfunction pointInterpolationHighPerformance(pointA, pointB, ratio, point) {\n    const {x: x, y: y} = (0, vutils_1.pointAt)(pointA.x, pointA.y, pointB.x, pointB.y, ratio), {x: x1, y: y1} = (0, \n    vutils_1.pointAt)(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio);\n    return point.x = x, point.y = y, point.x1 = x1, point.y1 = y1, point.defined = pointB.defined, \n    point;\n}\n\nfunction pointsInterpolation(pointsA, pointsB, ratio) {\n    if (!pointsA || !pointsB) return [];\n    Array.isArray(pointsA) || (pointsA = [ pointsA ]), Array.isArray(pointsB) || (pointsB = [ pointsB ]);\n    let points = [];\n    if (pointsA.length > pointsB.length) {\n        points = pointsB.map((point => {\n            const p = new vutils_1.Point(point.x, point.y, point.x1, point.y1);\n            return p.defined = point.defined, p;\n        }));\n        for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);\n    } else {\n        points = pointsB.map((point => {\n            const p = new vutils_1.Point(point.x, point.y, point.x1, point.y1);\n            return p.defined = point.defined, p;\n        }));\n        for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);\n    }\n    return points;\n}\n\nexports.circleBounds = circleBounds, exports.pointsEqual = pointsEqual, exports.pointEqual = pointEqual, \nexports.pointInterpolation = pointInterpolation, exports.pointInterpolationHighPerformance = pointInterpolationHighPerformance, \nexports.pointsInterpolation = pointsInterpolation, exports.transformKeys = [ \"x\", \"y\", \"dx\", \"dy\", \"scaleX\", \"scaleY\", \"angle\", \"anchor\", \"postMatrix\", \"scrollX\", \"scrollY\" ];\n\nconst isTransformKey = key => exports.transformKeys.includes(key);\n\nfunction getAttributeFromDefaultAttrList(attr, key) {\n    if ((0, vutils_1.isArray)(attr)) {\n        let val;\n        for (let i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];\n        return val;\n    }\n    return attr[key];\n}\n\nexports.isTransformKey = isTransformKey, exports.getAttributeFromDefaultAttrList = getAttributeFromDefaultAttrList;\n//# sourceMappingURL=utils.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.multiToOneMorph = exports.splitGraphic = exports.cloneGraphic = exports.MultiToOneMorphingPath = exports.oneToMultiMorph = exports.morphPath = exports.MorphingPath = void 0;\n\nconst split_path_1 = require(\"./../common/split-path\"), custom_path2d_1 = require(\"../common/custom-path2d\"), animate_1 = require(\"./animate\"), morphing_utils_1 = require(\"../common/morphing-utils\"), application_1 = require(\"../application\"), vutils_1 = require(\"@visactor/vutils\"), interpolate_1 = require(\"../color-string/interpolate\"), color_string_1 = require(\"../color-string\"), config_1 = require(\"./config\"), utils_1 = require(\"../common/utils\"), enums_1 = require(\"../common/enums\"), interpolateOtherAttrs = (attrs, out, ratio) => {\n    attrs.forEach((entry => {\n        if (Number.isFinite(entry.to)) out[entry.key] = entry.from + (entry.to - entry.from) * ratio; else if (\"fill\" === entry.key || \"stroke\" === entry.key) {\n            const color = (0, interpolate_1.interpolateColor)(entry.from, entry.to, ratio, !1);\n            color && (out[entry.key] = color);\n        }\n    }));\n}, interpolateMorphingData = (morphingData, path, ratio) => {\n    const tmpArr = [], newCp = [];\n    path.clear();\n    for (let i = 0; i < morphingData.length; i++) {\n        const item = morphingData[i], from = item.from, to = item.to, angle = item.rotation * ratio, fromCp = item.fromCp, toCp = item.toCp, sa = Math.sin(angle), ca = Math.cos(angle);\n        newCp[0] = fromCp[0] + (toCp[0] - fromCp[0]) * ratio, newCp[1] = fromCp[1] + (toCp[1] - fromCp[1]) * ratio;\n        for (let m = 0; m < from.length; m += 2) {\n            const x0 = from[m], y0 = from[m + 1], x = x0 * (1 - ratio) + to[m] * ratio, y = y0 * (1 - ratio) + to[m + 1] * ratio;\n            tmpArr[m] = x * ca - y * sa + newCp[0], tmpArr[m + 1] = x * sa + y * ca + newCp[1];\n        }\n        let x0 = tmpArr[0], y0 = tmpArr[1];\n        path.moveTo(x0, y0);\n        for (let m = 2; m < from.length; m += 6) {\n            const x1 = tmpArr[m], y1 = tmpArr[m + 1], x2 = tmpArr[m + 2], y2 = tmpArr[m + 3], x3 = tmpArr[m + 4], y3 = tmpArr[m + 5];\n            x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3 ? path.lineTo(x3, y3) : path.bezierCurveTo(x1, y1, x2, y2, x3, y3), \n            x0 = x3, y0 = y3;\n        }\n    }\n}, parseMorphingData = (fromPath, toPath, config) => {\n    const fromBezier = fromPath ? (0, morphing_utils_1.pathToBezierCurves)(fromPath) : [], toBezier = (0, \n    morphing_utils_1.pathToBezierCurves)(toPath);\n    config && fromBezier && (config.fromTransform && (0, morphing_utils_1.applyTransformOnBezierCurves)(fromBezier, config.fromTransform.clone().getInverse()), \n    (0, morphing_utils_1.applyTransformOnBezierCurves)(fromBezier, config.toTransfrom));\n    const [fromBezierCurves, toBezierCurves] = (0, morphing_utils_1.alignBezierCurves)(fromBezier, toBezier);\n    return fromPath ? (0, morphing_utils_1.findBestMorphingRotation)(fromBezierCurves, toBezierCurves, 10, Math.PI) : toBezierCurves.map(((to, index) => ({\n        from: fromBezierCurves[index],\n        to: to,\n        fromCp: [ 0, 0 ],\n        toCp: [ 0, 0 ],\n        rotation: 0\n    })));\n}, validateOtherAttrs = [ \"fill\", \"fillOpacity\", \"shadowBlur\", \"shadowColor\", \"shadowOffsetX\", \"shadowOffsetY\", \"stroke\", \"strokeOpacity\", \"lineDashOffset\" ], parseOtherAnimateAttrs = (fromAttrs, toAttrs) => {\n    if (!fromAttrs || !toAttrs) return null;\n    const res = [];\n    let hasAttr = !1;\n    return Object.keys(fromAttrs).forEach((fromKey => {\n        if (!validateOtherAttrs.includes(fromKey)) return;\n        const toValue = toAttrs[fromKey];\n        (0, vutils_1.isNil)(toValue) || (0, vutils_1.isNil)(fromAttrs[fromKey]) || toValue === fromAttrs[fromKey] || (\"fill\" === fromKey || \"stroke\" === fromKey ? res.push({\n            from: \"string\" == typeof fromAttrs[fromKey] ? color_string_1.ColorStore.Get(fromAttrs[fromKey], color_string_1.ColorType.Color255) : fromAttrs[fromKey],\n            to: \"string\" == typeof toValue ? color_string_1.ColorStore.Get(toValue, color_string_1.ColorType.Color255) : toValue,\n            key: fromKey\n        }) : res.push({\n            from: fromAttrs[fromKey],\n            to: toValue,\n            key: fromKey\n        }), hasAttr = !0);\n    })), hasAttr ? res : null;\n};\n\nclass MorphingPath extends animate_1.ACustomAnimate {\n    constructor(config, duration, easing) {\n        super(0, 1, duration, easing), this.morphingData = config.morphingData, this.otherAttrs = config.otherAttrs, \n        this.saveOnEnd = config.saveOnEnd;\n    }\n    getEndProps() {\n        return {};\n    }\n    onBind() {\n        this.target.createPathProxy(), this.onUpdate(!1, 0, this.target.attribute);\n    }\n    onEnd() {}\n    onUpdate(end, ratio, out) {\n        const target = this.target, pathProxy = \"function\" == typeof target.pathProxy ? target.pathProxy(target.attribute) : target.pathProxy;\n        interpolateMorphingData(this.morphingData, pathProxy, ratio), this.otherAttrs && this.otherAttrs.length && interpolateOtherAttrs(this.otherAttrs, out, ratio), \n        end && !this.saveOnEnd && (this.target.pathProxy = null);\n    }\n}\n\nexports.MorphingPath = MorphingPath;\n\nconst morphPath = (fromGraphic, toGraphic, animationConfig, fromGraphicTransform) => {\n    var _a, _b, _c;\n    if (fromGraphic && (!fromGraphic.valid || !fromGraphic.toCustomPath)) return __DEV__ && console.error(fromGraphic, \" is not validate\"), \n    null;\n    if (!toGraphic.valid || !toGraphic.toCustomPath) return __DEV__ && console.error(toGraphic, \" is not validate\"), \n    null;\n    let fromTransform = null == fromGraphic ? void 0 : fromGraphic.globalTransMatrix;\n    fromGraphicTransform && fromTransform && (fromTransform = fromGraphicTransform.clone().multiply(fromTransform.a, fromTransform.b, fromTransform.c, fromTransform.d, fromTransform.e, fromTransform.f));\n    const morphingData = parseMorphingData(null === (_a = null == fromGraphic ? void 0 : fromGraphic.toCustomPath) || void 0 === _a ? void 0 : _a.call(fromGraphic), toGraphic.toCustomPath(), {\n        fromTransform: fromTransform,\n        toTransfrom: toGraphic.globalTransMatrix\n    }), attrs = parseOtherAnimateAttrs(null == fromGraphic ? void 0 : fromGraphic.attribute, toGraphic.attribute), animate = toGraphic.animate(animationConfig);\n    return (null == animationConfig ? void 0 : animationConfig.delay) && animate.wait(animationConfig.delay), \n    animate.play(new MorphingPath({\n        morphingData: morphingData,\n        otherAttrs: attrs\n    }, null !== (_b = null == animationConfig ? void 0 : animationConfig.duration) && void 0 !== _b ? _b : config_1.DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig ? void 0 : animationConfig.easing) && void 0 !== _c ? _c : config_1.DefaultMorphingAnimateConfig.easing)), \n    animate;\n};\n\nexports.morphPath = morphPath;\n\nconst oneToMultiMorph = (fromGraphic, toGraphics, animationConfig) => {\n    var _a;\n    const validateToGraphics = toGraphics.filter((graphic => graphic && graphic.toCustomPath && graphic.valid));\n    validateToGraphics.length || __DEV__ && console.error(validateToGraphics, \" is not validate\"), \n    fromGraphic.valid && fromGraphic.toCustomPath || __DEV__ && console.error(fromGraphic, \" is not validate\");\n    const childGraphics = (\"clone\" === (null == animationConfig ? void 0 : animationConfig.splitPath) ? exports.cloneGraphic : null !== (_a = null == animationConfig ? void 0 : animationConfig.splitPath) && void 0 !== _a ? _a : exports.splitGraphic)(fromGraphic, validateToGraphics.length, !1), oldOnEnd = null == animationConfig ? void 0 : animationConfig.onEnd;\n    let count = validateToGraphics.length;\n    const onEachEnd = () => {\n        count--, 0 === count && oldOnEnd && oldOnEnd();\n    };\n    validateToGraphics.forEach(((toChild, index) => {\n        var _a;\n        const fromChild = childGraphics[index], delay = (null !== (_a = null == animationConfig ? void 0 : animationConfig.delay) && void 0 !== _a ? _a : 0) + ((null == animationConfig ? void 0 : animationConfig.individualDelay) ? animationConfig.individualDelay(index, validateToGraphics.length, fromChild, toChild) : 0);\n        (0, exports.morphPath)(fromChild, toChild, Object.assign({}, animationConfig, {\n            onEnd: onEachEnd,\n            delay: delay\n        }), fromGraphic.globalTransMatrix);\n    }));\n};\n\nexports.oneToMultiMorph = oneToMultiMorph;\n\nclass MultiToOneMorphingPath extends animate_1.ACustomAnimate {\n    constructor(config, duration, easing) {\n        super(0, 1, duration, easing), this.morphingData = config.morphingData, this.otherAttrs = config.otherAttrs;\n    }\n    getEndProps() {\n        return {};\n    }\n    onBind() {\n        this.addPathProxy();\n    }\n    addPathProxy() {\n        this.target.shadowRoot.forEachChildren((child => {\n            child.createPathProxy();\n        })), this.onUpdate(!1, 0, this.target.attribute);\n    }\n    clearPathProxy() {\n        this.target.shadowRoot.forEachChildren((child => {\n            child.pathProxy = null;\n        }));\n    }\n    onEnd() {}\n    onUpdate(end, ratio, out) {\n        this.target.shadowRoot.forEachChildren(((child, index) => {\n            var _a;\n            interpolateMorphingData(this.morphingData[index], \"function\" == typeof child.pathProxy ? child.pathProxy(child.attribute) : child.pathProxy, ratio), \n            (null === (_a = this.otherAttrs) || void 0 === _a ? void 0 : _a[index]) && this.otherAttrs[index].length && interpolateOtherAttrs(this.otherAttrs[index], child.attribute, ratio);\n        })), end && (this.clearPathProxy(), this.morphingData = null);\n    }\n}\n\nexports.MultiToOneMorphingPath = MultiToOneMorphingPath;\n\nconst parseShadowChildAttrs = graphicAttrs => {\n    const attrs = {};\n    return Object.keys(graphicAttrs).forEach((key => {\n        (0, utils_1.isTransformKey)(key) || (attrs[key] = graphicAttrs[key]);\n    })), attrs;\n}, appendShadowChildrenToGraphic = (graphic, children, count) => {\n    const childAttrs = parseShadowChildAttrs(graphic.attribute), shadowRoot = graphic.attachShadow();\n    if (children.length) shadowRoot.setTheme({\n        [children[0].type]: childAttrs\n    }), children.forEach((element => {\n        shadowRoot.appendChild(element);\n    })); else {\n        const box = graphic.AABBBounds, width = box.width(), height = box.height();\n        shadowRoot.setTheme({\n            rect: childAttrs\n        }), new Array(count).fill(0).forEach((el => {\n            const child = application_1.application.graphicService.creator.rect({\n                x: 0,\n                y: 0,\n                width: width,\n                height: height\n            });\n            shadowRoot.appendChild(child), children.push(child);\n        }));\n    }\n}, cloneGraphic = (graphic, count, needAppend) => {\n    const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute), path = graphic.toCustomPath();\n    for (let i = 0; i < count; i++) {\n        const element = {\n            path: (new custom_path2d_1.CustomPath2D).fromCustomPath2D(path)\n        };\n        children.push(application_1.application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));\n    }\n    return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;\n};\n\nexports.cloneGraphic = cloneGraphic;\n\nconst splitGraphic = (graphic, count, needAppend) => {\n    const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);\n    if (\"rect\" === graphic.type) {\n        (0, split_path_1.splitRect)(graphic, count).forEach((element => {\n            children.push(application_1.application.graphicService.creator.rect(needAppend ? element : Object.assign({}, childAttrs, element)));\n        }));\n    } else if (\"arc\" === graphic.type) {\n        (0, split_path_1.splitArc)(graphic, count).forEach((element => {\n            children.push(application_1.application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));\n        }));\n    } else if (\"circle\" === graphic.type) {\n        (0, split_path_1.splitCircle)(graphic, count).forEach((element => {\n            children.push(application_1.application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));\n        }));\n    } else if (\"line\" === graphic.type) {\n        const childrenAttrs = (0, split_path_1.splitLine)(graphic, count), defaultSymbol = {\n            size: 10,\n            symbolType: \"circle\"\n        };\n        childrenAttrs.forEach((element => {\n            children.push(application_1.application.graphicService.creator.symbol(needAppend ? Object.assign({}, element, defaultSymbol) : Object.assign({}, childAttrs, element, defaultSymbol)));\n        }));\n    } else if (\"polygon\" === graphic.type) {\n        (0, split_path_1.splitPolygon)(graphic, count).forEach((element => {\n            children.push(application_1.application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));\n        }));\n    } else if (\"area\" === graphic.type) {\n        (0, split_path_1.splitArea)(graphic, count).forEach((element => {\n            children.push(application_1.application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));\n        }));\n    } else if (\"path\" === graphic.type) {\n        (0, split_path_1.splitPath)(graphic, count).forEach((element => {\n            \"path\" in element ? children.push(application_1.application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element))) : children.push(application_1.application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));\n        }));\n    }\n    return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;\n};\n\nexports.splitGraphic = splitGraphic;\n\nconst multiToOneMorph = (fromGraphics, toGraphic, animationConfig) => {\n    var _a, _b, _c;\n    const validateFromGraphics = fromGraphics.filter((graphic => graphic.toCustomPath && graphic.valid));\n    validateFromGraphics.length || __DEV__ && console.error(fromGraphics, \" is not validate\"), \n    toGraphic.valid && toGraphic.toCustomPath || __DEV__ && console.error(toGraphic, \" is not validate\");\n    const childGraphics = (\"clone\" === (null == animationConfig ? void 0 : animationConfig.splitPath) ? exports.cloneGraphic : null !== (_a = null == animationConfig ? void 0 : animationConfig.splitPath) && void 0 !== _a ? _a : exports.splitGraphic)(toGraphic, validateFromGraphics.length, !0), toAttrs = toGraphic.attribute;\n    toGraphic.setAttribute(\"visible\", !1);\n    const morphingData = validateFromGraphics.map(((graphic, index) => parseMorphingData(graphic.toCustomPath(), childGraphics[index].toCustomPath(), {\n        fromTransform: graphic.globalTransMatrix,\n        toTransfrom: childGraphics[index].globalTransMatrix\n    }))), otherAttrs = validateFromGraphics.map(((graphic, index) => parseOtherAnimateAttrs(graphic.attribute, toAttrs)));\n    if (null == animationConfig ? void 0 : animationConfig.individualDelay) {\n        const oldOnEnd = animationConfig.onEnd;\n        let count = validateFromGraphics.length;\n        const onEachEnd = () => {\n            count--, 0 === count && (toGraphic.setAttributes({\n                visible: !0,\n                ratio: null\n            }, !1, {\n                type: enums_1.AttributeUpdateType.ANIMATE_END\n            }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd());\n        };\n        childGraphics.forEach(((to, index) => {\n            var _a, _b, _c;\n            const delay = (null !== (_a = animationConfig.delay) && void 0 !== _a ? _a : 0) + animationConfig.individualDelay(index, validateFromGraphics.length, fromGraphics[index], to), animate = to.animate(Object.assign({}, animationConfig, {\n                onEnd: onEachEnd\n            }));\n            animate.wait(delay), animate.play(new MorphingPath({\n                morphingData: morphingData[index],\n                saveOnEnd: !0,\n                otherAttrs: otherAttrs[index]\n            }, null !== (_b = animationConfig.duration) && void 0 !== _b ? _b : config_1.DefaultMorphingAnimateConfig.duration, null !== (_c = animationConfig.easing) && void 0 !== _c ? _c : config_1.DefaultMorphingAnimateConfig.easing));\n        }));\n    } else {\n        const oldOnEnd = null == animationConfig ? void 0 : animationConfig.onEnd, config = animationConfig ? Object.assign({}, animationConfig) : {};\n        config.onEnd = () => {\n            toGraphic.setAttribute(\"visible\", !0, !1, {\n                type: enums_1.AttributeUpdateType.ANIMATE_END\n            }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd();\n        };\n        const animate = toGraphic.animate(config);\n        (null == animationConfig ? void 0 : animationConfig.delay) && animate.wait(animationConfig.delay), \n        animate.play(new MultiToOneMorphingPath({\n            morphingData: morphingData,\n            otherAttrs: otherAttrs\n        }, null !== (_b = null == animationConfig ? void 0 : animationConfig.duration) && void 0 !== _b ? _b : config_1.DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig ? void 0 : animationConfig.easing) && void 0 !== _c ? _c : config_1.DefaultMorphingAnimateConfig.easing));\n    }\n};\n\nexports.multiToOneMorph = multiToOneMorph;\n//# sourceMappingURL=morphing.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.splitPath = exports.splitPolygon = exports.recursiveCallBinarySplit = exports.binarySplitPolygon = exports.splitLine = exports.splitArea = exports.splitCircle = exports.splitArc = exports.splitRect = exports.splitToGrids = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), morphing_utils_1 = require(\"./morphing-utils\");\n\nfunction splitToGrids(width, height, count) {\n    const ratio = width / height;\n    let rowCount, columnCount;\n    width >= height ? (columnCount = Math.ceil(Math.sqrt(count * ratio)), rowCount = Math.floor(count / columnCount), \n    0 === rowCount && (rowCount = 1, columnCount = count)) : (rowCount = Math.ceil(Math.sqrt(count / ratio)), \n    columnCount = Math.floor(count / rowCount), 0 === columnCount && (columnCount = 1, \n    rowCount = count));\n    const grids = [];\n    for (let i = 0; i < rowCount; i++) grids.push(columnCount);\n    const remained = count - rowCount * columnCount;\n    if (remained > 0) for (let i = 0; i < remained; i += columnCount) i + columnCount < remained ? grids.push(columnCount) : grids.push(remained - i);\n    return grids;\n}\n\nexports.splitToGrids = splitToGrids;\n\nconst splitRect = (rect, count) => {\n    const width = rect.getComputedAttribute(\"width\"), height = rect.getComputedAttribute(\"height\"), grids = splitToGrids(width, height, count), res = [], gridHeight = height / grids.length;\n    for (let i = 0, rowCount = grids.length; i < rowCount; i++) {\n        const columnCount = grids[i], gridWidth = width / columnCount;\n        for (let j = 0; j < columnCount; j++) res.push({\n            x: 0 + j * gridWidth,\n            y: 0 + i * gridHeight,\n            width: gridWidth,\n            height: gridHeight\n        });\n    }\n    return res;\n};\n\nexports.splitRect = splitRect;\n\nconst splitArc = (arc, count) => {\n    const angles = arc.getParsedAngle(), startAngle = angles.startAngle, endAngle = angles.endAngle, innerRadius = arc.getComputedAttribute(\"innerRadius\"), outerRadius = arc.getComputedAttribute(\"outerRadius\"), angleDelta = Math.abs(startAngle - endAngle), radiusDelta = Math.abs(outerRadius - innerRadius), grids = splitToGrids(angleDelta * (innerRadius + outerRadius) / 2, radiusDelta, count), res = [], gridRadius = radiusDelta / grids.length, radiusSign = outerRadius >= innerRadius ? 1 : -1, angleSign = endAngle >= startAngle ? 1 : -1;\n    for (let i = 0, rowCount = grids.length; i < rowCount; i++) {\n        const columnCount = grids[i], gridAngle = angleDelta / columnCount;\n        for (let j = 0; j < columnCount; j++) res.push({\n            innerRadius: outerRadius - gridRadius * i * radiusSign,\n            outerRadius: outerRadius - gridRadius * (i + 1) * radiusSign,\n            startAngle: startAngle + gridAngle * j * angleSign,\n            endAngle: startAngle + gridAngle * (j + 1) * angleSign\n        });\n    }\n    return res;\n};\n\nexports.splitArc = splitArc;\n\nconst splitCircle = (arc, count) => {\n    const startAngle = arc.getComputedAttribute(\"startAngle\"), endAngle = arc.getComputedAttribute(\"endAngle\"), radius = arc.getComputedAttribute(\"radius\"), angleDelta = Math.abs(startAngle - endAngle), grids = splitToGrids(angleDelta * radius, radius, count), res = [], gridAngle = angleDelta / grids[0], gridRadius = radius / grids.length, angleSign = endAngle >= startAngle ? 1 : -1;\n    for (let i = 0, rowCount = grids.length; i < rowCount; i++) for (let j = 0, columnCount = grids[i]; j < columnCount; j++) res.push({\n        innerRadius: gridRadius * i,\n        outerRadius: gridRadius * (i + 1),\n        startAngle: startAngle + gridAngle * j * angleSign,\n        endAngle: startAngle + gridAngle * (j + 1) * angleSign\n    });\n    return res;\n};\n\nexports.splitCircle = splitCircle;\n\nconst samplingPoints = (points, count) => {\n    const validatePoints = points.filter((point => !1 !== point.defined && (0, vutils_1.isNumber)(point.x) && (0, \n    vutils_1.isNumber)(point.y)));\n    if (0 === validatePoints.length) return [];\n    if (1 === validatePoints.length) return new Array(count).fill(0).map((i => validatePoints[0]));\n    const res = [];\n    if (count <= validatePoints.length) {\n        const step = validatePoints.length / count;\n        let i = 0, cur = 0;\n        for (;i < count; ) res.push(validatePoints[Math.floor(cur)]), cur += step, i++;\n        return res;\n    }\n    const insertCount = count - validatePoints.length, insetRatio = 1 / (insertCount / (validatePoints.length - 1) + 1);\n    let curCount = 0;\n    for (let i = 0, len = points.length; i < len; i++) if (res.push(points[i]), i < len - 1) {\n        let cur = insetRatio;\n        const xCur = points[i].x, yCur = points[i].y, xNext = points[i + 1].x, yNext = points[i + 1].y;\n        for (;cur < 1 && curCount < insertCount; ) res.push({\n            x: xCur + (xNext - xCur) * cur,\n            y: yCur + (yNext - yCur) * cur\n        }), cur += insetRatio, curCount += 1;\n    }\n    return res;\n}, splitArea = (area, count) => {\n    var _a, _b;\n    const attribute = area.attribute;\n    let points = attribute.points;\n    const segements = attribute.segments;\n    points || (points = segements.reduce(((res, seg) => {\n        var _a;\n        return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);\n    }), []));\n    const validatePoints = points.filter((point => !1 !== point.defined && (0, vutils_1.isNumber)(point.x) && (0, \n    vutils_1.isNumber)(point.y)));\n    if (!validatePoints.length) return [];\n    const allPoints = [];\n    validatePoints.forEach((point => {\n        allPoints.push({\n            x: point.x,\n            y: point.y\n        });\n    }));\n    for (let i = validatePoints.length - 1; i >= 0; i--) {\n        const point = validatePoints[i];\n        allPoints.push({\n            x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,\n            y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y\n        });\n    }\n    const res = [];\n    return (0, exports.recursiveCallBinarySplit)(points, count, res), res;\n};\n\nexports.splitArea = splitArea;\n\nconst splitLine = (line, count) => {\n    const attribute = line.attribute, points = attribute.points;\n    if (points) return samplingPoints(points, count);\n    if (attribute.segments) {\n        const allPoints = attribute.segments.reduce(((res, seg) => {\n            var _a;\n            return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);\n        }), []);\n        return samplingPoints(allPoints, count);\n    }\n    return [];\n};\n\nfunction crossProduct(dir1, dir2) {\n    return dir1[0] * dir2[1] - dir1[1] * dir2[0];\n}\n\nexports.splitLine = splitLine;\n\nconst clonePoints = points => points.map((p => ({\n    x: p.x,\n    y: p.y\n}))), splitPolygonByLine = (points, p0, p1) => {\n    const len = points.length, intersections = [];\n    for (let i = 0; i < len; i++) {\n        const cur = points[i], next = i === len - 1 ? points[0] : points[i + 1], res = (0, \n        vutils_1.getIntersectPoint)([ p0.x, p0.y ], [ p1.x, p1.y ], [ cur.x, cur.y ], [ next.x, next.y ]);\n        res && \"boolean\" != typeof res && intersections.push({\n            dot: crossProduct([ res[0] - p0.x, res[1] - p0.x ], [ p1.x - p0.x, p1.y - p0.x ]),\n            point: {\n                x: res[0],\n                y: res[1]\n            },\n            edgeIndex: i\n        });\n    }\n    if (intersections.length < 2) return [ clonePoints(points), clonePoints(points) ];\n    intersections.sort(((a, b) => a.dot - b.dot));\n    let is0 = intersections[0], is1 = intersections[intersections.length - 1];\n    is0.edgeIndex > is1.edgeIndex && ([is0, is1] = [ is1, is0 ]);\n    const newP0 = is0.point, newP1 = is1.point, newPointsA = [ {\n        x: newP0.x,\n        y: newP0.y\n    } ];\n    for (let i = is0.edgeIndex + 1; i <= is1.edgeIndex; i++) newPointsA.push({\n        x: points[i].x,\n        y: points[i].y\n    });\n    newPointsA.push({\n        x: newP1.x,\n        y: newP1.y\n    });\n    const newPointsB = [ {\n        x: newP1.x,\n        y: newP1.y\n    } ];\n    for (let i = is1.edgeIndex + 1, maxIndex = is0.edgeIndex + len; i <= maxIndex; i++) {\n        const p = points[i % len];\n        newPointsB.push({\n            x: p.x,\n            y: p.y\n        });\n    }\n    return newPointsB.push({\n        x: newP0.x,\n        y: newP0.y\n    }), [ newPointsA, newPointsB ];\n}, binarySplitPolygon = points => {\n    const box = new vutils_1.Bounds;\n    points.forEach((point => {\n        box.add(point.x, point.y);\n    }));\n    const width = box.width(), height = box.height();\n    if (width >= height) {\n        const midX = box.x1 + width / 2;\n        return splitPolygonByLine(points, {\n            x: midX,\n            y: box.y1\n        }, {\n            x: midX,\n            y: box.y2\n        });\n    }\n    const midY = box.y1 + height / 2;\n    return splitPolygonByLine(points, {\n        x: box.x1,\n        y: midY\n    }, {\n        x: box.x2,\n        y: midY\n    });\n};\n\nexports.binarySplitPolygon = binarySplitPolygon;\n\nconst recursiveCallBinarySplit = (points, count, out) => {\n    if (1 === count) out.push({\n        points: points\n    }); else {\n        const half = Math.floor(count / 2), res = (0, exports.binarySplitPolygon)(points);\n        (0, exports.recursiveCallBinarySplit)(res[0], half, out), (0, exports.recursiveCallBinarySplit)(res[1], count - half, out);\n    }\n};\n\nexports.recursiveCallBinarySplit = recursiveCallBinarySplit;\n\nconst splitPolygon = (polygon, count) => {\n    const points = polygon.attribute.points;\n    if (!points || !points.length) return [];\n    if (1 === count) return [ {\n        points: clonePoints(points)\n    } ];\n    const res = [];\n    return (0, exports.recursiveCallBinarySplit)(points, count, res), res;\n};\n\nexports.splitPolygon = splitPolygon;\n\nconst splitPath = (path, count) => {\n    const pathShape = path.getParsedPathShape(), bezierCurves = (0, morphing_utils_1.pathToBezierCurves)(pathShape);\n    if (!bezierCurves.length || count < 0) return [];\n    const subPathCnt = bezierCurves.length;\n    if (bezierCurves.length >= count) {\n        const res = [], stepCount = Math.floor(bezierCurves.length / count);\n        for (let i = 0; i < count; i++) {\n            const curves = bezierCurves.slice(i * stepCount, i === count - 1 ? subPathCnt : (i + 1) * stepCount);\n            res.push({\n                path: (0, morphing_utils_1.bezierCurversToPath)(curves)\n            });\n        }\n        return res;\n    }\n    const res = [], stepCount = Math.floor(count / subPathCnt);\n    let remain = count;\n    for (let c = 0; c < subPathCnt; c++) {\n        const points = [];\n        for (let i = 2, len = bezierCurves[c].length; i < len; i += 2) points.push({\n            x: bezierCurves[0][i],\n            y: bezierCurves[0][i + 1]\n        });\n        (0, exports.recursiveCallBinarySplit)(points, c === subPathCnt - 1 ? remain : stepCount, res), \n        remain -= stepCount;\n    }\n    return res;\n};\n\nexports.splitPath = splitPath;\n//# sourceMappingURL=split-path.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.bezierCurversToPath = exports.applyTransformOnBezierCurves = exports.pathToBezierCurves = exports.alignBezierCurves = exports.findBestMorphingRotation = exports.centroidOfSubpath = exports.alignSubpath = exports.cubicSubdivide = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), custom_path2d_1 = require(\"./custom-path2d\"), path_svg_1 = require(\"./path-svg\"), arc_1 = require(\"./shape/arc\");\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n    const p01 = (p1 - p0) * t + p0, p12 = (p2 - p1) * t + p1, p23 = (p3 - p2) * t + p2, p012 = (p12 - p01) * t + p01, p123 = (p23 - p12) * t + p12, p0123 = (p123 - p012) * t + p012;\n    out[0] = p0, out[1] = p01, out[2] = p012, out[3] = p0123, out[4] = p0123, out[5] = p123, \n    out[6] = p23, out[7] = p3;\n}\n\nfunction alignSubpath(subpath1, subpath2) {\n    const len1 = subpath1.length, len2 = subpath2.length;\n    if (len1 === len2) return [ subpath1, subpath2 ];\n    const tmpSegX = [], tmpSegY = [], shorterPath = len1 < len2 ? subpath1 : subpath2, shorterLen = Math.min(len1, len2), diff = Math.abs(len2 - len1) / 6, shorterBezierCount = (shorterLen - 2) / 6, eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount), newSubpath = [ shorterPath[0], shorterPath[1] ];\n    let remained = diff;\n    for (let i = 2; i < shorterLen; i += 6) {\n        let x0 = shorterPath[i - 2], y0 = shorterPath[i - 1], x1 = shorterPath[i], y1 = shorterPath[i + 1], x2 = shorterPath[i + 2], y2 = shorterPath[i + 3];\n        const x3 = shorterPath[i + 4], y3 = shorterPath[i + 5];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        const actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;\n        for (let k = 1; k <= actualSubDivCount; k++) {\n            const p = k / actualSubDivCount;\n            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX), cubicSubdivide(y0, y1, y2, y3, p, tmpSegY), \n            x0 = tmpSegX[3], y0 = tmpSegY[3], newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0), \n            x1 = tmpSegX[5], y1 = tmpSegY[5], x2 = tmpSegX[6], y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [ newSubpath, subpath2 ] : [ subpath1, newSubpath ];\n}\n\nfunction createSubpath(lastSubpath, otherSubpath) {\n    const prevSubPath = lastSubpath || otherSubpath, len = prevSubPath.length, lastX = prevSubPath[len - 2], lastY = prevSubPath[len - 1], newSubpath = [];\n    for (let i = 0; i < otherSubpath.length; i += 2) newSubpath[i] = lastX, newSubpath[i + 1] = lastY;\n    return newSubpath;\n}\n\nfunction reverseSubpath(array) {\n    const newArr = [], len = array.length;\n    for (let i = 0; i < len; i += 2) newArr[i] = array[len - i - 2], newArr[i + 1] = array[len - i - 1];\n    return newArr;\n}\n\nfunction centroidOfSubpath(array) {\n    let signedArea = 0, cx = 0, cy = 0;\n    const len = array.length;\n    for (let i = 0, j = len - 2; i < len; j = i, i += 2) {\n        const x0 = array[j], y0 = array[j + 1], x1 = array[i], y1 = array[i + 1], a = x0 * y1 - x1 * y0;\n        signedArea += a, cx += (x0 + x1) * a, cy += (y0 + y1) * a;\n    }\n    return 0 === signedArea ? [ array[0] || 0, array[1] || 0, 0 ] : [ cx / signedArea / 3, cy / signedArea / 3, signedArea ];\n}\n\nfunction findBestRotationOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    const bezierCount = (fromSubBeziers.length - 2) / 6;\n    let bestScore = 1 / 0, bestOffset = 0;\n    const len = fromSubBeziers.length, len2 = len - 2;\n    for (let offset = 0; offset < bezierCount; offset++) {\n        const cursorOffset = 6 * offset;\n        let score = 0;\n        for (let k = 0; k < len; k += 2) {\n            const idx = 0 === k ? cursorOffset : (cursorOffset + k - 2) % len2 + 2, x0 = fromSubBeziers[idx] - fromCp[0], y0 = fromSubBeziers[idx + 1] - fromCp[1], dx = toSubBeziers[k] - toCp[0] - x0, dy = toSubBeziers[k + 1] - toCp[1] - y0;\n            score += dx * dx + dy * dy;\n        }\n        score < bestScore && (bestScore = score, bestOffset = offset);\n    }\n    return bestOffset;\n}\n\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    const result = [];\n    let fromNeedsReverse;\n    for (let i = 0; i < fromArr.length; i++) {\n        let fromSubpathBezier = fromArr[i];\n        const toSubpathBezier = toArr[i], fromCp = centroidOfSubpath(fromSubpathBezier), toCp = centroidOfSubpath(toSubpathBezier);\n        null == fromNeedsReverse && (fromNeedsReverse = fromCp[2] < 0 != toCp[2] < 0);\n        const newFromSubpathBezier = [], newToSubpathBezier = [];\n        let bestAngle = 0, bestScore = 1 / 0;\n        const tmpArr = [], len = fromSubpathBezier.length;\n        fromNeedsReverse && (fromSubpathBezier = reverseSubpath(fromSubpathBezier));\n        const offset = 6 * findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp), len2 = len - 2;\n        for (let k = 0; k < len2; k += 2) {\n            const idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0], newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        if (newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0], newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1], \n        searchAngleIteration > 0) {\n            const step = searchAngleRange / searchAngleIteration;\n            for (let angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                const sa = Math.sin(angle), ca = Math.cos(angle);\n                let score = 0;\n                for (let k = 0; k < fromSubpathBezier.length; k += 2) {\n                    const x0 = newFromSubpathBezier[k], y0 = newFromSubpathBezier[k + 1], x1 = toSubpathBezier[k] - toCp[0], y1 = toSubpathBezier[k + 1] - toCp[1], newX1 = x1 * ca - y1 * sa, newY1 = x1 * sa + y1 * ca;\n                    tmpArr[k] = newX1, tmpArr[k + 1] = newY1;\n                    const dx = newX1 - x0, dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score, bestAngle = angle;\n                    for (let m = 0; m < tmpArr.length; m++) newToSubpathBezier[m] = tmpArr[m];\n                }\n            }\n        } else for (let i = 0; i < len; i += 2) newToSubpathBezier[i] = toSubpathBezier[i] - toCp[0], \n        newToSubpathBezier[i + 1] = toSubpathBezier[i + 1] - toCp[1];\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\n\nfunction alignBezierCurves(array1, array2) {\n    let lastSubpath1, lastSubpath2;\n    const newArray1 = [], newArray2 = [];\n    for (let i = 0; i < Math.max(array1.length, array2.length); i++) {\n        const subpath1 = array1[i], subpath2 = array2[i];\n        let newSubpath1, newSubpath2;\n        subpath1 ? subpath2 ? ([newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2), \n        lastSubpath1 = newSubpath1, lastSubpath2 = newSubpath2) : (newSubpath2 = createSubpath(lastSubpath2, subpath1), \n        newSubpath1 = subpath1) : (newSubpath1 = createSubpath(lastSubpath1, subpath2), \n        newSubpath2 = subpath2), newArray1.push(newSubpath1), newArray2.push(newSubpath2);\n    }\n    return [ newArray1, newArray2 ];\n}\n\nexports.cubicSubdivide = cubicSubdivide, exports.alignSubpath = alignSubpath, exports.centroidOfSubpath = centroidOfSubpath, \nexports.findBestMorphingRotation = findBestMorphingRotation, exports.alignBezierCurves = alignBezierCurves;\n\nconst addLineToBezierPath = (bezierPath, x0, y0, x1, y1) => {\n    (0, vutils_1.isNumberClose)(x0, x1) && (0, vutils_1.isNumberClose)(y0, y1) || bezierPath.push(x0, y0, x1, y1, x1, y1);\n};\n\nfunction pathToBezierCurves(path) {\n    const commandList = path.commandList, bezierArrayGroups = [];\n    let currentSubpath, xi = 0, yi = 0, x0 = 0, y0 = 0;\n    const createNewSubpath = (x, y) => {\n        currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), \n        currentSubpath = [ x, y ];\n    };\n    let x1, y1, x2, y2;\n    for (let i = 0, len = commandList.length; i < len; i++) {\n        const cmd = commandList[i], isFirst = 0 === i;\n        switch (isFirst && (x0 = xi = cmd[1], y0 = yi = cmd[2], [ path_svg_1.enumCommandMap.L, path_svg_1.enumCommandMap.C, path_svg_1.enumCommandMap.Q ].includes(cmd[0]) && (currentSubpath = [ x0, y0 ])), \n        cmd[0]) {\n          case path_svg_1.enumCommandMap.M:\n            xi = x0 = cmd[1], yi = y0 = cmd[2], createNewSubpath(x0, y0);\n            break;\n\n          case path_svg_1.enumCommandMap.L:\n            x1 = cmd[1], y1 = cmd[2], addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xi = x1, \n            yi = y1;\n            break;\n\n          case path_svg_1.enumCommandMap.C:\n            currentSubpath.push(cmd[1], cmd[2], cmd[3], cmd[4], xi = cmd[5], yi = cmd[6]);\n            break;\n\n          case path_svg_1.enumCommandMap.Q:\n            x1 = cmd[1], y1 = cmd[2], x2 = cmd[3], y2 = cmd[4], currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2), \n            xi = x2, yi = y2;\n            break;\n\n          case path_svg_1.enumCommandMap.A:\n            {\n                const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = rx, startAngle = cmd[4], endAngle = cmd[5], counterClockwise = !!cmd[6];\n                x1 = Math.cos(startAngle) * rx + cx, y1 = Math.sin(startAngle) * rx + cy, isFirst ? (x0 = x1, \n                y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), \n                xi = Math.cos(endAngle) * rx + cx, yi = Math.sin(endAngle) * rx + cy;\n                const step = (counterClockwise ? -1 : 1) * Math.PI / 2;\n                for (let angle = startAngle; counterClockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    const nextAngle = counterClockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);\n                    (0, arc_1.addArcToBezierPath)(currentSubpath, angle, nextAngle, cx, cy, rx, ry);\n                }\n                break;\n            }\n\n          case path_svg_1.enumCommandMap.E:\n            {\n                const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = cmd[4], rotate = cmd[5], startAngle = cmd[6], endAngle = cmd[7] + startAngle, anticlockwise = !!cmd[8], hasRotate = !(0, \n                vutils_1.isNumberClose)(rotate, 0), rc = Math.cos(rotate), rs = Math.sin(rotate);\n                let xTemp = Math.cos(startAngle) * rx, yTemp = Math.sin(startAngle) * ry;\n                hasRotate ? (x1 = xTemp * rc - yTemp * rs + cx, y1 = xTemp * rs + yTemp * rc + cy) : (x1 = xTemp + cx, \n                y1 = yTemp + cy), isFirst ? (x0 = x1, y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), \n                xTemp = Math.cos(endAngle) * rx, yTemp = Math.sin(endAngle) * ry, hasRotate ? (xi = xTemp * rc - yTemp * rs + cx, \n                yi = xTemp * rs + yTemp * rc + cy) : (xi = xTemp + cx, yi = yTemp + cy);\n                const step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                for (let angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    const nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);\n                    if ((0, arc_1.addArcToBezierPath)(currentSubpath, angle, nextAngle, cx, cy, rx, ry), \n                    hasRotate) {\n                        const curLen = currentSubpath.length;\n                        for (let j = curLen - 6; j <= curLen - 1; j += 2) xTemp = currentSubpath[j], yTemp = currentSubpath[j + 1], \n                        currentSubpath[j] = (xTemp - cx) * rc - (yTemp - cy) * rs + cx, currentSubpath[j + 1] = (xTemp - cx) * rs + (yTemp - cy) * rc + cy;\n                    }\n                }\n                break;\n            }\n\n          case path_svg_1.enumCommandMap.R:\n            x0 = xi = cmd[1], y0 = yi = cmd[2], x1 = x0 + cmd[3], y1 = y0 + cmd[4], createNewSubpath(x1, y0), \n            addLineToBezierPath(currentSubpath, x1, y0, x1, y1), addLineToBezierPath(currentSubpath, x1, y1, x0, y1), \n            addLineToBezierPath(currentSubpath, x0, y1, x0, y0), addLineToBezierPath(currentSubpath, x0, y0, x1, y0);\n            break;\n\n          case path_svg_1.enumCommandMap.AT:\n            {\n                const tx1 = cmd[1], ty1 = cmd[2], tx2 = cmd[3], ty2 = cmd[4], r = cmd[5], dis1 = vutils_1.PointService.distancePP({\n                    x: xi,\n                    y: yi\n                }, {\n                    x: tx1,\n                    y: ty1\n                }), dis2 = vutils_1.PointService.distancePP({\n                    x: tx2,\n                    y: ty2\n                }, {\n                    x: tx1,\n                    y: ty1\n                }), theta = ((xi - tx1) * (tx2 - tx1) + (yi - ty1) * (ty2 - ty1)) / (dis1 * dis2), dis = r / Math.sin(theta / 2), midX = (xi + tx2 - 2 * tx1) / 2, midY = (yi + ty2 - 2 * ty1) / 2, midLen = vutils_1.PointService.distancePP({\n                    x: midX,\n                    y: midY\n                }, {\n                    x: 0,\n                    y: 0\n                }), cx = tx1 + dis * midX / midLen, cy = tx2 + dis * midY / midLen, disP = Math.sqrt(dis * dis - r * r);\n                x0 = tx1 + disP * (xi - tx1) / dis1, y0 = ty1 + disP * (yi - ty1) / dis1, addLineToBezierPath(currentSubpath, xi, yi, x0, y0), \n                xi = tx1 + disP * (tx2 - tx1) / dis2, yi = ty1 + disP * (ty2 - ty1) / dis2;\n                const startAngle = (0, vutils_1.getAngleByPoint)({\n                    x: cx,\n                    y: cy\n                }, {\n                    x: x0,\n                    y: y0\n                }), endAngle = (0, vutils_1.getAngleByPoint)({\n                    x: cx,\n                    y: cy\n                }, {\n                    x: xi,\n                    y: yi\n                });\n                (0, arc_1.addArcToBezierPath)(currentSubpath, startAngle, endAngle, cx, cy, r, r);\n                break;\n            }\n\n          case path_svg_1.enumCommandMap.Z:\n            currentSubpath && addLineToBezierPath(currentSubpath, xi, yi, x0, y0), xi = x0, \n            yi = y0;\n        }\n    }\n    return currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), \n    bezierArrayGroups;\n}\n\nfunction applyTransformOnBezierCurves(bezierCurves, martrix) {\n    for (let i = 0; i < bezierCurves.length; i++) {\n        const subPath = bezierCurves[i];\n        for (let k = 0; k < subPath.length; k += 2) {\n            const x = subPath[k], y = subPath[k + 1], res = {\n                x: x,\n                y: y\n            };\n            martrix.transformPoint({\n                x: x,\n                y: y\n            }, res), subPath[k] = res.x, subPath[k + 1] = res.y;\n        }\n    }\n}\n\nfunction bezierCurversToPath(bezierCurves) {\n    const path = new custom_path2d_1.CustomPath2D;\n    for (let i = 0; i < bezierCurves.length; i++) {\n        const subPath = bezierCurves[i];\n        if (subPath.length > 2) {\n            path.moveTo(subPath[0], subPath[1]);\n            for (let k = 2; k < subPath.length; k += 6) path.bezierCurveTo(subPath[k], subPath[k + 1], subPath[k + 2], subPath[k + 3], subPath[k + 4], subPath[k + 5]);\n        }\n    }\n    return path;\n}\n\nexports.pathToBezierCurves = pathToBezierCurves, exports.applyTransformOnBezierCurves = applyTransformOnBezierCurves, \nexports.bezierCurversToPath = bezierCurversToPath;\n//# sourceMappingURL=morphing-utils.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.colorStringInterpolationToStr = exports.interpolatePureColorArray = exports.interpolateGradientConicalColor = exports.interpolateGradientRadialColor = exports.interpolateGradientLinearColor = exports.interpolateColor = void 0;\n\nconst index_1 = require(\"./index\");\n\nfunction colorArrayToString(color, alphaChannel = !1) {\n    return Array.isArray(color) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;\n}\n\nfunction interpolateColor(from, to, ratio, alphaChannel, cb) {\n    if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || !1;\n    let fromArray, toArray, fromGradient = !1, toGradient = !1;\n    if (Array.isArray(from) ? fromArray = from : \"string\" == typeof from ? fromArray = index_1.ColorStore.Get(from, index_1.ColorType.Color255) : fromGradient = !0, \n    Array.isArray(to) ? toArray = to : \"string\" == typeof to ? toArray = index_1.ColorStore.Get(to, index_1.ColorType.Color255) : toGradient = !0, \n    fromGradient !== toGradient) {\n        const gradient = fromGradient ? from : to, pure = fromGradient ? to : from, gradientFromPure = Object.assign(Object.assign({}, gradient), {\n            stops: gradient.stops.map((v => Object.assign(Object.assign({}, v), {\n                color: colorArrayToString(pure)\n            })))\n        });\n        return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);\n    }\n    if (fromGradient) {\n        if (from.gradient === to.gradient) {\n            const fc = from, tc = to, fromStops = fc.stops, toStops = tc.stops;\n            if (fromStops.length !== toStops.length) return !1;\n            if (\"linear\" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);\n            if (\"radial\" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);\n            if (\"conical\" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);\n        }\n        return !1;\n    }\n    cb && cb(fromArray, toArray);\n    return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);\n}\n\nfunction interpolateGradientLinearColor(fc, tc, ratio) {\n    const fStops = fc.stops, tStops = tc.stops;\n    return {\n        gradient: \"linear\",\n        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,\n        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,\n        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,\n        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,\n        stops: new Array(fStops.length).fill(0).map(((_, i) => ({\n            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),\n            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio\n        })))\n    };\n}\n\nfunction interpolateGradientRadialColor(fc, tc, ratio) {\n    const fStops = fc.stops, tStops = tc.stops;\n    return {\n        gradient: \"radial\",\n        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,\n        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,\n        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,\n        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,\n        r0: fc.r0 + (tc.r0 - fc.r0) * ratio,\n        r1: fc.r1 + (tc.r1 - fc.r1) * ratio,\n        stops: new Array(fStops.length).fill(0).map(((_, i) => ({\n            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),\n            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio\n        })))\n    };\n}\n\nfunction interpolateGradientConicalColor(fc, tc, ratio) {\n    const fStops = fc.stops, tStops = tc.stops;\n    return {\n        gradient: \"conical\",\n        startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,\n        endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,\n        x: fc.x + (tc.x - fc.x) * ratio,\n        y: fc.y + (tc.y - fc.y) * ratio,\n        stops: new Array(fStops.length).fill(0).map(((_, i) => ({\n            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),\n            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio\n        })))\n    };\n}\n\nfunction interpolatePureColorArray(from, to, ratio) {\n    return [ from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio ];\n}\n\nexports.interpolateColor = interpolateColor, exports.interpolateGradientLinearColor = interpolateGradientLinearColor, \nexports.interpolateGradientRadialColor = interpolateGradientRadialColor, exports.interpolateGradientConicalColor = interpolateGradientConicalColor, \nexports.interpolatePureColorArray = interpolatePureColorArray;\n\nconst _fromColorRGB = [ 0, 0, 0, 0 ], _toColorRGB = [ 0, 0, 0, 0 ];\n\nfunction colorStringInterpolationToStr(fromColor, toColor, ratio) {\n    return index_1.ColorStore.Get(fromColor, index_1.ColorType.Color255, _fromColorRGB), \n    index_1.ColorStore.Get(toColor, index_1.ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;\n}\n\nexports.colorStringInterpolationToStr = colorStringInterpolationToStr;\n//# sourceMappingURL=interpolate.js.map","\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.ColorStore = exports.ColorType = exports.colorEqual = exports.colorString = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), colorName_1 = __importDefault(require(\"./colorName\")), reverseNames = {};\n\nfor (const name in colorName_1.default) (0, vutils_1.has)(colorName_1.default, name) && (reverseNames[colorName_1.default[name]] = name);\n\nconst cs = {\n    to: {},\n    get: {}\n};\n\nfunction clamp(num, min, max) {\n    return Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n    const str = num.toString(16).toUpperCase();\n    return str.length < 2 ? \"0\" + str : str;\n}\n\nfunction colorEqual(color1, color2) {\n    const {value: c1 = [ 0, 0, 0, 0 ]} = cs.get(color1) || {}, {value: c2 = [ 0, 0, 0, 0 ]} = cs.get(color2) || {};\n    return c1.every(((item, index) => item === c2[index]));\n}\n\nvar ColorType;\n\ncs.get = function(str, arr = [ 0, 0, 0, 1 ]) {\n    let val, model;\n    switch (str.substring(0, 3).toLowerCase()) {\n      case \"hsl\":\n        val = cs.get.hsl(str, arr), model = \"hsl\";\n        break;\n\n      case \"hwb\":\n        val = cs.get.hwb(str, arr), model = \"hwb\";\n        break;\n\n      default:\n        val = cs.get.rgb(str, arr), model = \"rgb\";\n    }\n    return val ? {\n        model: model,\n        value: val\n    } : null;\n}, cs.get.rgb = function(str, arr = [ 0, 0, 0, 1 ]) {\n    if (!str) return null;\n    const rgb = arr;\n    let match, i, hexAlpha;\n    if (match = str.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)) {\n        for (hexAlpha = match[2], match = match[1], i = 0; i < 3; i++) {\n            const i2 = 2 * i;\n            rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);\n        }\n        hexAlpha && (rgb[3] = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100);\n    } else if (match = str.match(/^#([a-f0-9]{3,4})$/i)) {\n        for (match = match[1], hexAlpha = match[3], i = 0; i < 3; i++) rgb[i] = parseInt(match[i] + match[i], 16);\n        hexAlpha && (rgb[3] = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100);\n    } else if (match = str.match(/^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d.]+)\\s*)?\\)$/)) {\n        for (i = 0; i < 3; i++) rgb[i] = parseInt(match[i + 1], 10);\n        match[4] && (rgb[3] = parseFloat(match[4]));\n    } else {\n        if (!(match = str.match(/^rgba?\\(\\s*([+-]?[\\d.]+)%\\s*,\\s*([+-]?[\\d.]+)%\\s*,\\s*([+-]?[\\d.]+)%\\s*(?:,\\s*([+-]?[\\d.]+)\\s*)?\\)$/))) {\n            if (match = str.match(/(\\D+)/)) {\n                if (\"transparent\" === match[1]) return [ 0, 0, 0, 0 ];\n                const _color = colorName_1.default[match[1]];\n                return rgb[0] = _color[0], rgb[1] = _color[1], rgb[2] = _color[2], rgb[3] = _color[3], \n                rgb ? (rgb[3] = 1, rgb) : null;\n            }\n            return null;\n        }\n        for (i = 0; i < 3; i++) rgb[i] = Math.round(2.55 * parseFloat(match[i + 1]));\n        match[4] && (rgb[3] = parseFloat(match[4]));\n    }\n    for (i = 0; i < 3; i++) rgb[i] = clamp(rgb[i], 0, 255);\n    return rgb[3] = clamp(rgb[3], 0, 1), rgb;\n}, cs.get.hsl = function(str, arr = [ 0, 0, 0, 1 ]) {\n    if (!str) return null;\n    const match = str.match(/^hsla?\\(\\s*([+-]?(?:\\d*\\.)?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d.]+)%\\s*,\\s*([+-]?[\\d.]+)%\\s*(?:,\\s*([+-]?[\\d.]+)\\s*)?\\)$/);\n    if (match) {\n        const alpha = parseFloat(match[4]);\n        return arr[0] = (parseFloat(match[1]) + 360) % 360, arr[1] = clamp(parseFloat(match[2]), 0, 100), \n        arr[2] = clamp(parseFloat(match[3]), 0, 100), arr[3] = clamp(isNaN(alpha) ? 1 : alpha, 0, 1), \n        arr;\n    }\n    return null;\n}, cs.get.hwb = function(str, arr = [ 0, 0, 0, 1 ]) {\n    if (!str) return null;\n    const match = str.match(/^hwb\\(\\s*([+-]?\\d*[.]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d.]+)%\\s*,\\s*([+-]?[\\d.]+)%\\s*(?:,\\s*([+-]?[\\d.]+)\\s*)?\\)$/);\n    if (match) {\n        const alpha = parseFloat(match[4]);\n        return arr[0] = (parseFloat(match[1]) % 360 + 360) % 360, arr[1] = clamp(parseFloat(match[2]), 0, 100), \n        arr[2] = clamp(parseFloat(match[3]), 0, 100), arr[3] = clamp(isNaN(alpha) ? 1 : alpha, 0, 1), \n        arr;\n    }\n    return null;\n}, cs.to.hex = function(...args) {\n    const rgba = args;\n    return \"#\" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(255 * rgba[3])) : \"\");\n}, cs.to.rgb = function(...args) {\n    const rgba = args;\n    return rgba.length < 4 || 1 === rgba[3] ? \"rgb(\" + Math.round(rgba[0]) + \", \" + Math.round(rgba[1]) + \", \" + Math.round(rgba[2]) + \")\" : \"rgba(\" + Math.round(rgba[0]) + \", \" + Math.round(rgba[1]) + \", \" + Math.round(rgba[2]) + \", \" + rgba[3] + \")\";\n}, cs.to.rgb.percent = function(...args) {\n    const rgba = args, r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);\n    return rgba.length < 4 || 1 === rgba[3] ? \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\" : \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + rgba[3] + \")\";\n}, cs.to.hsl = function(...args) {\n    const hsla = args;\n    return hsla.length < 4 || 1 === hsla[3] ? \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\" : \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \" + hsla[3] + \")\";\n}, cs.to.hwb = function(...args) {\n    const hwba = args;\n    let a = \"\";\n    return hwba.length >= 4 && 1 !== hwba[3] && (a = \", \" + hwba[3]), \"hwb(\" + hwba[0] + \", \" + hwba[1] + \"%, \" + hwba[2] + \"%\" + a + \")\";\n}, cs.to.keyword = function(rgb) {\n    return reverseNames[rgb.slice(0, 3)];\n}, exports.default = cs, exports.colorString = cs, exports.colorEqual = colorEqual, \nfunction(ColorType) {\n    ColorType[ColorType.Color255 = 0] = \"Color255\", ColorType[ColorType.Color1 = 1] = \"Color1\";\n}(ColorType = exports.ColorType || (exports.ColorType = {}));\n\nclass ColorStore {\n    static Get(str, size = ColorType.Color1, arr = [ 0, 0, 0, 1 ]) {\n        if (size === ColorType.Color1) {\n            let color = ColorStore.store1[str];\n            if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], \n            arr;\n            if (color = cs.get(str), color && color.value) {\n                const value = color.value, data = [ value[0] / 255, value[1] / 255, value[2] / 255, value[3] ];\n                ColorStore.store1[str] = data, ColorStore.store255[str] = value, arr[0] = data[0], \n                arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];\n            }\n            return arr;\n        }\n        let color = ColorStore.store255[str];\n        if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], \n        arr;\n        if (color = cs.get(str), color && color.value) {\n            const value = color.value;\n            ColorStore.store1[str] = [ value[0] / 255, value[1] / 255, value[2] / 255, value[3] ], \n            ColorStore.store255[str] = value, arr[0] = value[0], arr[1] = value[1], arr[2] = value[2], \n            arr[3] = value[3];\n        }\n        return arr;\n    }\n    static Set(str, size, arr) {\n        if (size === ColorType.Color1) {\n            if (ColorStore.store1[str]) return;\n            ColorStore.store1[str] = arr, ColorStore.store255[str] = [ Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3]) ];\n        } else {\n            if (ColorStore.store255[str]) return;\n            ColorStore.store255[str] = arr, ColorStore.store1[str] = [ arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3] ];\n        }\n    }\n}\n\nexports.ColorStore = ColorStore, ColorStore.store255 = {}, ColorStore.store1 = {};\n//# sourceMappingURL=index.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.default = {\n    aliceblue: [ 240, 248, 255 ],\n    antiquewhite: [ 250, 235, 215 ],\n    aqua: [ 0, 255, 255 ],\n    aquamarine: [ 127, 255, 212 ],\n    azure: [ 240, 255, 255 ],\n    beige: [ 245, 245, 220 ],\n    bisque: [ 255, 228, 196 ],\n    black: [ 0, 0, 0 ],\n    blanchedalmond: [ 255, 235, 205 ],\n    blue: [ 0, 0, 255 ],\n    blueviolet: [ 138, 43, 226 ],\n    brown: [ 165, 42, 42 ],\n    burlywood: [ 222, 184, 135 ],\n    cadetblue: [ 95, 158, 160 ],\n    chartreuse: [ 127, 255, 0 ],\n    chocolate: [ 210, 105, 30 ],\n    coral: [ 255, 127, 80 ],\n    cornflowerblue: [ 100, 149, 237 ],\n    cornsilk: [ 255, 248, 220 ],\n    crimson: [ 220, 20, 60 ],\n    cyan: [ 0, 255, 255 ],\n    darkblue: [ 0, 0, 139 ],\n    darkcyan: [ 0, 139, 139 ],\n    darkgoldenrod: [ 184, 134, 11 ],\n    darkgray: [ 169, 169, 169 ],\n    darkgreen: [ 0, 100, 0 ],\n    darkgrey: [ 169, 169, 169 ],\n    darkkhaki: [ 189, 183, 107 ],\n    darkmagenta: [ 139, 0, 139 ],\n    darkolivegreen: [ 85, 107, 47 ],\n    darkorange: [ 255, 140, 0 ],\n    darkorchid: [ 153, 50, 204 ],\n    darkred: [ 139, 0, 0 ],\n    darksalmon: [ 233, 150, 122 ],\n    darkseagreen: [ 143, 188, 143 ],\n    darkslateblue: [ 72, 61, 139 ],\n    darkslategray: [ 47, 79, 79 ],\n    darkslategrey: [ 47, 79, 79 ],\n    darkturquoise: [ 0, 206, 209 ],\n    darkviolet: [ 148, 0, 211 ],\n    deeppink: [ 255, 20, 147 ],\n    deepskyblue: [ 0, 191, 255 ],\n    dimgray: [ 105, 105, 105 ],\n    dimgrey: [ 105, 105, 105 ],\n    dodgerblue: [ 30, 144, 255 ],\n    firebrick: [ 178, 34, 34 ],\n    floralwhite: [ 255, 250, 240 ],\n    forestgreen: [ 34, 139, 34 ],\n    fuchsia: [ 255, 0, 255 ],\n    gainsboro: [ 220, 220, 220 ],\n    ghostwhite: [ 248, 248, 255 ],\n    gold: [ 255, 215, 0 ],\n    goldenrod: [ 218, 165, 32 ],\n    gray: [ 128, 128, 128 ],\n    green: [ 0, 128, 0 ],\n    greenyellow: [ 173, 255, 47 ],\n    grey: [ 128, 128, 128 ],\n    honeydew: [ 240, 255, 240 ],\n    hotpink: [ 255, 105, 180 ],\n    indianred: [ 205, 92, 92 ],\n    indigo: [ 75, 0, 130 ],\n    ivory: [ 255, 255, 240 ],\n    khaki: [ 240, 230, 140 ],\n    lavender: [ 230, 230, 250 ],\n    lavenderblush: [ 255, 240, 245 ],\n    lawngreen: [ 124, 252, 0 ],\n    lemonchiffon: [ 255, 250, 205 ],\n    lightblue: [ 173, 216, 230 ],\n    lightcoral: [ 240, 128, 128 ],\n    lightcyan: [ 224, 255, 255 ],\n    lightgoldenrodyellow: [ 250, 250, 210 ],\n    lightgray: [ 211, 211, 211 ],\n    lightgreen: [ 144, 238, 144 ],\n    lightgrey: [ 211, 211, 211 ],\n    lightpink: [ 255, 182, 193 ],\n    lightsalmon: [ 255, 160, 122 ],\n    lightseagreen: [ 32, 178, 170 ],\n    lightskyblue: [ 135, 206, 250 ],\n    lightslategray: [ 119, 136, 153 ],\n    lightslategrey: [ 119, 136, 153 ],\n    lightsteelblue: [ 176, 196, 222 ],\n    lightyellow: [ 255, 255, 224 ],\n    lime: [ 0, 255, 0 ],\n    limegreen: [ 50, 205, 50 ],\n    linen: [ 250, 240, 230 ],\n    magenta: [ 255, 0, 255 ],\n    maroon: [ 128, 0, 0 ],\n    mediumaquamarine: [ 102, 205, 170 ],\n    mediumblue: [ 0, 0, 205 ],\n    mediumorchid: [ 186, 85, 211 ],\n    mediumpurple: [ 147, 112, 219 ],\n    mediumseagreen: [ 60, 179, 113 ],\n    mediumslateblue: [ 123, 104, 238 ],\n    mediumspringgreen: [ 0, 250, 154 ],\n    mediumturquoise: [ 72, 209, 204 ],\n    mediumvioletred: [ 199, 21, 133 ],\n    midnightblue: [ 25, 25, 112 ],\n    mintcream: [ 245, 255, 250 ],\n    mistyrose: [ 255, 228, 225 ],\n    moccasin: [ 255, 228, 181 ],\n    navajowhite: [ 255, 222, 173 ],\n    navy: [ 0, 0, 128 ],\n    oldlace: [ 253, 245, 230 ],\n    olive: [ 128, 128, 0 ],\n    olivedrab: [ 107, 142, 35 ],\n    orange: [ 255, 165, 0 ],\n    orangered: [ 255, 69, 0 ],\n    orchid: [ 218, 112, 214 ],\n    palegoldenrod: [ 238, 232, 170 ],\n    palegreen: [ 152, 251, 152 ],\n    paleturquoise: [ 175, 238, 238 ],\n    palevioletred: [ 219, 112, 147 ],\n    papayawhip: [ 255, 239, 213 ],\n    peachpuff: [ 255, 218, 185 ],\n    peru: [ 205, 133, 63 ],\n    pink: [ 255, 192, 203 ],\n    plum: [ 221, 160, 221 ],\n    powderblue: [ 176, 224, 230 ],\n    purple: [ 128, 0, 128 ],\n    rebeccapurple: [ 102, 51, 153 ],\n    red: [ 255, 0, 0 ],\n    rosybrown: [ 188, 143, 143 ],\n    royalblue: [ 65, 105, 225 ],\n    saddlebrown: [ 139, 69, 19 ],\n    salmon: [ 250, 128, 114 ],\n    sandybrown: [ 244, 164, 96 ],\n    seagreen: [ 46, 139, 87 ],\n    seashell: [ 255, 245, 238 ],\n    sienna: [ 160, 82, 45 ],\n    silver: [ 192, 192, 192 ],\n    skyblue: [ 135, 206, 235 ],\n    slateblue: [ 106, 90, 205 ],\n    slategray: [ 112, 128, 144 ],\n    slategrey: [ 112, 128, 144 ],\n    snow: [ 255, 250, 250 ],\n    springgreen: [ 0, 255, 127 ],\n    steelblue: [ 70, 130, 180 ],\n    tan: [ 210, 180, 140 ],\n    teal: [ 0, 128, 128 ],\n    thistle: [ 216, 191, 216 ],\n    tomato: [ 255, 99, 71 ],\n    turquoise: [ 64, 224, 208 ],\n    violet: [ 238, 130, 238 ],\n    wheat: [ 245, 222, 179 ],\n    white: [ 255, 255, 255 ],\n    whitesmoke: [ 245, 245, 245 ],\n    yellow: [ 255, 255, 0 ],\n    yellowgreen: [ 154, 205, 50 ]\n};\n//# sourceMappingURL=colorName.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.ResourceLoader = void 0;\n\nconst application_1 = require(\"../application\");\n\nclass ResourceLoader {\n    static GetImage(url, mark) {\n        var _a;\n        let data = ResourceLoader.cache.get(url);\n        data ? \"fail\" === data.loadState ? application_1.application.global.getRequestAnimationFrame()((() => {\n            mark.imageLoadFail(url);\n        })) : \"init\" === data.loadState || \"loading\" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && application_1.application.global.getRequestAnimationFrame()((() => {\n            mark.imageLoadSuccess(url, data.data);\n        })) : (data = {\n            type: \"image\",\n            loadState: \"init\"\n        }, ResourceLoader.cache.set(url, data), data.dataPromise = application_1.application.global.loadImage(url), \n        data.dataPromise ? (data.waitingMark = [ mark ], data.dataPromise.then((res => {\n            var _a;\n            data.loadState = (null == res ? void 0 : res.data) ? \"success\" : \"fail\", data.data = null == res ? void 0 : res.data, \n            null === (_a = data.waitingMark) || void 0 === _a || _a.map(((mark, index) => {\n                (null == res ? void 0 : res.data) ? (data.loadState = \"success\", data.data = res.data, \n                mark.imageLoadSuccess(url, res.data)) : (data.loadState = \"fail\", mark.imageLoadFail(url));\n            }));\n        }))) : (data.loadState = \"fail\", mark.imageLoadFail(url)));\n    }\n    static GetSvg(svgStr, mark) {\n        var _a;\n        let data = ResourceLoader.cache.get(svgStr);\n        data ? \"fail\" === data.loadState ? application_1.application.global.getRequestAnimationFrame()((() => {\n            mark.imageLoadFail(svgStr);\n        })) : \"init\" === data.loadState || \"loading\" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && application_1.application.global.getRequestAnimationFrame()((() => {\n            mark.imageLoadSuccess(svgStr, data.data);\n        })) : (data = {\n            type: \"image\",\n            loadState: \"init\"\n        }, ResourceLoader.cache.set(svgStr, data), data.dataPromise = application_1.application.global.loadSvg(svgStr), \n        data.dataPromise ? (data.waitingMark = [ mark ], data.dataPromise.then((res => {\n            var _a;\n            data.loadState = (null == res ? void 0 : res.data) ? \"success\" : \"fail\", data.data = null == res ? void 0 : res.data, \n            null === (_a = data.waitingMark) || void 0 === _a || _a.map(((mark, index) => {\n                (null == res ? void 0 : res.data) ? (data.loadState = \"success\", data.data = res.data, \n                mark.imageLoadSuccess(svgStr, res.data)) : (data.loadState = \"fail\", mark.imageLoadFail(svgStr));\n            }));\n        }))) : (data.loadState = \"fail\", mark.imageLoadFail(svgStr)));\n    }\n    static GetFile(url, type) {\n        let data = ResourceLoader.cache.get(url);\n        return data ? \"init\" === data.loadState || \"fail\" === data.loadState ? Promise.reject() : \"loading\" === data.loadState ? data.dataPromise.then((data => data.data)) : Promise.resolve(data.data) : (data = {\n            type: type,\n            loadState: \"init\"\n        }, ResourceLoader.cache.set(url, data), \"arrayBuffer\" === type ? data.dataPromise = application_1.application.global.loadArrayBuffer(url) : \"blob\" === type ? data.dataPromise = application_1.application.global.loadBlob(url) : \"json\" === type && (data.dataPromise = application_1.application.global.loadJson(url)), \n        data.dataPromise.then((data => data.data)));\n    }\n}\n\nexports.ResourceLoader = ResourceLoader, ResourceLoader.cache = new Map;\n//# sourceMappingURL=loader.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.GraphicCreator = exports.GraphicService = exports.TEXT_NUMBER_TYPE = exports.SYMBOL_NUMBER_TYPE = exports.RICHTEXT_NUMBER_TYPE = exports.RECT3D_NUMBER_TYPE = exports.RECT_NUMBER_TYPE = exports.PYRAMID3D_NUMBER_TYPE = exports.POLYGON_NUMBER_TYPE = exports.PATH_NUMBER_TYPE = exports.LINE_NUMBER_TYPE = exports.IMAGE_NUMBER_TYPE = exports.GROUP_NUMBER_TYPE = exports.GLYPH_NUMBER_TYPE = exports.CIRCLE_NUMBER_TYPE = exports.AREA_NUMBER_TYPE = exports.ARC3D_NUMBER_TYPE = exports.ARC_NUMBER_TYPE = void 0;\n\nconst tools_1 = require(\"./tools\");\n\nexports.ARC_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.ARC3D_NUMBER_TYPE = (0, \ntools_1.genNumberType)(), exports.AREA_NUMBER_TYPE = (0, tools_1.genNumberType)(), \nexports.CIRCLE_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.GLYPH_NUMBER_TYPE = (0, \ntools_1.genNumberType)(), exports.GROUP_NUMBER_TYPE = (0, tools_1.genNumberType)(), \nexports.IMAGE_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.LINE_NUMBER_TYPE = (0, \ntools_1.genNumberType)(), exports.PATH_NUMBER_TYPE = (0, tools_1.genNumberType)(), \nexports.POLYGON_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.PYRAMID3D_NUMBER_TYPE = (0, \ntools_1.genNumberType)(), exports.RECT_NUMBER_TYPE = (0, tools_1.genNumberType)(), \nexports.RECT3D_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.RICHTEXT_NUMBER_TYPE = (0, \ntools_1.genNumberType)(), exports.SYMBOL_NUMBER_TYPE = (0, tools_1.genNumberType)(), \nexports.TEXT_NUMBER_TYPE = (0, tools_1.genNumberType)(), exports.GraphicService = Symbol.for(\"GraphicService\"), \nexports.GraphicCreator = Symbol.for(\"GraphicCreator\");\n//# sourceMappingURL=constants.js.map\n","\n\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))((function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            var value;\n            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {\n                resolve(value);\n            }))).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    }));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.genNumberType = exports.boundStroke = exports.waitForAllSubLayers = exports.incrementalAddTo = void 0;\n\nconst application_1 = require(\"../application\");\n\nfunction incrementalAddTo(group, graphic) {\n    group.incrementalAppendChild(graphic);\n}\n\nfunction waitForAllSubLayers(stage) {\n    return __awaiter(this, void 0, void 0, (function*() {\n        const promiseList = [], layers = stage.getChildren();\n        yield new Promise((resolve => {\n            application_1.application.global.getRequestAnimationFrame()((() => {\n                resolve(null);\n            }));\n        })), layers.forEach((l => {\n            l.subLayers.size && l.subLayers.forEach((sl => {\n                sl.drawContribution && sl.drawContribution.hooks && sl.drawContribution.rendering && promiseList.push(new Promise((resolve => {\n                    sl.drawContribution.hooks.completeDraw.tap(\"outWait\", (() => {\n                        sl.drawContribution.hooks.completeDraw.taps = sl.drawContribution.hooks.completeDraw.taps.filter((i => \"outWait\" !== i.name)), \n                        resolve(null);\n                    }));\n                })));\n            }));\n        })), yield Promise.all(promiseList);\n    }));\n}\n\nfunction boundStroke(bounds, halfW, miter, pad = 0) {\n    return bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), \n    bounds;\n}\n\nfunction miterAdjustment(miter, strokeWidth) {\n    return miter ? strokeWidth : 0;\n}\n\nexports.incrementalAddTo = incrementalAddTo, exports.waitForAllSubLayers = waitForAllSubLayers, \nexports.boundStroke = boundStroke;\n\nlet NUMBER_TYPE = 0;\n\nfunction genNumberType() {\n    return NUMBER_TYPE++;\n}\n\nexports.genNumberType = genNumberType;\n//# sourceMappingURL=tools.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultWindow = exports.WindowHandlerContribution = exports.Window = void 0;\n\nconst inversify_1 = require(\"inversify\"), generator_1 = require(\"../common/generator\"), container_1 = require(\"../container\"), tapable_1 = require(\"../tapable\"), constants_1 = require(\"../constants\");\n\nexports.Window = Symbol.for(\"Window\"), exports.WindowHandlerContribution = Symbol.for(\"WindowHandlerContribution\");\n\nlet DefaultWindow = class {\n    get width() {\n        if (this._handler) {\n            const wh = this._handler.getWH();\n            return this._width = wh.width;\n        }\n        return this._width;\n    }\n    get height() {\n        if (this._handler) {\n            const wh = this._handler.getWH();\n            return this._height = wh.height;\n        }\n        return this._height;\n    }\n    get dpr() {\n        return this._handler.getDpr();\n    }\n    constructor(global) {\n        this.global = global, this.hooks = {\n            onChange: new tapable_1.SyncHook([ \"x\", \"y\", \"width\", \"height\" ])\n        }, this._uid = generator_1.Generator.GenAutoIncrementId();\n    }\n    postInit() {\n        this.global.hooks.onSetEnv.tap(\"window\", (() => {\n            this.active();\n        })), this.active();\n    }\n    active() {\n        const global = this.global;\n        if (!global.env || this.actived) return;\n        container_1.container.getNamed(exports.WindowHandlerContribution, global.env).configure(this, global), \n        this.actived = !0;\n    }\n    get style() {\n        return this._handler.getStyle();\n    }\n    set style(style) {\n        this._handler.setStyle(style);\n    }\n    create(params) {\n        this._handler.createWindow(params);\n        const windowWH = this._handler.getWH();\n        this._width = windowWH.width, this._height = windowWH.height, this.title = this._handler.getTitle(), \n        this.resizable = !0;\n    }\n    setWindowHandler(handler) {\n        this._handler = handler;\n    }\n    setDpr(dpr) {\n        return this._handler.setDpr(dpr);\n    }\n    resize(w, h) {\n        return this._handler.resizeWindow(w, h);\n    }\n    configure() {\n        throw new Error(\"\");\n    }\n    release() {\n        return this._handler.releaseWindow();\n    }\n    getContext() {\n        return this._handler.getContext();\n    }\n    getNativeHandler() {\n        return this._handler.getNativeHandler();\n    }\n    getImageBuffer(type) {\n        return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;\n    }\n    addEventListener(type, listener, options) {\n        return this._handler.addEventListener(type, listener, options);\n    }\n    removeEventListener(type, listener, options) {\n        return this._handler.removeEventListener(type, listener, options);\n    }\n    dispatchEvent(event) {\n        return this._handler.dispatchEvent(event);\n    }\n    getBoundingClientRect() {\n        return this._handler.getBoundingClientRect();\n    }\n    getContainer() {\n        return this._handler.container;\n    }\n    clearViewBox(viewBox, color) {\n        this._handler.clearViewBox(viewBox, color);\n    }\n};\n\n__decorate([ (0, inversify_1.postConstruct)(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0) ], DefaultWindow.prototype, \"postInit\", null), \nDefaultWindow = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultWindow), \nexports.DefaultWindow = DefaultWindow;\n//# sourceMappingURL=window.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.LayerService = exports.GraphicUtil = exports.TransformUtil = void 0, \nexports.TransformUtil = Symbol.for(\"TransformUtil\"), exports.GraphicUtil = Symbol.for(\"GraphicUtil\"), \nexports.LayerService = Symbol.for(\"LayerService\");\n//# sourceMappingURL=constants.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), render_service_1 = require(\"./render-service\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(render_service_1.DefaultRenderService).toSelf(), bind(render_service_1.RenderService).toService(render_service_1.DefaultRenderService);\n}));\n//# sourceMappingURL=render-modules.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultRenderService = exports.BeforeRenderConstribution = exports.RenderService = void 0;\n\nconst inversify_1 = require(\"inversify\"), render_1 = require(\"./contributions/render\");\n\nexports.RenderService = Symbol.for(\"RenderService\"), exports.BeforeRenderConstribution = Symbol.for(\"BeforeRenderConstribution\");\n\nlet DefaultRenderService = class {\n    constructor(drawContribution) {\n        this.drawContribution = drawContribution;\n    }\n    prepare(updateBounds) {\n        this.renderTreeRoots.forEach((g => {\n            this._prepare(g, updateBounds);\n        }));\n    }\n    _prepare(g, updateBounds) {\n        g.forEachChildren((g => {\n            this._prepare(g, updateBounds);\n        })), g.update({\n            bounds: updateBounds,\n            trans: !0\n        });\n    }\n    prepareRenderList() {}\n    beforeDraw(params) {}\n    draw(params) {\n        this.drawContribution.draw(this, Object.assign({}, this.drawParams));\n    }\n    afterDraw(params) {}\n    render(groups, params) {\n        this.renderTreeRoots = groups, this.drawParams = params;\n        const updateBounds = params.updateBounds;\n        this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params), this.draw(params), \n        this.afterDraw(params);\n    }\n};\n\nDefaultRenderService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.DrawContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultRenderService), \nexports.DefaultRenderService = DefaultRenderService;\n//# sourceMappingURL=render-service.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./arc-render\"), exports), __exportStar(require(\"./circle-render\"), exports), \n__exportStar(require(\"./line-render\"), exports), __exportStar(require(\"./area-render\"), exports), \n__exportStar(require(\"./path-render\"), exports), __exportStar(require(\"./rect-render\"), exports), \n__exportStar(require(\"./symbol-render\"), exports), __exportStar(require(\"./text-render\"), exports), \n__exportStar(require(\"./graphic-render\"), exports), __exportStar(require(\"./polygon-render\"), exports), \n__exportStar(require(\"./image-render\"), exports), __exportStar(require(\"./symbol\"), exports), \n__exportStar(require(\"./contributions\"), exports), __exportStar(require(\"./utils\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasArcRender = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), utils_1 = require(\"../../../common/utils\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), utils_2 = require(\"./utils\"), conical_gradient_1 = require(\"../../../canvas/contributions/browser/conical-gradient\"), arc_contribution_render_1 = require(\"./contributions/arc-contribution-render\"), enums_1 = require(\"../../../common/enums\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasArcRender = class {\n    constructor(arcRenderContribitions) {\n        this.arcRenderContribitions = arcRenderContribitions, this.numberType = constants_1.ARC_NUMBER_TYPE;\n    }\n    drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {\n        const capAngle = _ea - _sa, data = arc.getParsedAngle(), startAngle = data.startAngle;\n        let endAngle = data.endAngle;\n        endAngle = _ea;\n        const deltaAngle = (0, vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;\n        let collapsedToLine = !1;\n        if (outerRadius < innerRadius) {\n            const temp = outerRadius;\n            outerRadius = innerRadius, innerRadius = temp;\n        }\n        const cornerRadius = arc.getParsedCornerRadius(), {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);\n        let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;\n        const xors = outerRadius * (0, vutils_1.cos)(outerStartAngle), yors = outerRadius * (0, \n        vutils_1.sin)(outerStartAngle), xire = innerRadius * (0, vutils_1.cos)(innerEndAngle), yire = innerRadius * (0, \n        vutils_1.sin)(innerEndAngle);\n        let xore, yore, xirs, yirs;\n        if ((maxInnerCornerRadius > vutils_1.epsilon || maxOuterCornerRadius > vutils_1.epsilon) && (xore = outerRadius * (0, \n        vutils_1.cos)(outerEndAngle), yore = outerRadius * (0, vutils_1.sin)(outerEndAngle), \n        xirs = innerRadius * (0, vutils_1.cos)(innerStartAngle), yirs = innerRadius * (0, \n        vutils_1.sin)(innerStartAngle), deltaAngle < vutils_1.pi)) {\n            const oc = (0, utils_2.intersect)(xors, yors, xirs, yirs, xore, yore, xire, yire);\n            if (oc) {\n                const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / (0, \n                vutils_1.sin)((0, vutils_1.acos)((ax * bx + ay * by) / ((0, vutils_1.sqrt)(ax * ax + ay * ay) * (0, \n                vutils_1.sqrt)(bx * bx + by * by))) / 2), lc = (0, vutils_1.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);\n                limitedIcr = (0, vutils_1.min)(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), \n                limitedOcr = (0, vutils_1.min)(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));\n            }\n        }\n        if (limitedOcr > vutils_1.epsilon) {\n            const cornerRadiusStart = (0, vutils_1.min)(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = (0, \n            vutils_1.min)(outerCornerRadiusEnd, limitedOcr), t0 = (0, utils_2.cornerTangents)(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = (0, \n            utils_2.cornerTangents)(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));\n            if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), \n            context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, (0, vutils_1.atan2)(t0.y01, t0.x01), (0, \n            vutils_1.atan2)(t1.y01, t1.x01), !clockwise); else {\n                const a1 = endAngle - capAngle - .03, a2 = (0, vutils_1.atan2)(t1.y11, t1.x11);\n                context.arc(cx, cy, outerRadius, a1, a2, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, (0, \n                vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise);\n            }\n        } else context.moveTo(cx + xors, cy + yors);\n        if (!(innerRadius > vutils_1.epsilon) || innerDeltaAngle < .001) context.lineTo(cx + xire, cy + yire), \n        collapsedToLine = !0; else if (limitedIcr > vutils_1.epsilon) {\n            const cornerRadiusStart = (0, vutils_1.min)(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = (0, \n            vutils_1.min)(innerCornerRadiusEnd, limitedIcr), t0 = (0, utils_2.cornerTangents)(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = (0, \n            utils_2.cornerTangents)(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));\n            if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {\n                const arcEndAngle = (0, vutils_1.atan2)(t1.y01, t1.x01);\n                context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, (0, vutils_1.atan2)(t0.y01, t0.x01), arcEndAngle, !clockwise);\n            } else {\n                cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, (0, \n                vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise);\n                const a1 = (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), a2 = endAngle - capAngle - .03;\n                context.arc(cx, cy, innerRadius, a1, a2, clockwise);\n            }\n        } else context.lineTo(cx + innerRadius * (0, vutils_1.cos)(innerStartAngle), cy + innerRadius * (0, \n        vutils_1.sin)(innerStartAngle));\n        return collapsedToLine;\n    }\n    drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {\n        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc, {fill: fill = arcAttribute.fill, background: background, stroke: stroke = arcAttribute.stroke, opacity: opacity = arcAttribute.opacity, fillOpacity: fillOpacity = arcAttribute.fillOpacity, lineWidth: lineWidth = arcAttribute.lineWidth, strokeOpacity: strokeOpacity = arcAttribute.strokeOpacity, visible: visible = arcAttribute.visible, x: originX = arcAttribute.x, y: originY = arcAttribute.y} = arc.attribute, fVisible = (0, \n        utils_2.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_2.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n        utils_2.runFill)(fill), doStroke = (0, utils_2.runStroke)(stroke, lineWidth);\n        if (!arc.valid || !visible) return;\n        if (!(doFill || doStroke || background)) return;\n        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;\n        const {outerRadius: outerRadius = arcAttribute.outerRadius, innerRadius: innerRadius = arcAttribute.innerRadius, cap: cap = arcAttribute.cap, forceShowCap: forceShowCap = arcAttribute.forceShowCap} = arc.attribute, {isFullStroke: isFullStroke, stroke: arrayStroke} = (0, \n        utils_1.parseStroke)(stroke);\n        if ((doFill || isFullStroke) && (context.beginPath(), (0, utils_2.drawArcPath)(arc, context, x, y, outerRadius, innerRadius), \n        this._arcRenderContribitions || (this._arcRenderContribitions = this.arcRenderContribitions.getContributions() || [], \n        this._arcRenderContribitions.sort(((a, b) => b.order - a.order))), this._arcRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, fillCb, strokeCb);\n        })), context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), \n        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), \n        context.fill())), doStroke && isFullStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), \n        context.stroke()))), !isFullStroke && doStroke) {\n            context.beginPath();\n            (0, utils_2.drawArcPath)(arc, context, x, y, outerRadius, innerRadius, arrayStroke);\n            strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), \n            context.stroke());\n        }\n        if (cap && forceShowCap) {\n            const {startAngle: sa, endAngle: ea} = arc.getParsedAngle();\n            if ((0, vutils_1.abs)(ea - sa) >= vutils_1.pi2 - vutils_1.epsilon) {\n                context.beginPath();\n                const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius, {endAngle: endAngle = arcAttribute.endAngle, fill: fill = arcAttribute.fill} = arc.attribute, startAngle = endAngle;\n                if (this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle), \n                doFill) {\n                    const color = fill;\n                    if (\"conical\" === color.gradient) {\n                        const lastColor = (0, conical_gradient_1.getConicGradientAt)(0, 0, endAngle, color);\n                        fillCb || utils_2.fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), \n                        context.fillStyle = lastColor, context.fill());\n                    }\n                }\n                doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), \n                context.stroke()));\n            }\n        }\n        this._arcRenderContribitions || (this._arcRenderContribitions = this.arcRenderContribitions.getContributions() || []), \n        this._arcRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, fillCb, strokeCb);\n        }));\n    }\n    draw(arc, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc;\n        context.highPerformanceSave();\n        let {x: x = arcAttribute.x, y: y = arcAttribute.y} = arc.attribute;\n        if (arc.transMatrix.onlyTranslate()) {\n            const point = arc.getOffsetXY(arcAttribute);\n            x += point.x, y += point.y, context.setTransformForCurrent();\n        } else x = 0, y = 0, context.transformFromMatrix(arc.transMatrix, !0);\n        (0, utils_2.drawPathProxy)(arc, context, x, y, drawContext, params) || this.drawShape(arc, context, x, y, drawContext, params), \n        context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasArcRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(arc_contribution_render_1.ArcRenderContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasArcRender), \nexports.DefaultCanvasArcRender = DefaultCanvasArcRender;\n//# sourceMappingURL=arc-render.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.drawArcPath = exports.cornerTangents = exports.intersect = exports.drawPathProxy = exports.rectStrokeVisible = exports.strokeVisible = exports.rectFillVisible = exports.fillVisible = exports.runStroke = exports.runFill = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), render_command_list_1 = require(\"../../../common/render-command-list\"), theme_1 = require(\"../../../graphic/theme\");\n\nfunction runFill(fill) {\n    return !!fill;\n}\n\nfunction runStroke(stroke, lineWidth) {\n    let s;\n    return s = (0, vutils_1.isArray)(stroke) ? stroke.some((item => item || void 0 === item)) : !!stroke, \n    s && lineWidth > 0;\n}\n\nfunction fillVisible(opacity, fillOpacity) {\n    return opacity * fillOpacity > 0;\n}\n\nfunction rectFillVisible(opacity, fillOpacity, width, height) {\n    return opacity * fillOpacity > 0 && width > 0 && height > 0;\n}\n\nfunction strokeVisible(opacity, strokeOpacity) {\n    return opacity * strokeOpacity > 0;\n}\n\nfunction rectStrokeVisible(opacity, strokeOpacity, width, height) {\n    return opacity * strokeOpacity > 0 && width > 0 && height > 0;\n}\n\nfunction drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {\n    if (!graphic.pathProxy) return !1;\n    const themeAttributes = (0, theme_1.getTheme)(graphic, null == params ? void 0 : params.theme)[graphic.type], {fill: fill = themeAttributes.fill, stroke: stroke = themeAttributes.stroke, opacity: opacity = themeAttributes.opacity, fillOpacity: fillOpacity = themeAttributes.fillOpacity, lineWidth: lineWidth = themeAttributes.lineWidth, strokeOpacity: strokeOpacity = themeAttributes.strokeOpacity, visible: visible = themeAttributes.visible} = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke, lineWidth);\n    if (!visible) return !0;\n    if (!doFill && !doStroke) return !0;\n    if (!(fVisible || sVisible || fillCb || strokeCb)) return !0;\n    context.beginPath();\n    const path = \"function\" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;\n    return (0, render_command_list_1.renderCommandList)(path.commandList, context, x, y), \n    context.setShadowStyle && context.setShadowStyle(graphic, graphic.attribute, themeAttributes), \n    doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x, y, themeAttributes), \n    context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x, y, themeAttributes), \n    context.fill())), !0;\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2;\n    let t = y32 * x10 - x32 * y10;\n    return t * t < vutils_1.epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, \n    [ x0 + t * x10, y0 + t * y10 ]);\n}\n\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {\n    const x01 = x0 - x1, y01 = y0 - y1, lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));\n    let cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2;\n    const cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;\n    return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), \n    {\n        cx: cx0,\n        cy: cy0,\n        x01: -ox,\n        y01: -oy,\n        x11: cx0 * (r1 / r - 1),\n        y11: cy0 * (r1 / r - 1)\n    };\n}\n\nfunction drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {\n    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, \n    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;\n    let collapsedToLine = !1;\n    if (outerRadius < innerRadius) {\n        const temp = outerRadius;\n        outerRadius = innerRadius, innerRadius = temp;\n    }\n    if (outerRadius <= vutils_1.epsilon) context.moveTo(cx, cy); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + outerRadius * (0, \n    vutils_1.cos)(startAngle), cy + outerRadius * (0, vutils_1.sin)(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), \n    innerRadius > vutils_1.epsilon && (context.moveTo(cx + innerRadius * (0, vutils_1.cos)(endAngle), cy + innerRadius * (0, \n    vutils_1.sin)(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise)); else {\n        const cornerRadius = arc.getParsedCornerRadius(), {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);\n        let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;\n        const xors = outerRadius * (0, vutils_1.cos)(outerStartAngle), yors = outerRadius * (0, \n        vutils_1.sin)(outerStartAngle), xire = innerRadius * (0, vutils_1.cos)(innerEndAngle), yire = innerRadius * (0, \n        vutils_1.sin)(innerEndAngle);\n        let xore, yore, xirs, yirs;\n        if ((maxInnerCornerRadius > vutils_1.epsilon || maxOuterCornerRadius > vutils_1.epsilon) && (xore = outerRadius * (0, \n        vutils_1.cos)(outerEndAngle), yore = outerRadius * (0, vutils_1.sin)(outerEndAngle), \n        xirs = innerRadius * (0, vutils_1.cos)(innerStartAngle), yirs = innerRadius * (0, \n        vutils_1.sin)(innerStartAngle), deltaAngle < vutils_1.pi)) {\n            const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);\n            if (oc) {\n                const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / (0, \n                vutils_1.sin)((0, vutils_1.acos)((ax * bx + ay * by) / ((0, vutils_1.sqrt)(ax * ax + ay * ay) * (0, \n                vutils_1.sqrt)(bx * bx + by * by))) / 2), lc = (0, vutils_1.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);\n                limitedIcr = (0, vutils_1.min)(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), \n                limitedOcr = (0, vutils_1.min)(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));\n            }\n        }\n        if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), \n        collapsedToLine = !0; else if (limitedOcr > vutils_1.epsilon) {\n            const cornerRadiusStart = (0, vutils_1.min)(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = (0, \n            vutils_1.min)(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));\n            limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), \n            context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, (0, vutils_1.atan2)(t0.y01, t0.x01), (0, \n            vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * (0, \n            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * (0, \n            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), \n            cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, (0, \n            vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise), \n            context.arc(cx, cy, outerRadius, (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, \n            vutils_1.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, (0, \n            vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * (0, \n            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * (0, \n            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * (0, \n            vutils_1.sin)(outerEndAngle));\n        } else partStroke && !partStroke[0] || (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise));\n        if (!(innerRadius > vutils_1.epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), \n        collapsedToLine = !0; else if (limitedIcr > vutils_1.epsilon) {\n            const cornerRadiusStart = (0, vutils_1.min)(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = (0, \n            vutils_1.min)(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));\n            if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), \n            limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {\n                const arcEndAngle = (0, vutils_1.atan2)(t1.y01, t1.x01);\n                !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, (0, \n                vutils_1.atan2)(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + (0, \n                vutils_1.cos)(arcEndAngle), cy + t0.cy + (0, vutils_1.sin)(arcEndAngle));\n            } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, (0, \n            vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise), \n            context.arc(cx, cy, innerRadius, (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, \n            vutils_1.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, (0, \n            vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * (0, \n            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * (0, \n            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);\n        } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), \n        !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * (0, \n        vutils_1.cos)(innerStartAngle), cy + innerRadius * (0, vutils_1.sin)(innerStartAngle));\n    }\n    return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * (0, vutils_1.cos)(endAngle), cy + outerRadius * (0, \n    vutils_1.cos)(endAngle)) : context.closePath(), collapsedToLine;\n}\n\nexports.runFill = runFill, exports.runStroke = runStroke, exports.fillVisible = fillVisible, \nexports.rectFillVisible = rectFillVisible, exports.strokeVisible = strokeVisible, \nexports.rectStrokeVisible = rectStrokeVisible, exports.drawPathProxy = drawPathProxy, \nexports.intersect = intersect, exports.cornerTangents = cornerTangents, exports.drawArcPath = drawArcPath;\n//# sourceMappingURL=utils.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.createConicalGradient = exports.getConicGradientAt = exports.ColorInterpolate = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), application_1 = require(\"../../../application\"), interpolate_1 = require(\"../../../color-string/interpolate\");\n\nclass ConicalCanvas {\n    static GetCanvas() {\n        try {\n            return ConicalCanvas.canvas || (ConicalCanvas.canvas = application_1.application.global.createCanvas({})), \n            ConicalCanvas.canvas;\n        } catch (err) {\n            return null;\n        }\n    }\n    static GetCtx() {\n        if (!ConicalCanvas.ctx) {\n            const conicalCanvas = ConicalCanvas.GetCanvas();\n            ConicalCanvas.ctx = conicalCanvas.getContext(\"2d\");\n        }\n        return ConicalCanvas.ctx;\n    }\n}\n\nclass ColorInterpolate {\n    constructor(stops = [], precision = 100) {\n        const canvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();\n        if (canvas.width = precision, canvas.height = 1, !conicalCtx) return;\n        if (conicalCtx.translate(0, 0), !conicalCtx) throw new Error(\"ctx\");\n        const gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);\n        stops.forEach((stop => {\n            gradient.addColorStop(stop[0], stop[1]);\n        })), conicalCtx.fillStyle = gradient, conicalCtx.fillRect(0, 0, precision, 1), this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;\n    }\n    getColor(offset) {\n        const rgba = this.rgbaSet.slice(4 * offset, 4 * offset + 4);\n        return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3] / 255})`;\n    }\n    static GetOrCreate(stops = [], precision = 100) {\n        let str = \"\";\n        stops.forEach((item => str += item.join())), str += precision;\n        let colorInter = ColorInterpolate.dataMap.get(str);\n        return colorInter || (colorInter = new ColorInterpolate(stops, precision), ColorInterpolate.dataMap.set(str, colorInter)), \n        colorInter;\n    }\n    static SetColorInterpolateInstance(stops, ins) {\n        ColorInterpolate.dataMap.set(stops, ins);\n    }\n    static GetColorInterpolateInstance(stops) {\n        return ColorInterpolate.dataMap.get(stops);\n    }\n}\n\nexports.ColorInterpolate = ColorInterpolate, ColorInterpolate.dataMap = new Map;\n\nclass ConicalPatternStore {\n    static GetSize(minSize) {\n        for (let i = 0; i < ConicalPatternStore.ImageSize.length; i++) if (ConicalPatternStore.ImageSize[i] >= minSize) return ConicalPatternStore.ImageSize[i];\n        return minSize;\n    }\n    static Get(stops, x, y, startAngle, endAngle, w, h) {\n        const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle), data = ConicalPatternStore.cache[key];\n        if (!data || 0 === data.length) return null;\n        for (let i = 0; i < data.length; i++) if (data[i].width >= w && data[i].height >= h) return data[i].pattern;\n        return null;\n    }\n    static Set(stops, x, y, startAngle, endAngle, pattern, w, h) {\n        const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);\n        ConicalPatternStore.cache[key] ? ConicalPatternStore.cache[key].push({\n            width: w,\n            height: h,\n            pattern: pattern\n        }) : ConicalPatternStore.cache[key] = [ {\n            width: w,\n            height: h,\n            pattern: pattern\n        } ];\n    }\n    static GenKey(stops, x, y, startAngle, endAngle) {\n        return `${x},${y},${startAngle},${endAngle},${stops.join()}`;\n    }\n}\n\nfunction getConicGradientAt(x, y, angle, color) {\n    const {stops: stops, startAngle: startAngle, endAngle: endAngle} = color;\n    for (;angle < 0; ) angle += vutils_1.pi2;\n    for (;angle > vutils_1.pi2; ) angle -= vutils_1.pi2;\n    if (angle < startAngle) return stops[0].color;\n    if (angle > endAngle) return stops[0].color;\n    let startStop, endStop, percent = (angle - startAngle) / (endAngle - startAngle);\n    for (let i = 0; i < stops.length; i++) if (stops[i].offset >= percent) {\n        startStop = stops[i - 1], endStop = stops[i];\n        break;\n    }\n    return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), \n    (0, interpolate_1.interpolateColor)(startStop.color, endStop.color, percent, !1);\n}\n\nfunction createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {\n    const deltaDeg = Math.floor(180 * deltaAngle / Math.PI), conicalCanvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();\n    if (!conicalCtx) return null;\n    const width = ConicalPatternStore.GetSize(minW), height = ConicalPatternStore.GetSize(minH);\n    let pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);\n    if (pattern) return pattern;\n    const r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2)))), stepNum = deltaDeg + 1, step = deltaAngle / Math.max(1, stepNum - 1), colorInter = ColorInterpolate.GetOrCreate(stops, stepNum), lineWidth = 2 * Math.PI * r / 360;\n    conicalCanvas.width = width, conicalCanvas.height = height, conicalCtx.setTransform(1, 0, 0, 1, 0, 0), \n    conicalCtx.clearRect(0, 0, width, height), conicalCtx.translate(x, y), conicalCtx.rotate(startAngle);\n    for (let i = 0, len = stepNum - 1; i < len && !(startAngle + i * step > endAngle); i++) {\n        const color = colorInter.getColor(i);\n        conicalCtx.beginPath(), conicalCtx.rotate(step), conicalCtx.moveTo(0, 0), conicalCtx.lineTo(r, -2 * lineWidth), \n        conicalCtx.lineTo(r, 0), conicalCtx.fillStyle = color, conicalCtx.closePath(), conicalCtx.fill();\n    }\n    const imageData = conicalCtx.getImageData(0, 0, width, height);\n    return conicalCanvas.width = imageData.width, conicalCanvas.height = imageData.height, \n    conicalCtx.putImageData(imageData, 0, 0), pattern = context.createPattern(conicalCanvas, \"no-repeat\"), \n    ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height), \n    pattern;\n}\n\nConicalPatternStore.cache = {}, ConicalPatternStore.ImageSize = [ 20, 40, 80, 160, 320, 640, 1280, 2560 ], \nexports.getConicGradientAt = getConicGradientAt, exports.createConicalGradient = createConicalGradient;\n//# sourceMappingURL=conical-gradient.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultArcTextureRenderContribution = exports.DefaultArcBackgroundRenderContribution = exports.DefaultArcRenderContribution = exports.ArcRenderContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), canvas_utils_1 = require(\"../../../../common/canvas-utils\"), base_contribution_render_1 = require(\"./base-contribution-render\"), utils_1 = require(\"../utils\"), enums_1 = require(\"../../../../common/enums\");\n\nexports.ArcRenderContribution = Symbol.for(\"ArcRenderContribution\");\n\nlet DefaultArcRenderContribution = class {\n    constructor() {\n        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, \n        this.order = 0;\n    }\n    drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, fillCb, strokeCb) {\n        const {innerRadius: innerRadius = arcAttribute.innerRadius, outerRadius: outerRadius = arcAttribute.outerRadius, startAngle: startAngle = arcAttribute.startAngle, endAngle: endAngle = arcAttribute.endAngle, opacity: opacity = arcAttribute.opacity, outerBorder: outerBorder, innerBorder: innerBorder} = arc.attribute;\n        if (outerBorder) {\n            const {distance: distance = arcAttribute.outerBorder.distance} = outerBorder, d = (0, \n            canvas_utils_1.getScaledStroke)(context, distance, context.dpr), deltaAngle = distance / outerRadius;\n            if (arc.setAttributes({\n                outerRadius: outerRadius + d,\n                innerRadius: innerRadius - d,\n                startAngle: startAngle - deltaAngle,\n                endAngle: endAngle + deltaAngle\n            }), context.beginPath(), (0, utils_1.drawArcPath)(arc, context, x, y, outerRadius + d, innerRadius - d), \n            context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), \n            strokeCb) strokeCb(context, outerBorder, arcAttribute.outerBorder); else if (sVisible) {\n                const lastOpacity = arcAttribute.outerBorder.opacity;\n                arcAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(arc, outerBorder, x, y, arcAttribute.outerBorder), \n                arcAttribute.outerBorder.opacity = lastOpacity, context.stroke();\n            }\n        }\n        if (innerBorder) {\n            const {distance: distance = arcAttribute.innerBorder.distance} = innerBorder, d = (0, \n            canvas_utils_1.getScaledStroke)(context, distance, context.dpr), deltaAngle = distance / outerRadius;\n            if (arc.setAttributes({\n                outerRadius: outerRadius - d,\n                innerRadius: innerRadius + d,\n                startAngle: startAngle + deltaAngle,\n                endAngle: endAngle - deltaAngle\n            }), context.beginPath(), (0, utils_1.drawArcPath)(arc, context, x, y, outerRadius - d, innerRadius + d), \n            context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), \n            strokeCb) strokeCb(context, innerBorder, arcAttribute.innerBorder); else if (sVisible) {\n                const lastOpacity = arcAttribute.innerBorder.opacity;\n                arcAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(arc, innerBorder, x, y, arcAttribute.innerBorder), \n                arcAttribute.innerBorder.opacity = lastOpacity, context.stroke();\n            }\n        }\n        arc.setAttributes({\n            outerRadius: outerRadius,\n            innerRadius: innerRadius,\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n    }\n};\n\nDefaultArcRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultArcRenderContribution), \nexports.DefaultArcRenderContribution = DefaultArcRenderContribution;\n\nlet DefaultArcBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;\n    }\n};\n\nDefaultArcBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultArcBackgroundRenderContribution), \nexports.DefaultArcBackgroundRenderContribution = DefaultArcBackgroundRenderContribution;\n\nlet DefaultArcTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;\n    }\n};\n\nDefaultArcTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultArcTextureRenderContribution), \nexports.DefaultArcTextureRenderContribution = DefaultArcTextureRenderContribution;\n//# sourceMappingURL=arc-contribution-render.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.createColor = exports.getScaledStroke = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nfunction getScaledStroke(context, width, dpr) {\n    let strokeWidth = width;\n    const {a: a, b: b, c: c, d: d} = context.currentMatrix, scaleX = Math.sign(a) * Math.sqrt(a * a + b * b), scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);\n    return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, \n    strokeWidth);\n}\n\nfunction createColor(context, c, params, offsetX, offsetY) {\n    if (!c || !0 === c) return \"black\";\n    let result, color;\n    if ((0, vutils_1.isArray)(c)) for (let i = 0; i < c.length && (color = c[i], !color); i++) ; else color = c;\n    return \"string\" == typeof color ? color : (\"linear\" === color.gradient ? result = createLinearGradient(context, color, params, offsetX, offsetY) : \"conical\" === color.gradient ? result = createConicGradient(context, color, params, offsetX, offsetY) : \"radial\" === color.gradient && (result = createRadialGradient(context, color, params, offsetX, offsetY)), \n    result || \"orange\");\n}\n\nfunction createLinearGradient(context, color, params, offsetX = 0, offsetY = 0) {\n    var _a, _b, _c, _d;\n    const bounds = params.AABBBounds;\n    if (!bounds) return;\n    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;\n    if (params.attribute) {\n        const {scaleX: scaleX = 1, scaleY: scaleY = 1} = params.attribute;\n        if (scaleX * scaleY == 0) return;\n        w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;\n    }\n    const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);\n    return color.stops.forEach((stop => {\n        canvasGradient.addColorStop(stop.offset, stop.color);\n    })), canvasGradient;\n}\n\nfunction createRadialGradient(context, color, params, offsetX = 0, offsetY = 0) {\n    var _a, _b, _c, _d, _e, _f;\n    const bounds = params.AABBBounds;\n    if (!bounds) return;\n    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;\n    if (params.attribute) {\n        const {scaleX: scaleX = 1, scaleY: scaleY = 1} = params.attribute;\n        if (scaleX * scaleY == 0) return;\n        x /= scaleX, y /= scaleY, w /= scaleX, h /= scaleY;\n    }\n    const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : .5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : .5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : .5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : .5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : .5));\n    return color.stops.forEach((stop => {\n        canvasGradient.addColorStop(stop.offset, stop.color);\n    })), canvasGradient;\n}\n\nfunction createConicGradient(context, color, params, offsetX = 0, offsetY = 0) {\n    var _a, _b;\n    const bounds = params.AABBBounds;\n    if (!bounds) return;\n    let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;\n    if (params.attribute) {\n        const {scaleX: scaleX = 1, scaleY: scaleY = 1} = params.attribute;\n        if (scaleX * scaleY == 0) return;\n        w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;\n    }\n    const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);\n    return color.stops.forEach((stop => {\n        canvasGradient.addColorStop(stop.offset, stop.color);\n    })), canvasGradient.GetPattern(w + x, h + y, undefined);\n}\n\n//# sourceMappingURL=canvas-utils.js.map\nexports.getScaledStroke = getScaledStroke, exports.createColor = createColor;","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultBaseTextureRenderContribution = exports.DefaultBaseBackgroundRenderContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), graphic_1 = require(\"../../../../graphic\"), canvas_allocate_1 = require(\"../../../../allocator/canvas-allocate\"), vutils_1 = require(\"@visactor/vutils\"), enums_1 = require(\"../../../../common/enums\");\n\nlet DefaultBaseBackgroundRenderContribution = class {\n    constructor() {\n        this.time = enums_1.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, \n        this.order = 0;\n    }\n    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb, options) {\n        const {background: background} = graphic.attribute;\n        if (background) if (graphic.backgroundImg && graphic.resources) {\n            const res = graphic.resources.get(background);\n            if (\"success\" !== res.state || !res.data) return;\n            if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {\n                const groupAttribute = (0, graphic_1.getTheme)(graphic.parent).group, {scrollX: scrollX = groupAttribute.scrollX, scrollY: scrollY = groupAttribute.scrollY} = graphic.parent.attribute;\n                context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);\n            }\n            context.clip();\n            const b = graphic.AABBBounds;\n            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.drawImage(res.data, b.x1, b.y1, b.width(), b.height()), \n            context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();\n        } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), \n        context.fillStyle = background, context.fill(), context.highPerformanceRestore();\n    }\n};\n\nDefaultBaseBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultBaseBackgroundRenderContribution), \nexports.DefaultBaseBackgroundRenderContribution = DefaultBaseBackgroundRenderContribution;\n\nlet DefaultBaseTextureRenderContribution = class {\n    constructor() {\n        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, \n        this.order = 10;\n    }\n    createCommonPattern(size, padding, color, targetContext, cb) {\n        const r = (size - 2 * padding) / 2, canvas = canvas_allocate_1.canvasAllocate.allocate({\n            width: size,\n            height: size,\n            dpr: 1\n        }), ctx = canvas.getContext(\"2d\");\n        if (!ctx) return null;\n        ctx.clearRect(0, 0, size, size), cb(r, ctx);\n        const pattern = targetContext.createPattern(canvas.nativeCanvas, \"repeat\");\n        return canvas_allocate_1.canvasAllocate.free(canvas), pattern;\n    }\n    createCirclePattern(size, padding, color, targetContext) {\n        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {\n            ctx.fillStyle = color, ctx.arc(r, r, r, 0, vutils_1.pi2), ctx.fill();\n        }));\n    }\n    createDiamondPattern(size, padding, color, targetContext) {\n        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {\n            const x = size / 2, y = x;\n            ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), \n            ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();\n        }));\n    }\n    createRectPattern(size, padding, color, targetContext) {\n        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {\n            const x = padding, y = x;\n            ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);\n        }));\n    }\n    createVerticalLinePattern(size, padding, color, targetContext) {\n        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {\n            const x = padding;\n            ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);\n        }));\n    }\n    createHorizontalLinePattern(size, padding, color, targetContext) {\n        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {\n            const y = padding;\n            ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);\n        }));\n    }\n    createBiasLRLinePattern(size, padding, color, targetContext) {\n        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {\n            ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);\n            const dx = size / 2, dy = -dx;\n            ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), \n            ctx.stroke();\n        }));\n    }\n    createBiasRLLinePattern(size, padding, color, targetContext) {\n        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {\n            ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);\n            const dx = size / 2, dy = dx;\n            ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), \n            ctx.lineTo(-dx, -dy + size), ctx.stroke();\n        }));\n    }\n    createGridPattern(size, padding, color, targetContext) {\n        return this.createCommonPattern(size, padding, color, targetContext, ((r, ctx) => {\n            const x = padding, y = x;\n            ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);\n        }));\n    }\n    initTextureMap(ctx, stage) {\n        this.textureMap = new Map;\n    }\n    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb, options) {\n        this.textureMap || this.initTextureMap(context, graphic.stage);\n        const {texture: texture = graphicAttribute.texture, textureColor: textureColor = graphicAttribute.textureColor, textureSize: textureSize = graphicAttribute.textureSize, texturePadding: texturePadding = graphicAttribute.texturePadding} = graphic.attribute;\n        if (!texture) return;\n        let pattern = this.textureMap.get(texture);\n        if (!pattern) switch (texture) {\n          case \"circle\":\n            pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"diamond\":\n            pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"rect\":\n            pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"vertical-line\":\n            pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"horizontal-line\":\n            pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"bias-lr\":\n            pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"bias-rl\":\n            pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"grid\":\n            pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);\n        }\n        pattern && (context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), \n        context.fillStyle = pattern, context.fill(), context.highPerformanceRestore());\n    }\n};\n\nDefaultBaseTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultBaseTextureRenderContribution), \nexports.DefaultBaseTextureRenderContribution = DefaultBaseTextureRenderContribution;\n//# sourceMappingURL=base-contribution-render.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./node-tree\"), exports), __exportStar(require(\"./circle\"), exports), \n__exportStar(require(\"./text\"), exports), __exportStar(require(\"./symbol\"), exports), \n__exportStar(require(\"./builtin-symbol\"), exports), __exportStar(require(\"./line\"), exports), \n__exportStar(require(\"./rect\"), exports), __exportStar(require(\"./rect3d\"), exports), \n__exportStar(require(\"./glyph\"), exports), __exportStar(require(\"./richtext\"), exports), \n__exportStar(require(\"./path\"), exports), __exportStar(require(\"./area\"), exports), \n__exportStar(require(\"./image\"), exports), __exportStar(require(\"./arc\"), exports), \n__exportStar(require(\"./arc3d\"), exports), __exportStar(require(\"./group\"), exports), \n__exportStar(require(\"./polygon\"), exports), __exportStar(require(\"./pyramid3d\"), exports), \n__exportStar(require(\"./config\"), exports), __exportStar(require(\"./graphic-service/graphic-service\"), exports), \n__exportStar(require(\"./graphic-creator\"), exports), __exportStar(require(\"./builtin-symbol\"), exports), \n__exportStar(require(\"./graphic\"), exports), __exportStar(require(\"./bounds\"), exports), \n__exportStar(require(\"./theme\"), exports), __exportStar(require(\"./tools\"), exports), \n__exportStar(require(\"./constants\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Circle = void 0;\n\nconst graphic_1 = require(\"./graphic\"), custom_path2d_1 = require(\"../common/custom-path2d\"), utils_1 = require(\"../common/utils\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), constants_1 = require(\"./constants\"), CIRCLE_UPDATE_TAG_KEY = [ \"radius\", \"startAngle\", \"endAngle\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Circle extends graphic_1.Graphic {\n    constructor(params = {\n        radius: 1\n    }) {\n        super(params), this.type = \"circle\", this.numberType = constants_1.CIRCLE_NUMBER_TYPE;\n    }\n    isValid() {\n        return super.isValid() && this._isValid();\n    }\n    _isValid() {\n        const {startAngle: startAngle, endAngle: endAngle, radius: radius} = this.attribute;\n        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);\n    }\n    doUpdateAABBBounds(full) {\n        const circleTheme = (0, theme_1.getTheme)(this).circle;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateCircleAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).circle, this._AABBBounds, full, this), {boundsPadding: boundsPadding = circleTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this).circle[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < CIRCLE_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = CIRCLE_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < CIRCLE_UPDATE_TAG_KEY.length; i++) {\n            if (key === CIRCLE_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    toCustomPath() {\n        var _a, _b, _c;\n        const attribute = this.attribute, radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute(\"radius\"), startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute(\"startAngle\"), endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute(\"endAngle\"), path = new custom_path2d_1.CustomPath2D;\n        return path.arc(0, 0, radius, startAngle, endAngle), path;\n    }\n    clone() {\n        return new Circle(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Circle = Circle;\n//# sourceMappingURL=circle.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Text = void 0;\n\nconst text_1 = require(\"../common/text\"), layout_1 = require(\"../core/contributions/textMeasure/layout\"), application_1 = require(\"../application\"), graphic_1 = require(\"./graphic\"), theme_1 = require(\"./theme\"), utils_1 = require(\"../common/utils\"), constants_1 = require(\"./constants\"), TEXT_UPDATE_TAG_KEY = [ \"text\", \"maxLineWidth\", \"fontSize\", \"fontFamily\", \"fontWeight\", \"ellipsis\", \"lineHeight\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Text extends graphic_1.Graphic {\n    get font() {\n        const textTheme = (0, theme_1.getTheme)(this).text;\n        return this._font || (this._font = (0, text_1.getContextFont)(this.attribute, textTheme)), \n        this._font;\n    }\n    get clipedText() {\n        var _a;\n        const attribute = this.attribute, textTheme = (0, theme_1.getTheme)(this).text;\n        if (Array.isArray(attribute.text)) return;\n        const {maxLineWidth: maxLineWidth = textTheme.maxLineWidth} = attribute;\n        return Number.isFinite(maxLineWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();\n    }\n    get clipedWidth() {\n        if (!Array.isArray(this.attribute.text)) return this.tryUpdateAABBBounds(), this.cache.clipedWidth;\n    }\n    get cliped() {\n        const textTheme = (0, theme_1.getTheme)(this).text, attribute = this.attribute;\n        if (Array.isArray(attribute.text)) return;\n        const {maxLineWidth: maxLineWidth = textTheme.maxLineWidth} = attribute;\n        return !!Number.isFinite(maxLineWidth) && (this.tryUpdateAABBBounds(), this.clipedText === attribute.text);\n    }\n    get multilineLayout() {\n        if (Array.isArray(this.attribute.text)) return this.tryUpdateAABBBounds(), this.cache.layoutData;\n    }\n    constructor(params = {\n        text: \"\",\n        fontSize: 16\n    }) {\n        super(params), this.type = \"text\", this.numberType = constants_1.TEXT_NUMBER_TYPE, \n        this.cache = {};\n    }\n    isValid() {\n        return super.isValid() && this._isValid();\n    }\n    _isValid() {\n        const {text: text} = this.attribute;\n        return null != text && \"\" !== text;\n    }\n    doUpdateAABBBounds() {\n        const textTheme = (0, theme_1.getTheme)(this).text;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateTextAABBBounds(attribute, textTheme, this._AABBBounds, this), {boundsPadding: boundsPadding = textTheme.boundsPadding} = this.attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    updateSingallineAABBBounds(text) {\n        var _a;\n        const textTheme = (0, theme_1.getTheme)(this).text, textMeasure = application_1.application.graphicUtil.textMeasure;\n        let width, str;\n        const buf = 2, attribute = this.attribute, {maxLineWidth: maxLineWidth = textTheme.maxLineWidth, ellipsis: ellipsis = textTheme.ellipsis, textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline, fontSize: fontSize = textTheme.fontSize, stroke: stroke = textTheme.stroke, lineHeight: lineHeight = (null !== (_a = attribute.lineHeight) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf), lineWidth: lineWidth = textTheme.lineWidth} = attribute;\n        if (!this.shouldUpdateShape() && this.cache) {\n            width = this.cache.clipedWidth;\n            const dx = (0, text_1.textDrawOffsetX)(textAlign, width), dy = (0, text_1.textLayoutOffsetY)(textBaseline, lineHeight, fontSize);\n            return this._AABBBounds.set(dx, dy, dx + width, dy + lineHeight), stroke && this._AABBBounds.expand(lineWidth / 2), \n            this._AABBBounds;\n        }\n        if (Number.isFinite(maxLineWidth)) {\n            if (ellipsis) {\n                const strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffix(text.toString(), {\n                    fontSize: fontSize\n                }, maxLineWidth, strEllipsis);\n                str = data.str, width = data.width;\n            } else {\n                const data = textMeasure.clipText(text.toString(), {\n                    fontSize: fontSize\n                }, maxLineWidth);\n                str = data.str, width = data.width;\n            }\n            this.cache.clipedText = str, this.cache.clipedWidth = width;\n        } else width = textMeasure.measureTextWidth(text.toString(), {\n            fontSize: fontSize\n        }), this.cache.clipedText = text.toString(), this.cache.clipedWidth = width;\n        this.clearUpdateShapeTag();\n        const dx = (0, text_1.textDrawOffsetX)(textAlign, width), dy = (0, text_1.textLayoutOffsetY)(textBaseline, lineHeight, fontSize);\n        return this._AABBBounds.set(dx, dy, dx + width, dy + lineHeight), stroke && this._AABBBounds.expand(lineWidth / 2), \n        this._AABBBounds;\n    }\n    updateMultilineAABBBounds(text) {\n        var _a;\n        const textTheme = (0, theme_1.getTheme)(this).text, attribute = this.attribute, {fontFamily: fontFamily = textTheme.fontFamily, textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline, fontSize: fontSize = textTheme.fontSize, lineHeight: lineHeight = attribute.lineHeight || attribute.fontSize || textTheme.fontSize, ellipsis: ellipsis = textTheme.ellipsis, maxLineWidth: maxLineWidth, stroke: stroke = textTheme.stroke, lineWidth: lineWidth = textTheme.lineWidth} = attribute;\n        if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {\n            const bbox = this.cache.layoutData.bbox;\n            return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), \n            stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;\n        }\n        const textMeasure = application_1.application.graphicUtil.textMeasure, layoutData = new layout_1.CanvasTextLayout(fontFamily, {\n            fontSize: fontSize\n        }, textMeasure).GetLayoutByLines(text, textAlign, textBaseline, lineHeight, !0 === ellipsis ? textTheme.ellipsis : ellipsis || void 0, maxLineWidth), {bbox: bbox} = layoutData;\n        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), \n        stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this).text[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < TEXT_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = TEXT_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < TEXT_UPDATE_TAG_KEY.length; i++) {\n            if (key === TEXT_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    clone() {\n        return new Text(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Text = Text;\n//# sourceMappingURL=text.js.map\n","\n\nfunction getContextFont(text, defaultAttr = {}, fontSizeScale) {\n    fontSizeScale || (fontSizeScale = 1);\n    const {fontStyle: fontStyle = defaultAttr.fontStyle, fontVariant: fontVariant = defaultAttr.fontVariant, fontWeight: fontWeight = defaultAttr.fontWeight, fontSize: fontSize = defaultAttr.fontSize, fontFamily: fontFamily = defaultAttr.fontFamily} = text;\n    return (fontStyle ? fontStyle + \" \" : \"\") + (fontVariant ? fontVariant + \" \" : \"\") + (fontWeight ? fontWeight + \" \" : \"\") + fontSize * fontSizeScale + \"px \" + (fontFamily || \"sans-serif\");\n}\n\nfunction textDrawOffsetY(baseline, h) {\n    return \"top\" === baseline ? Math.ceil(.79 * h) : \"middle\" === baseline ? Math.round(.3 * h) : \"bottom\" === baseline ? Math.round(-.21 * h) : 0;\n}\n\nfunction textDrawOffsetX(textAlign, width) {\n    return \"end\" === textAlign || \"right\" === textAlign ? -width : \"center\" === textAlign ? -width / 2 : 0;\n}\n\nfunction textLayoutOffsetY(baseline, lineHeight, fontSize) {\n    return \"middle\" === baseline ? -lineHeight / 2 : \"top\" === baseline ? 0 : \"bottom\" === baseline ? -lineHeight : baseline && \"alphabetic\" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), \n    -(lineHeight - fontSize) / 2 - .79 * fontSize);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.textLayoutOffsetY = exports.textDrawOffsetX = exports.textDrawOffsetY = exports.getContextFont = void 0, \nexports.getContextFont = getContextFont, exports.textDrawOffsetY = textDrawOffsetY, \nexports.textDrawOffsetX = textDrawOffsetX, exports.textLayoutOffsetY = textLayoutOffsetY;\n//# sourceMappingURL=text.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CanvasTextLayout = void 0;\n\nclass CanvasTextLayout {\n    constructor(fontFamily, options, textMeasure) {\n        this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;\n    }\n    LayoutBBox(bbox, textAlign, textBaseline) {\n        if (\"left\" === textAlign || \"start\" === textAlign) bbox.xOffset = 0; else if (\"center\" === textAlign) bbox.xOffset = bbox.width / -2; else {\n            if (\"right\" !== textAlign && \"end\" !== textAlign) throw new Error(\"textAlign\");\n            bbox.xOffset = -bbox.width;\n        }\n        return bbox.yOffset = \"top\" === textBaseline ? 0 : \"middle\" === textBaseline ? bbox.height / -2 : \"alphabetic\" === textBaseline ? -.79 * bbox.height : -bbox.height, \n        bbox;\n    }\n    GetLayout(str, width, height, textAlign, textBaseline, lineHeight, suffix, miniApp) {\n        const linesLayout = [], bboxWH = [ width, height ], bboxOffset = [ 0, 0 ];\n        for (;str.length > 0; ) {\n            const {str: clipText} = this.textMeasure.clipTextWithSuffix(str, this.textOptions, width, suffix);\n            linesLayout.push({\n                str: clipText,\n                width: this.textMeasure.measureTextWidth(clipText, this.textOptions)\n            }), str = str.substring(clipText.length);\n        }\n        \"left\" === textAlign || \"start\" === textAlign || (\"center\" === textAlign ? bboxOffset[0] = bboxWH[0] / -2 : \"right\" !== textAlign && \"end\" !== textAlign || (bboxOffset[0] = -bboxWH[0])), \n        \"top\" === textBaseline || (\"middle\" === textBaseline ? bboxOffset[1] = bboxWH[1] / -2 : \"bottom\" === textBaseline && (bboxOffset[1] = -bboxWH[1]));\n        const bbox = {\n            xOffset: bboxOffset[0],\n            yOffset: bboxOffset[1],\n            width: bboxWH[0],\n            height: bboxWH[1]\n        };\n        return this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);\n    }\n    GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = \"\", lineWidth) {\n        lines = lines.map((l => l.toString()));\n        const linesLayout = [], bboxWH = [ 0, 0 ];\n        if (\"number\" == typeof lineWidth && lineWidth !== 1 / 0) {\n            let width;\n            for (let i = 0, len = lines.length; i < len; i++) width = Math.min(this.textMeasure.measureTextWidth(lines[i], this.textOptions), lineWidth), \n            linesLayout.push({\n                str: this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, width, suffix).str,\n                width: width\n            });\n            bboxWH[0] = lineWidth;\n        } else {\n            let width, text;\n            lineWidth = 0;\n            for (let i = 0, len = lines.length; i < len; i++) text = lines[i], width = this.textMeasure.measureTextWidth(text, this.textOptions), \n            lineWidth = Math.max(lineWidth, width), linesLayout.push({\n                str: text,\n                width: width\n            });\n            bboxWH[0] = lineWidth;\n        }\n        bboxWH[1] = linesLayout.length * lineHeight;\n        const bbox = {\n            xOffset: 0,\n            yOffset: 0,\n            width: bboxWH[0],\n            height: bboxWH[1]\n        };\n        return this.LayoutBBox(bbox, textAlign, textBaseline), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);\n    }\n    layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {\n        const origin = [ 0, 0 ], totalLineHeight = lines.length * lineHeight;\n        \"top\" === textBaseline || (\"middle\" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : \"bottom\" === textBaseline && (origin[1] = bbox.height - totalLineHeight));\n        for (let i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);\n        return {\n            bbox: bbox,\n            lines: lines,\n            fontFamily: this.fontFamily,\n            fontSize: this.textOptions.fontSize,\n            fontWeight: this.textOptions.fontWeight,\n            lineHeight: lineHeight,\n            textAlign: textAlign,\n            textBaseline: textBaseline\n        };\n    }\n    lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {\n        return \"left\" === textAlign || \"start\" === textAlign ? line.leftOffset = 0 : \"center\" === textAlign ? line.leftOffset = (bbox.width - line.width) / 2 : \"right\" !== textAlign && \"end\" !== textAlign || (line.leftOffset = bbox.width - line.width), \n        line.topOffset = (lineHeight - this.textOptions.fontSize) / 2 + .79 * this.textOptions.fontSize + origin[1], \n        origin[1] += lineHeight, line;\n    }\n}\n\nexports.CanvasTextLayout = CanvasTextLayout;\n//# sourceMappingURL=layout.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Symbol = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), builtin_symbol_1 = require(\"./builtin-symbol\"), graphic_1 = require(\"./graphic\"), utils_1 = require(\"../common/utils\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), custom_path2d_1 = require(\"../common/custom-path2d\"), constants_1 = require(\"./constants\"), SYMBOL_UPDATE_TAG_KEY = [ \"symbolType\", \"size\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Symbol extends graphic_1.Graphic {\n    constructor(params = {\n        symbolType: \"circle\"\n    }) {\n        super(params), this.type = \"symbol\", this.numberType = constants_1.SYMBOL_NUMBER_TYPE;\n    }\n    getParsedPath() {\n        return this.shouldUpdateShape() && (this.doUpdateParsedPath(), this.clearUpdateShapeTag()), \n        this._parsedPath;\n    }\n    isValid() {\n        return super.isValid() && this._isValid();\n    }\n    _isValid() {\n        const {size: size} = this.attribute;\n        return (0, vutils_1.isArray)(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);\n    }\n    doUpdateParsedPath() {\n        const symbolTheme = (0, theme_1.getTheme)(this).symbol, {symbolType: symbolType = symbolTheme.symbolType} = this.attribute;\n        let path = builtin_symbol_1.builtinSymbolsMap[symbolType];\n        if (path) return this._parsedPath = path, path;\n        if (path = Symbol.userSymbolMap[symbolType], path) return this._parsedPath = path, \n        path;\n        const cache = (new custom_path2d_1.CustomPath2D).fromString(symbolType), width = cache.bounds.width(), height = cache.bounds.height(), scale = 1 / (0, \n        vutils_1.max)(width, height);\n        return cache.transform(0, 0, scale, scale), this._parsedPath = new builtin_symbol_1.CustomSymbolClass(symbolType, cache), \n        Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;\n    }\n    doUpdateAABBBounds(full) {\n        const symbolTheme = (0, theme_1.getTheme)(this).symbol;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateSymbolAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).symbol, this._AABBBounds, full, this), {boundsPadding: boundsPadding = symbolTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this).symbol[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < SYMBOL_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = SYMBOL_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < SYMBOL_UPDATE_TAG_KEY.length; i++) {\n            if (key === SYMBOL_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    toCustomPath() {\n        const symbolInstance = this.getParsedPath(), size = this.attribute.size, formattedSize = (0, \n        vutils_1.isArray)(size) ? size : [ size, size ];\n        return symbolInstance.path ? (new custom_path2d_1.CustomPath2D).fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : (new custom_path2d_1.CustomPath2D).fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);\n    }\n    clone() {\n        return new Symbol(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Symbol = Symbol, Symbol.userSymbolMap = {};\n//# sourceMappingURL=symbol.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n}, __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.builtinSymbolsMap = exports.builtinSymbols = void 0;\n\nconst circle_1 = __importDefault(require(\"./circle\")), cross_1 = __importDefault(require(\"./cross\")), diamond_1 = __importDefault(require(\"./diamond\")), square_1 = __importDefault(require(\"./square\")), triangle_1 = __importDefault(require(\"./triangle\")), star_1 = __importDefault(require(\"./star\")), arrow_1 = __importDefault(require(\"./arrow\")), wedge_1 = __importDefault(require(\"./wedge\")), stroke_1 = __importDefault(require(\"./stroke\")), wye_1 = __importDefault(require(\"./wye\")), triangle_left_1 = __importDefault(require(\"./triangle-left\")), triangle_right_1 = __importDefault(require(\"./triangle-right\")), triangle_up_1 = __importDefault(require(\"./triangle-up\")), triangle_down_1 = __importDefault(require(\"./triangle-down\")), thin_triangle_1 = __importDefault(require(\"./thin-triangle\")), arrow2_left_1 = __importDefault(require(\"./arrow2-left\")), arrow2_right_1 = __importDefault(require(\"./arrow2-right\")), rect_1 = __importDefault(require(\"./rect\"));\n\nexports.builtinSymbols = [ circle_1.default, cross_1.default, diamond_1.default, square_1.default, thin_triangle_1.default, triangle_1.default, star_1.default, arrow_1.default, wedge_1.default, stroke_1.default, wye_1.default, triangle_left_1.default, triangle_right_1.default, triangle_up_1.default, triangle_down_1.default, arrow2_left_1.default, arrow2_right_1.default, rect_1.default ], \nexports.builtinSymbolsMap = {}, exports.builtinSymbols.forEach((symbol => {\n    exports.builtinSymbolsMap[symbol.type] = symbol;\n})), __exportStar(require(\"./utils\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CircleSymbol = exports.circle = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nfunction circle(ctx, r, x, y, z) {\n    return z ? ctx.arc(x, y, r, 0, vutils_1.tau, !1, z) : ctx.arc(x, y, r, 0, vutils_1.tau), \n    !1;\n}\n\nexports.circle = circle;\n\nclass CircleSymbol {\n    constructor() {\n        this.type = \"circle\", this.pathStr = \"M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0\";\n    }\n    draw(ctx, size, x, y, z) {\n        return circle(ctx, size / 2, x, y, z);\n    }\n    drawOffset(ctx, size, x, y, offset, z) {\n        return circle(ctx, size / 2 + offset, x, y, z);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.CircleSymbol = CircleSymbol, exports.default = new CircleSymbol;\n//# sourceMappingURL=circle.js.map\n","\n\nfunction cross(ctx, r, x, y, z) {\n    return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), \n    ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), \n    ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), \n    ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), \n    ctx.closePath(), !0;\n}\n\nfunction crossOffset(ctx, r, x, y, offset, z) {\n    return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), \n    ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), \n    ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), \n    ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), \n    ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), \n    ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), \n    ctx.closePath(), !0;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CrossSymbol = exports.crossOffset = exports.cross = void 0, exports.cross = cross, \nexports.crossOffset = crossOffset;\n\nclass CrossSymbol {\n    constructor() {\n        this.type = \"cross\", this.pathStr = \"M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z\";\n    }\n    draw(ctx, size, x, y, z) {\n        return cross(ctx, size / 6, x, y, z);\n    }\n    drawOffset(ctx, size, x, y, offset, z) {\n        return crossOffset(ctx, size / 6, x, y, offset, z);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.CrossSymbol = CrossSymbol, exports.default = new CrossSymbol;\n//# sourceMappingURL=cross.js.map\n","\n\nfunction diamond(ctx, r, x, y, z) {\n    return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), \n    ctx.lineTo(x - r, y, z), ctx.closePath(), !0;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DiamondSymbol = exports.diamond = void 0, exports.diamond = diamond;\n\nclass DiamondSymbol {\n    constructor() {\n        this.type = \"diamond\", this.pathStr = \"M-0.5,0L0,-0.5L0.5,0L0,0.5Z\";\n    }\n    draw(ctx, size, x, y, z) {\n        return diamond(ctx, size / 2, x, y, z);\n    }\n    drawFitDir(ctx, size, x, y, z) {\n        return diamond(ctx, size / 2, x, y, z);\n    }\n    drawOffset(ctx, size, x, y, offset, z) {\n        return diamond(ctx, size / 2 + offset, x, y, z);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.DiamondSymbol = DiamondSymbol, exports.default = new DiamondSymbol;\n//# sourceMappingURL=diamond.js.map\n","\n\nfunction square(ctx, r, x, y) {\n    const wh = 2 * r;\n    return ctx.rect(x - r, y - r, wh, wh), !1;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.SquareSymbol = exports.square = void 0, exports.square = square;\n\nclass SquareSymbol {\n    constructor() {\n        this.type = \"square\", this.pathStr = \"M-0.5,-0.5h1v1h-1Z\";\n    }\n    draw(ctx, size, x, y) {\n        return square(ctx, size / 2, x, y);\n    }\n    drawOffset(ctx, size, x, y, offset) {\n        return square(ctx, size / 2 + offset, x, y);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.SquareSymbol = SquareSymbol, exports.default = new SquareSymbol;\n//# sourceMappingURL=square.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.TriangleSymbol = exports.triangle = void 0;\n\nconst triangle_up_1 = require(\"./triangle-up\");\n\nexports.triangle = triangle_up_1.trianglUp;\n\nclass TriangleSymbol extends triangle_up_1.TriangleUpSymbol {\n    constructor() {\n        super(...arguments), this.type = \"triangle\";\n    }\n}\n\nexports.TriangleSymbol = TriangleSymbol, exports.default = new TriangleSymbol;\n//# sourceMappingURL=triangle.js.map\n","\n\nfunction trianglUp(ctx, r, x, y) {\n    return ctx.moveTo(x + r, r + y), ctx.lineTo(x - r, r + y), ctx.lineTo(x, y - r), \n    ctx.closePath(), !0;\n}\n\nfunction trianglUpOffset(ctx, r, x, y, offset) {\n    return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), \n    ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), !0;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.TriangleUpSymbol = exports.trianglUpOffset = exports.trianglUp = void 0, \nexports.trianglUp = trianglUp, exports.trianglUpOffset = trianglUpOffset;\n\nclass TriangleUpSymbol {\n    constructor() {\n        this.type = \"triangleUp\", this.pathStr = \"M0.5,0.5 L-0.5,0.5 L0,-0.5 Z\";\n    }\n    draw(ctx, size, x, y) {\n        return trianglUp(ctx, size / 2, x, y);\n    }\n    drawOffset(ctx, size, x, y, offset) {\n        return trianglUpOffset(ctx, size / 2, x, y, offset);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.TriangleUpSymbol = TriangleUpSymbol, exports.default = new TriangleUpSymbol;\n//# sourceMappingURL=triangle-up.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.StarSymbol = exports.star = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10), kx = Math.sin(vutils_1.tau / 10) * kr, ky = -Math.cos(vutils_1.tau / 10) * kr;\n\nfunction star(ctx, r, transX, transY) {\n    const x = kx * r, y = ky * r;\n    ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);\n    for (let i = 1; i < 5; ++i) {\n        const a = vutils_1.tau * i / 5, c = Math.cos(a), s = Math.sin(a);\n        ctx.lineTo(s * r + transX, -c * r + transY), ctx.lineTo(c * x - s * y + transX, s * x + c * y + transY);\n    }\n    return ctx.closePath(), !0;\n}\n\nexports.star = star;\n\nclass StarSymbol {\n    constructor() {\n        this.type = \"star\", this.pathStr = \"M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0\";\n    }\n    draw(ctx, size, transX, transY) {\n        return star(ctx, size / 2, transX, transY);\n    }\n    drawOffset(ctx, size, transX, transY, offset) {\n        return star(ctx, size / 2 + offset, transX, transY);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.StarSymbol = StarSymbol, exports.default = new StarSymbol;\n//# sourceMappingURL=star.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.ArrowSymbol = exports.arrow = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), sqrt3 = (0, vutils_1.sqrt)(3);\n\nfunction arrow(ctx, r, transX, transY) {\n    const triangleH = r, trangleBottomSide = triangleH / sqrt3, rectW = trangleBottomSide / 5, rectH = r;\n    return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), \n    ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), \n    ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), \n    ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), !0;\n}\n\nexports.arrow = arrow;\n\nclass ArrowSymbol {\n    constructor() {\n        this.type = \"arrow\", this.pathStr = \"M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z\";\n    }\n    draw(ctx, size, transX, transY) {\n        return arrow(ctx, size / 2, transX, transY);\n    }\n    drawOffset(ctx, size, transX, transY, offset) {\n        return arrow(ctx, size / 2 + offset, transX, transY);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.ArrowSymbol = ArrowSymbol, exports.default = new ArrowSymbol;\n//# sourceMappingURL=arrow.js.map\n","\n\nfunction wedge(ctx, r, transX, transY) {\n    const h = 2 * r;\n    return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), \n    ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), !0;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.WedgeSymbol = exports.wedge = void 0, exports.wedge = wedge;\n\nclass WedgeSymbol {\n    constructor() {\n        this.type = \"wedge\", this.pathStr = \"M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z\";\n    }\n    draw(ctx, size, transX, transY) {\n        return wedge(ctx, size / 2, transX, transY);\n    }\n    drawOffset(ctx, size, transX, transY, offset) {\n        return wedge(ctx, size / 2 + offset, transX, transY);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.WedgeSymbol = WedgeSymbol, exports.default = new WedgeSymbol;\n//# sourceMappingURL=wedge.js.map\n","\n\nfunction stroke(ctx, r, transX, transY) {\n    return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), !1;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.StrokeSymbol = exports.stroke = void 0, exports.stroke = stroke;\n\nclass StrokeSymbol {\n    constructor() {\n        this.type = \"stroke\", this.pathStr = \"\";\n    }\n    draw(ctx, size, transX, transY) {\n        return stroke(ctx, size / 2, transX, transY);\n    }\n    drawOffset(ctx, size, transX, transY, offset) {\n        return stroke(ctx, size / 2 + offset, transX, transY);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.StrokeSymbol = StrokeSymbol, exports.default = new StrokeSymbol;\n//# sourceMappingURL=stroke.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.WyeSymbol = exports.wye = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), c = -.5, s = (0, vutils_1.sqrt)(3) / 2, k = 1 / (0, \nvutils_1.sqrt)(12), a = 3 * (k / 2 + 1);\n\nfunction wye(ctx, r, transX, transY) {\n    const x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;\n    return ctx.moveTo(x0 + transX, y0 + transY), ctx.lineTo(x1 + transX, y1 + transY), \n    ctx.lineTo(x2 + transX, y2 + transY), ctx.lineTo(c * x0 - s * y0 + transX, s * x0 + c * y0 + transY), \n    ctx.lineTo(c * x1 - s * y1 + transX, s * x1 + c * y1 + transY), ctx.lineTo(c * x2 - s * y2 + transX, s * x2 + c * y2 + transY), \n    ctx.lineTo(c * x0 + s * y0 + transX, c * y0 - s * x0 + transY), ctx.lineTo(c * x1 + s * y1 + transX, c * y1 - s * x1 + transY), \n    ctx.lineTo(c * x2 + s * y2 + transX, c * y2 - s * x2 + transY), ctx.closePath(), \n    !1;\n}\n\nexports.wye = wye;\n\nclass WyeSymbol {\n    constructor() {\n        this.type = \"wye\", this.pathStr = \"M4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,-4.51351666838205,0A4.51351666838205,4.51351666838205,0,1,1,4.51351666838205,0\";\n    }\n    draw(ctx, size, transX, transY) {\n        return wye(ctx, size / 2, transX, transY);\n    }\n    drawOffset(ctx, size, transX, transY, offset) {\n        return wye(ctx, size / 2 + offset, transX, transY);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.WyeSymbol = WyeSymbol, exports.default = new WyeSymbol;\n//# sourceMappingURL=wye.js.map\n","\n\nfunction trianglLeft(ctx, r, x, y) {\n    return ctx.moveTo(-r + x, y), ctx.lineTo(r + x, r + y), ctx.lineTo(r + x, y - r), \n    ctx.closePath(), !0;\n}\n\nfunction trianglLeftOffset(ctx, r, x, y, offset) {\n    return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), \n    ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), !0;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.TriangleLeftSymbol = exports.trianglLeftOffset = exports.trianglLeft = void 0, \nexports.trianglLeft = trianglLeft, exports.trianglLeftOffset = trianglLeftOffset;\n\nclass TriangleLeftSymbol {\n    constructor() {\n        this.type = \"triangleLeft\", this.pathStr = \"M-0.5,0 L0.5,0.5 L0.5,-0.5 Z\";\n    }\n    draw(ctx, size, x, y) {\n        return trianglLeft(ctx, size / 2, x, y);\n    }\n    drawOffset(ctx, size, x, y, offset) {\n        return trianglLeftOffset(ctx, size / 2, x, y, offset);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.TriangleLeftSymbol = TriangleLeftSymbol, exports.default = new TriangleLeftSymbol;\n//# sourceMappingURL=triangle-left.js.map\n","\n\nfunction trianglRight(ctx, r, x, y) {\n    return ctx.moveTo(x - r, r + y), ctx.lineTo(r + x, y), ctx.lineTo(x - r, y - r), \n    ctx.closePath(), !0;\n}\n\nfunction trianglRightOffset(ctx, r, x, y, offset) {\n    return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), \n    ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), !0;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.TriangleRightSymbol = exports.trianglRightOffset = exports.trianglRight = void 0, \nexports.trianglRight = trianglRight, exports.trianglRightOffset = trianglRightOffset;\n\nclass TriangleRightSymbol {\n    constructor() {\n        this.type = \"triangleRight\", this.pathStr = \"M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z\";\n    }\n    draw(ctx, size, x, y) {\n        return trianglRight(ctx, size / 2, x, y);\n    }\n    drawOffset(ctx, size, x, y, offset) {\n        return trianglRightOffset(ctx, size / 2, x, y, offset);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.TriangleRightSymbol = TriangleRightSymbol, exports.default = new TriangleRightSymbol;\n//# sourceMappingURL=triangle-right.js.map\n","\n\nfunction trianglDown(ctx, r, x, y) {\n    return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y - r), ctx.lineTo(x, y + r), \n    ctx.closePath(), !0;\n}\n\nfunction trianglDownOffset(ctx, r, x, y, offset) {\n    return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), \n    ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), !0;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.TriangleDownSymbol = exports.trianglDownOffset = exports.trianglDown = void 0, \nexports.trianglDown = trianglDown, exports.trianglDownOffset = trianglDownOffset;\n\nclass TriangleDownSymbol {\n    constructor() {\n        this.type = \"triangleDown\", this.pathStr = \"M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z\";\n    }\n    draw(ctx, size, x, y) {\n        return trianglDown(ctx, size / 2, x, y);\n    }\n    drawOffset(ctx, size, x, y, offset) {\n        return trianglDownOffset(ctx, size / 2, x, y, offset);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.TriangleDownSymbol = TriangleDownSymbol, exports.default = new TriangleDownSymbol;\n//# sourceMappingURL=triangle-down.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.ThinTriangleSymbol = exports.thinTriangle = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), triangle_up_1 = require(\"./triangle-up\"), sqrt3 = (0, \nvutils_1.sqrt)(3);\n\nfunction thinTriangle(ctx, r, x, y) {\n    const h = r * sqrt3;\n    return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), \n    ctx.closePath(), !0;\n}\n\nexports.thinTriangle = thinTriangle;\n\nclass ThinTriangleSymbol extends triangle_up_1.TriangleUpSymbol {\n    constructor() {\n        super(...arguments), this.type = \"thinTriangle\", this.pathStr = \"M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z\";\n    }\n    draw(ctx, size, x, y) {\n        return thinTriangle(ctx, size / 2 / sqrt3, x, y);\n    }\n    drawOffset(ctx, size, x, y, offset) {\n        return thinTriangle(ctx, size / 2 / sqrt3 + offset, x, y);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.ThinTriangleSymbol = ThinTriangleSymbol, exports.default = new ThinTriangleSymbol;\n//# sourceMappingURL=thin-triangle.js.map\n","\n\nfunction arrow2Left(ctx, r, transX, transY) {\n    const r2 = 2 * r;\n    return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), \n    !0;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Arrow2LeftSymbol = exports.arrow2Left = void 0, exports.arrow2Left = arrow2Left;\n\nclass Arrow2LeftSymbol {\n    constructor() {\n        this.type = \"arrow2Left\", this.pathStr = \"M 0.25 -0.5 L -0.25 0 l 0.5 0.5\";\n    }\n    draw(ctx, size, transX, transY) {\n        return arrow2Left(ctx, size / 4, transX, transY);\n    }\n    drawOffset(ctx, size, transX, transY, offset) {\n        return arrow2Left(ctx, size / 4 + offset, transX, transY);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.Arrow2LeftSymbol = Arrow2LeftSymbol, exports.default = new Arrow2LeftSymbol;\n//# sourceMappingURL=arrow2-left.js.map\n","\n\nfunction arrow2Right(ctx, r, transX, transY) {\n    const r2 = 2 * r;\n    return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), \n    !0;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Arrow2RightSymbol = exports.arrow2Right = void 0, exports.arrow2Right = arrow2Right;\n\nclass Arrow2RightSymbol {\n    constructor() {\n        this.type = \"arrow2Right\", this.pathStr = \"M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5\";\n    }\n    draw(ctx, size, transX, transY) {\n        return arrow2Right(ctx, size / 4, transX, transY);\n    }\n    drawOffset(ctx, size, transX, transY, offset) {\n        return arrow2Right(ctx, size / 4 + offset, transX, transY);\n    }\n    bounds(size, bounds) {\n        const r = size / 2;\n        bounds.x1 = -r, bounds.x2 = r, bounds.y1 = -r, bounds.y2 = r;\n    }\n}\n\nexports.Arrow2RightSymbol = Arrow2RightSymbol, exports.default = new Arrow2RightSymbol;\n//# sourceMappingURL=arrow2-right.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.RectSymbol = exports.rect = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nfunction rect(ctx, size, x, y) {\n    return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), !1;\n}\n\nexports.rect = rect;\n\nclass RectSymbol {\n    constructor() {\n        this.type = \"rect\", this.pathStr = \"M-0.5,-0.5h1v1h-1Z\";\n    }\n    draw(ctx, size, x, y) {\n        return rect(ctx, (0, vutils_1.isNumber)(size) ? [ size, size ] : size, x, y);\n    }\n    drawOffset(ctx, size, x, y, offset) {\n        return rect(ctx, (0, vutils_1.isNumber)(size) ? [ size + 2 * offset, size + 2 * offset ] : [ size[0] + 2 * offset, size[1] + 2 * offset ], x, y);\n    }\n    bounds(size, bounds) {\n        const rectSize = (0, vutils_1.isNumber)(size) ? [ size, size ] : size;\n        bounds.x1 = -rectSize[0] / 2, bounds.x2 = rectSize[0] / 2, bounds.y1 = -rectSize[1] / 2, \n        bounds.y2 = rectSize[1] / 2;\n    }\n}\n\nexports.RectSymbol = RectSymbol, exports.default = new RectSymbol;\n//# sourceMappingURL=rect.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CustomSymbolClass = void 0;\n\nconst render_command_list_1 = require(\"../../common/render-command-list\");\n\nclass CustomSymbolClass {\n    constructor(type, path) {\n        this.pathStr = \"\", this.type = type, this.path = path;\n    }\n    drawOffset(ctx, size, x, y, offset) {\n        return (0, render_command_list_1.renderCommandList)(this.path.commandList, ctx, x, y, size + offset, size + offset), \n        !1;\n    }\n    draw(ctx, size, x, y) {\n        return (0, render_command_list_1.renderCommandList)(this.path.commandList, ctx, x, y, size, size), \n        !1;\n    }\n    bounds(size, bounds) {\n        this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, \n        bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);\n    }\n}\n\nexports.CustomSymbolClass = CustomSymbolClass;\n//# sourceMappingURL=utils.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Line = void 0;\n\nconst graphic_1 = require(\"./graphic\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), utils_1 = require(\"../common/utils\"), custom_path2d_1 = require(\"../common/custom-path2d\"), constants_1 = require(\"./constants\"), LINE_UPDATE_TAG_KEY = [ \"segments\", \"points\", \"curveType\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Line extends graphic_1.Graphic {\n    constructor(params = {}) {\n        super(params), this.type = \"line\", this.numberType = constants_1.LINE_NUMBER_TYPE;\n    }\n    isValid() {\n        return super.isValid() && this._isValid();\n    }\n    _isValid() {\n        const {points: points, segments: segments} = this.attribute;\n        return segments ? 0 !== segments.length : !!points && !(points.length <= 1);\n    }\n    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {\n        \"points\" === key && (nextAttributes.points = (0, utils_1.pointsInterpolation)(lastStepVal, nextStepVal, ratio));\n    }\n    doUpdateAABBBounds() {\n        const lineTheme = (0, theme_1.getTheme)(this).line;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateLineAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).line, this._AABBBounds, this), {boundsPadding: boundsPadding = lineTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this).line[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < LINE_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = LINE_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < LINE_UPDATE_TAG_KEY.length; i++) {\n            if (key === LINE_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    toCustomPath() {\n        const attribute = this.attribute, path = new custom_path2d_1.CustomPath2D, segments = attribute.segments, parsePoints = points => {\n            if (points && points.length) {\n                let isFirst = !0;\n                points.forEach((point => {\n                    !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), \n                    isFirst = !1);\n                }));\n            }\n        };\n        return segments && segments.length ? segments.forEach((seg => {\n            parsePoints(seg.points);\n        })) : attribute.points && parsePoints(attribute.points), path;\n    }\n    clone() {\n        return new Line(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Line = Line;\n//# sourceMappingURL=line.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Rect = void 0;\n\nconst graphic_1 = require(\"./graphic\"), custom_path2d_1 = require(\"../common/custom-path2d\"), utils_1 = require(\"../common/utils\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), constants_1 = require(\"./constants\"), RECT_UPDATE_TAG_KEY = [ \"width\", \"height\", \"cornerRadius\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Rect extends graphic_1.Graphic {\n    constructor(params) {\n        super(params), this.type = \"rect\", this.numberType = constants_1.RECT_NUMBER_TYPE;\n    }\n    isValid() {\n        return super.isValid() && this._isValid();\n    }\n    _isValid() {\n        const {width: width, height: height} = this.attribute;\n        return this._validNumber(width) && this._validNumber(height);\n    }\n    doUpdateAABBBounds() {\n        const rectTheme = (0, theme_1.getTheme)(this).rect;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateRectAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).rect, this._AABBBounds, this), {boundsPadding: boundsPadding = rectTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this).rect[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < RECT_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = RECT_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < RECT_UPDATE_TAG_KEY.length; i++) {\n            if (key === RECT_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    toCustomPath() {\n        const attribute = this.attribute, width = attribute.width, height = attribute.height, path = new custom_path2d_1.CustomPath2D;\n        return path.moveTo(0, 0), path.rect(0, 0, width, height), path;\n    }\n    clone() {\n        return new Rect(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Rect = Rect;\n//# sourceMappingURL=rect.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Rect3d = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), rect_1 = require(\"./rect\"), theme_1 = require(\"./theme\"), constants_1 = require(\"./constants\"), CUBE_VERTICES = [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 1, 1, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 1 ], [ 1, 1, 1 ], [ 0, 1, 1 ] ];\n\nclass Rect3d extends rect_1.Rect {\n    constructor(params) {\n        super(params), this.type = \"rect3d\", this.numberType = constants_1.RECT3D_NUMBER_TYPE;\n    }\n    findFace() {\n        const faces = {\n            polygons: [],\n            vertices: [],\n            edges: []\n        }, rectTheme = (0, theme_1.getTheme)(this).rect3d, {width: width = rectTheme.width, height: height = rectTheme.width, length: length = (0, \n        vutils_1.min)(rectTheme.width, rectTheme.height)} = this.attribute;\n        for (let i = 0; i < CUBE_VERTICES.length; i++) {\n            const v = CUBE_VERTICES[i];\n            faces.vertices.push([ v[0] * width, v[1] * height, v[2] * length ]);\n        }\n        return faces.polygons.push({\n            polygon: [ 0, 1, 5, 4 ],\n            normal: [ 0, -1, 0 ]\n        }), faces.polygons.push({\n            polygon: [ 2, 3, 7, 6 ],\n            normal: [ 0, 1, 0 ]\n        }), faces.polygons.push({\n            polygon: [ 4, 7, 3, 0 ],\n            normal: [ -1, 0, 0 ]\n        }), faces.polygons.push({\n            polygon: [ 1, 2, 6, 5 ],\n            normal: [ 1, 0, 0 ]\n        }), faces.polygons.push({\n            polygon: [ 0, 1, 2, 3 ],\n            normal: [ 0, 0, -1 ]\n        }), faces.polygons.push({\n            polygon: [ 4, 5, 6, 7 ],\n            normal: [ 0, 0, 1 ]\n        }), faces.edges = [ [ 0, 1 ], [ 1, 2 ], [ 2, 3 ], [ 3, 0 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 4 ], [ 0, 4 ], [ 3, 7 ], [ 1, 5 ], [ 2, 6 ] ], \n        faces;\n    }\n}\n\nexports.Rect3d = Rect3d;\n//# sourceMappingURL=rect3d.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Glyph = void 0;\n\nconst graphic_1 = require(\"./graphic\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), constants_1 = require(\"./constants\");\n\nclass Glyph extends graphic_1.Graphic {\n    constructor(params) {\n        super(params), this.type = \"glyph\", this.numberType = constants_1.GLYPH_NUMBER_TYPE, \n        this.subGraphic = [], this._onInit && this._onInit(this), this.valid = this.isValid();\n    }\n    setSubGraphic(subGraphic) {\n        this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach((g => {\n            g.glyphHost = this, Object.setPrototypeOf(g.attribute, this.attribute);\n        })), this.valid = this.isValid(), this.addUpdateBoundTag();\n    }\n    detachSubGraphic() {\n        this.subGraphic.forEach((g => {\n            g.glyphHost = null, Object.setPrototypeOf(g.attribute, {});\n        }));\n    }\n    getSubGraphic() {\n        return this.subGraphic;\n    }\n    onInit(cb) {\n        this._onInit = cb;\n    }\n    onUpdate(cb) {\n        this._onUpdate = cb;\n    }\n    isValid() {\n        return !0;\n    }\n    setAttribute(key, value, forceUpdateTag, context) {\n        super.setAttribute(key, value, forceUpdateTag, context), this.subGraphic.forEach((g => {\n            g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();\n        }));\n    }\n    setAttributes(params, forceUpdateTag = !1, context) {\n        super.setAttributes(params, forceUpdateTag, context), this.subGraphic.forEach((g => {\n            g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();\n        }));\n    }\n    translate(x, y) {\n        return super.translate(x, y), this.subGraphic.forEach((g => {\n            g.addUpdatePositionTag(), g.addUpdateBoundTag();\n        })), this;\n    }\n    translateTo(x, y) {\n        return super.translateTo(x, y), this.subGraphic.forEach((g => {\n            g.addUpdatePositionTag(), g.addUpdateBoundTag();\n        })), this;\n    }\n    scale(scaleX, scaleY, scaleCenter) {\n        return super.scale(scaleX, scaleY, scaleCenter), this.subGraphic.forEach((g => {\n            g.addUpdatePositionTag(), g.addUpdateBoundTag();\n        })), this;\n    }\n    scaleTo(scaleX, scaleY) {\n        return super.scaleTo(scaleX, scaleY), this.subGraphic.forEach((g => {\n            g.addUpdatePositionTag(), g.addUpdateBoundTag();\n        })), this;\n    }\n    rotate(angle) {\n        return super.rotate(angle), this.subGraphic.forEach((g => {\n            g.addUpdatePositionTag(), g.addUpdateBoundTag();\n        })), this;\n    }\n    rotateTo(angle) {\n        return super.rotate(angle), this.subGraphic.forEach((g => {\n            g.addUpdatePositionTag(), g.addUpdateBoundTag();\n        })), this;\n    }\n    doUpdateAABBBounds() {\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const bounds = application_1.application.graphicService.updateGlyphAABBBounds(this.attribute, (0, \n        theme_1.getTheme)(this).glyph, this._AABBBounds, this);\n        return this.clearUpdateBoundTag(), bounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    needUpdateTags(keys) {\n        return !1;\n    }\n    needUpdateTag(key) {\n        return !1;\n    }\n    useStates(states, hasAnimation) {\n        var _a;\n        if (!states.length) return void this.clearStates(hasAnimation);\n        if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some(((stateName, index) => this.currentStates[index] !== stateName)))) return;\n        const stateAttrs = {}, subAttrs = this.subGraphic.map((() => ({})));\n        states.forEach((stateName => {\n            var _a;\n            const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];\n            attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a = attrs.subAttributes) || void 0 === _a ? void 0 : _a.length) && subAttrs.forEach(((subAttrs, index) => {\n                Object.assign(subAttrs, attrs.subAttributes[index]);\n            })));\n        })), this.subGraphic.forEach(((graphic, index) => {\n            graphic.updateNormalAttrs(subAttrs[index]), graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);\n        })), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);\n    }\n    clearStates(hasAnimation) {\n        this.hasState() && this.normalAttrs && (this.subGraphic.forEach((graphic => {\n            graphic.applyStateAttrs(graphic.normalAttrs, this.currentStates, hasAnimation, !0), \n            graphic.normalAttrs = null;\n        })), this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0), \n        this.normalAttrs = null, this.currentStates = []);\n    }\n    clone() {\n        const glyph = new Glyph(Object.assign({}, this.attribute));\n        return glyph.setSubGraphic(this.subGraphic.map((g => g.clone()))), glyph;\n    }\n}\n\nexports.Glyph = Glyph;\n//# sourceMappingURL=glyph.js.map\n","\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.RichText = void 0;\n\nconst graphic_1 = require(\"./graphic\"), config_1 = require(\"./config\"), frame_1 = __importDefault(require(\"./richtext/frame\")), paragraph_1 = __importDefault(require(\"./richtext/paragraph\")), wrapper_1 = __importDefault(require(\"./richtext/wrapper\")), theme_1 = require(\"./theme\"), icon_1 = require(\"./richtext/icon\"), application_1 = require(\"../application\"), utils_1 = require(\"../common/utils\"), constants_1 = require(\"./constants\"), RICHTEXT_UPDATE_TAG_KEY = [ \"width\", \"height\", \"ellipsis\", \"wordBreak\", \"verticalDirection\", \"maxHeight\", \"maxWidth\", \"textAlign\", \"textBaseline\", \"textConfig\", \"layoutDirection\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass RichText extends graphic_1.Graphic {\n    constructor(params) {\n        super(params), this.type = \"richtext\", this._currentHoverIcon = null, this.numberType = constants_1.RICHTEXT_NUMBER_TYPE;\n    }\n    get width() {\n        var _a;\n        return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.width;\n    }\n    set width(w) {\n        this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());\n    }\n    get height() {\n        var _a;\n        return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.height;\n    }\n    set height(h) {\n        this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());\n    }\n    get maxWidth() {\n        return this.attribute.maxWidth;\n    }\n    set maxWidth(mw) {\n        this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());\n    }\n    get maxHeight() {\n        return this.attribute.maxHeight;\n    }\n    set maxHeight(mh) {\n        this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());\n    }\n    get ellipsis() {\n        var _a;\n        return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.ellipsis;\n    }\n    set ellipsis(e) {\n        this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());\n    }\n    get wordBreak() {\n        var _a;\n        return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.wordBreak;\n    }\n    set wordBreak(wb) {\n        this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());\n    }\n    get verticalDirection() {\n        var _a;\n        return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.verticalDirection;\n    }\n    set verticalDirection(vd) {\n        this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, \n        this.addUpdateShapeAndBoundsTag());\n    }\n    get textAlign() {\n        var _a;\n        return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.textAlign;\n    }\n    set textAlign(align) {\n        this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());\n    }\n    get textBaseline() {\n        var _a;\n        return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.textBaseline;\n    }\n    set textBaseline(baseline) {\n        this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, \n        this.addUpdateShapeAndBoundsTag());\n    }\n    get textConfig() {\n        var _a;\n        return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : config_1.DefaultRichTextAttribute.textConfig;\n    }\n    set textConfig(config) {\n        this.attribute.textConfig = config, this.addUpdateShapeAndBoundsTag();\n    }\n    doUpdateAABBBounds() {\n        const richTextTheme = (0, theme_1.getTheme)(this).richtext;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateRichTextAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).richtext, this._AABBBounds, this), {boundsPadding: boundsPadding = richTextTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    getDefaultAttribute(name) {\n        return config_1.DefaultRichTextAttribute[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < RICHTEXT_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = RICHTEXT_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < RICHTEXT_UPDATE_TAG_KEY.length; i++) {\n            if (key === RICHTEXT_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    getFrameCache() {\n        return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), \n        this._frameCache;\n    }\n    doUpdateFrameCache() {\n        var _a;\n        const {textConfig: textConfig, maxWidth: maxWidth, maxHeight: maxHeight, width: width, height: height, ellipsis: ellipsis, wordBreak: wordBreak, verticalDirection: verticalDirection, textAlign: textAlign, textBaseline: textBaseline, layoutDirection: layoutDirection, singleLine: singleLine} = this.attribute, paragraphs = [];\n        for (let i = 0; i < textConfig.length; i++) if (\"image\" in textConfig[i]) {\n            const config = textConfig[i], iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);\n            if (iconCache) paragraphs.push(iconCache); else {\n                const icon = new icon_1.RichTextIcon(config);\n                icon.successCallback = () => {\n                    var _a;\n                    this.addUpdateBoundTag(), null === (_a = this.stage) || void 0 === _a || _a.renderNextFrame();\n                }, icon.richtextId = config.id, paragraphs.push(icon);\n            }\n        } else if (textConfig[i].text.includes(\"\\n\")) {\n            const textParts = textConfig[i].text.split(\"\\n\");\n            for (let j = 0; j < textParts.length; j++) paragraphs.push(new paragraph_1.default(textParts[j], 0 !== j, textConfig[i]));\n        } else paragraphs.push(new paragraph_1.default(textConfig[i].text, !1, textConfig[i]));\n        const frameHeight = \"number\" == typeof maxHeight && (!height || height > maxHeight) ? maxHeight : height, frameWidth = \"number\" == typeof maxWidth && (!width || width > maxWidth) ? maxWidth : width, frame = new frame_1.default(0, 0, frameWidth || 0, frameHeight || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || \"horizontal\", \"number\" == typeof maxWidth && (!width || width > maxWidth), \"number\" == typeof maxHeight && (!height || height > maxHeight), singleLine || !1, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons), wrapper = new wrapper_1.default(frame);\n        for (let i = 0; i < paragraphs.length; i++) wrapper.deal(paragraphs[i]);\n        wrapper.send(), this._frameCache = frame;\n    }\n    clone() {\n        return new RichText(Object.assign({}, this.attribute));\n    }\n    setStage(stage, layer) {\n        super.setStage(stage, layer);\n        this.getFrameCache().icons.forEach((icon => {\n            icon.setStage(stage, layer);\n        }));\n    }\n    bindIconEvent() {\n        this.addEventListener(\"pointermove\", (e => {\n            var _a, _b, _c, _d, _e;\n            const pickedIcon = this.pickIcon(e.global);\n            pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(!1), \n            this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(!0), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), \n            null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : !pickedIcon && this._currentHoverIcon && (this._currentHoverIcon.setHoverState(!1), \n            this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), \n            null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame()));\n        })), this.addEventListener(\"pointerleave\", (e => {\n            var _a, _b;\n            this._currentHoverIcon && (this._currentHoverIcon.setHoverState(!1), this._currentHoverIcon = null, \n            null === (_a = this.stage) || void 0 === _a || _a.setCursor(), null === (_b = this.stage) || void 0 === _b || _b.renderNextFrame());\n        }));\n    }\n    pickIcon(point) {\n        const frameCache = this.getFrameCache(), {e: x, f: y} = this.globalTransMatrix;\n        let pickIcon;\n        return frameCache.icons.forEach((icon => {\n            var _a, _b;\n            icon.AABBBounds.containsPoint({\n                x: point.x - x,\n                y: point.y - y\n            }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x, \n            pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y);\n        })), pickIcon;\n    }\n}\n\nexports.RichText = RichText;\n//# sourceMappingURL=richtext.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst utils_1 = require(\"./utils\");\n\nclass Frame {\n    constructor(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {\n        this.left = left, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, \n        this.bottom = top + height, this.right = left + width, this.ellipsis = ellipsis, \n        this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], \n        this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, \n        this.directionKey = utils_1.DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, \n        this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), \n        this.icons = icons) : this.icons = new Map;\n    }\n    draw(ctx, drawIcon) {\n        const {width: actualWidth, height: actualHeight} = this.getActualSize(), width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;\n        let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;\n        height = Math.min(height, actualHeight);\n        let deltaY = 0;\n        switch (this.globalBaseline) {\n          case \"top\":\n            deltaY = 0;\n            break;\n\n          case \"middle\":\n            deltaY = -height / 2;\n            break;\n\n          case \"bottom\":\n            deltaY = -height;\n        }\n        let deltaX = 0;\n        switch (this.globalAlign) {\n          case \"left\":\n            deltaX = 0;\n            break;\n\n          case \"center\":\n            deltaX = -width / 2;\n            break;\n\n          case \"right\":\n            deltaX = -width;\n        }\n        let frameHeight = this[this.directionKey.height];\n        this.singleLine && (frameHeight = this.lines[0].height + 1);\n        let lastLineTag = !1;\n        if (\"middle\" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {\n            const {top: top, height: height} = this.lines[i];\n            if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;\n            let lastLine = !1;\n            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, \n            lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);\n        } else {\n            const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);\n            \"vertical\" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;\n            for (let i = 0; i < this.lines.length; i++) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);\n        } else if (\"bottom\" === this.verticalDirection && \"vertical\" !== this.layoutDirection) for (let i = 0; i < this.lines.length; i++) {\n            const {top: top, height: height} = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;\n            if (0 === frameHeight) this.lines[i].draw(ctx, !1, deltaX, y + deltaY, drawIcon); else {\n                if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) return lastLineTag;\n                {\n                    let lastLine = !1;\n                    this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top] && (lastLine = !0, \n                    lastLineTag = !0), this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, drawIcon);\n                }\n            }\n        } else {\n            \"bottom\" === this.verticalDirection && \"vertical\" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);\n            for (let i = 0; i < this.lines.length; i++) {\n                \"bottom\" === this.verticalDirection && \"vertical\" === this.layoutDirection && (deltaX -= this.lines[i].height + this.lines[i].top);\n                const {top: top, height: height} = this.lines[i];\n                if (0 === frameHeight) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon); else {\n                    if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;\n                    {\n                        let lastLine = !1;\n                        this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, \n                        lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);\n                    }\n                }\n            }\n        }\n        return lastLineTag;\n    }\n    getActualSize() {\n        return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();\n    }\n    getRawActualSize() {\n        let width = 0, height = 0;\n        for (let i = 0; i < this.lines.length; i++) {\n            const line = this.lines[i];\n            line.actualWidth > width && (width = line.actualWidth), height += line.height;\n        }\n        return {\n            width: \"vertical\" === this.layoutDirection ? height : width,\n            height: \"vertical\" === this.layoutDirection ? width : height\n        };\n    }\n    getActualSizeWidthEllipsis() {\n        let widthBound = 0, heightBound = 0;\n        const {width: actualWidth, height: actualHeight} = this.getRawActualSize();\n        this.width;\n        let height = this.height || actualHeight || 0;\n        height = Math.min(height, actualHeight);\n        let frameHeight = this[this.directionKey.height];\n        if (this.singleLine && (frameHeight = this.lines[0].height + 1), \"middle\" === this.verticalDirection) if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {\n            const {top: top, height: height} = this.lines[i];\n            if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ; else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {\n                const lineWidth = this.lines[i].getWidthWithEllips();\n                lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;\n            } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), \n            heightBound += this.lines[i].height;\n        } else {\n            Math.floor((frameHeight - this.actualHeight) / 2);\n            for (let i = 0; i < this.lines.length; i++) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), \n            heightBound += this.lines[i].height;\n        } else if (\"bottom\" === this.verticalDirection) for (let i = 0; i < this.lines.length; i++) {\n            const {top: top, height: height} = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;\n            if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), \n            heightBound += this.lines[i].height; else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ; else {\n                if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {\n                    const lineWidth = this.lines[i].getWidthWithEllips();\n                    lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;\n                } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), \n                heightBound += this.lines[i].height;\n            }\n        } else for (let i = 0; i < this.lines.length; i++) {\n            const {top: top, height: height} = this.lines[i];\n            if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), \n            heightBound += this.lines[i].height; else if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ; else {\n                if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {\n                    const lineWidth = this.lines[i].getWidthWithEllips();\n                    lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;\n                } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), \n                heightBound += this.lines[i].height;\n            }\n        }\n        return {\n            width: \"vertical\" === this.layoutDirection ? heightBound : widthBound,\n            height: \"vertical\" === this.layoutDirection ? widthBound : heightBound\n        };\n    }\n}\n\nexports.default = Frame;\n//# sourceMappingURL=frame.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.getFontString = exports.measureTextCanvas = exports.measureTextDom = exports.testLetter = exports.getStrByWithCanvas = exports.getStrByWithDom = exports.prepareContext = exports.applyStrokeStyle = exports.applyFillStyle = exports.regFirstSpace = exports.regLetter = exports.DIRECTION_KEY = void 0;\n\nconst application_1 = require(\"../../application\");\n\nexports.DIRECTION_KEY = {\n    horizontal: {\n        width: \"width\",\n        height: \"height\",\n        left: \"left\",\n        top: \"top\",\n        x: \"x\",\n        y: \"y\",\n        bottom: \"bottom\"\n    },\n    vertical: {\n        width: \"height\",\n        height: \"width\",\n        left: \"top\",\n        top: \"left\",\n        x: \"y\",\n        y: \"x\",\n        bottom: \"right\"\n    }\n};\n\nconst defaultFormatting = {\n    fontSize: 16,\n    fontFamily: \"sans-serif\",\n    fill: !0,\n    stroke: !1,\n    fontWeight: \"normal\",\n    lineHeight: \"normal\",\n    fontStyle: \"normal\",\n    textDecoration: \"none\",\n    textAlign: \"left\",\n    script: \"normal\"\n}, nbsp = String.fromCharCode(160);\n\nexports.regLetter = /\\w|\\(|\\)/;\n\nconst regPunctuation = /[.?!,;:/]/;\n\nfunction applyFillStyle(ctx, character) {\n    const fillStyle = character && character.fill || defaultFormatting.fill;\n    if (!fillStyle) return void (ctx.globalAlpha = 0);\n    ctx.globalAlpha = 1, ctx.fillStyle = fillStyle;\n    let fontSize = character.fontSize || 16;\n    switch (character.script) {\n      case \"super\":\n      case \"sub\":\n        fontSize *= .8;\n    }\n    ctx.setTextStyle({\n        textAlign: \"left\",\n        textBaseline: character.textBaseline || \"alphabetic\",\n        fontStyle: character.fontStyle || \"\",\n        fontWeight: character.fontWeight || \"\",\n        fontSize: fontSize,\n        fontFamily: character.fontFamily || \"sans-serif\"\n    });\n}\n\nfunction applyStrokeStyle(ctx, character) {\n    const strokeStyle = character && character.stroke || defaultFormatting.stroke;\n    if (!strokeStyle) return void (ctx.globalAlpha = 0);\n    ctx.globalAlpha = 1, ctx.lineWidth = 1, ctx.strokeStyle = strokeStyle;\n    let fontSize = character.fontSize || 16;\n    switch (character.script) {\n      case \"super\":\n      case \"sub\":\n        fontSize *= .8;\n    }\n    ctx.setTextStyle({\n        textAlign: \"left\",\n        textBaseline: character.textBaseline || \"alphabetic\",\n        fontStyle: character.fontStyle || \"\",\n        fontWeight: character.fontWeight || \"\",\n        fontSize: fontSize,\n        fontFamily: character.fontFamily || \"sans-serif\"\n    });\n}\n\nfunction prepareContext(ctx) {\n    ctx.setTextStyle({\n        textAlign: \"left\",\n        textBaseline: \"bottom\"\n    });\n}\n\nfunction getStrByWithDom(desc, width, style, guessIndex, needTestLetter) {\n    desc = desc.replace(/\\s/g, nbsp);\n    const span = document.createElement(\"span\");\n    span.setAttribute(\"style\", style), span.style.visibility = \"hidden\", span.style.whiteSpace = \"nowrap\", \n    document.body.appendChild(span);\n    let index = guessIndex, temp = desc.slice(0, index);\n    span.innerText = temp;\n    let tempWidth = span.offsetWidth, tempNext = desc.slice(0, index + 1);\n    span.innerText = tempNext;\n    let tempWidthNext = span.offsetWidth;\n    for (;tempWidth > width || tempWidthNext <= width; ) tempWidth > width ? index-- : index++, \n    temp = desc.slice(0, index), span.innerText = temp, tempWidth = span.offsetWidth, \n    tempNext = desc.slice(0, index + 1), span.innerText = tempNext, tempWidthNext = span.offsetWidth;\n    return needTestLetter && (index = testLetter(desc, index)), document.body.removeChild(span), \n    index;\n}\n\nfunction getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {\n    if (!width || width <= 0) return 0;\n    const textMeasure = application_1.application.graphicUtil.textMeasure;\n    let index = guessIndex, temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);\n    for (;tempWidth > width || tempWidthNext <= width; ) {\n        if (tempWidth > width ? index-- : index++, index > desc.length) {\n            index = desc.length;\n            break;\n        }\n        if (index < 0) {\n            index = 0;\n            break;\n        }\n        temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), \n        tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);\n    }\n    return needTestLetter && (index = testLetter(desc, index)), index;\n}\n\nfunction testLetter(string, index) {\n    let i = index;\n    for (;exports.regLetter.test(string[i - 1]) && exports.regLetter.test(string[i]) || regPunctuation.test(string[i]); ) if (i--, \n    i <= 0) return index;\n    return i;\n}\n\nfunction measureTextDom(text, style) {\n    var _a;\n    let div;\n    const span = document.createElement(\"span\"), block = document.createElement(\"div\");\n    div = document.createElement(\"div\"), block.style.display = \"inline-block\", block.style.width = \"1px\", \n    block.style.height = \"0\", div.style.visibility = \"hidden\", div.style.position = \"absolute\", \n    div.style.top = \"0\", div.style.left = \"0\", div.style.width = \"500px\", div.style.height = \"200px\", \n    div.style.whiteSpace = \"nowrap\", div.appendChild(span), div.appendChild(block), \n    document.body.appendChild(div);\n    const result = {};\n    try {\n        span.setAttribute(\"style\", style), span.style.whiteSpace = \"nowrap\", span.style.display = \"inline-block\", \n        span.innerHTML = \"\", span.appendChild(document.createTextNode(text.replace(/\\s/g, nbsp))), \n        block.style.verticalAlign = \"baseline\", result.ascent = block.offsetTop - span.offsetTop, \n        block.style.verticalAlign = \"bottom\", result.height = block.offsetTop - span.offsetTop, \n        result.descent = result.height - result.ascent, result.width = span.offsetWidth;\n    } finally {\n        null === (_a = div.parentNode) || void 0 === _a || _a.removeChild(div), div = null;\n    }\n    return result;\n}\n\nfunction measureTextCanvas(text, character) {\n    const measurement = application_1.application.graphicUtil.textMeasure.measureText(text, character), result = {\n        ascent: 0,\n        height: 0,\n        descent: 0,\n        width: 0\n    };\n    return \"number\" != typeof measurement.actualBoundingBoxAscent || \"number\" != typeof measurement.actualBoundingBoxDescent ? (result.width = Math.floor(measurement.width), \n    result.height = character.fontSize || 0, result.ascent = result.height, result.descent = 0) : (result.width = Math.floor(measurement.width), \n    result.height = Math.floor(measurement.actualBoundingBoxAscent + measurement.actualBoundingBoxDescent), \n    result.ascent = Math.floor(measurement.actualBoundingBoxAscent), result.descent = result.height - result.ascent), \n    result;\n}\n\nfunction getFontString(character, ctx) {\n    let fontSize = character && character.fontSize || defaultFormatting.fontSize;\n    if (character) switch (character.script) {\n      case \"super\":\n      case \"sub\":\n        fontSize *= .8;\n    }\n    return (character && character.fontStyle || \"\") + \" \" + (character && character.fontWeight || \"\") + \" \" + (fontSize || 12) + \"px \" + (character && character.fontFamily || defaultFormatting.fontFamily);\n}\n\nexports.regFirstSpace = /\\S/, exports.applyFillStyle = applyFillStyle, exports.applyStrokeStyle = applyStrokeStyle, \nexports.prepareContext = prepareContext, exports.getStrByWithDom = getStrByWithDom, \nexports.getStrByWithCanvas = getStrByWithCanvas, exports.testLetter = testLetter, \nexports.measureTextDom = measureTextDom, exports.measureTextCanvas = measureTextCanvas, \nexports.getFontString = getFontString;\n//# sourceMappingURL=utils.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.seperateParagraph = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nclass Paragraph {\n    constructor(text, newLine, character) {\n        this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || \"alphabetic\", \n        \"number\" == typeof character.lineHeight ? this.lineHeight = character.lineHeight > this.fontSize ? character.lineHeight : this.fontSize : this.lineHeight = Math.floor(1.2 * this.fontSize), \n        this.height = this.lineHeight;\n        const {ascent: ascent, height: height, descent: descent, width: width} = (0, utils_1.measureTextCanvas)(text, character);\n        let halfDetaHeight = 0, deltaAscent = 0, deltaDescent = 0;\n        this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), \n        deltaDescent = Math.floor(halfDetaHeight)), \"top\" === this.textBaseline ? (this.ascent = halfDetaHeight, \n        this.descent = height - halfDetaHeight) : \"bottom\" === this.textBaseline ? (this.ascent = height - halfDetaHeight, \n        this.descent = halfDetaHeight) : \"middle\" === this.textBaseline ? (this.ascent = this.height / 2, \n        this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), \n        this.length = text.length, this.width = width || 0, this.text = text || \"\", this.newLine = newLine || !1, \n        this.character = character, this.left = 0, this.top = 0, this.ellipsis = \"normal\", \n        this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, \"vertical\" === character.direction && (this.direction = character.direction, \n        this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, \n        this.height = this.widthOrigin, this.lineHeight = this.height);\n    }\n    updateWidth() {\n        const {width: width} = (0, utils_1.measureTextCanvas)(this.text, this.character);\n        this.width = width, \"vertical\" === this.direction && (this.widthOrigin = this.width, \n        this.width = this.heightOrigin, this.height = this.widthOrigin);\n    }\n    draw(ctx, baseline, deltaLeft, isLineFirst, textAlign) {\n        let text = this.text, left = this.left + deltaLeft;\n        baseline += this.top;\n        let direction = this.direction;\n        if (this.verticalEllipsis) text = \"...\", direction = \"vertical\", baseline -= this.ellipsisWidth / 2; else {\n            if (\"hide\" === this.ellipsis) return;\n            if (\"add\" === this.ellipsis) text += \"...\", \"right\" === textAlign && (left -= this.ellipsisWidth); else if (\"replace\" === this.ellipsis) {\n                const index = (0, utils_1.getStrByWithCanvas)(text, (\"vertical\" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);\n                if (text = text.slice(0, index), text += \"...\", \"right\" === textAlign) {\n                    const {width: width} = (0, utils_1.measureTextCanvas)(this.text.slice(index), this.character);\n                    \"vertical\" === direction || (left -= this.ellipsisWidth - width);\n                }\n            }\n        }\n        switch (this.character.script) {\n          case \"super\":\n            baseline -= this.ascent * (1 / 3);\n            break;\n\n          case \"sub\":\n            baseline += this.descent / 2;\n        }\n        \"vertical\" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left, baseline), \n        ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left, baseline), \n        left = 0, baseline = 0), this.character.stroke && ((0, utils_1.applyStrokeStyle)(ctx, this.character), \n        ctx.strokeText(text, left, baseline)), (0, utils_1.applyFillStyle)(ctx, this.character), \n        this.character.fill && ctx.fillText(text, left, baseline), this.character.fill && (\"boolean\" == typeof this.character.lineThrough || \"boolean\" == typeof this.character.underline ? (this.character.underline && ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1), \n        this.character.lineThrough && ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)) : \"underline\" === this.character.textDecoration ? ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1) : \"line-through\" === this.character.textDecoration && ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)), \n        \"vertical\" === direction && ctx.restore();\n    }\n    getWidthWithEllips(direction) {\n        let text = this.text;\n        const width = \"vertical\" === direction ? this.height : this.width;\n        if (\"hide\" === this.ellipsis) return width;\n        if (\"add\" === this.ellipsis) return width + this.ellipsisWidth;\n        if (\"replace\" === this.ellipsis) {\n            const index = (0, utils_1.getStrByWithCanvas)(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);\n            text = text.slice(0, index), text += \"...\";\n            const {width: measureWidth} = (0, utils_1.measureTextCanvas)(this.text.slice(index), this.character);\n            return width + this.ellipsisWidth - measureWidth;\n        }\n        return width;\n    }\n}\n\nfunction seperateParagraph(paragraph, index) {\n    const text1 = paragraph.text.slice(0, index), text2 = paragraph.text.slice(index);\n    return [ new Paragraph(text1, paragraph.newLine, paragraph.character), new Paragraph(text2, !0, paragraph.character) ];\n}\n\nexports.default = Paragraph, exports.seperateParagraph = seperateParagraph;\n//# sourceMappingURL=paragraph.js.map\n","\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst line_1 = __importDefault(require(\"./line\")), paragraph_1 = require(\"./paragraph\"), utils_1 = require(\"./utils\"), icon_1 = require(\"./icon\");\n\nclass Wrapper {\n    constructor(frame) {\n        this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, \n        this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, \n        this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, \n        this.directionKey = utils_1.DIRECTION_KEY[this.direction];\n    }\n    store(paragraph) {\n        if (paragraph instanceof icon_1.RichTextIcon) {\n            this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), \n            this.lineWidth += paragraph[this.directionKey.width];\n            let iconAscent = 0, iconDescent = 0;\n            \"top\" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : \"bottom\" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, \n            iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), \n            this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);\n        } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], \n        this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), \n        this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));\n    }\n    send() {\n        if (0 === this.lineBuffer.length) return;\n        const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent, maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent, line = new line_1.default(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, \"horizontal\" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);\n        this.frame.lines.push(line), this.frame.actualHeight += line.height, this.y += line.height, \n        this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;\n    }\n    deal(paragraph) {\n        paragraph instanceof icon_1.RichTextIcon ? \"horizontal\" === this.direction && 0 === this.width || \"vertical\" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), \n        this.send()) : (this.send(), this.deal(paragraph)) : \"number\" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), \n        0 !== paragraph.text.length && (\"horizontal\" === this.direction && 0 === this.width || \"vertical\" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), \n        this.deal(paragraph)) : this.cut(paragraph)));\n    }\n    cut(paragraph) {\n        const availableWidth = this[this.directionKey.width] - this.lineWidth || 0, guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0, index = (0, \n        utils_1.getStrByWithCanvas)(paragraph.text, availableWidth, paragraph.character, guessIndex, \"break-word\" === this.frame.wordBreak);\n        if (0 !== index) {\n            const [p1, p2] = (0, paragraph_1.seperateParagraph)(paragraph, index);\n            this.store(p1), this.deal(p2);\n        } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));\n    }\n}\n\nexports.default = Wrapper;\n//# sourceMappingURL=wrapper.js.map\n","\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst icon_1 = require(\"./icon\"), paragraph_1 = __importDefault(require(\"./paragraph\")), utils_1 = require(\"./utils\");\n\nclass Line {\n    constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {\n        this.left = left, this.width = width, this.baseline = baseline, this.ascent = ascent, \n        this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map((p => p)), \n        this.textAlign = (this.paragraphs[0] instanceof icon_1.RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || \"left\", \n        this.direction = direction, this.directionKey = utils_1.DIRECTION_KEY[this.direction];\n        const directionKey = this.directionKey;\n        this.actualWidth = 0;\n        let maxHeight = 0;\n        this.paragraphs.forEach(((word, index) => {\n            if (0 === index && word instanceof paragraph_1.default) {\n                const result = utils_1.regFirstSpace.exec(word.text);\n                0 !== (null == result ? void 0 : result.index) && (word.text = word.text.slice(null == result ? void 0 : result.index), \n                word.updateWidth());\n            }\n            this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);\n        })), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth;\n        let x = this.left, spacing = 0;\n        if (this.actualWidth < width && !isWidthMax) switch (this.textAlign) {\n          case \"right\":\n            x = width - this.actualWidth;\n            break;\n\n          case \"center\":\n            x = (width - this.actualWidth) / 2;\n            break;\n\n          case \"justify\":\n            this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1);\n        }\n        this.paragraphs.map((function(paragraph) {\n            paragraph instanceof icon_1.RichTextIcon ? (paragraph[\"_\" + directionKey.x] = x, \n            x += paragraph[directionKey.width] + spacing, paragraph[\"_\" + directionKey.y] = \"top\" === paragraph.attribute.textBaseline ? 0 : \"bottom\" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, \n            x += paragraph[directionKey.width] + spacing);\n        }));\n    }\n    draw(ctx, lastLine, x, y, drawIcon) {\n        if (lastLine) {\n            let otherParagraphWidth = 0;\n            for (let i = this.paragraphs.length - 1; i >= 0; i--) {\n                const paragraph = this.paragraphs[i];\n                if (paragraph instanceof icon_1.RichTextIcon) break;\n                if (\"vertical\" === this.direction && \"vertical\" !== paragraph.direction) {\n                    paragraph.verticalEllipsis = !0;\n                    break;\n                }\n                const {width: width} = (0, utils_1.measureTextCanvas)(\"...\", paragraph.character), ellipsisWidth = width || 0;\n                if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {\n                    paragraph.ellipsis = \"add\";\n                    break;\n                }\n                if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {\n                    paragraph.ellipsis = \"replace\", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;\n                    break;\n                }\n                paragraph.ellipsis = \"hide\", otherParagraphWidth += paragraph.width;\n            }\n        }\n        this.paragraphs.map(((paragraph, index) => {\n            if (paragraph instanceof icon_1.RichTextIcon) return paragraph.setAttributes({\n                x: x + paragraph._x,\n                y: y + paragraph._y\n            }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);\n            paragraph.draw(ctx, y + this.ascent, x, 0 === index, this.textAlign);\n        }));\n    }\n    getWidthWithEllips() {\n        let otherParagraphWidth = 0;\n        for (let i = this.paragraphs.length - 1; i >= 0; i--) {\n            const paragraph = this.paragraphs[i];\n            if (paragraph instanceof icon_1.RichTextIcon) break;\n            const {width: width} = (0, utils_1.measureTextCanvas)(\"...\", paragraph.character), ellipsisWidth = width || 0;\n            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {\n                paragraph.ellipsis = \"add\", paragraph.ellipsisWidth = ellipsisWidth;\n                break;\n            }\n            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {\n                paragraph.ellipsis = \"replace\", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;\n                break;\n            }\n            paragraph.ellipsis = \"hide\", otherParagraphWidth += paragraph.width;\n        }\n        let width = 0;\n        return this.paragraphs.map(((paragraph, index) => {\n            paragraph instanceof icon_1.RichTextIcon ? width += paragraph.width : width += paragraph.getWidthWithEllips(this.direction);\n        })), width;\n    }\n}\n\nexports.default = Line;\n//# sourceMappingURL=line.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.RichTextIcon = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), image_1 = require(\"../image\"), config_1 = require(\"../config\"), utils_1 = require(\"../../common/utils\");\n\nclass RichTextIcon extends image_1.Image {\n    constructor(params) {\n        if (super(params), this._x = 0, this._y = 0, this._hovered = !1, this._marginArray = [ 0, 0, 0, 0 ], \n        \"always\" === params.backgroundShowMode && (this._hovered = !0), params.margin) {\n            const marginArray = (0, utils_1.parsePadding)(params.margin);\n            this._marginArray = \"number\" == typeof marginArray ? [ marginArray, marginArray, marginArray, marginArray ] : marginArray;\n        }\n        this.onBeforeAttributeUpdate = (val, attributes, key) => {\n            if ((0, vutils_1.isArray)(key) && -1 !== key.indexOf(\"margin\") || \"margin\" === key) if (attributes.margin) {\n                const marginArray = (0, utils_1.parsePadding)(attributes.margin);\n                this._marginArray = \"number\" == typeof marginArray ? [ marginArray, marginArray, marginArray, marginArray ] : marginArray;\n            } else this._marginArray = [ 0, 0, 0, 0 ];\n        };\n    }\n    get width() {\n        var _a;\n        return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];\n    }\n    get height() {\n        var _a;\n        return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];\n    }\n    tryUpdateAABBBounds() {\n        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;\n        this.doUpdateAABBBounds();\n        const {width: width = config_1.DefaultImageAttribute.width, height: height = config_1.DefaultImageAttribute.height} = this.attribute, {backgroundWidth: backgroundWidth = width, backgroundHeight: backgroundHeight = height} = this.attribute, expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;\n        return this._AABBBounds.expand([ 0, 2 * expandX, 2 * expandY, 0 ]), this._AABBBounds;\n    }\n    setHoverState(hovered) {\n        \"hover\" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);\n    }\n}\n\nexports.RichTextIcon = RichTextIcon;\n//# sourceMappingURL=icon.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Image = void 0;\n\nconst graphic_1 = require(\"./graphic\"), config_1 = require(\"./config\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), utils_1 = require(\"../common/utils\"), constants_1 = require(\"./constants\"), IMAGE_UPDATE_TAG_KEY = [ \"width\", \"height\", \"image\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Image extends graphic_1.Graphic {\n    constructor(params) {\n        super(params), this.type = \"image\", this.numberType = constants_1.IMAGE_NUMBER_TYPE, \n        this.loadImage(this.attribute.image);\n    }\n    get width() {\n        var _a;\n        return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0;\n    }\n    set width(width) {\n        this.attribute.width === width && (this.attribute.width = width, this.addUpdateShapeAndBoundsTag());\n    }\n    get height() {\n        var _a;\n        return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0;\n    }\n    set height(height) {\n        this.attribute.height === height && (this.attribute.height = height, this.addUpdateShapeAndBoundsTag());\n    }\n    get repeatX() {\n        var _a;\n        return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : \"no-repeat\";\n    }\n    set repeatX(repeatX) {\n        this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);\n    }\n    get repeatY() {\n        var _a;\n        return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : \"no-repeat\";\n    }\n    set repeatY(repeatY) {\n        this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);\n    }\n    get image() {\n        return this.attribute.image;\n    }\n    set image(image) {\n        image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));\n    }\n    imageLoadSuccess(url, image, cb) {\n        super.imageLoadSuccess(url, image, (() => {\n            this.successCallback && this.successCallback();\n        }));\n    }\n    imageLoadFail(url, cb) {\n        super.imageLoadFail(url, (() => {\n            this.failCallback && this.failCallback();\n        }));\n    }\n    doUpdateAABBBounds() {\n        const imageTheme = (0, theme_1.getTheme)(this).image;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateImageAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).image, this._AABBBounds, this), {boundsPadding: boundsPadding = imageTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    getDefaultAttribute(name) {\n        return config_1.DefaultImageAttribute[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < IMAGE_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = IMAGE_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < IMAGE_UPDATE_TAG_KEY.length; i++) {\n            if (key === IMAGE_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    clone() {\n        return new Image(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Image = Image;\n//# sourceMappingURL=image.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Path = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), graphic_1 = require(\"./graphic\"), utils_1 = require(\"../common/utils\"), custom_path2d_1 = require(\"../common/custom-path2d\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), constants_1 = require(\"./constants\"), PATH_UPDATE_TAG_KEY = [ \"path\", \"customPath\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Path extends graphic_1.Graphic {\n    constructor(params) {\n        super(params), this.type = \"path\", this.numberType = constants_1.PATH_NUMBER_TYPE;\n    }\n    get pathShape() {\n        return this.tryUpdateAABBBounds(), this.getParsedPathShape();\n    }\n    isValid() {\n        return super.isValid() && this._isValid();\n    }\n    _isValid() {\n        const {path: path} = this.attribute;\n        return null != path && \"\" !== path;\n    }\n    getParsedPathShape() {\n        const pathTheme = (0, theme_1.getTheme)(this).path;\n        if (!this.valid) return pathTheme.path;\n        const attribute = this.attribute;\n        return attribute.path instanceof custom_path2d_1.CustomPath2D ? attribute.path : ((0, \n        vutils_1.isNil)(this.cache) && this.doUpdatePathShape(), this.cache instanceof custom_path2d_1.CustomPath2D ? this.cache : pathTheme.path);\n    }\n    doUpdateAABBBounds() {\n        const pathTheme = (0, theme_1.getTheme)(this).path;\n        this.doUpdatePathShape(), this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updatePathAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).path, this._AABBBounds, this), {boundsPadding: boundsPadding = pathTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    doUpdatePathShape() {\n        const attribute = this.attribute;\n        (0, vutils_1.isString)(attribute.path, !0) ? this.cache = (new custom_path2d_1.CustomPath2D).fromString(attribute.path) : attribute.customPath && (this.cache = new custom_path2d_1.CustomPath2D, \n        attribute.customPath(this.cache, this));\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this).path[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < PATH_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = PATH_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < PATH_UPDATE_TAG_KEY.length; i++) {\n            if (key === PATH_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    toCustomPath() {\n        return (new custom_path2d_1.CustomPath2D).fromCustomPath2D(this.getParsedPathShape(), 0, 0);\n    }\n    clone() {\n        return new Path(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Path = Path;\n//# sourceMappingURL=path.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Area = void 0;\n\nconst graphic_1 = require(\"./graphic\"), custom_path2d_1 = require(\"../common/custom-path2d\"), utils_1 = require(\"../common/utils\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), constants_1 = require(\"./constants\"), AREA_UPDATE_TAG_KEY = [ \"segments\", \"points\", \"curveType\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Area extends graphic_1.Graphic {\n    constructor(params) {\n        super(params), this.type = \"area\", this.numberType = constants_1.AREA_NUMBER_TYPE;\n    }\n    isValid() {\n        return super.isValid() && this._isValid();\n    }\n    _isValid() {\n        const {points: points, segments: segments} = this.attribute;\n        return segments ? 0 !== segments.length : !!points && 0 !== points.length;\n    }\n    doUpdateAABBBounds() {\n        const areaTheme = (0, theme_1.getTheme)(this).area;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateAreaAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).area, this._AABBBounds, this), {boundsPadding: boundsPadding = areaTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {\n        \"points\" === key && (nextAttributes.points = (0, utils_1.pointsInterpolation)(lastStepVal, nextStepVal, ratio));\n    }\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this).area[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < AREA_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = AREA_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < AREA_UPDATE_TAG_KEY.length; i++) {\n            if (key === AREA_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    toCustomPath() {\n        const path = new custom_path2d_1.CustomPath2D, attribute = this.attribute, segments = attribute.segments, parsePoints = points => {\n            if (points && points.length) {\n                let isFirst = !0;\n                const basePoints = [];\n                if (points.forEach((point => {\n                    var _a, _b;\n                    !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), \n                    basePoints.push({\n                        x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,\n                        y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y\n                    }), isFirst = !1);\n                })), basePoints.length) {\n                    for (let i = basePoints.length - 1; i >= 0; i--) path.lineTo(basePoints[i].x, basePoints[i].y);\n                    path.closePath();\n                }\n            }\n        };\n        return attribute.points ? parsePoints(attribute.points) : segments && segments.length && segments.forEach((seg => {\n            parsePoints(seg.points);\n        })), path;\n    }\n    clone() {\n        return new Area(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Area = Area;\n//# sourceMappingURL=area.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Arc = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), graphic_1 = require(\"./graphic\"), custom_path2d_1 = require(\"../common/custom-path2d\"), utils_1 = require(\"../common/utils\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), constants_1 = require(\"./constants\"), ARC_UPDATE_TAG_KEY = [ \"innerRadius\", \"outerRadius\", \"startAngle\", \"endAngle\", \"cornerRadius\", \"padAngle\", \"padRadius\", \"cap\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Arc extends graphic_1.Graphic {\n    constructor(params) {\n        super(params), this.type = \"arc\", this.numberType = constants_1.ARC_NUMBER_TYPE;\n    }\n    isValid() {\n        return super.isValid() && this._isValid();\n    }\n    _isValid() {\n        const {startAngle: startAngle, endAngle: endAngle, outerRadius: outerRadius, innerRadius: innerRadius} = this.attribute;\n        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);\n    }\n    getParsedCornerRadius() {\n        const arcTheme = (0, theme_1.getTheme)(this).arc, {cornerRadius: cornerRadius = arcTheme.cornerRadius, outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius} = this.attribute;\n        if (0 === cornerRadius || \"0%\" === cornerRadius) return 0;\n        const deltaRadius = Math.abs(outerRadius - innerRadius);\n        return Math.min((0, vutils_1.isNumber)(cornerRadius, !0) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);\n    }\n    getParsedAngle() {\n        const arcTheme = (0, theme_1.getTheme)(this).arc;\n        let {startAngle: startAngle = arcTheme.startAngle, endAngle: endAngle = arcTheme.endAngle} = this.attribute;\n        const {cap: cap = arcTheme.cap} = this.attribute, sign = endAngle - startAngle >= 0 ? 1 : -1, deltaAngle = endAngle - startAngle;\n        if (startAngle = (0, vutils_1.clampAngleByRadian)(startAngle), endAngle = startAngle + deltaAngle, \n        cap && (0, vutils_1.abs)(deltaAngle) < vutils_1.pi2 - vutils_1.epsilon) {\n            let startCap = 1, endCap = 1;\n            cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));\n            const {outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius} = this.attribute, capWidth = Math.abs(outerRadius - innerRadius) / 2, capAngle = capWidth / outerRadius;\n            if (capWidth > vutils_1.epsilon && outerRadius > vutils_1.epsilon) return {\n                startAngle: startAngle - sign * capAngle * startCap,\n                endAngle: endAngle + sign * capAngle * endCap\n            };\n        }\n        return {\n            startAngle: startAngle,\n            endAngle: endAngle\n        };\n    }\n    getParsePadAngle(startAngle, endAngle) {\n        const arcTheme = (0, theme_1.getTheme)(this).arc, {outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius, padAngle: padAngle = arcTheme.padAngle} = this.attribute, {padRadius: padRadius = (0, \n        vutils_1.sqrt)(outerRadius * outerRadius + innerRadius * innerRadius)} = this.attribute, deltaAngle = (0, \n        vutils_1.abs)(endAngle - startAngle);\n        let outerStartAngle = startAngle, outerEndAngle = endAngle, innerStartAngle = startAngle, innerEndAngle = endAngle;\n        const halfPadAngle = padAngle / 2;\n        let innerDeltaAngle = deltaAngle, outerDeltaAngle = deltaAngle;\n        if (halfPadAngle > vutils_1.epsilon && padRadius > vutils_1.epsilon) {\n            const sign = endAngle > startAngle ? 1 : -1;\n            let p0 = (0, vutils_1.asin)(Number(padRadius) / innerRadius * (0, vutils_1.sin)(halfPadAngle)), p1 = (0, \n            vutils_1.asin)(Number(padRadius) / outerRadius * (0, vutils_1.sin)(halfPadAngle));\n            return (innerDeltaAngle -= 2 * p0) > vutils_1.epsilon ? (p0 *= sign, innerStartAngle += p0, \n            innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), \n            (outerDeltaAngle -= 2 * p1) > vutils_1.epsilon ? (p1 *= sign, outerStartAngle += p1, \n            outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), \n            {\n                outerStartAngle: outerStartAngle,\n                outerEndAngle: outerEndAngle,\n                innerStartAngle: innerStartAngle,\n                innerEndAngle: innerEndAngle,\n                innerDeltaAngle: innerDeltaAngle,\n                outerDeltaAngle: outerDeltaAngle\n            };\n        }\n        return {\n            outerStartAngle: outerStartAngle,\n            outerEndAngle: outerEndAngle,\n            innerStartAngle: innerStartAngle,\n            innerEndAngle: innerEndAngle,\n            innerDeltaAngle: innerDeltaAngle,\n            outerDeltaAngle: outerDeltaAngle\n        };\n    }\n    doUpdateAABBBounds(full) {\n        const arcTheme = (0, theme_1.getTheme)(this).arc;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateArcAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).arc, this._AABBBounds, full, this), {boundsPadding: boundsPadding = arcTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        bounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < ARC_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = ARC_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < ARC_UPDATE_TAG_KEY.length; i++) {\n            if (key === ARC_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this).arc[name];\n    }\n    toCustomPath() {\n        const attribute = this.attribute, {startAngle: startAngle, endAngle: endAngle} = this.getParsedAngle();\n        let innerRadius = attribute.innerRadius, outerRadius = attribute.outerRadius;\n        const deltaAngle = (0, vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;\n        if (outerRadius < innerRadius) {\n            const temp = outerRadius;\n            outerRadius = innerRadius, innerRadius = temp;\n        }\n        const path = new custom_path2d_1.CustomPath2D;\n        if (outerRadius <= vutils_1.epsilon) path.moveTo(0, 0); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) path.moveTo(0 + outerRadius * (0, \n        vutils_1.cos)(startAngle), 0 + outerRadius * (0, vutils_1.sin)(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), \n        innerRadius > vutils_1.epsilon && (path.moveTo(0 + innerRadius * (0, vutils_1.cos)(endAngle), 0 + innerRadius * (0, \n        vutils_1.sin)(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise)); else {\n            const xors = outerRadius * (0, vutils_1.cos)(startAngle), yors = outerRadius * (0, \n            vutils_1.sin)(startAngle), xire = innerRadius * (0, vutils_1.cos)(endAngle), yire = innerRadius * (0, \n            vutils_1.sin)(endAngle);\n            path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), \n            path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), \n            path.closePath();\n        }\n        return path;\n    }\n    clone() {\n        return new Arc(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Arc = Arc;\n//# sourceMappingURL=arc.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Arc3d = void 0;\n\nconst arc_1 = require(\"./arc\"), theme_1 = require(\"./theme\"), application_1 = require(\"../application\"), utils_1 = require(\"../common/utils\"), constants_1 = require(\"./constants\");\n\nclass Arc3d extends arc_1.Arc {\n    constructor(params) {\n        super(params), this.type = \"arc3d\", this.numberType = constants_1.ARC3D_NUMBER_TYPE;\n    }\n    doUpdateAABBBounds() {\n        const polygonTheme = (0, theme_1.getTheme)(this).arc;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updateArc3dAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).polygon, this._AABBBounds, this), {boundsPadding: boundsPadding = polygonTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        this._AABBBounds;\n    }\n}\n\nexports.Arc3d = Arc3d;\n//# sourceMappingURL=arc3d.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Polygon = void 0;\n\nconst graphic_1 = require(\"./graphic\"), theme_1 = require(\"./theme\"), utils_1 = require(\"../common/utils\"), custom_path2d_1 = require(\"../common/custom-path2d\"), application_1 = require(\"../application\"), constants_1 = require(\"./constants\"), POLYGON_UPDATE_TAG_KEY = [ \"points\", \"cornerRadius\", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];\n\nclass Polygon extends graphic_1.Graphic {\n    constructor(params) {\n        super(params), this.type = \"polygon\", this.numberType = constants_1.POLYGON_NUMBER_TYPE;\n    }\n    isValid() {\n        return super.isValid() && this._isValid();\n    }\n    _isValid() {\n        const {points: points} = this.attribute;\n        return points && points.length >= 2;\n    }\n    doUpdateAABBBounds() {\n        const polygonTheme = (0, theme_1.getTheme)(this).polygon;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updatePolygonAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).polygon, this._AABBBounds, this), {boundsPadding: boundsPadding = polygonTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        this._AABBBounds;\n    }\n    tryUpdateOBBBounds() {\n        throw new Error(\"\");\n    }\n    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {\n        \"points\" === key && (nextAttributes.points = (0, utils_1.pointsInterpolation)(lastStepVal, nextStepVal, ratio));\n    }\n    getDefaultAttribute(name) {\n        return (0, theme_1.getTheme)(this).polygon[name];\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < POLYGON_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = POLYGON_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return !1;\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < POLYGON_UPDATE_TAG_KEY.length; i++) {\n            if (key === POLYGON_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return !1;\n    }\n    toCustomPath() {\n        const points = this.attribute.points, path = new custom_path2d_1.CustomPath2D;\n        return points.forEach(((point, index) => {\n            0 === index ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y);\n        })), path.closePath(), path;\n    }\n    clone() {\n        return new Polygon(Object.assign({}, this.attribute));\n    }\n}\n\nexports.Polygon = Polygon;\n//# sourceMappingURL=polygon.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Pyramid3d = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), utils_1 = require(\"../common/utils\"), application_1 = require(\"../application\"), polygon_1 = require(\"./polygon\"), theme_1 = require(\"./theme\"), constants_1 = require(\"./constants\");\n\nclass Pyramid3d extends polygon_1.Polygon {\n    constructor(params) {\n        super(params), this.type = \"pyramid3d\", this.numberType = constants_1.PYRAMID3D_NUMBER_TYPE;\n    }\n    doUpdateAABBBounds() {\n        const polygonTheme = (0, theme_1.getTheme)(this).polygon;\n        this._AABBBounds.setValue(1 / 0, 1 / 0, -1 / 0, -1 / 0);\n        const attribute = this.attribute, bounds = application_1.application.graphicService.updatePyramid3dAABBBounds(attribute, (0, \n        theme_1.getTheme)(this).polygon, this._AABBBounds, this), {boundsPadding: boundsPadding = polygonTheme.boundsPadding} = attribute, paddingArray = (0, \n        utils_1.parsePadding)(boundsPadding);\n        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), \n        this._AABBBounds;\n    }\n    findFace() {\n        const {points: points} = this.attribute, kList = points.map(((p, i) => {\n            const p1 = 3 === i ? points[0] : points[i + 1], dx = p.x - p1.x;\n            return 0 === dx ? 0 : (p.y - p1.y) / dx;\n        })), pointsMap = points.map((p => ({\n            p: p,\n            d: 0\n        })));\n        let find = !1, maxD = 0;\n        for (let i = 0; i < kList.length - 1; i++) {\n            for (let j = i + 1; j < kList.length; j++) {\n                if (kList[i] === kList[j]) {\n                    find = !0;\n                    const d1 = vutils_1.PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);\n                    pointsMap[i].d = d1, pointsMap[i + 1].d = d1, maxD = (0, vutils_1.max)(maxD, d1);\n                    const d2 = vutils_1.PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);\n                    pointsMap[j].d = d2, pointsMap[j + 1].d = d2, maxD = (0, vutils_1.max)(maxD, d2);\n                }\n                if (find) break;\n            }\n            if (find) break;\n        }\n        for (let i = points.length - 1; i >= 0; i--) {\n            const p = points[i];\n            pointsMap.unshift({\n                p: p,\n                d: 0\n            });\n        }\n        for (let i = 0; i < points.length; i++) {\n            const delta = (maxD - pointsMap[i + points.length].d) / 2;\n            pointsMap[i].d += delta, pointsMap[i + points.length].d += delta;\n        }\n        const faces = {\n            polygons: [],\n            vertices: [],\n            edges: []\n        };\n        return pointsMap.forEach((p => {\n            faces.vertices.push([ p.p.x, p.p.y, p.d ]);\n        })), faces.polygons.push({\n            polygon: [ 0, 4, 5, 1 ],\n            normal: [ 0, -1, 0 ]\n        }), faces.polygons.push({\n            polygon: [ 7, 6, 2, 3 ],\n            normal: [ 0, 1, 0 ]\n        }), faces.polygons.push({\n            polygon: [ 0, 4, 7, 3 ],\n            normal: [ -1, 0, 0 ]\n        }), faces.polygons.push({\n            polygon: [ 1, 5, 6, 2 ],\n            normal: [ 1, 0, 0 ]\n        }), faces.polygons.push({\n            polygon: [ 0, 1, 2, 3 ],\n            normal: [ 0, 0, -1 ]\n        }), faces.polygons.push({\n            polygon: [ 4, 5, 6, 7 ],\n            normal: [ 0, 0, 1 ]\n        }), faces.edges = [ [ 0, 1 ], [ 1, 2 ], [ 2, 3 ], [ 3, 0 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 4 ], [ 0, 4 ], [ 3, 7 ], [ 1, 5 ], [ 2, 6 ] ], \n        faces;\n    }\n    _isValid() {\n        return super._isValid() && 4 === this.attribute.points.length;\n    }\n}\n\nexports.Pyramid3d = Pyramid3d;\n//# sourceMappingURL=pyramid3d.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultGraphicService = exports.shouldUseMat4 = exports.getModelMatrix = exports.getExtraModelMatrix = exports.multiplyMat4Mat4 = exports.multiplyMat4Mat3 = exports.mat3Tomat4 = exports.translate = exports.rotateY = exports.rotateX = void 0;\n\nconst inversify_1 = require(\"inversify\"), vutils_1 = require(\"@visactor/vutils\"), tapable_1 = require(\"../../tapable\"), rect_contribution_1 = require(\"./rect-contribution\"), text_1 = require(\"../../common/text\"), symbol_contribution_1 = require(\"./symbol-contribution\"), tools_1 = require(\"../tools\"), circle_contribution_1 = require(\"./circle-contribution\"), arc_contribution_1 = require(\"./arc-contribution\"), path_contribution_1 = require(\"./path-contribution\"), matrix_allocate_1 = require(\"../../allocator/matrix-allocate\"), contribution_provider_1 = require(\"../../common/contribution-provider\"), bounds_context_1 = require(\"../../common/bounds-context\"), render_command_list_1 = require(\"../../common/render-command-list\"), utils_1 = require(\"../../common/utils\"), constants_1 = require(\"../constants\");\n\nfunction identity(out) {\n    return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, \n    out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, \n    out[14] = 0, out[15] = 1, out;\n}\n\nfunction rotateX(out, a, rad) {\n    const s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    return a !== out && (out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], \n    out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[4] = a10 * c + a20 * s, \n    out[5] = a11 * c + a21 * s, out[6] = a12 * c + a22 * s, out[7] = a13 * c + a23 * s, \n    out[8] = a20 * c - a10 * s, out[9] = a21 * c - a11 * s, out[10] = a22 * c - a12 * s, \n    out[11] = a23 * c - a13 * s, out;\n}\n\nfunction rotateY(out, a, rad) {\n    const s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];\n    return a !== out && (out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], \n    out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c - a20 * s, \n    out[1] = a01 * c - a21 * s, out[2] = a02 * c - a22 * s, out[3] = a03 * c - a23 * s, \n    out[8] = a00 * s + a20 * c, out[9] = a01 * s + a21 * c, out[10] = a02 * s + a22 * c, \n    out[11] = a03 * s + a23 * c, out;\n}\n\nfunction rotateZ(out, a, rad) {\n    const s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];\n    return a !== out && (out[8] = a[8], out[9] = a[9], out[10] = a[10], out[11] = a[11], \n    out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c + a10 * s, \n    out[1] = a01 * c + a11 * s, out[2] = a02 * c + a12 * s, out[3] = a03 * c + a13 * s, \n    out[4] = a10 * c - a00 * s, out[5] = a11 * c - a01 * s, out[6] = a12 * c - a02 * s, \n    out[7] = a13 * c - a03 * s, out;\n}\n\nfunction translate(out, a, v) {\n    const x = v[0], y = v[1], z = v[2];\n    let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;\n    return a === out ? (out[12] = a[0] * x + a[4] * y + a[8] * z + a[12], out[13] = a[1] * x + a[5] * y + a[9] * z + a[13], \n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14], out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]) : (a00 = a[0], \n    a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], \n    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], out[0] = a00, out[1] = a01, out[2] = a02, \n    out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, \n    out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a[12], \n    out[13] = a01 * x + a11 * y + a21 * z + a[13], out[14] = a02 * x + a12 * y + a22 * z + a[14], \n    out[15] = a03 * x + a13 * y + a23 * z + a[15]), out;\n}\n\nfunction mat3Tomat4(out, b) {\n    out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, \n    out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, \n    out[13] = b.f, out[14] = 0, out[15] = 1;\n}\n\nfunction multiplyMat4Mat3(out, a, b) {\n    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n    let b0 = b.a, b1 = b.b, b2 = 0, b3 = 0;\n    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, \n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, \n    b0 = b.c, b1 = b.d, b2 = 0, b3 = 0, out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, \n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, \n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = 0, b1 = 0, b2 = 1, b3 = 0, \n    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, \n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, \n    b0 = b.e, b1 = b.f, b2 = 0, b3 = 1, out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, \n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, \n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;\n}\n\nfunction scale(out, a, v) {\n    const x = v[0], y = v[1], z = v[2];\n    return out[0] = a[0] * x, out[1] = a[1] * x, out[2] = a[2] * x, out[3] = a[3] * x, \n    out[4] = a[4] * y, out[5] = a[5] * y, out[6] = a[6] * y, out[7] = a[7] * y, out[8] = a[8] * z, \n    out[9] = a[9] * z, out[10] = a[10] * z, out[11] = a[11] * z, out[12] = a[12], out[13] = a[13], \n    out[14] = a[14], out[15] = a[15], out;\n}\n\nfunction multiplyMat4Mat4(out, a, b) {\n    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, \n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, \n    b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, \n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, \n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], \n    b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, \n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, \n    b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, \n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, \n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;\n}\n\nfunction getExtraModelMatrix(dx, dy, graphic) {\n    const {alpha: alpha, beta: beta} = graphic.attribute;\n    if (!alpha && !beta) return null;\n    const {anchor3d: anchor3d = graphic.attribute.anchor} = graphic.attribute, _anchor = [ 0, 0 ];\n    if (anchor3d) {\n        if (\"string\" == typeof anchor3d[0]) {\n            const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;\n            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;\n        } else _anchor[0] = anchor3d[0];\n        if (\"string\" == typeof anchor3d[1]) {\n            const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;\n            _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;\n        } else _anchor[1] = anchor3d[1];\n    }\n    if (\"text\" === graphic.type) {\n        const {textAlign: textAlign} = graphic.attribute;\n        _anchor[0] += (0, text_1.textDrawOffsetX)(textAlign, graphic.clipedWidth);\n    }\n    _anchor[0] += dx, _anchor[1] += dy;\n    const modelMatrix = matrix_allocate_1.mat4Allocate.allocate();\n    return translate(modelMatrix, modelMatrix, [ _anchor[0], _anchor[1], 0 ]), beta && rotateX(modelMatrix, modelMatrix, beta), \n    alpha && rotateY(modelMatrix, modelMatrix, alpha), translate(modelMatrix, modelMatrix, [ -_anchor[0], -_anchor[1], 0 ]), \n    modelMatrix;\n}\n\nfunction getModelMatrix(out, graphic, theme) {\n    var _a;\n    const {x: x = theme.x, y: y = theme.y, z: z = theme.z, dx: dx = theme.dx, dy: dy = theme.dy, dz: dz = theme.dz, scaleX: scaleX = theme.scaleX, scaleY: scaleY = theme.scaleY, scaleZ: scaleZ = theme.scaleZ, alpha: alpha = theme.alpha, beta: beta = theme.beta, angle: angle = theme.angle, anchor3d: anchor3d = graphic.attribute.anchor, anchor: anchor} = graphic.attribute, _anchor = [ 0, 0, 0 ];\n    if (anchor3d) {\n        if (\"string\" == typeof anchor3d[0]) {\n            const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;\n            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;\n        } else _anchor[0] = anchor3d[0];\n        if (\"string\" == typeof anchor3d[1]) {\n            const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;\n            _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;\n        } else _anchor[1] = anchor3d[1];\n        _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;\n    }\n    if (identity(out), translate(out, out, [ x + dx, y + dy, z + dz ]), translate(out, out, [ _anchor[0], _anchor[1], _anchor[2] ]), \n    rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [ -_anchor[0], -_anchor[1], _anchor[2] ]), \n    scale(out, out, [ scaleX, scaleY, scaleZ ]), angle) {\n        const m = matrix_allocate_1.mat4Allocate.allocate(), _anchor = [ 0, 0 ];\n        if (anchor) {\n            if (\"string\" == typeof anchor3d[0]) {\n                const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;\n                _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;\n            } else _anchor[0] = anchor3d[0];\n            if (\"string\" == typeof anchor3d[1]) {\n                const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;\n                _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;\n            } else _anchor[1] = anchor3d[1];\n        }\n        translate(m, m, [ _anchor[0], _anchor[1], 0 ]), rotateZ(m, m, angle), translate(m, m, [ -_anchor[0], -_anchor[1], 0 ]), \n        multiplyMat4Mat4(out, out, m);\n    }\n}\n\nfunction shouldUseMat4(graphic) {\n    const {alpha: alpha, beta: beta} = graphic.attribute;\n    return alpha || beta;\n}\n\nexports.rotateX = rotateX, exports.rotateY = rotateY, exports.translate = translate, \nexports.mat3Tomat4 = mat3Tomat4, exports.multiplyMat4Mat3 = multiplyMat4Mat3, exports.multiplyMat4Mat4 = multiplyMat4Mat4, \nexports.getExtraModelMatrix = getExtraModelMatrix, exports.getModelMatrix = getModelMatrix, \nexports.shouldUseMat4 = shouldUseMat4;\n\nlet DefaultGraphicService = class {\n    constructor(creator, rectBoundsContribitions, symbolBoundsContribitions, circleBoundsContribitions, arcBoundsContribitions, pathBoundsContribitions) {\n        this.creator = creator, this.rectBoundsContribitions = rectBoundsContribitions, \n        this.symbolBoundsContribitions = symbolBoundsContribitions, this.circleBoundsContribitions = circleBoundsContribitions, \n        this.arcBoundsContribitions = arcBoundsContribitions, this.pathBoundsContribitions = pathBoundsContribitions, \n        this.hooks = {\n            onAttributeUpdate: new tapable_1.SyncHook([ \"graphic\" ]),\n            onSetStage: new tapable_1.SyncHook([ \"graphic\", \"stage\" ]),\n            onRemove: new tapable_1.SyncHook([ \"graphic\" ]),\n            onAddIncremental: new tapable_1.SyncHook([ \"graphic\", \"group\", \"stage\" ]),\n            onClearIncremental: new tapable_1.SyncHook([ \"graphic\", \"group\", \"stage\" ]),\n            beforeUpdateAABBBounds: new tapable_1.SyncHook([ \"graphic\", \"stage\", \"willUpdate\", \"aabbBounds\" ]),\n            afterUpdateAABBBounds: new tapable_1.SyncHook([ \"graphic\", \"stage\", \"aabbBounds\", \"globalAABBBounds\", \"selfChange\" ])\n        }, this.tempAABBBounds1 = new vutils_1.AABBBounds, this.tempAABBBounds2 = new vutils_1.AABBBounds;\n    }\n    onAttributeUpdate(graphic) {\n        this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);\n    }\n    onSetStage(graphic, stage) {\n        this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);\n    }\n    onRemove(graphic) {\n        this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);\n    }\n    onAddIncremental(graphic, group, stage) {\n        this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);\n    }\n    onClearIncremental(group, stage) {\n        this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);\n    }\n    beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {\n        this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);\n    }\n    afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {\n        this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);\n    }\n    updatePathProxyAABBBounds(aabbBounds, graphic) {\n        const path = \"function\" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;\n        if (!path) return !1;\n        const boundsContext = new bounds_context_1.BoundsContext(aabbBounds);\n        return (0, render_command_list_1.renderCommandList)(path.commandList, boundsContext, 0, 0), \n        !0;\n    }\n    updateRectAABBBounds(attribute, rectTheme, aabbBounds, graphic) {\n        if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {\n            const {width: width = rectTheme.width, height: height = rectTheme.height} = attribute;\n            aabbBounds.set(0, 0, width, height);\n        }\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._rectBoundsContribitions || (this._rectBoundsContribitions = this.rectBoundsContribitions.getContributions() || []), \n        this._rectBoundsContribitions.length && this._rectBoundsContribitions.forEach((c => {\n            c.updateBounds(attribute, rectTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);\n        })), this.transformAABBBounds(attribute, aabbBounds, rectTheme, !1, graphic), aabbBounds;\n    }\n    updateGroupAABBBounds(attribute, groupTheme, aabbBounds, graphic) {\n        const {width: width, height: height, path: path, clip: clip = groupTheme.clip} = attribute;\n        path && path.length ? path.forEach((g => {\n            aabbBounds.union(g.AABBBounds);\n        })) : null != width && null != height && aabbBounds.set(0, 0, width, height), clip || graphic.forEachChildren((node => {\n            aabbBounds.union(node.AABBBounds);\n        }));\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, groupTheme, !1, graphic), \n        aabbBounds;\n    }\n    updateGlyphAABBBounds(attribute, theme, aabbBounds, graphic) {\n        return graphic.getSubGraphic().forEach((node => {\n            aabbBounds.union(node.AABBBounds);\n        })), aabbBounds;\n    }\n    updateRichTextAABBBounds(attribute, richtextTheme, aabbBounds, graphic) {\n        if (!graphic) return aabbBounds;\n        const {width: width = richtextTheme.width, height: height = richtextTheme.height, maxWidth: maxWidth = richtextTheme.maxWidth, maxHeight: maxHeight = richtextTheme.maxHeight, textAlign: textAlign = richtextTheme.textAlign, textBaseline: textBaseline = richtextTheme.textBaseline} = attribute;\n        if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height); else {\n            const frameCache = graphic.getFrameCache(), {width: actualWidth, height: actualHeight} = frameCache.getActualSize();\n            let contentWidth = width || actualWidth || 0, contentHeight = height || actualHeight || 0;\n            contentHeight = \"number\" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, \n            contentWidth = \"number\" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, \n            aabbBounds.set(0, 0, contentWidth, contentHeight);\n        }\n        let deltaY = 0;\n        switch (textBaseline) {\n          case \"top\":\n            deltaY = 0;\n            break;\n\n          case \"middle\":\n            deltaY = -aabbBounds.height() / 2;\n            break;\n\n          case \"bottom\":\n            deltaY = -aabbBounds.height();\n        }\n        let deltaX = 0;\n        switch (textAlign) {\n          case \"left\":\n            deltaX = 0;\n            break;\n\n          case \"center\":\n            deltaX = -aabbBounds.width() / 2;\n            break;\n\n          case \"right\":\n            deltaX = -aabbBounds.width();\n        }\n        aabbBounds.translate(deltaX, deltaY);\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, richtextTheme, !1, graphic), \n        aabbBounds;\n    }\n    updateTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {\n        if (!graphic) return aabbBounds;\n        const {text: text = textTheme.text} = graphic.attribute;\n        Array.isArray(text) ? graphic.updateMultilineAABBBounds(text) : graphic.updateSingallineAABBBounds(text);\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), (0, vutils_1.transformBoundsWithMatrix)(aabbBounds, aabbBounds, graphic.transMatrix), \n        aabbBounds;\n    }\n    updatePathAABBBounds(attribute, pathTheme, aabbBounds, graphic) {\n        this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic);\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        this._pathBoundsContribitions || (this._pathBoundsContribitions = this.pathBoundsContribitions.getContributions() || []), \n        this._pathBoundsContribitions.length && this._pathBoundsContribitions.forEach((c => {\n            c.updateBounds(attribute, pathTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);\n        }));\n        const {lineJoin: lineJoin = pathTheme.lineJoin} = attribute;\n        return this.transformAABBBounds(attribute, aabbBounds, pathTheme, \"miter\" === lineJoin, graphic), \n        aabbBounds;\n    }\n    updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic) {\n        if (!graphic) return aabbBounds;\n        const pathShape = graphic.getParsedPathShape();\n        return aabbBounds.union(pathShape.getBounds()), aabbBounds;\n    }\n    updatePyramid3dAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {\n        if (!graphic) return aabbBounds;\n        const stage = graphic.stage;\n        if (!stage || !stage.camera) return aabbBounds;\n        graphic.findFace().vertices.forEach((v => {\n            const x = v[0], y = v[1];\n            aabbBounds.add(x, y);\n        }));\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, polygonTheme, !1, graphic), \n        aabbBounds;\n    }\n    updateArc3dAABBBounds(attribute, arcTheme, aabbBounds, graphic) {\n        if (!graphic) return aabbBounds;\n        const stage = graphic.stage;\n        if (!stage || !stage.camera) return aabbBounds;\n        const {outerRadius: outerRadius = arcTheme.outerRadius, height: height = 0} = attribute, r = outerRadius + height;\n        aabbBounds.setValue(-r, -r, r, r);\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, arcTheme, !1, graphic), \n        aabbBounds;\n    }\n    updatePolygonAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {\n        this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic);\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);\n        const {lineJoin: lineJoin = polygonTheme.lineJoin} = attribute;\n        return this.transformAABBBounds(attribute, aabbBounds, polygonTheme, \"miter\" === lineJoin, graphic), \n        aabbBounds;\n    }\n    updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic) {\n        const {points: points = polygonTheme.points} = attribute;\n        return points.forEach((p => {\n            aabbBounds.add(p.x, p.y);\n        })), aabbBounds;\n    }\n    updateLineAABBBounds(attribute, lineTheme, aabbBounds, graphic) {\n        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic));\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);\n        const {lineJoin: lineJoin = lineTheme.lineJoin} = attribute;\n        return this.transformAABBBounds(attribute, aabbBounds, lineTheme, \"miter\" === lineJoin, graphic), \n        aabbBounds;\n    }\n    updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {\n        const {points: points = lineTheme.points} = attribute, b = aabbBounds;\n        return points.forEach((p => {\n            b.add(p.x, p.y);\n        })), b;\n    }\n    updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {\n        const {segments: segments = lineTheme.segments} = attribute, b = aabbBounds;\n        return segments.forEach((s => {\n            s.points.forEach((p => {\n                b.add(p.x, p.y);\n            }));\n        })), b;\n    }\n    updateAreaAABBBounds(attribute, areaTheme, aabbBounds, graphic) {\n        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic));\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);\n        const {lineJoin: lineJoin = areaTheme.lineJoin} = attribute;\n        return this.transformAABBBounds(attribute, aabbBounds, areaTheme, \"miter\" === lineJoin, graphic), \n        aabbBounds;\n    }\n    updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {\n        const {points: points = areaTheme.points} = attribute, b = aabbBounds;\n        return points.forEach((p => {\n            var _a, _b;\n            b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);\n        })), b;\n    }\n    updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {\n        const {segments: segments = areaTheme.segments} = attribute, b = aabbBounds;\n        return segments.forEach((s => {\n            s.points.forEach((p => {\n                var _a, _b;\n                b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);\n            }));\n        })), b;\n    }\n    updateCircleAABBBounds(attribute, circleTheme, aabbBounds, full, graphic) {\n        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic));\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._circleBoundsContribitions || (this._circleBoundsContribitions = this.circleBoundsContribitions.getContributions() || []), \n        this._circleBoundsContribitions.length && this._circleBoundsContribitions.forEach((c => {\n            c.updateBounds(attribute, circleTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);\n        })), this.transformAABBBounds(attribute, aabbBounds, circleTheme, !1, graphic), \n        aabbBounds;\n    }\n    updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) {\n        const {radius: radius = circleTheme.radius} = attribute;\n        return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;\n    }\n    updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic) {\n        const {startAngle: startAngle = circleTheme.startAngle, endAngle: endAngle = circleTheme.endAngle, radius: radius = circleTheme.radius} = attribute;\n        return endAngle - startAngle > vutils_1.pi2 - vutils_1.epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : (0, \n        utils_1.circleBounds)(startAngle, endAngle, radius, aabbBounds), aabbBounds;\n    }\n    updateArcAABBBounds(attribute, arcTheme, aabbBounds, full, graphic) {\n        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic));\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        this._arcBoundsContribitions || (this._arcBoundsContribitions = this.arcBoundsContribitions.getContributions() || []), \n        this._arcBoundsContribitions.length && this._arcBoundsContribitions.forEach((c => {\n            c.updateBounds(attribute, arcTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);\n        }));\n        const {lineJoin: lineJoin = arcTheme.lineJoin} = attribute;\n        return this.transformAABBBounds(attribute, aabbBounds, arcTheme, \"miter\" === lineJoin, graphic), \n        aabbBounds;\n    }\n    updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) {\n        const {outerRadius: outerRadius = arcTheme.outerRadius} = attribute;\n        return aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;\n    }\n    updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic) {\n        const {outerRadius: outerRadius = arcTheme.outerRadius, innerRadius: innerRadius = arcTheme.innerRadius} = attribute;\n        let {endAngle: endAngle = arcTheme.endAngle, startAngle: startAngle = arcTheme.startAngle} = attribute;\n        if (startAngle > endAngle) {\n            const temp = startAngle;\n            startAngle = endAngle, endAngle = temp;\n        }\n        return outerRadius <= vutils_1.epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > vutils_1.pi2 - vutils_1.epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : ((0, \n        utils_1.circleBounds)(startAngle, endAngle, outerRadius, aabbBounds), (0, utils_1.circleBounds)(startAngle, endAngle, innerRadius, aabbBounds)), \n        aabbBounds;\n    }\n    updateSymbolAABBBounds(attribute, symbolTheme, aabbBounds, full, graphic) {\n        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic));\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        this._symbolBoundsContribitions || (this._symbolBoundsContribitions = this.symbolBoundsContribitions.getContributions() || []), \n        this._symbolBoundsContribitions.length && this._symbolBoundsContribitions.forEach((c => {\n            c.updateBounds(attribute, symbolTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);\n        }));\n        const {lineJoin: lineJoin = symbolTheme.lineJoin} = attribute;\n        return this.transformAABBBounds(attribute, aabbBounds, symbolTheme, \"miter\" === lineJoin, graphic), \n        aabbBounds;\n    }\n    updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) {\n        const {size: size = symbolTheme.size} = attribute;\n        if ((0, vutils_1.isArray)(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2); else {\n            const halfWH = size / 2;\n            aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);\n        }\n        return aabbBounds;\n    }\n    updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic) {\n        if (!graphic) return aabbBounds;\n        const {size: size = symbolTheme.size} = attribute;\n        return graphic.getParsedPath().bounds(size, aabbBounds), aabbBounds;\n    }\n    updateImageAABBBounds(attribute, imageTheme, aabbBounds, graphic) {\n        if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {\n            const {width: width = imageTheme.width, height: height = imageTheme.height} = attribute;\n            aabbBounds.set(0, 0, width, height);\n        }\n        const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), \n        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, imageTheme, !1, graphic), \n        aabbBounds;\n    }\n    combindShadowAABBBounds(bounds, graphic) {\n        if (graphic && graphic.shadowRoot) {\n            const b = graphic.shadowRoot.AABBBounds;\n            bounds.union(b);\n        }\n    }\n    transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {\n        const {scaleX: scaleX = theme.scaleX, scaleY: scaleY = theme.scaleY, stroke: stroke = theme.stroke, shadowBlur: shadowBlur = theme.shadowBlur, lineWidth: lineWidth = theme.lineWidth, strokeBoundsBuffer: strokeBoundsBuffer = theme.strokeBoundsBuffer} = attribute, tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;\n        if (stroke) {\n            const scaledHalfLineWidth = lineWidth / Math.abs(scaleX + scaleY);\n            (0, tools_1.boundStroke)(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), \n            tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);\n        }\n        if (shadowBlur) {\n            const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);\n            (0, tools_1.boundStroke)(tb1, shadowBlurHalfWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1);\n        }\n        this.combindShadowAABBBounds(aabbBounds, graphic), (0, vutils_1.transformBoundsWithMatrix)(aabbBounds, aabbBounds, graphic.transMatrix);\n    }\n};\n\nDefaultGraphicService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(constants_1.GraphicCreator)), __param(1, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(1, (0, \ninversify_1.named)(rect_contribution_1.RectBoundsContribution)), __param(2, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(2, (0, \ninversify_1.named)(symbol_contribution_1.SymbolBoundsContribution)), __param(3, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(3, (0, \ninversify_1.named)(circle_contribution_1.CircleBoundsContribution)), __param(4, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(4, (0, \ninversify_1.named)(arc_contribution_1.ArcBoundsContribution)), __param(5, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(5, (0, \ninversify_1.named)(path_contribution_1.PathBoundsContribution)), __metadata(\"design:paramtypes\", [ Object, Object, Object, Object, Object, Object ]) ], DefaultGraphicService), \nexports.DefaultGraphicService = DefaultGraphicService;\n//# sourceMappingURL=graphic-service.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultRectOuterBorderBoundsContribution = exports.RectBoundsContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), common_contribution_1 = require(\"./common-contribution\");\n\nexports.RectBoundsContribution = Symbol.for(\"RectBoundsContribution\");\n\nlet DefaultRectOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {};\n\nDefaultRectOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultRectOuterBorderBoundsContribution), \nexports.DefaultRectOuterBorderBoundsContribution = DefaultRectOuterBorderBoundsContribution;\n//# sourceMappingURL=rect-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultOuterBorderBoundsContribution = void 0;\n\nconst inversify_1 = require(\"inversify\");\n\nlet DefaultOuterBorderBoundsContribution = class {\n    updateBounds(attribute, theme, aabbBounds, graphic) {\n        const {outerBorder: outerBorder, shadowBlur: shadowBlur = theme.shadowBlur} = attribute;\n        if (outerBorder) {\n            const defaultOuterBorder = theme.outerBorder, {distance: distance = defaultOuterBorder.distance, lineWidth: lineWidth = defaultOuterBorder.lineWidth} = outerBorder;\n            aabbBounds.expand(distance + shadowBlur + lineWidth / 2);\n        }\n        return aabbBounds;\n    }\n};\n\nDefaultOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultOuterBorderBoundsContribution), \nexports.DefaultOuterBorderBoundsContribution = DefaultOuterBorderBoundsContribution;\n//# sourceMappingURL=common-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultSymbolOuterBorderBoundsContribution = exports.SymbolBoundsContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), tools_1 = require(\"../tools\"), common_contribution_1 = require(\"./common-contribution\");\n\nexports.SymbolBoundsContribution = Symbol.for(\"SymbolBoundsContribution\");\n\nlet DefaultSymbolOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {\n    updateBounds(attribute, symbolTheme, aabbBounds, graphic) {\n        const {outerBorder: outerBorder, shadowBlur: shadowBlur = symbolTheme.shadowBlur, strokeBoundsBuffer: strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer} = attribute;\n        if (outerBorder) {\n            const defaultOuterBorder = symbolTheme.outerBorder, {distance: distance = defaultOuterBorder.distance, lineWidth: lineWidth = defaultOuterBorder.lineWidth} = outerBorder;\n            (0, tools_1.boundStroke)(aabbBounds, distance + shadowBlur + lineWidth / 2, !0, strokeBoundsBuffer);\n        }\n        return aabbBounds;\n    }\n};\n\nDefaultSymbolOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultSymbolOuterBorderBoundsContribution), \nexports.DefaultSymbolOuterBorderBoundsContribution = DefaultSymbolOuterBorderBoundsContribution;\n//# sourceMappingURL=symbol-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCircleOuterBorderBoundsContribution = exports.CircleBoundsContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), common_contribution_1 = require(\"./common-contribution\");\n\nexports.CircleBoundsContribution = Symbol.for(\"CircleBoundsContribution\");\n\nlet DefaultCircleOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {};\n\nDefaultCircleOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultCircleOuterBorderBoundsContribution), \nexports.DefaultCircleOuterBorderBoundsContribution = DefaultCircleOuterBorderBoundsContribution;\n//# sourceMappingURL=circle-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultArcOuterBorderBoundsContribution = exports.ArcBoundsContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), common_contribution_1 = require(\"./common-contribution\");\n\nexports.ArcBoundsContribution = Symbol.for(\"ArcBoundsContribution\");\n\nlet DefaultArcOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {};\n\nDefaultArcOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultArcOuterBorderBoundsContribution), \nexports.DefaultArcOuterBorderBoundsContribution = DefaultArcOuterBorderBoundsContribution;\n//# sourceMappingURL=arc-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultPathOuterBorderBoundsContribution = exports.PathBoundsContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), common_contribution_1 = require(\"./common-contribution\");\n\nexports.PathBoundsContribution = Symbol.for(\"PathBoundsContribution\");\n\nlet DefaultPathOuterBorderBoundsContribution = class extends common_contribution_1.DefaultOuterBorderBoundsContribution {};\n\nDefaultPathOuterBorderBoundsContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPathOuterBorderBoundsContribution), \nexports.DefaultPathOuterBorderBoundsContribution = DefaultPathOuterBorderBoundsContribution;\n//# sourceMappingURL=path-contribution.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.mat4Allocate = exports.matrixAllocate = exports.DefaultMat4Allocate = exports.DefaultMatrixAllocate = exports.createMat4 = exports.Mat4Allocate = exports.MatrixAllocate = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\");\n\nfunction createMat4() {\n    return [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ];\n}\n\nexports.MatrixAllocate = Symbol.for(\"MatrixAllocate\"), exports.Mat4Allocate = Symbol.for(\"Mat4Allocate\"), \nexports.createMat4 = createMat4;\n\nclass DefaultMatrixAllocate {\n    constructor() {\n        this.pools = [];\n    }\n    allocate(a, b, c, d, e, f) {\n        if (!this.pools.length) return new vutils_1.Matrix(a, b, c, d, e, f);\n        const m = this.pools.pop();\n        return m.a = a, m.b = b, m.c = c, m.d = d, m.e = e, m.f = f, m;\n    }\n    allocateByObj(matrix) {\n        if (!this.pools.length) return new vutils_1.Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n        const m = this.pools.pop();\n        return m.a = matrix.a, m.b = matrix.b, m.c = matrix.c, m.d = matrix.d, m.e = matrix.e, \n        m.f = matrix.f, m;\n    }\n    free(d) {\n        this.pools.push(d);\n    }\n    get length() {\n        return this.pools.length;\n    }\n    release(...params) {\n        this.pools = [];\n    }\n}\n\nexports.DefaultMatrixAllocate = DefaultMatrixAllocate;\n\nclass DefaultMat4Allocate {\n    constructor() {\n        this.pools = [];\n    }\n    static identity(out) {\n        return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, \n        out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, \n        out[14] = 0, out[15] = 1, out;\n    }\n    allocate() {\n        if (!this.pools.length) return createMat4();\n        const m = this.pools.pop();\n        return DefaultMat4Allocate.identity(m), m;\n    }\n    allocateByObj(d) {\n        let m;\n        m = this.pools.length ? this.pools.pop() : createMat4();\n        for (let i = 0; i < m.length; i++) m[i] = d[i];\n        return m;\n    }\n    free(m) {\n        m && this.pools.push(m);\n    }\n    get length() {\n        return this.pools.length;\n    }\n    release(...params) {\n        this.pools = [];\n    }\n}\n\nexports.DefaultMat4Allocate = DefaultMat4Allocate, exports.matrixAllocate = new DefaultMatrixAllocate, \nexports.mat4Allocate = new DefaultMat4Allocate;\n//# sourceMappingURL=matrix-allocate.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.graphicCreator = exports.createRichText = exports.createShadowRoot = exports.createPolygon = exports.createImage = exports.createSymbol = exports.createWrapText = exports.createText = exports.createGlyph = exports.createRect3d = exports.createRect = exports.createPath = exports.createLine = exports.createGroup = exports.createCircle = exports.createArea = exports.createPyramid3d = exports.createArc3d = exports.createArc = void 0;\n\nconst arc_1 = require(\"./arc\"), area_1 = require(\"./area\"), circle_1 = require(\"./circle\"), group_1 = require(\"./group\"), image_1 = require(\"./image\"), line_1 = require(\"./line\"), path_1 = require(\"./path\"), polygon_1 = require(\"./polygon\"), rect_1 = require(\"./rect\"), symbol_1 = require(\"./symbol\"), shadow_root_1 = require(\"./shadow-root\"), text_1 = require(\"./text\"), richtext_1 = require(\"./richtext\"), glyph_1 = require(\"./glyph\"), rect3d_1 = require(\"./rect3d\"), arc3d_1 = require(\"./arc3d\"), pyramid3d_1 = require(\"./pyramid3d\"), wrap_text_1 = require(\"./wrap-text\");\n\nfunction createArc(attributes) {\n    return new arc_1.Arc(attributes);\n}\n\nfunction createArc3d(attributes) {\n    return new arc3d_1.Arc3d(attributes);\n}\n\nfunction createPyramid3d(attributes) {\n    return new pyramid3d_1.Pyramid3d(attributes);\n}\n\nfunction createArea(attributes) {\n    return new area_1.Area(attributes);\n}\n\nfunction createCircle(attributes) {\n    return new circle_1.Circle(attributes);\n}\n\nfunction createGroup(attributes) {\n    return new group_1.Group(attributes);\n}\n\nfunction createLine(attributes) {\n    return new line_1.Line(attributes);\n}\n\nfunction createPath(attributes) {\n    return new path_1.Path(attributes);\n}\n\nfunction createRect(attributes) {\n    return new rect_1.Rect(attributes);\n}\n\nfunction createRect3d(attributes) {\n    return new rect3d_1.Rect3d(attributes);\n}\n\nfunction createGlyph(attributes) {\n    return new glyph_1.Glyph(attributes);\n}\n\nfunction createText(attributes) {\n    return new text_1.Text(attributes);\n}\n\nfunction createWrapText(attributes) {\n    return new wrap_text_1.WrapText(attributes);\n}\n\nfunction createSymbol(attributes) {\n    return new symbol_1.Symbol(attributes);\n}\n\nfunction createImage(attributes) {\n    return new image_1.Image(attributes);\n}\n\nfunction createPolygon(attributes) {\n    return new polygon_1.Polygon(attributes);\n}\n\nfunction createShadowRoot(graphic) {\n    return new shadow_root_1.ShadowRoot(graphic);\n}\n\nfunction createRichText(attributes) {\n    return new richtext_1.RichText(attributes);\n}\n\nexports.createArc = createArc, exports.createArc3d = createArc3d, exports.createPyramid3d = createPyramid3d, \nexports.createArea = createArea, exports.createCircle = createCircle, exports.createGroup = createGroup, \nexports.createLine = createLine, exports.createPath = createPath, exports.createRect = createRect, \nexports.createRect3d = createRect3d, exports.createGlyph = createGlyph, exports.createText = createText, \nexports.createWrapText = createWrapText, exports.createSymbol = createSymbol, exports.createImage = createImage, \nexports.createPolygon = createPolygon, exports.createShadowRoot = createShadowRoot, \nexports.createRichText = createRichText, exports.graphicCreator = {\n    arc: createArc,\n    area: createArea,\n    circle: createCircle,\n    group: createGroup,\n    image: createImage,\n    line: createLine,\n    path: createPath,\n    rect: createRect,\n    rect3d: createRect3d,\n    symbol: createSymbol,\n    text: createText,\n    richtext: createRichText,\n    polygon: createPolygon,\n    shadowRoot: createShadowRoot,\n    wrapText: createWrapText\n};\n//# sourceMappingURL=graphic-creator.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.ShadowRoot = void 0;\n\nconst group_1 = require(\"./group\");\n\nclass ShadowRoot extends group_1.Group {\n    constructor(graphic) {\n        super({\n            x: 0,\n            y: 0\n        }), this.type = \"shadowroot\", this.shadowHost = graphic;\n    }\n    addUpdateBoundTag() {\n        super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();\n    }\n    addUpdateShapeAndBoundsTag() {\n        super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();\n    }\n    tryUpdateGlobalTransMatrix(clearTag = !0) {\n        if (this.shouldUpdateGlobalMatrix()) {\n            const m = this.transMatrix;\n            this._globalTransMatrix ? this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f) : this._globalTransMatrix = m.clone(), \n            this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();\n        }\n        return this._globalTransMatrix;\n    }\n    doUpdateGlobalMatrix() {\n        if (this.shadowHost) {\n            const parentMatrix = this.shadowHost.globalTransMatrix;\n            this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);\n        }\n    }\n    tryUpdateGlobalAABBBounds() {\n        return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), \n        this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), \n        this._globalAABBBounds;\n    }\n}\n\nexports.ShadowRoot = ShadowRoot;\n//# sourceMappingURL=shadow-root.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.WrapText = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), layout_1 = require(\"../core/contributions/textMeasure/layout\"), application_1 = require(\"../application\"), text_1 = require(\"./text\"), theme_1 = require(\"./theme\"), WRAP_TEXT_UPDATE_TAG_KEY = [ \"heightLimit\", \"lineClamp\" ];\n\nclass WrapText extends text_1.Text {\n    _isValid() {\n        const {text: text} = this.attribute;\n        return (0, vutils_1.isArray)(text) ? !text.every((t => null == t || \"\" === t)) : null != text && \"\" !== text;\n    }\n    updateMultilineAABBBounds(text) {\n        var _a;\n        const textTheme = (0, theme_1.getTheme)(this).text, {fontFamily: fontFamily = textTheme.fontFamily, textAlign: textAlign = textTheme.textAlign, textBaseline: textBaseline = textTheme.textBaseline, fontSize: fontSize = textTheme.fontSize, lineHeight: lineHeight = this.attribute.lineHeight || this.attribute.fontSize || textTheme.fontSize, ellipsis: ellipsis = textTheme.ellipsis, maxLineWidth: maxLineWidth, stroke: stroke = textTheme.stroke, lineWidth: lineWidth = textTheme.lineWidth, heightLimit: heightLimit = 0, lineClamp: lineClamp} = this.attribute;\n        if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {\n            const bbox = this.cache.layoutData.bbox;\n            return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), \n            stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;\n        }\n        const textMeasure = application_1.application.graphicUtil.textMeasure, layoutObj = new layout_1.CanvasTextLayout(fontFamily, {\n            fontSize: fontSize\n        }, textMeasure), lines = text.map((l => l.toString())), linesLayout = [], bboxWH = [ 0, 0 ];\n        let lineCountLimit = 1 / 0;\n        if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), \n        lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), \"number\" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {\n            if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {\n                const str = lines[i];\n                if (i === lineCountLimit - 1) {\n                    const clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis);\n                    linesLayout.push({\n                        str: clip.str,\n                        width: clip.width\n                    });\n                    break;\n                }\n                const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth);\n                if (linesLayout.push({\n                    str: clip.str,\n                    width: clip.width\n                }), clip.str.length === str.length) ; else {\n                    const newStr = str.substring(clip.str.length);\n                    lines.splice(i + 1, 0, newStr);\n                }\n            }\n            let maxWidth = 0;\n            linesLayout.forEach((layout => {\n                maxWidth = Math.max(maxWidth, layout.width);\n            })), bboxWH[0] = maxWidth;\n        } else {\n            let width, text, lineWidth = 0;\n            for (let i = 0, len = lines.length; i < len; i++) {\n                if (i === lineCountLimit - 1) {\n                    const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis);\n                    linesLayout.push({\n                        str: clip.str,\n                        width: clip.width\n                    }), lineWidth = Math.max(lineWidth, clip.width);\n                    break;\n                }\n                text = lines[i], width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions), \n                lineWidth = Math.max(lineWidth, width), linesLayout.push({\n                    str: text,\n                    width: width\n                });\n            }\n            bboxWH[0] = lineWidth;\n        }\n        bboxWH[1] = linesLayout.length * (lineHeight + 2);\n        const bbox = {\n            xOffset: 0,\n            yOffset: 0,\n            width: bboxWH[0],\n            height: bboxWH[1]\n        };\n        layoutObj.LayoutBBox(bbox, textAlign, textBaseline);\n        const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);\n        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), \n        stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;\n    }\n    needUpdateTags(keys) {\n        for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {\n            const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];\n            if (-1 !== keys.indexOf(attrKey)) return !0;\n        }\n        return super.needUpdateTags(keys);\n    }\n    needUpdateTag(key) {\n        for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {\n            if (key === WRAP_TEXT_UPDATE_TAG_KEY[i]) return !0;\n        }\n        return super.needUpdateTag(key);\n    }\n}\n\nexports.WrapText = WrapText;\n//# sourceMappingURL=wrap-text.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.getTextBounds = void 0;\n\nconst graphic_creator_1 = require(\"./graphic-creator\"), text = (0, graphic_creator_1.createText)({\n    text: \"\"\n});\n\nfunction getTextBounds(params) {\n    return text.setAttributes(params), text.AABBBounds;\n}\n\nexports.getTextBounds = getTextBounds;\n//# sourceMappingURL=bounds.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.canvasAllocate = exports.DefaultCanvasAllocate = void 0;\n\nconst application_1 = require(\"../application\"), util_1 = require(\"../canvas/util\");\n\nclass DefaultCanvasAllocate {\n    constructor() {\n        this.pools = [];\n    }\n    allocate(data) {\n        if (!this.pools.length) return (0, util_1.wrapCanvas)(Object.assign({\n            nativeCanvas: application_1.application.global.createCanvas(data)\n        }, data));\n        const m = this.pools.pop();\n        return m.resize(data.width, data.height), m.dpr = data.dpr, m;\n    }\n    allocateByObj(canvas) {\n        if (!this.pools.length) {\n            const data = {\n                width: canvas.width / canvas.dpr,\n                height: canvas.height / canvas.dpr,\n                dpr: canvas.dpr\n            };\n            return (0, util_1.wrapCanvas)(Object.assign({\n                nativeCanvas: application_1.application.global.createCanvas(data)\n            }, data));\n        }\n        const m = this.pools.pop();\n        return m.width = canvas.width, m.height = canvas.height, m;\n    }\n    free(d) {\n        this.pools.push(d);\n    }\n    get length() {\n        return this.pools.length;\n    }\n    release(...params) {\n        this.pools = [];\n    }\n}\n\nexports.DefaultCanvasAllocate = DefaultCanvasAllocate, exports.canvasAllocate = new DefaultCanvasAllocate;\n//# sourceMappingURL=canvas-allocate.js.map","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasCircleRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), circle_contribution_render_1 = require(\"./contributions/circle-contribution-render\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), utils_1 = require(\"./utils\"), enums_1 = require(\"../../../common/enums\");\n\nlet DefaultCanvasCircleRender = class {\n    constructor(circleRenderContribitions) {\n        this.circleRenderContribitions = circleRenderContribitions, this.numberType = constants_1.CIRCLE_NUMBER_TYPE;\n    }\n    drawShape(circle, context, x, y, drawContext, params, fillCb, strokeCb) {\n        const circleAttribute = (0, theme_1.getTheme)(circle, null == params ? void 0 : params.theme).circle, {fill: fill = circleAttribute.fill, background: background, stroke: stroke = circleAttribute.stroke, radius: radius = circleAttribute.radius, startAngle: startAngle = circleAttribute.startAngle, endAngle: endAngle = circleAttribute.endAngle, fillOpacity: fillOpacity = circleAttribute.fillOpacity, strokeOpacity: strokeOpacity = circleAttribute.strokeOpacity, opacity: opacity = circleAttribute.opacity, lineWidth: lineWidth = circleAttribute.lineWidth, visible: visible = circleAttribute.visible, x: originX = circleAttribute.x, y: originY = circleAttribute.y} = circle.attribute, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        circle.valid && visible && (doFill || doStroke || background) && (fVisible || sVisible || fillCb || strokeCb || background) && (context.beginPath(), \n        context.arc(x, y, radius, startAngle, endAngle), context.closePath(), this._circleRenderContribitions || (this._circleRenderContribitions = this.circleRenderContribitions.getContributions() || [], \n        this._circleRenderContribitions.sort(((a, b) => b.order - a.order))), this._circleRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, fillCb, strokeCb);\n        })), context.setShadowStyle && context.setShadowStyle(circle, circle.attribute, circleAttribute), \n        doFill && (fillCb ? fillCb(context, circle.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), \n        context.fill())), doStroke && (strokeCb ? strokeCb(context, circle.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), \n        context.stroke())), this._circleRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, fillCb, strokeCb);\n        })));\n    }\n    draw(circle, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        context.highPerformanceSave();\n        const circleAttribute = (0, theme_1.getTheme)(circle, null == params ? void 0 : params.theme).circle;\n        let {x: x = circleAttribute.x, y: y = circleAttribute.y} = circle.attribute;\n        if (circle.transMatrix.onlyTranslate()) {\n            const point = circle.getOffsetXY(circleAttribute);\n            x += point.x, y += point.y, context.setTransformForCurrent();\n        } else x = 0, y = 0, context.transformFromMatrix(circle.transMatrix, !0);\n        (0, utils_1.drawPathProxy)(circle, context, x, y, drawContext, params) || this.drawShape(circle, context, x, y, drawContext, params), \n        context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasCircleRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(circle_contribution_render_1.CircleRenderContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasCircleRender), \nexports.DefaultCanvasCircleRender = DefaultCanvasCircleRender;\n//# sourceMappingURL=circle-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCircleTextureRenderContribution = exports.DefaultCircleBackgroundRenderContribution = exports.DefaultCircleRenderContribution = exports.CircleRenderContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), canvas_utils_1 = require(\"../../../../common/canvas-utils\"), base_contribution_render_1 = require(\"./base-contribution-render\"), enums_1 = require(\"../../../../common/enums\");\n\nexports.CircleRenderContribution = Symbol.for(\"CircleRenderContribution\");\n\nlet DefaultCircleRenderContribution = class {\n    constructor() {\n        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, \n        this.order = 0;\n    }\n    drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, fillCb, strokeCb) {\n        const {radius: radius = circleAttribute.radius, startAngle: startAngle = circleAttribute.startAngle, endAngle: endAngle = circleAttribute.endAngle, opacity: opacity = circleAttribute.opacity, outerBorder: outerBorder, innerBorder: innerBorder} = circle.attribute;\n        if (outerBorder) {\n            const {distance: distance = circleAttribute.outerBorder.distance} = outerBorder, dw = (0, \n            canvas_utils_1.getScaledStroke)(context, distance, context.dpr);\n            if (context.beginPath(), context.arc(x, y, radius + dw, startAngle, endAngle), context.closePath(), \n            context.setShadowStyle && context.setShadowStyle(circle, circle.attribute, circleAttribute), \n            strokeCb) strokeCb(context, outerBorder, circleAttribute.outerBorder); else if (sVisible) {\n                const lastOpacity = circleAttribute.outerBorder.opacity;\n                circleAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(circle, outerBorder, x, y, circleAttribute.outerBorder), \n                circleAttribute.outerBorder.opacity = lastOpacity, context.stroke();\n            }\n        }\n        if (innerBorder) {\n            const {distance: distance = circleAttribute.innerBorder.distance} = innerBorder, dw = (0, \n            canvas_utils_1.getScaledStroke)(context, distance, context.dpr);\n            if (context.beginPath(), context.arc(x, y, radius - dw, startAngle, endAngle), context.closePath(), \n            context.setShadowStyle && context.setShadowStyle(circle, circle.attribute, circleAttribute), \n            strokeCb) strokeCb(context, innerBorder, circleAttribute.innerBorder); else if (sVisible) {\n                const lastOpacity = circleAttribute.innerBorder.opacity;\n                circleAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(circle, innerBorder, x, y, circleAttribute.innerBorder), \n                circleAttribute.innerBorder.opacity = lastOpacity, context.stroke();\n            }\n        }\n    }\n};\n\nDefaultCircleRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultCircleRenderContribution), \nexports.DefaultCircleRenderContribution = DefaultCircleRenderContribution;\n\nlet DefaultCircleBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;\n    }\n};\n\nDefaultCircleBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultCircleBackgroundRenderContribution), \nexports.DefaultCircleBackgroundRenderContribution = DefaultCircleBackgroundRenderContribution;\n\nlet DefaultCircleTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;\n    }\n};\n\nDefaultCircleTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultCircleTextureRenderContribution), \nexports.DefaultCircleTextureRenderContribution = DefaultCircleTextureRenderContribution;\n//# sourceMappingURL=circle-contribution-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasLineRender = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), utils_1 = require(\"./utils\"), base_render_1 = require(\"./base-render\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), render_curve_1 = require(\"../../../common/render-curve\"), segment_1 = require(\"../../../common/segment\");\n\nlet DefaultCanvasLineRender = class extends base_render_1.BaseRender {\n    constructor() {\n        super(...arguments), this.numberType = constants_1.LINE_NUMBER_TYPE;\n    }\n    draw(line, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        context.highPerformanceSave();\n        const lineAttribute = (0, theme_1.getTheme)(line, null == params ? void 0 : params.theme).line, data = this.transform(line, lineAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        this.z = z, (0, utils_1.drawPathProxy)(line, context, x, y, drawContext) || (this.drawShape(line, context, x, y, drawContext, params), \n        this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n        context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();\n    }\n    drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {\n        var _a;\n        context.beginPath();\n        const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;\n        (0, render_curve_1.drawSegments)(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {\n            offsetX: offsetX,\n            offsetY: offsetY,\n            offsetZ: z\n        }), line.cache && !(0, vutils_1.isArray)(line.cache) && line.attribute.curveType && line.attribute.curveType.includes(\"Closed\") && context.closePath(), \n        context.setShadowStyle && context.setShadowStyle(line, attribute, defaultAttribute);\n        const {x: originX = 0, x: originY = 0} = attribute;\n        return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), \n        context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), \n        context.stroke())), !1;\n    }\n    drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {\n        const lineAttribute = (0, theme_1.getTheme)(line, null == params ? void 0 : params.theme).line, {fill: fill = lineAttribute.fill, stroke: stroke = lineAttribute.stroke, opacity: opacity = lineAttribute.opacity, fillOpacity: fillOpacity = lineAttribute.fillOpacity, strokeOpacity: strokeOpacity = lineAttribute.strokeOpacity, lineWidth: lineWidth = lineAttribute.lineWidth, visible: visible = lineAttribute.visible} = line.attribute, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        if (!line.valid || !visible) return;\n        if (!doFill && !doStroke) return;\n        if (!(fVisible || sVisible || fillCb || strokeCb)) return;\n        if (line.shouldUpdateShape()) {\n            const {points: points, segments: segments, curveType: curveType = lineAttribute.curveType} = line.attribute, _points = points;\n            if (segments && segments.length) {\n                let startPoint, lastSeg;\n                line.cache = segments.map(((seg, index) => (1 === index ? startPoint = {\n                    x: lastSeg.endX,\n                    y: lastSeg.endY,\n                    defined: lastSeg.curves[lastSeg.curves.length - 1].defined\n                } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined), \n                lastSeg = (0, segment_1.calcLineCache)(seg.points, curveType, {\n                    startPoint: startPoint\n                }), lastSeg)));\n            } else {\n                if (!points || !points.length) return line.cache = null, void line.clearUpdateShapeTag();\n                line.cache = (0, segment_1.calcLineCache)(_points, curveType);\n            }\n            line.clearUpdateShapeTag();\n        }\n        const {clipRange: clipRange = lineAttribute.clipRange, clipRangeByDimension: clipRangeByDimension = lineAttribute.clipRangeByDimension} = line.attribute;\n        if (Array.isArray(line.cache)) if (1 === clipRange) {\n            let skip = !1;\n            line.cache.forEach(((cache, index) => {\n                skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute.segments[index], [ lineAttribute, line.attribute ], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb));\n            }));\n        } else {\n            const totalLength = line.cache.reduce(((l, c) => l + c.getLength()), 0), totalDrawLength = clipRange * totalLength;\n            let drawedLengthUntilLast = 0, skip = !1;\n            line.cache.forEach(((cache, index) => {\n                if (skip) return;\n                const curSegLength = cache.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;\n                drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute.segments[index], [ lineAttribute, line.attribute ], (0, \n                vutils_1.min)(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb));\n            }));\n        } else this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);\n    }\n};\n\nDefaultCanvasLineRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasLineRender), \nexports.DefaultCanvasLineRender = DefaultCanvasLineRender;\n//# sourceMappingURL=line-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BaseRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), graphic_1 = require(\"../../../graphic\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\");\n\nlet BaseRender = class {\n    transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = !1) {\n        const transMatrix = graphic.transMatrix, {x: x = graphicAttribute.x, y: y = graphicAttribute.y, z: z = graphicAttribute.z, scaleX: scaleX = graphicAttribute.scaleX, scaleY: scaleY = graphicAttribute.scaleY, angle: angle = graphicAttribute.angle, postMatrix: postMatrix} = graphic.attribute, onlyTranslate = transMatrix.onlyTranslate() && !postMatrix, lastModelMatrix = context.modelMatrix, camera = context.camera, result = {\n            x: x,\n            y: y,\n            z: z,\n            lastModelMatrix: lastModelMatrix\n        }, shouldTransform3d = camera && (use3dMatrixIn3dMode || (0, graphic_1.shouldUseMat4)(graphic));\n        if (shouldTransform3d) {\n            const nextModelMatrix = matrix_allocate_1.mat4Allocate.allocate(), modelMatrix = matrix_allocate_1.mat4Allocate.allocate();\n            (0, graphic_1.getModelMatrix)(modelMatrix, graphic, graphicAttribute), lastModelMatrix ? (0, \n            graphic_1.multiplyMat4Mat4)(nextModelMatrix, lastModelMatrix, modelMatrix) : (0, \n            graphic_1.multiplyMat4Mat4)(nextModelMatrix, nextModelMatrix, modelMatrix), result.x = 0, \n            result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, !0), \n            matrix_allocate_1.mat4Allocate.free(modelMatrix);\n        }\n        if (onlyTranslate && !lastModelMatrix) {\n            const point = graphic.getOffsetXY(graphicAttribute);\n            result.x += point.x, result.y += point.y, result.z = z, context.setTransformForCurrent();\n        } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, !0); else if (camera && context.project) {\n            const point = graphic.getOffsetXY(graphicAttribute);\n            result.x += point.x, result.y += point.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);\n        } else context.transformFromMatrix(graphic.transMatrix, !0), result.x = 0, result.y = 0, \n        result.z = 0;\n        return result;\n    }\n    transformUseContext2d(graphic, graphicAttribute, z, context) {\n        const camera = context.camera;\n        if (this.camera = camera, camera) {\n            const bounds = graphic.AABBBounds, width = bounds.x2 - bounds.x1, height = bounds.y2 - bounds.y1, p1 = context.project(0, 0, z), p2 = context.project(width, 0, z), p3 = context.project(width, height, z), _p1 = {\n                x: 0,\n                y: 0\n            }, _p2 = {\n                x: width,\n                y: 0\n            }, _p3 = {\n                x: width,\n                y: height\n            };\n            context.camera = null;\n            const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y), m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom, m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom, m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom, m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom, dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom, dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;\n            context.setTransform(m11, m12, m21, m22, dx, dy, !0);\n        }\n    }\n    restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {\n        this.camera && (context.camera = this.camera);\n    }\n    transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle) {\n        const p = context.project(x, y, z);\n        context.translate(p.x, p.y, !1), context.scale(scaleX, scaleY, !1), context.rotate(angle, !1), \n        context.translate(-p.x, -p.y, !1), context.setTransformForCurrent();\n    }\n};\n\nBaseRender = __decorate([ (0, inversify_1.injectable)() ], BaseRender), exports.BaseRender = BaseRender;\n//# sourceMappingURL=base-render.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.drawIncrementalAreaSegments = exports.drawIncrementalSegments = exports.drawSegments = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), enums_1 = require(\"./enums\"), cubic_bezier_1 = require(\"./segment/curve/cubic-bezier\");\n\nfunction drawSegments(path, segPath, percent, clipRangeByDimension, params) {\n    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0} = params || {};\n    let needMoveTo = !0;\n    const {curves: curves} = segPath;\n    if (percent >= 1) return void curves.forEach((curve => {\n        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), \n        drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;\n    }));\n    if (percent <= 0) return;\n    let direction;\n    \"x\" === clipRangeByDimension ? direction = enums_1.Direction.ROW : \"y\" === clipRangeByDimension ? direction = enums_1.Direction.COLUMN : \"auto\" === clipRangeByDimension && (direction = segPath.direction);\n    const totalDrawLength = percent * segPath.tryUpdateLength(direction);\n    let drawedLengthUntilLast = 0;\n    for (let i = 0, n = curves.length; i < n; i++) {\n        const curve = curves[i], curCurveLength = curve.getLength(direction), _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;\n        if (drawedLengthUntilLast += curCurveLength, _p < 0) break;\n        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), \n        drawSegItem(path, curve, (0, vutils_1.min)(_p, 1), params), needMoveTo = !1) : needMoveTo = !0;\n    }\n}\n\nfunction drawIncrementalSegments(path, lastSeg, segments, params) {\n    const {offsetX: offsetX = 0, offsetY: offsetY = 0} = params || {}, startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];\n    path.moveTo(startP.x + offsetX, startP.y + offsetY), segments.points.forEach((p => {\n        !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);\n    }));\n}\n\nfunction drawIncrementalAreaSegments(path, lastSeg, segments, params) {\n    const {offsetX: offsetX = 0, offsetY: offsetY = 0} = params || {}, {points: points} = segments, definedPointsList = [];\n    let lastIdx = 0;\n    for (let i = 0; i < points.length; i++) !1 === points[i].defined && (lastIdx + 1 !== i && definedPointsList.slice(lastIdx, i), \n    lastIdx = i);\n    definedPointsList.length, definedPointsList.push(points), definedPointsList.forEach(((points, i) => {\n        var _a, _b, _c, _d;\n        const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points[0];\n        path.moveTo(startP.x + offsetX, startP.y + offsetY), points.forEach((p => {\n            !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);\n        }));\n        for (let i = points.length - 1; i >= 0; i--) {\n            const p = points[i];\n            path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);\n        }\n        path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), \n        path.closePath();\n    }));\n}\n\nfunction drawSegItem(ctx, curve, endPercent, params) {\n    if (!curve.p1) return;\n    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0} = params || {};\n    if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ); else if (curve.p2 && curve.p3) {\n        const [curve1] = (0, cubic_bezier_1.divideCubic)(curve, endPercent);\n        ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);\n    } else {\n        const p = curve.getPointAt(endPercent);\n        ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);\n    }\n}\n\n//# sourceMappingURL=render-curve.js.map\nexports.drawSegments = drawSegments, exports.drawIncrementalSegments = drawIncrementalSegments, \nexports.drawIncrementalAreaSegments = drawIncrementalAreaSegments;","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasAreaRender = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), segment_1 = require(\"../../../common/segment\"), theme_1 = require(\"../../../graphic/theme\"), utils_1 = require(\"./utils\"), area_contribution_render_1 = require(\"./contributions/area-contribution-render\"), enums_1 = require(\"../../../common/enums\"), render_area_1 = require(\"../../../common/render-area\"), constants_1 = require(\"../../../graphic/constants\");\n\nfunction calcLineCache(points, curveType, params) {\n    switch (curveType) {\n      case \"linear\":\n      default:\n        return (0, segment_1.genLinearSegments)(points, params);\n\n      case \"basis\":\n        return (0, segment_1.genBasisSegments)(points, params);\n\n      case \"monotoneX\":\n        return (0, segment_1.genMonotoneXSegments)(points, params);\n\n      case \"monotoneY\":\n        return (0, segment_1.genMonotoneYSegments)(points, params);\n\n      case \"step\":\n        return (0, segment_1.genStepSegments)(points, .5, params);\n\n      case \"stepBefore\":\n        return (0, segment_1.genStepSegments)(points, 0, params);\n\n      case \"stepAfter\":\n        return (0, segment_1.genStepSegments)(points, 1, params);\n\n      case \"linearClosed\":\n        return (0, segment_1.genLinearClosedSegments)(points, params);\n    }\n}\n\nlet DefaultCanvasAreaRender = class {\n    constructor(areaRenderContribitions) {\n        this.areaRenderContribitions = areaRenderContribitions, this.numberType = constants_1.AREA_NUMBER_TYPE;\n    }\n    drawShape(area, context, x, y, drawContext, params, fillCb, strokeCb) {\n        var _a, _b, _c, _d, _e, _f;\n        const areaAttribute = (0, theme_1.getTheme)(area, null == params ? void 0 : params.theme).area, {fill: fill = areaAttribute.fill, fillOpacity: fillOpacity = areaAttribute.fillOpacity, opacity: opacity = areaAttribute.opacity, visible: visible = areaAttribute.visible, z: z = areaAttribute.z, stroke: stroke = area.attribute.stroke, lineWidth: lineWidth = areaAttribute.lineWidth, strokeOpacity: strokeOpacity = areaAttribute.strokeOpacity} = area.attribute, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), doFill = (0, utils_1.runFill)(fill), doStroke = (0, \n        utils_1.runStroke)(stroke, lineWidth), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity);\n        if (!area.valid || !visible) return;\n        if (!doFill && !doStroke) return;\n        if (!(fVisible || fillCb || sVisible || strokeCb)) return;\n        const {clipRange: clipRange = areaAttribute.clipRange} = area.attribute;\n        if (area.shouldUpdateShape()) {\n            const {points: points, segments: segments, curveType: curveType = areaAttribute.curveType} = area.attribute;\n            if (segments && segments.length) {\n                let startPoint, lastTopSeg;\n                const topCaches = segments.map(((seg, index) => (1 === index ? startPoint = {\n                    x: lastTopSeg.endX,\n                    y: lastTopSeg.endY\n                } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY), \n                lastTopSeg = calcLineCache(seg.points, curveType, {\n                    startPoint: startPoint\n                }), lastTopSeg)));\n                let lastBottomSeg;\n                const bottomCaches = [];\n                for (let i = segments.length - 1; i >= 0; i--) {\n                    const points = segments[i].points, bottomPoints = [];\n                    for (let i = points.length - 1; i >= 0; i--) bottomPoints.push({\n                        x: null !== (_a = points[i].x1) && void 0 !== _a ? _a : points[i].x,\n                        y: null !== (_b = points[i].y1) && void 0 !== _b ? _b : points[i].y\n                    });\n                    if (0 !== i) {\n                        const lastSegmentPoints = segments[i - 1].points, endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];\n                        endPoint && bottomPoints.push({\n                            x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,\n                            y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y\n                        });\n                    }\n                    lastBottomSeg = calcLineCache(bottomPoints, curveType), bottomCaches.unshift(lastBottomSeg);\n                }\n                area.cacheArea = bottomCaches.map(((item, index) => ({\n                    top: topCaches[index],\n                    bottom: item\n                })));\n            } else {\n                if (!points || !points.length) return area.cache = null, void area.clearUpdateShapeTag();\n                {\n                    const topPoints = points, bottomPoints = [];\n                    for (let i = points.length - 1; i >= 0; i--) bottomPoints.push({\n                        x: null !== (_e = points[i].x1) && void 0 !== _e ? _e : points[i].x,\n                        y: null !== (_f = points[i].y1) && void 0 !== _f ? _f : points[i].y\n                    });\n                    const topCache = calcLineCache(topPoints, curveType), bottomCache = calcLineCache(bottomPoints, \"stepBefore\" === curveType ? \"stepAfter\" : \"stepAfter\" === curveType ? \"stepBefore\" : curveType);\n                    area.cacheArea = {\n                        top: topCache,\n                        bottom: bottomCache\n                    };\n                }\n            }\n            area.clearUpdateShapeTag();\n        }\n        if (Array.isArray(area.cacheArea)) if (1 === clipRange) {\n            let skip = !1;\n            area.cacheArea.forEach(((cache, index) => {\n                skip || (skip = this.drawSegmentItem(context, cache, !!fill, fillOpacity, area.attribute.segments[index], [ areaAttribute, area.attribute ], clipRange, x, y, z, area, fillCb));\n            }));\n        } else {\n            const totalLength = area.cacheArea.reduce(((l, c) => l + c.top.getLength()), 0), totalDrawLength = clipRange * totalLength;\n            let drawedLengthUntilLast = 0, skip = !1;\n            area.cacheArea.forEach(((cache, index) => {\n                if (skip) return;\n                const curSegLength = cache.top.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;\n                drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, fillOpacity, area.attribute.segments[index], [ areaAttribute, area.attribute ], (0, \n                vutils_1.min)(_cr, 1), x, y, z, area, fillCb));\n            }));\n        } else this.drawSegmentItem(context, area.cacheArea, !!fill, fillOpacity, area.attribute, areaAttribute, clipRange, x, y, z, area, fillCb);\n    }\n    draw(area, renderService, drawContext, params) {\n        const {context: context} = drawContext, areaAttribute = (0, theme_1.getTheme)(area, null == params ? void 0 : params.theme).area;\n        let {x: x = areaAttribute.x, y: y = areaAttribute.y} = area.attribute;\n        if (context.highPerformanceSave(), area.transMatrix.onlyTranslate()) {\n            const point = area.getOffsetXY(areaAttribute);\n            x += point.x, y += point.y, context.setTransformForCurrent();\n        } else x = 0, y = 0, context.transformFromMatrix(area.transMatrix, !0);\n        (0, utils_1.drawPathProxy)(area, context, x, y, drawContext, params) || this.drawShape(area, context, x, y, drawContext, params), \n        context.highPerformanceRestore();\n    }\n    drawSegmentItem(context, cache, fill, fillOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, fillCb) {\n        context.beginPath();\n        (0, render_area_1.drawAreaSegments)(context.camera ? context : context.nativeContext, cache, clipRange, {\n            offsetX: offsetX,\n            offsetY: offsetY,\n            offsetZ: offsetZ\n        }), this._areaRenderContribitions || (this._areaRenderContribitions = this.areaRenderContribitions.getContributions() || [], \n        this._areaRenderContribitions.sort(((a, b) => b.order - a.order))), this._areaRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, fillCb, null, {\n                attribute: attribute\n            });\n        })), context.setShadowStyle && context.setShadowStyle(area, attribute, defaultAttribute);\n        const {x: originX = 0, x: originY = 0} = attribute;\n        return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), \n        context.fill())), this._areaRenderContribitions || (this._areaRenderContribitions = this.areaRenderContribitions.getContributions() || []), \n        this._areaRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, fillCb, null, {\n                attribute: attribute\n            });\n        })), !1;\n    }\n};\n\nDefaultCanvasAreaRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(area_contribution_render_1.AreaRenderContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasAreaRender), \nexports.DefaultCanvasAreaRender = DefaultCanvasAreaRender;\n//# sourceMappingURL=area-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultAreaTextureRenderContribution = exports.DefaultAreaBackgroundRenderContribution = exports.AreaRenderContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), base_contribution_render_1 = require(\"./base-contribution-render\"), utils_1 = require(\"../../../../common/utils\"), enums_1 = require(\"../../../../common/enums\");\n\nexports.AreaRenderContribution = Symbol.for(\"AreaRenderContribution\");\n\nlet DefaultAreaBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;\n    }\n};\n\nDefaultAreaBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultAreaBackgroundRenderContribution), \nexports.DefaultAreaBackgroundRenderContribution = DefaultAreaBackgroundRenderContribution;\n\nlet DefaultAreaTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;\n    }\n    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb, options) {\n        var _a, _b, _c, _d;\n        this.textureMap || this.initTextureMap(context, graphic.stage);\n        const {attribute: attribute = graphic.attribute} = options || {}, {texture: texture = (null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : (0, \n        utils_1.getAttributeFromDefaultAttrList)(graphicAttribute, \"texture\")), textureColor: textureColor = (null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : (0, \n        utils_1.getAttributeFromDefaultAttrList)(graphicAttribute, \"textureColor\")), textureSize: textureSize = (null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : (0, \n        utils_1.getAttributeFromDefaultAttrList)(graphicAttribute, \"textureSize\")), texturePadding: texturePadding = (null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : (0, \n        utils_1.getAttributeFromDefaultAttrList)(graphicAttribute, \"texturePadding\"))} = attribute;\n        if (!texture) return;\n        let pattern = this.textureMap.get(texture);\n        if (!pattern) switch (texture) {\n          case \"circle\":\n            pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"diamond\":\n            pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"rect\":\n            pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"vertical-line\":\n            pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"horizontal-line\":\n            pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"bias-lr\":\n            pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"bias-rl\":\n            pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);\n            break;\n\n          case \"grid\":\n            pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);\n        }\n        pattern && (context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), \n        context.fillStyle = pattern, context.fill(), context.highPerformanceRestore());\n    }\n};\n\nDefaultAreaTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultAreaTextureRenderContribution), \nexports.DefaultAreaTextureRenderContribution = DefaultAreaTextureRenderContribution;\n//# sourceMappingURL=area-contribution-render.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.drawAreaSegments = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), enums_1 = require(\"./enums\"), cubic_bezier_1 = require(\"./segment/curve/cubic-bezier\"), line_1 = require(\"./segment/curve/line\");\n\nfunction drawAreaSegments(path, segPath, percent, params) {\n    var _a;\n    const {top: top, bottom: bottom} = segPath;\n    if (percent >= 1) {\n        const topList = [], bottomList = [];\n        let lastDefined = !0;\n        for (let i = 0, n = top.curves.length; i < n; i++) {\n            const topCurve = top.curves[i];\n            lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), \n            topList.length = 0, bottomList.length = 0) : (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1])), \n            lastDefined = !lastDefined) : lastDefined && (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1]));\n        }\n        return void drawAreaBlock(path, topList, bottomList, params);\n    }\n    if (percent <= 0) return;\n    let {direction: direction} = params || {};\n    const {curves: topCurves} = top, endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1, xTotalLength = (0, \n    vutils_1.abs)(endP.x - topCurves[0].p0.x), yTotalLength = (0, vutils_1.abs)(endP.y - topCurves[0].p0.y);\n    direction = null != direction ? direction : xTotalLength > yTotalLength ? enums_1.Direction.ROW : enums_1.Direction.COLUMN, \n    Number.isFinite(xTotalLength) || (direction = enums_1.Direction.COLUMN), Number.isFinite(yTotalLength) || (direction = enums_1.Direction.ROW);\n    const totalDrawLength = percent * (direction === enums_1.Direction.ROW ? xTotalLength : yTotalLength);\n    let drawedLengthUntilLast = 0, lastDefined = !0;\n    const topList = [], bottomList = [];\n    for (let i = 0, n = top.curves.length; i < n; i++) {\n        const topCurve = top.curves[i], curCurveLength = topCurve.getLength(direction), percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;\n        if (percent < 0) break;\n        drawedLengthUntilLast += curCurveLength;\n        let tc = null, bc = null;\n        lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), \n        topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n - i - 1]), \n        lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n - i - 1]), \n        tc && bc && (percent < 1 && (tc = tc.p2 && tc.p3 ? (0, cubic_bezier_1.divideCubic)(tc, percent)[0] : (0, \n        line_1.divideLinear)(tc, percent)[0], bc = bc.p2 && bc.p3 ? (0, cubic_bezier_1.divideCubic)(bc, 1 - percent)[1] : (0, \n        line_1.divideLinear)(bc, 1 - percent)[1]), tc.defined = lastDefined, bc.defined = lastDefined, \n        topList.push(tc), bottomList.push(bc)), tc = null, bc = null;\n    }\n    drawAreaBlock(path, topList, bottomList, params);\n}\n\nfunction drawAreaBlock(path, topList, bottomList, params) {\n    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0} = params || {};\n    let needMoveTo = !0;\n    topList.forEach((curve => {\n        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), \n        drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;\n    })), needMoveTo = !0;\n    for (let i = bottomList.length - 1; i >= 0; i--) {\n        const curve = bottomList[i];\n        curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), \n        drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;\n    }\n}\n\nfunction drawSegItem(ctx, curve, endPercent, params) {\n    if (!curve.p1) return;\n    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0} = params || {};\n    if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ); else if (curve.p2 && curve.p3) {\n        const [curve1] = (0, cubic_bezier_1.divideCubic)(curve, endPercent);\n        ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);\n    } else {\n        const p = curve.getPointAt(endPercent);\n        ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);\n    }\n}\n\n//# sourceMappingURL=render-area.js.map\nexports.drawAreaSegments = drawAreaSegments;","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasPathRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), render_command_list_1 = require(\"../../../common/render-command-list\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), utils_1 = require(\"./utils\"), path_contribution_render_1 = require(\"./contributions/path-contribution-render\"), enums_1 = require(\"../../../common/enums\"), base_render_1 = require(\"./base-render\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\");\n\nlet DefaultCanvasPathRender = class extends base_render_1.BaseRender {\n    constructor(pathRenderContribitions) {\n        super(), this.pathRenderContribitions = pathRenderContribitions, this.numberType = constants_1.PATH_NUMBER_TYPE;\n    }\n    drawShape(path, context, x, y, drawContext, params, fillCb, strokeCb) {\n        var _a, _b;\n        const pathAttribute = (0, theme_1.getTheme)(path, null == params ? void 0 : params.theme).path, {fill: fill = pathAttribute.fill, stroke: stroke = pathAttribute.stroke, fillOpacity: fillOpacity = pathAttribute.fillOpacity, strokeOpacity: strokeOpacity = pathAttribute.strokeOpacity, opacity: opacity = pathAttribute.opacity, background: background, lineWidth: lineWidth = pathAttribute.lineWidth, visible: visible = pathAttribute.visible, x: originX = pathAttribute.x, y: originY = pathAttribute.y} = path.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        if (path.valid && visible && (doFill || doStroke || background) && (fVisible || sVisible || fillCb || strokeCb || background)) {\n            if (context.beginPath(), path.pathShape) (0, render_command_list_1.renderCommandList)(path.pathShape.commandList, context, x, y, 1, 1, z); else {\n                const path2D = null !== (_b = path.attribute.path) && void 0 !== _b ? _b : pathAttribute.path;\n                (0, render_command_list_1.renderCommandList)(path2D.commandList, context, x, y, 1, 1, z);\n            }\n            this._pathRenderContribitions || (this._pathRenderContribitions = this.pathRenderContribitions.getContributions() || [], \n            this._pathRenderContribitions.sort(((a, b) => b.order - a.order))), this._pathRenderContribitions.forEach((c => {\n                c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, fillCb, strokeCb);\n            })), context.setShadowStyle && context.setShadowStyle(path, path.attribute, pathAttribute), \n            doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute), \n            context.stroke())), doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute), \n            context.fill())), this._pathRenderContribitions.forEach((c => {\n                c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, fillCb, strokeCb);\n            }));\n        }\n    }\n    draw(path, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        context.highPerformanceSave();\n        const pathAttribute = (0, theme_1.getTheme)(path, null == params ? void 0 : params.theme).path, data = this.transform(path, pathAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        this.z = z, (0, utils_1.drawPathProxy)(path, context, x, y, drawContext, params) || (this.drawShape(path, context, x, y, drawContext, params), \n        this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n        context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasPathRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(path_contribution_render_1.PathRenderContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasPathRender), \nexports.DefaultCanvasPathRender = DefaultCanvasPathRender;\n//# sourceMappingURL=path-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultPathTextureRenderContribution = exports.DefaultPathBackgroundRenderContribution = exports.PathRenderContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), base_contribution_render_1 = require(\"./base-contribution-render\"), enums_1 = require(\"../../../../common/enums\");\n\nexports.PathRenderContribution = Symbol.for(\"PathRenderContribution\");\n\nlet DefaultPathBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;\n    }\n};\n\nDefaultPathBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPathBackgroundRenderContribution), \nexports.DefaultPathBackgroundRenderContribution = DefaultPathBackgroundRenderContribution;\n\nlet DefaultPathTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;\n    }\n};\n\nDefaultPathTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPathTextureRenderContribution), \nexports.DefaultPathTextureRenderContribution = DefaultPathTextureRenderContribution;\n//# sourceMappingURL=path-contribution-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasRectRender = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), rect_1 = require(\"../../../common/shape/rect\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), rect_contribution_render_1 = require(\"./contributions/rect-contribution-render\"), utils_1 = require(\"./utils\"), enums_1 = require(\"../../../common/enums\");\n\nlet DefaultCanvasRectRender = class {\n    constructor(rectRenderContribitions) {\n        this.rectRenderContribitions = rectRenderContribitions, this.type = \"rect\", this.numberType = constants_1.RECT_NUMBER_TYPE;\n    }\n    drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {\n        const rectAttribute = (0, theme_1.getTheme)(rect, null == params ? void 0 : params.theme).rect, {fill: fill = rectAttribute.fill, background: background, stroke: stroke = rectAttribute.stroke, width: width = rectAttribute.width, height: height = rectAttribute.height, cornerRadius: cornerRadius = rectAttribute.cornerRadius, opacity: opacity = rectAttribute.opacity, fillOpacity: fillOpacity = rectAttribute.fillOpacity, lineWidth: lineWidth = rectAttribute.lineWidth, strokeOpacity: strokeOpacity = rectAttribute.strokeOpacity, visible: visible = rectAttribute.visible, x: originX = rectAttribute.x, y: originY = rectAttribute.y} = rect.attribute, fVisible = (0, \n        utils_1.rectFillVisible)(opacity, fillOpacity, width, height), sVisible = (0, utils_1.rectStrokeVisible)(opacity, strokeOpacity, width, height), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        if (!rect.valid || !visible) return;\n        if (!(doFill || doStroke || background)) return;\n        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;\n        0 === cornerRadius || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (context.beginPath(), \n        context.rect(x, y, width, height)) : (context.beginPath(), (0, rect_1.createRectPath)(context, x, y, width, height, cornerRadius)), \n        this._rectRenderContribitions || (this._rectRenderContribitions = this.rectRenderContribitions.getContributions() || [], \n        this._rectRenderContribitions.sort(((a, b) => b.order - a.order)));\n        const doFillOrStroke = {\n            doFill: doFill,\n            doStroke: doStroke\n        };\n        this._rectRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, fillCb, strokeCb, doFillOrStroke);\n        })), context.setShadowStyle && context.setShadowStyle(rect, rect.attribute, rectAttribute), \n        doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), \n        context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), \n        context.stroke())), this._rectRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, fillCb, strokeCb);\n        }));\n    }\n    draw(rect, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        context.highPerformanceSave();\n        const rectAttribute = (0, theme_1.getTheme)(rect, null == params ? void 0 : params.theme).rect;\n        let {x: x = rectAttribute.x, y: y = rectAttribute.y} = rect.attribute;\n        if (rect.transMatrix.onlyTranslate()) {\n            const point = rect.getOffsetXY(rectAttribute);\n            x += point.x, y += point.y, context.setTransformForCurrent();\n        } else x = 0, y = 0, context.transformFromMatrix(rect.transMatrix, !0);\n        (0, utils_1.drawPathProxy)(rect, context, x, y, drawContext, params) || this.drawShape(rect, context, x, y, drawContext, params), \n        context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasRectRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(rect_contribution_render_1.RectRenderContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasRectRender), \nexports.DefaultCanvasRectRender = DefaultCanvasRectRender;\n//# sourceMappingURL=rect-render.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.createRectPath = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), halfPi = vutils_1.pi / 2;\n\nfunction createRectPath(path, x, y, width, height, rectCornerRadius) {\n    let cornerRadius;\n    if ((0, vutils_1.isNumber)(rectCornerRadius, !0)) cornerRadius = [ rectCornerRadius, rectCornerRadius, rectCornerRadius, rectCornerRadius ]; else if (Array.isArray(rectCornerRadius)) {\n        const cornerRadiusArr = rectCornerRadius;\n        switch (cornerRadiusArr.length) {\n          case 0:\n            cornerRadius = [ 0, 0, 0, 0 ];\n            break;\n\n          case 1:\n            cornerRadius = [ cornerRadiusArr[0], cornerRadiusArr[0], cornerRadiusArr[0], cornerRadiusArr[0] ];\n            break;\n\n          case 2:\n          case 3:\n            cornerRadius = [ cornerRadiusArr[0], cornerRadiusArr[1], cornerRadiusArr[0], cornerRadiusArr[1] ];\n            break;\n\n          default:\n            cornerRadius = cornerRadiusArr.slice(0, 5);\n        }\n    } else cornerRadius = [ 0, 0, 0, 0 ];\n    if (width < 0 || Math.abs(cornerRadius[0]) + Math.abs(cornerRadius[1]) + Math.abs(cornerRadius[2]) + Math.abs(cornerRadius[3]) < 1e-12) return path.rect(x, y, width, height);\n    const [leftTop, rightTop, rightBottom, leftBottom] = [ [ x, y ], [ x + width, y ], [ x + width, y + height ], [ x, y + height ] ], maxCornerRadius = Math.min(width / 2, height / 2), _cornerRadius = [ Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3]) ], leftTopPoint1 = [ leftTop[0] + _cornerRadius[0], leftTop[1] ], leftTopPoint2 = [ leftTop[0], leftTop[1] + _cornerRadius[0] ], rightTopPoint1 = [ rightTop[0] - _cornerRadius[1], rightTop[1] ], rightTopPoint2 = [ rightTop[0], rightTop[1] + _cornerRadius[1] ], rightBottomPoint1 = [ rightBottom[0] - _cornerRadius[2], rightBottom[1] ], rightBottomPoint2 = [ rightBottom[0], rightBottom[1] - _cornerRadius[2] ], leftBottomPoint1 = [ leftBottom[0] + _cornerRadius[3], leftBottom[1] ], leftBottomPoint2 = [ leftBottom[0], leftBottom[1] - _cornerRadius[3] ];\n    if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), \n    !(0, vutils_1.arrayEqual)(rightTopPoint1, rightTopPoint2)) {\n        const centerX = rightTopPoint1[0], centerY = rightTopPoint1[1] + _cornerRadius[1];\n        path.arc(centerX, centerY, _cornerRadius[1], -halfPi, 0, !1);\n    }\n    if (path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !(0, vutils_1.arrayEqual)(rightBottomPoint1, rightBottomPoint2)) {\n        const centerX = rightBottomPoint2[0] - _cornerRadius[2], centerY = rightBottomPoint2[1];\n        path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi, !1);\n    }\n    if (path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !(0, vutils_1.arrayEqual)(leftBottomPoint1, leftBottomPoint2)) {\n        const centerX = leftBottomPoint1[0], centerY = leftBottomPoint1[1] - _cornerRadius[3];\n        path.arc(centerX, centerY, _cornerRadius[3], halfPi, vutils_1.pi, !1);\n    }\n    if (path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !(0, vutils_1.arrayEqual)(leftTopPoint1, leftTopPoint2)) {\n        const centerX = leftTopPoint1[0], centerY = leftTopPoint1[1] + _cornerRadius[0];\n        path.arc(centerX, centerY, _cornerRadius[0], vutils_1.pi, vutils_1.pi + halfPi, !1);\n    }\n    return path.closePath(), path;\n}\n\nexports.createRectPath = createRectPath;\n//# sourceMappingURL=rect.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.SplitRectAfterRenderContribution = exports.SplitRectBeforeRenderContribution = exports.DefaultRectTextureRenderContribution = exports.DefaultRectBackgroundRenderContribution = exports.DefaultRectRenderContribution = exports.RectRenderContribution = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), canvas_utils_1 = require(\"../../../../common/canvas-utils\"), base_contribution_render_1 = require(\"./base-contribution-render\"), rect_1 = require(\"../../../../common/shape/rect\"), enums_1 = require(\"../../../../common/enums\");\n\nexports.RectRenderContribution = Symbol.for(\"RectRenderContribution\");\n\nlet DefaultRectRenderContribution = class {\n    constructor() {\n        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, \n        this.order = 0;\n    }\n    drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, fillCb, strokeCb) {\n        const {width: width = rectAttribute.width, height: height = rectAttribute.height, cornerRadius: cornerRadius = rectAttribute.cornerRadius, opacity: opacity = rectAttribute.opacity, outerBorder: outerBorder, innerBorder: innerBorder} = rect.attribute;\n        if (outerBorder) {\n            const {distance: distance = rectAttribute.outerBorder.distance} = outerBorder, d = (0, \n            canvas_utils_1.getScaledStroke)(context, distance, context.dpr), nextX = x - d, nextY = y - d, dw = 2 * d;\n            if (0 === cornerRadius || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (context.beginPath(), \n            context.rect(nextX, nextY, width + dw, height + dw)) : (context.beginPath(), (0, \n            rect_1.createRectPath)(context, nextX, nextY, width + dw, height + dw, cornerRadius)), \n            context.setShadowStyle && context.setShadowStyle(rect, rect.attribute, rectAttribute), \n            strokeCb) strokeCb(context, outerBorder, rectAttribute.outerBorder); else if (sVisible) {\n                const lastOpacity = rectAttribute.outerBorder.opacity;\n                rectAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(rect, outerBorder, x, y, rectAttribute.outerBorder), \n                rectAttribute.outerBorder.opacity = lastOpacity, context.stroke();\n            }\n        }\n        if (innerBorder) {\n            const {distance: distance = rectAttribute.innerBorder.distance} = innerBorder, d = (0, \n            canvas_utils_1.getScaledStroke)(context, distance, context.dpr), nextX = x + d, nextY = y + d, dw = 2 * d;\n            if (0 === cornerRadius || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (context.beginPath(), \n            context.rect(nextX, nextY, width - dw, height - dw)) : (context.beginPath(), (0, \n            rect_1.createRectPath)(context, nextX, nextY, width - dw, height - dw, cornerRadius)), \n            context.setShadowStyle && context.setShadowStyle(rect, rect.attribute, rectAttribute), \n            strokeCb) strokeCb(context, innerBorder, rectAttribute.innerBorder); else if (sVisible) {\n                const lastOpacity = rectAttribute.innerBorder.opacity;\n                rectAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(rect, innerBorder, x, y, rectAttribute.innerBorder), \n                rectAttribute.innerBorder.opacity = lastOpacity, context.stroke();\n            }\n        }\n    }\n};\n\nDefaultRectRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultRectRenderContribution), \nexports.DefaultRectRenderContribution = DefaultRectRenderContribution;\n\nlet DefaultRectBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;\n    }\n};\n\nDefaultRectBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultRectBackgroundRenderContribution), \nexports.DefaultRectBackgroundRenderContribution = DefaultRectBackgroundRenderContribution;\n\nlet DefaultRectTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;\n    }\n};\n\nDefaultRectTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultRectTextureRenderContribution), \nexports.DefaultRectTextureRenderContribution = DefaultRectTextureRenderContribution;\n\nlet SplitRectBeforeRenderContribution = class {\n    constructor() {\n        this.time = enums_1.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, \n        this.order = 0;\n    }\n    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb, doFillOrStroke) {\n        const {stroke: stroke = groupAttribute.stroke} = group.attribute;\n        Array.isArray(stroke) && stroke.some((s => !1 === s)) && (doFillOrStroke.doStroke = !1);\n    }\n};\n\nSplitRectBeforeRenderContribution = __decorate([ (0, inversify_1.injectable)() ], SplitRectBeforeRenderContribution), \nexports.SplitRectBeforeRenderContribution = SplitRectBeforeRenderContribution;\n\nlet SplitRectAfterRenderContribution = class {\n    constructor() {\n        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, \n        this.order = 0;\n    }\n    drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb) {\n        const {width: width = groupAttribute.width, height: height = groupAttribute.height, stroke: stroke = groupAttribute.stroke} = rect.attribute;\n        if (Array.isArray(stroke) && stroke.some((s => !1 === s))) {\n            if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), context.beginPath(), \n            context.moveTo(x, y), stroke[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), \n            stroke[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), \n            stroke[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke[3]) {\n                const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;\n                context.lineTo(x, adjustY);\n            } else context.moveTo(x, y);\n            context.stroke();\n        }\n    }\n};\n\nSplitRectAfterRenderContribution = __decorate([ (0, inversify_1.injectable)() ], SplitRectAfterRenderContribution), \nexports.SplitRectAfterRenderContribution = SplitRectAfterRenderContribution;\n//# sourceMappingURL=rect-contribution-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasSymbolRender = void 0;\n\nconst matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), inversify_1 = require(\"inversify\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), base_render_1 = require(\"./base-render\"), enums_1 = require(\"../../../common/enums\"), symbol_contribution_render_1 = require(\"./contributions/symbol-contribution-render\"), utils_1 = require(\"./utils\");\n\nlet DefaultCanvasSymbolRender = class extends base_render_1.BaseRender {\n    constructor(symbolRenderContribitions) {\n        super(), this.symbolRenderContribitions = symbolRenderContribitions, this.numberType = constants_1.SYMBOL_NUMBER_TYPE;\n    }\n    drawShape(symbol, context, x, y, drawContext, params, fillCb, strokeCb) {\n        var _a;\n        const symbolAttribute = (0, theme_1.getTheme)(symbol, null == params ? void 0 : params.theme).symbol, {size: size = symbolAttribute.size, fill: fill = symbolAttribute.fill, background: background, fillOpacity: fillOpacity = symbolAttribute.fillOpacity, strokeOpacity: strokeOpacity = symbolAttribute.strokeOpacity, opacity: opacity = symbolAttribute.opacity, lineWidth: lineWidth = symbolAttribute.lineWidth, stroke: stroke = symbolAttribute.stroke, visible: visible = symbolAttribute.visible, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX: scaleX = symbolAttribute.scaleX, scaleY: scaleY = symbolAttribute.scaleY} = symbol.attribute, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        if (!symbol.valid || !visible) return;\n        if (!(doFill || doStroke || background)) return;\n        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;\n        const parsedPath = symbol.getParsedPath();\n        if (!parsedPath) return;\n        const {keepDirIn3d: keepDirIn3d = symbolAttribute.keepDirIn3d} = symbol.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;\n        if (context.beginPath(), keepDirIn3d && context.camera && context.project) {\n            const p = context.project(x, y, z), camera = context.camera;\n            context.camera = null, !1 === parsedPath.draw(context, size, p.x, p.y) && context.closePath(), \n            context.camera = camera;\n        } else !1 === parsedPath.draw(context, size, x, y, z) && context.closePath();\n        this._symbolRenderContribitions || (this._symbolRenderContribitions = this.symbolRenderContribitions.getContributions() || [], \n        this._symbolRenderContribitions.sort(((a, b) => b.order - a.order))), this._symbolRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, fillCb, strokeCb);\n        })), context.setShadowStyle && context.setShadowStyle(symbol, symbol.attribute, symbolAttribute), \n        doFill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), \n        context.fill())), doStroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), \n        context.stroke())), this._symbolRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, fillCb, strokeCb);\n        }));\n    }\n    draw(symbol, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        context.highPerformanceSave();\n        const symbolAttribute = (0, theme_1.getTheme)(symbol, null == params ? void 0 : params.theme).symbol, data = this.transform(symbol, symbolAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        this.z = z, (0, utils_1.drawPathProxy)(symbol, context, x, y, drawContext, params) || (this.drawShape(symbol, context, x, y, drawContext, params), \n        this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n        context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasSymbolRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(symbol_contribution_render_1.SymbolRenderContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasSymbolRender), \nexports.DefaultCanvasSymbolRender = DefaultCanvasSymbolRender;\n//# sourceMappingURL=symbol-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultSymbolTextureRenderContribution = exports.DefaultSymbolBackgroundRenderContribution = exports.DefaultSymbolRenderContribution = exports.SymbolRenderContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), canvas_utils_1 = require(\"../../../../common/canvas-utils\"), base_contribution_render_1 = require(\"./base-contribution-render\"), enums_1 = require(\"../../../../common/enums\");\n\nexports.SymbolRenderContribution = Symbol.for(\"SymbolRenderContribution\");\n\nlet DefaultSymbolRenderContribution = class {\n    constructor() {\n        this.time = enums_1.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, \n        this.order = 0;\n    }\n    drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, fillCb, strokeCb) {\n        const {size: size = symbolAttribute.size, opacity: opacity = symbolAttribute.opacity, outerBorder: outerBorder, innerBorder: innerBorder} = symbol.attribute, parsedPath = symbol.getParsedPath();\n        if (parsedPath) {\n            if (outerBorder) {\n                const {distance: distance = symbolAttribute.outerBorder.distance} = outerBorder, d = (0, \n                canvas_utils_1.getScaledStroke)(context, distance, context.dpr);\n                if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, d) && context.closePath(), \n                context.setShadowStyle && context.setShadowStyle(symbol, symbol.attribute, symbolAttribute), \n                strokeCb) strokeCb(context, outerBorder, symbolAttribute.outerBorder); else if (sVisible) {\n                    const lastOpacity = symbolAttribute.outerBorder.opacity;\n                    symbolAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(symbol, outerBorder, x, y, symbolAttribute.outerBorder), \n                    symbolAttribute.outerBorder.opacity = lastOpacity, context.stroke();\n                }\n            }\n            if (innerBorder) {\n                const {distance: distance = symbolAttribute.innerBorder.distance} = innerBorder, d = (0, \n                canvas_utils_1.getScaledStroke)(context, distance, context.dpr);\n                if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, -d) && context.closePath(), \n                context.setShadowStyle && context.setShadowStyle(symbol, symbol.attribute, symbolAttribute), \n                strokeCb) strokeCb(context, innerBorder, symbolAttribute.innerBorder); else if (sVisible) {\n                    const lastOpacity = symbolAttribute.innerBorder.opacity;\n                    symbolAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(symbol, innerBorder, x, y, symbolAttribute.innerBorder), \n                    symbolAttribute.innerBorder.opacity = lastOpacity, context.stroke();\n                }\n            }\n        }\n    }\n};\n\nDefaultSymbolRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultSymbolRenderContribution), \nexports.DefaultSymbolRenderContribution = DefaultSymbolRenderContribution;\n\nclass DefaultSymbolBackgroundRenderContribution extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;\n    }\n}\n\nexports.DefaultSymbolBackgroundRenderContribution = DefaultSymbolBackgroundRenderContribution;\n\nclass DefaultSymbolTextureRenderContribution extends base_contribution_render_1.DefaultBaseTextureRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;\n    }\n}\n\nexports.DefaultSymbolTextureRenderContribution = DefaultSymbolTextureRenderContribution;\n//# sourceMappingURL=symbol-contribution-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasTextRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), text_1 = require(\"../../../common/text\"), utils_1 = require(\"./utils\"), base_render_1 = require(\"./base-render\");\n\nlet DefaultCanvasTextRender = class extends base_render_1.BaseRender {\n    constructor() {\n        super(...arguments), this.numberType = constants_1.TEXT_NUMBER_TYPE;\n    }\n    drawShape(text, context, x, y, drawContext, params, fillCb, strokeCb) {\n        var _a;\n        const textAttribute = (0, theme_1.getTheme)(text, null == params ? void 0 : params.theme).text, {text: str, fill: fill = textAttribute.fill, stroke: stroke = textAttribute.stroke, fillOpacity: fillOpacity = textAttribute.fillOpacity, strokeOpacity: strokeOpacity = textAttribute.strokeOpacity, opacity: opacity = textAttribute.opacity, lineWidth: lineWidth = textAttribute.lineWidth, visible: visible = textAttribute.visible, underline: underline = textAttribute.underline, lineThrough: lineThrough = textAttribute.lineThrough, keepDirIn3d: keepDirIn3d = textAttribute.keepDirIn3d, fontSize: fontSize = textAttribute.fontSize, textBaseline: textBaseline = textAttribute.textBaseline, x: originX = textAttribute.x, y: originY = textAttribute.y} = text.attribute, lineHeight = null !== (_a = text.attribute.lineHeight) && void 0 !== _a ? _a : fontSize, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        if (!text.valid || !visible) return;\n        if (!(doFill || doStroke || fVisible || sVisible)) return;\n        const transform3dMatrixToContextMatrix = !keepDirIn3d, z = this.z || 0;\n        if (context.beginPath(), context.setShadowStyle && context.setShadowStyle(text, text.attribute, textAttribute), \n        transform3dMatrixToContextMatrix && this.transformUseContext2d(text, textAttribute, z, context), \n        Array.isArray(str)) {\n            context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z);\n            const {multilineLayout: multilineLayout} = text;\n            if (!multilineLayout) return void context.highPerformanceRestore();\n            const {xOffset: xOffset, yOffset: yOffset} = multilineLayout.bbox;\n            doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), \n            multilineLayout.lines.forEach((line => {\n                context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);\n            })))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), \n            multilineLayout.lines.forEach((line => {\n                context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z), \n                this.drawMultiUnderLine(underline, lineThrough, text, (line.leftOffset || 0) + x, (line.topOffset || 0) + yOffset + y, z, line.width, textAttribute, context);\n            }))));\n        } else {\n            context.setTextStyle(text.attribute, textAttribute, z);\n            const t = text.clipedText;\n            let dy = 0;\n            lineHeight !== fontSize && (\"top\" === textBaseline ? dy = (lineHeight - fontSize) / 2 : \"middle\" === textBaseline || \"bottom\" === textBaseline && (dy = -(lineHeight - fontSize) / 2)), \n            doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), \n            context.strokeText(t, x, y + dy, z))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), \n            context.fillText(t, x, y + dy, z), this.drawUnderLine(underline, lineThrough, text, x, y + dy, z, textAttribute, context)));\n        }\n        transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text, textAttribute, z, context);\n    }\n    draw(text, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        context.highPerformanceSave();\n        const textAttribute = (0, theme_1.getTheme)(text, null == params ? void 0 : params.theme).text, {keepDirIn3d: keepDirIn3d = textAttribute.keepDirIn3d} = text.attribute, computed3dMatrix = !keepDirIn3d, data = this.transform(text, textAttribute, context, computed3dMatrix), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        this.z = z, this.drawShape(text, context, x, y, drawContext, params), this.z = 0, \n        context.modelMatrix = lastModelMatrix, context.highPerformanceRestore();\n    }\n    drawUnderLine(underline, lineThrough, text, x, y, z, textAttribute, context) {\n        if (lineThrough + underline <= 0) return;\n        const {textAlign: textAlign = textAttribute.textAlign, textBaseline: textBaseline = textAttribute.textBaseline, fontSize: fontSize = textAttribute.fontSize, fill: fill = textAttribute.fill, opacity: opacity = textAttribute.opacity, fillOpacity: fillOpacity = textAttribute.fillOpacity} = text.attribute, w = text.clipedWidth, offsetX = (0, \n        text_1.textDrawOffsetX)(textAlign, w), offsetY = (0, text_1.textLayoutOffsetY)(textBaseline, fontSize, fontSize), attribute = {\n            lineWidth: 0,\n            stroke: fill,\n            opacity: opacity,\n            strokeOpacity: fillOpacity\n        };\n        if (underline) {\n            attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, x, y, textAttribute), \n            context.beginPath();\n            const dy = y + offsetY + fontSize;\n            context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();\n        }\n        if (lineThrough) {\n            attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, x, y, textAttribute), \n            context.beginPath();\n            const dy = y + offsetY + fontSize / 2;\n            context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();\n        }\n    }\n    drawMultiUnderLine(underline, lineThrough, text, x, y, z, w, textAttribute, context) {\n        if (lineThrough + underline <= 0) return;\n        const {textAlign: textAlign = textAttribute.textAlign, fontSize: fontSize = textAttribute.fontSize, fill: fill = textAttribute.fill, opacity: opacity = textAttribute.opacity, fillOpacity: fillOpacity = textAttribute.fillOpacity} = text.attribute, offsetX = (0, \n        text_1.textDrawOffsetX)(textAlign, w), offsetY = (0, text_1.textLayoutOffsetY)(\"alphabetic\", fontSize, fontSize), attribute = {\n            lineWidth: 0,\n            stroke: fill,\n            opacity: opacity,\n            strokeOpacity: fillOpacity\n        };\n        let deltaY = -3;\n        if (underline) {\n            attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, x, y, textAttribute), \n            context.beginPath();\n            const dy = y + offsetY + fontSize + deltaY;\n            context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();\n        }\n        if (deltaY = -1, lineThrough) {\n            attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, x, y, textAttribute), \n            context.beginPath();\n            const dy = y + offsetY + fontSize / 2 + deltaY;\n            context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();\n        }\n    }\n};\n\nDefaultCanvasTextRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasTextRender), \nexports.DefaultCanvasTextRender = DefaultCanvasTextRender;\n//# sourceMappingURL=text-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.AbstractGraphicRender = void 0;\n\nconst inversify_1 = require(\"inversify\");\n\nlet AbstractGraphicRender = class {};\n\nAbstractGraphicRender = __decorate([ (0, inversify_1.injectable)() ], AbstractGraphicRender), \nexports.AbstractGraphicRender = AbstractGraphicRender;\n//# sourceMappingURL=graphic-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasPolygonRender = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), polygon_1 = require(\"../../../common/polygon\"), utils_1 = require(\"./utils\"), polygon_contribution_render_1 = require(\"./contributions/polygon-contribution-render\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), enums_1 = require(\"../../../common/enums\");\n\nlet DefaultCanvasPolygonRender = class {\n    constructor(polygonRenderContribitions) {\n        this.polygonRenderContribitions = polygonRenderContribitions, this.numberType = constants_1.POLYGON_NUMBER_TYPE;\n    }\n    drawShape(polygon, context, x, y, drawContext, params, fillCb, strokeCb) {\n        const polygonAttribute = (0, theme_1.getTheme)(polygon, null == params ? void 0 : params.theme).polygon, {points: points = polygonAttribute.points, fill: fill = polygonAttribute.fill, stroke: stroke = polygonAttribute.stroke, cornerRadius: cornerRadius = polygonAttribute.cornerRadius, fillOpacity: fillOpacity = polygonAttribute.fillOpacity, background: background, strokeOpacity: strokeOpacity = polygonAttribute.strokeOpacity, lineWidth: lineWidth = polygonAttribute.lineWidth, opacity: opacity = polygonAttribute.opacity, visible: visible = polygonAttribute.visible, x: originX = polygonAttribute.x, y: originY = polygonAttribute.y} = polygon.attribute, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        polygon.valid && visible && (doFill || doStroke || background) && (fVisible || sVisible || fillCb || strokeCb || background) && (context.beginPath(), \n        cornerRadius <= 0 || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (0, \n        polygon_1.drawPolygon)(context.camera ? context : context.nativeContext, points, x, y) : (0, \n        polygon_1.drawRoundedPolygon)(context.camera ? context : context.nativeContext, points, x, y, cornerRadius), \n        context.closePath(), this._polygonRenderContribitions || (this._polygonRenderContribitions = this.polygonRenderContribitions.getContributions() || [], \n        this._polygonRenderContribitions.sort(((a, b) => b.order - a.order))), this._polygonRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, fillCb, strokeCb);\n        })), context.setShadowStyle && context.setShadowStyle(polygon, polygon.attribute, polygonAttribute), \n        doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fillOpacity && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), \n        context.fill())), doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : strokeOpacity && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), \n        context.stroke())), this._polygonRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, fillCb, strokeCb);\n        })));\n    }\n    draw(polygon, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        context.highPerformanceSave();\n        const polygonAttribute = (0, theme_1.getTheme)(polygon, null == params ? void 0 : params.theme).polygon;\n        let {x: x = polygonAttribute.x, y: y = polygonAttribute.y} = polygon.attribute;\n        if (polygon.transMatrix.onlyTranslate()) {\n            const point = polygon.getOffsetXY(polygonAttribute);\n            x += point.x, y += point.y, context.setTransformForCurrent();\n        } else x = 0, y = 0, context.transformFromMatrix(polygon.transMatrix, !0);\n        (0, utils_1.drawPathProxy)(polygon, context, x, y, drawContext, params) || this.drawShape(polygon, context, x, y, drawContext, params), \n        context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasPolygonRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(polygon_contribution_render_1.PolygonRenderContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasPolygonRender), \nexports.DefaultCanvasPolygonRender = DefaultCanvasPolygonRender;\n//# sourceMappingURL=polygon-render.js.map\n","\n\nfunction drawPolygon(path, points, x, y) {\n    path.moveTo(points[0].x + x, points[0].y + y);\n    for (let i = 1; i < points.length; i++) path.lineTo(points[i].x + x, points[i].y + y);\n}\n\nfunction drawRoundedPolygon(path, points, x, y, cornerRadius) {\n    var _a;\n    if (points.length < 3) drawPolygon(path, points, x, y); else for (let i = 0; i < points.length; i++) {\n        const p1 = points[i], angularPoint = points[(i + 1) % points.length], p2 = points[(i + 2) % points.length], dx1 = angularPoint.x - p1.x, dy1 = angularPoint.y - p1.y, dx2 = angularPoint.x - p2.x, dy2 = angularPoint.y - p2.y, angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2, tan = Math.abs(Math.tan(angle));\n        let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[(i + 1) % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius, segment = radius / tan;\n        const length1 = getLength(dx1, dy1), length2 = getLength(dx2, dy2), length = Math.min(length1, length2);\n        segment > length && (segment = length, radius = length * tan);\n        const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1), p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2), dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x, dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y, L = getLength(dx, dy), circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);\n        let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);\n        const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);\n        let sweepAngle = endAngle - startAngle;\n        sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), \n        0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), \n        sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), \n        path.lineTo(p2Cross.x + x, p2Cross.y + y);\n    }\n}\n\nfunction getLength(dx, dy) {\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction getProportionPoint(point, segment, length, dx, dy) {\n    const factor = segment / length;\n    return {\n        x: point.x - dx * factor,\n        y: point.y - dy * factor\n    };\n}\n\n//# sourceMappingURL=polygon.js.map\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.drawRoundedPolygon = exports.drawPolygon = void 0, exports.drawPolygon = drawPolygon, \nexports.drawRoundedPolygon = drawRoundedPolygon;","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultPolygonTextureRenderContribution = exports.DefaultPolygonBackgroundRenderContribution = exports.PolygonRenderContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), base_contribution_render_1 = require(\"./base-contribution-render\"), enums_1 = require(\"../../../../common/enums\");\n\nexports.PolygonRenderContribution = Symbol.for(\"PolygonRenderContribution\");\n\nlet DefaultPolygonBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;\n    }\n};\n\nDefaultPolygonBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPolygonBackgroundRenderContribution), \nexports.DefaultPolygonBackgroundRenderContribution = DefaultPolygonBackgroundRenderContribution;\n\nlet DefaultPolygonTextureRenderContribution = class extends base_contribution_render_1.DefaultBaseTextureRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.afterFillStroke;\n    }\n};\n\nDefaultPolygonTextureRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultPolygonTextureRenderContribution), \nexports.DefaultPolygonTextureRenderContribution = DefaultPolygonTextureRenderContribution;\n//# sourceMappingURL=polygon-contribution-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasImageRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), theme_1 = require(\"../../../graphic/theme\"), image_contribution_render_1 = require(\"./contributions/image-contribution-render\"), utils_1 = require(\"./utils\"), constants_1 = require(\"../../../graphic/constants\"), enums_1 = require(\"../../../common/enums\"), repeatStr = [ \"\", \"repeat-x\", \"repeat-y\", \"repeat\" ];\n\nlet DefaultCanvasImageRender = class {\n    constructor(imageRenderContribitions) {\n        this.imageRenderContribitions = imageRenderContribitions, this.numberType = constants_1.IMAGE_NUMBER_TYPE;\n    }\n    drawShape(image, context, x, y, drawContext, params, fillCb) {\n        const imageAttribute = (0, theme_1.getTheme)(image).image, {fill: fill = imageAttribute.fill, width: width = imageAttribute.width, height: height = imageAttribute.height, opacity: opacity = imageAttribute.opacity, fillOpacity: fillOpacity = imageAttribute.fillOpacity, visible: visible = imageAttribute.visible, repeatX: repeatX = imageAttribute.repeatX, repeatY: repeatY = imageAttribute.repeatY, image: url} = image.attribute, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), doFill = (0, utils_1.runFill)(fill);\n        if (image.valid && visible && doFill && (fVisible || fillCb)) {\n            if (this._imageRenderContribitions || (this._imageRenderContribitions = this.imageRenderContribitions.getContributions() || []), \n            this._imageRenderContribitions.forEach((c => {\n                c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, fillCb);\n            })), context.setShadowStyle && context.setShadowStyle(image, imageAttribute), doFill) if (fillCb) fillCb(context, image.attribute, imageAttribute); else if (fVisible) {\n                if (!url || !image.resources) return;\n                const res = image.resources.get(url);\n                if (\"success\" !== res.state) return;\n                context.setCommonStyle(image, image.attribute, x, y, imageAttribute);\n                let repeat = 0;\n                if (\"repeat\" === repeatX && (repeat |= 1), \"repeat\" === repeatY && (repeat |= 2), \n                repeat) {\n                    const pattern = context.createPattern(res.data, repeatStr[repeat]);\n                    context.fillStyle = pattern, context.fillRect(x, y, width, height);\n                } else context.drawImage(res.data, x, y, width, height);\n            }\n            this._imageRenderContribitions.forEach((c => {\n                c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, fillCb);\n            }));\n        }\n    }\n    draw(image, renderService, drawContext) {\n        const {context: context} = renderService.drawParams;\n        if (!context) return;\n        const imageAttribute = (0, theme_1.getTheme)(image).image;\n        let {x: x = imageAttribute.x, y: y = imageAttribute.y} = image.attribute;\n        const {image: url} = image.attribute;\n        if (!url || !image.resources) return;\n        if (\"success\" === image.resources.get(url).state) {\n            if (context.highPerformanceSave(), image.transMatrix.onlyTranslate()) {\n                const point = image.getOffsetXY(imageAttribute);\n                x += point.x, y += point.y, context.setTransformForCurrent();\n            } else x = 0, y = 0, context.transformFromMatrix(image.transMatrix, !0);\n            this.drawShape(image, context, x, y, drawContext), context.highPerformanceRestore();\n        }\n    }\n};\n\nDefaultCanvasImageRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(image_contribution_render_1.ImageRenderContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasImageRender), \nexports.DefaultCanvasImageRender = DefaultCanvasImageRender;\n//# sourceMappingURL=image-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultImageBackgroundRenderContribution = exports.ImageRenderContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), graphic_1 = require(\"../../../../graphic\"), base_contribution_render_1 = require(\"./base-contribution-render\"), enums_1 = require(\"../../../../common/enums\");\n\nexports.ImageRenderContribution = Symbol.for(\"ImageRenderContribution\");\n\nlet DefaultImageBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;\n    }\n    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb) {\n        const {background: background, width: width, height: height} = graphic.attribute;\n        if (background) if (graphic.backgroundImg) {\n            const res = graphic.resources.get(background);\n            if (\"success\" !== res.state || !res.data) return;\n            if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {\n                const groupAttribute = (0, graphic_1.getTheme)(graphic.parent).group, {scrollX: scrollX = groupAttribute.scrollX, scrollY: scrollY = groupAttribute.scrollY} = graphic.parent.attribute;\n                context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);\n            }\n            const b = graphic.AABBBounds;\n            context.drawImage(res.data, b.x1, b.y1, b.width(), b.height()), context.restore(), \n            graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();\n        } else {\n            context.beginPath();\n            const b = graphic.AABBBounds;\n            context.rect(x, y, b.width(), b.height()), context.fillStyle = background, context.globalAlpha = 1, \n            context.fill();\n        }\n    }\n};\n\nDefaultImageBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultImageBackgroundRenderContribution), \nexports.DefaultImageBackgroundRenderContribution = DefaultImageBackgroundRenderContribution;\n//# sourceMappingURL=image-contribution-render.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DrawContribution = exports.RenderSelector = exports.ImageRender = exports.GlyphRender = exports.Pyramid3dRender = exports.RichTextRender = exports.TextRender = exports.SymbolRender = exports.Rect3DRender = exports.RectRender = exports.PolygonRender = exports.PathRender = exports.LineRender = exports.GroupRender = exports.GraphicRender = exports.CircleRender = exports.AreaRender = exports.Arc3dRender = exports.ArcRender = exports.IncrementalDrawContribution = void 0, \nexports.IncrementalDrawContribution = Symbol.for(\"IncrementalDrawContribution\"), \nexports.ArcRender = Symbol.for(\"ArcRender\"), exports.Arc3dRender = Symbol.for(\"Arc3dRender\"), \nexports.AreaRender = Symbol.for(\"AreaRender\"), exports.CircleRender = Symbol.for(\"CircleRender\"), \nexports.GraphicRender = Symbol.for(\"GraphicRender\"), exports.GroupRender = Symbol.for(\"GroupRender\"), \nexports.LineRender = Symbol.for(\"LineRender\"), exports.PathRender = Symbol.for(\"PathRender\"), \nexports.PolygonRender = Symbol.for(\"PolygonRender\"), exports.RectRender = Symbol.for(\"RectRender\"), \nexports.Rect3DRender = Symbol.for(\"Rect3DRender\"), exports.SymbolRender = Symbol.for(\"SymbolRender\"), \nexports.TextRender = Symbol.for(\"TextRender\"), exports.RichTextRender = Symbol.for(\"RichTextRender\"), \nexports.Pyramid3dRender = Symbol.for(\"Pyramid3dRender\"), exports.GlyphRender = Symbol.for(\"GlyphRender\"), \nexports.ImageRender = Symbol.for(\"ImageRender\"), exports.RenderSelector = Symbol.for(\"RenderSelector\"), \nexports.DrawContribution = Symbol.for(\"DrawContribution\");\n//# sourceMappingURL=symbol.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./arc-contribution-render\"), exports), __exportStar(require(\"./base-contribution-render\"), exports), \n__exportStar(require(\"./circle-contribution-render\"), exports), __exportStar(require(\"./group-contribution-render\"), exports), \n__exportStar(require(\"./image-contribution-render\"), exports), __exportStar(require(\"./rect-contribution-render\"), exports), \n__exportStar(require(\"./symbol-contribution-render\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultGroupBackgroundRenderContribution = exports.GroupRenderContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), base_contribution_render_1 = require(\"./base-contribution-render\"), enums_1 = require(\"../../../../common/enums\");\n\nexports.GroupRenderContribution = Symbol.for(\"GroupRenderContribution\");\n\nlet DefaultGroupBackgroundRenderContribution = class extends base_contribution_render_1.DefaultBaseBackgroundRenderContribution {\n    constructor() {\n        super(...arguments), this.time = enums_1.BaseRenderContributionTime.beforeFillStroke;\n    }\n    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, fillCb, strokeCb) {\n        const {background: background} = graphic.attribute;\n        if (background) if (graphic.backgroundImg && graphic.resources) {\n            const res = graphic.resources.get(background);\n            if (\"success\" !== res.state || !res.data) return;\n            context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0);\n            const b = graphic.AABBBounds;\n            context.drawImage(res.data, b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), \n            context.setTransformForCurrent();\n        } else context.highPerformanceSave(), context.fillStyle = background, context.fill(), \n        context.highPerformanceRestore();\n    }\n};\n\nDefaultGroupBackgroundRenderContribution = __decorate([ (0, inversify_1.injectable)() ], DefaultGroupBackgroundRenderContribution), \nexports.DefaultGroupBackgroundRenderContribution = DefaultGroupBackgroundRenderContribution;\n//# sourceMappingURL=group-contribution-render.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), picker_service_1 = require(\"./picker-service\"), global_picker_service_1 = require(\"./global-picker-service\"), canvas_picker_service_1 = require(\"./canvas-picker-service\"), math_picker_service_1 = require(\"./math-picker-service\"), pick_interceptor_1 = require(\"./pick-interceptor\"), contribution_provider_1 = require(\"../common/contribution-provider\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(canvas_picker_service_1.DefaultCanvasPickerService).toSelf().inSingletonScope(), \n    bind(math_picker_service_1.DefaultMathPickerService).toSelf().inSingletonScope(), \n    bind(picker_service_1.PickerService).toService(canvas_picker_service_1.DefaultCanvasPickerService), \n    bind(global_picker_service_1.DefaultGlobalPickerService).toSelf().inSingletonScope(), \n    bind(global_picker_service_1.GlobalPickerService).toService(global_picker_service_1.DefaultGlobalPickerService), \n    bind(pick_interceptor_1.Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), \n    bind(pick_interceptor_1.PickItemInterceptor).toService(pick_interceptor_1.Canvas3DPickItemInterceptor), \n    (0, contribution_provider_1.bindContributionProvider)(bind, pick_interceptor_1.PickItemInterceptor);\n}));\n//# sourceMappingURL=pick-modules.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultPickService = exports.PickerService = exports.GraphicPicker = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), sort_1 = require(\"../common/sort\"), contribution_provider_1 = require(\"../common/contribution-provider\"), graphic_1 = require(\"../graphic\"), matrix_allocate_1 = require(\"../allocator/matrix-allocate\"), pick_interceptor_1 = require(\"./pick-interceptor\"), constants_1 = require(\"../constants\");\n\nexports.GraphicPicker = Symbol.for(\"GraphicPicker\"), exports.PickerService = Symbol.for(\"PickerService\");\n\nlet DefaultPickService = class {\n    constructor(global, pickItemInterceptorContributions) {\n        this.global = global, this.pickItemInterceptorContributions = pickItemInterceptorContributions, \n        this.type = \"default\";\n    }\n    _init() {\n        this.InterceptorContributions = this.pickItemInterceptorContributions.getContributions().sort(((a, b) => a.order - b.order));\n    }\n    pick(graphics, point, params) {\n        let result = {\n            graphic: null,\n            group: null\n        };\n        params.pickerService = this;\n        let offsetX = 0, offsetY = 0;\n        if (params && params.bounds) {\n            if (!params.bounds.contains(point.x, point.y)) return result;\n            offsetX = params.bounds.x1, offsetY = params.bounds.y1;\n        }\n        this.pickContext && (this.pickContext.inuse = !0), params.pickContext = this.pickContext, \n        this.pickContext && this.pickContext.clearMatrix(!0, 1);\n        const parentMatrix = new vutils_1.Matrix(1, 0, 0, 1, offsetX, offsetY);\n        let group;\n        for (let i = graphics.length - 1; i >= 0 && (graphics[i].isContainer ? result = this.pickGroup(graphics[i], point, parentMatrix, params) : result.graphic = this.pickItem(graphics[i], point, params), \n        !result.graphic); i--) group || (group = result.group);\n        return result.graphic || (result.group = group), this.pickContext && (this.pickContext.inuse = !1), \n        result;\n    }\n    containsPoint(graphic, point, params) {\n        return !!this.pickItem(graphic, point, params);\n    }\n    pickGroup(group, point, parentMatrix, params) {\n        let result = {\n            group: null,\n            graphic: null\n        };\n        if (!1 === group.attribute.visibleAll) return result;\n        const context = params.pickContext, lastMatrix = context.modelMatrix;\n        if (context.camera) {\n            const m = group.transMatrix, matrix = matrix_allocate_1.mat4Allocate.allocate();\n            if ((0, graphic_1.mat3Tomat4)(matrix, m), lastMatrix) {\n                if (matrix) {\n                    const m = matrix_allocate_1.mat4Allocate.allocate();\n                    context.modelMatrix = (0, graphic_1.multiplyMat4Mat4)(m, lastMatrix, matrix), matrix_allocate_1.mat4Allocate.free(matrix);\n                }\n            } else (0, graphic_1.mat3Tomat4)(matrix, group.globalTransMatrix), context.modelMatrix = matrix;\n        }\n        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {\n            const drawContribution = this.InterceptorContributions[i];\n            if (drawContribution.beforePickItem) {\n                const result = drawContribution.beforePickItem(group, this, point, params, {\n                    parentMatrix: parentMatrix\n                });\n                if (result) return context.modelMatrix !== lastMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n                context.modelMatrix = lastMatrix, result;\n            }\n        }\n        const transMatrix = group.transMatrix, currentGroupMatrix = matrix_allocate_1.matrixAllocate.allocateByObj(parentMatrix), newPoint = new vutils_1.Point(point.x, point.y);\n        currentGroupMatrix.transformPoint(newPoint, newPoint);\n        const insideGroup = group.AABBBounds.containsPoint(newPoint);\n        if (!insideGroup && !group.stage.camera) return result;\n        const groupPicked = !1 !== group.attribute.pickable && insideGroup;\n        return currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), \n        !1 !== group.attribute.childrenPickable && (0, sort_1.foreach)(group, graphic_1.DefaultAttribute.zIndex, (graphic => {\n            if (graphic.isContainer) {\n                const newPoint = new vutils_1.Point(point.x, point.y), theme = (0, graphic_1.getTheme)(group).group, {scrollX: scrollX = theme.scrollX, scrollY: scrollY = theme.scrollY} = group.attribute;\n                newPoint.x -= scrollX, newPoint.y -= scrollY, result = this.pickGroup(graphic, newPoint, currentGroupMatrix, params);\n            } else {\n                const newPoint = new vutils_1.Point(point.x, point.y);\n                currentGroupMatrix.transformPoint(newPoint, newPoint);\n                const theme = (0, graphic_1.getTheme)(group).group, {scrollX: scrollX = theme.scrollX, scrollY: scrollY = theme.scrollY} = group.attribute;\n                newPoint.x -= scrollX, newPoint.y -= scrollY;\n                const pickedItem = this.pickItem(graphic, newPoint, params);\n                result.graphic = pickedItem;\n            }\n            return !!result.graphic || !!result.group;\n        }), !0, !!context.camera), context.modelMatrix !== lastMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n        context.modelMatrix = lastMatrix, result.graphic || result.group || !groupPicked || group.stage.camera || (result.group = group), \n        matrix_allocate_1.matrixAllocate.free(currentGroupMatrix), result;\n    }\n    selectPicker(graphic) {\n        const picker = this.pickerMap.get(graphic.numberType);\n        return picker || null;\n    }\n};\n\nDefaultPickService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(constants_1.Global)), __param(1, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(1, (0, \ninversify_1.named)(pick_interceptor_1.PickItemInterceptor)), __metadata(\"design:paramtypes\", [ Object, Object ]) ], DefaultPickService), \nexports.DefaultPickService = DefaultPickService;\n//# sourceMappingURL=picker-service.js.map\n","\n\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))((function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            var value;\n            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {\n                resolve(value);\n            }))).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    }));\n};\n\nfunction foreach(graphic, defaultZIndex, cb, reverse = !1, sort3d = !1) {\n    const childMap = {}, zIdxArray = [];\n    let needSort = !1;\n    if (sort3d) needSort = !0; else {\n        let lastZIndex;\n        graphic.forEachChildren(((item, i) => {\n            const {zIndex: zIndex = defaultZIndex} = item.attribute;\n            if (0 === i) lastZIndex = zIndex; else if (lastZIndex !== zIndex) return needSort = !0, \n            !0;\n            return !1;\n        }), reverse);\n    }\n    if (needSort) {\n        graphic.forEachChildren((item => {\n            const {zIndex: zIndex = defaultZIndex} = item.attribute;\n            childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [ item ], zIdxArray.push(zIndex));\n        }), reverse), zIdxArray.sort(((a, b) => reverse ? b - a : a - b));\n        let skip = !1;\n        for (let i = 0; i < zIdxArray.length && !skip; i++) {\n            const idx = zIdxArray[i], children = childMap[idx];\n            sort3d && children.sort(((a, b) => {\n                var _a, _b;\n                return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a.attribute.z) && void 0 !== _b ? _b : 0));\n            }));\n            for (let i = 0; i < children.length; i++) if (cb(children[i], i)) {\n                skip = !0;\n                break;\n            }\n        }\n    } else graphic.forEachChildren(cb, reverse);\n}\n\nfunction foreachAsync(graphic, defaultZIndex, cb, reverse = !1) {\n    return __awaiter(this, void 0, void 0, (function*() {\n        yield graphic.forEachChildrenAsync(cb, reverse);\n    }));\n}\n\nfunction findNextGraphic(graphic, id, defaultZIndex, reverse = !1) {\n    const childMap = {}, zIdxArray = [];\n    let needSort = !1;\n    graphic.forEachChildren(((item, i) => {\n        const {zIndex: zIndex = defaultZIndex} = item.attribute;\n        if (0 === i) ; else if (undefined !== zIndex) return needSort = !0, !0;\n        return !1;\n    }), reverse);\n    let result = null, next = !1;\n    if (needSort) {\n        graphic.forEachChildren((item => {\n            const {zIndex: zIndex = defaultZIndex} = item.attribute;\n            childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [ item ], zIdxArray.push(zIndex));\n        }), reverse), zIdxArray.sort(((a, b) => reverse ? b - a : a - b));\n        let skip = !1;\n        for (let i = 0; i < zIdxArray.length && !skip; i++) {\n            const idx = zIdxArray[i], children = childMap[idx];\n            for (let i = 0; i < children.length; i++) {\n                if (next) {\n                    skip = !0, result = children[i];\n                    break;\n                }\n                children[i]._uid !== id || (next = !0);\n            }\n        }\n    } else graphic.forEachChildren((item => next ? (result = item, !0) : (item._uid === id && (next = !0), \n    !1)), reverse);\n    return result;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.findNextGraphic = exports.foreachAsync = exports.foreach = void 0, exports.foreach = foreach, \nexports.foreachAsync = foreachAsync, exports.findNextGraphic = findNextGraphic;\n//# sourceMappingURL=sort.js.map","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Canvas3DPickItemInterceptor = exports.PickItemInterceptor = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), constants_1 = require(\"../graphic/constants\");\n\nexports.PickItemInterceptor = Symbol.for(\"PickItemInterceptor\");\n\nlet Canvas3DPickItemInterceptor = class {\n    constructor() {\n        this.order = 1;\n    }\n    beforePickItem(graphic, pickerService, point, pickParams, params) {\n        if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;\n        const context = pickerService.pickContext, stage = graphic.stage;\n        if (!context || !stage) return null;\n        if (pickParams.in3dInterceptor = !0, context.save(), this.initCanvasCtx(context), \n        context.camera = stage.camera, graphic.isContainer) {\n            let result, isPie = !1, is3d = !1;\n            if (graphic.forEachChildren((c => (isPie = c.numberType === constants_1.ARC3D_NUMBER_TYPE, \n            !isPie))), graphic.forEachChildren((c => (is3d = !!c.findFace, !is3d))), isPie) {\n                const children = graphic.getChildren(), sortedChildren = [ ...children ];\n                sortedChildren.sort(((a, b) => {\n                    var _a, _b, _c, _d;\n                    let angle1 = (null !== (_b = null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0 + a.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2, angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;\n                    for (;angle1 < 0; ) angle1 += vutils_1.pi2;\n                    for (;angle2 < 0; ) angle2 += vutils_1.pi2;\n                    return angle2 - angle1;\n                })), sortedChildren.forEach((c => {\n                    c._next = null, c._prev = null;\n                })), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c => {\n                    graphic.appendChild(c);\n                })), pickParams.hack_pieFace = \"outside\", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), \n                result.graphic || (pickParams.hack_pieFace = \"inside\", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams)), \n                result.graphic || (pickParams.hack_pieFace = \"top\", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams)), \n                graphic.removeAllChild(), children.forEach((c => {\n                    c._next = null, c._prev = null;\n                })), children.forEach((c => {\n                    graphic.appendChild(c);\n                }));\n            } else if (is3d) {\n                const children = graphic.getChildren(), zChildren = children.map((g => ({\n                    ave_z: g.findFace().vertices.map((v => {\n                        var _a;\n                        return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];\n                    })).reduce(((a, b) => a + b), 0),\n                    g: g\n                })));\n                zChildren.sort(((a, b) => b.ave_z - a.ave_z)), graphic.removeAllChild(), zChildren.forEach((i => {\n                    i.g._next = null, i.g._prev = null;\n                })), graphic.update(), zChildren.forEach((i => {\n                    graphic.add(i.g);\n                })), result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), \n                graphic.removeAllChild(), children.forEach((g => {\n                    g._next = null, g._prev = null;\n                })), graphic.update(), children.forEach((g => {\n                    graphic.add(g);\n                }));\n            } else result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);\n            return context.camera = null, context.restore(), pickParams.in3dInterceptor = !1, \n            result;\n        }\n        return null;\n    }\n    initCanvasCtx(context) {\n        context.setTransformForCurrent();\n    }\n};\n\nCanvas3DPickItemInterceptor = __decorate([ (0, inversify_1.injectable)() ], Canvas3DPickItemInterceptor), \nexports.Canvas3DPickItemInterceptor = Canvas3DPickItemInterceptor;\n//# sourceMappingURL=pick-interceptor.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultGlobalPickerService = exports.GlobalPickerService = exports.BoundsPicker = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), constants_1 = require(\"../constants\");\n\nexports.BoundsPicker = Symbol.for(\"BoundsPicker\"), exports.GlobalPickerService = Symbol.for(\"GlobalPickerService\");\n\nlet DefaultGlobalPickerService = class {\n    constructor(global) {\n        this.global = global, this.global.hooks.onSetEnv.tap(\"global-picker-service\", ((lastEnv, env, global) => {\n            this.configure(global, env);\n        })), this.configure(this.global, this.global.env);\n    }\n    configure(global, env) {}\n    pick(graphics, point, params) {\n        let result = {\n            graphic: null,\n            group: null\n        };\n        const parentMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0);\n        let group;\n        for (let i = 0; i < graphics.length && (graphics[i].isContainer ? result = this.pickGroup(graphics[i], point, parentMatrix, params) : result.graphic = this.pickItem(graphics[i], point, params), \n        !result.graphic); i++) group || (group = result.group);\n        return result.graphic || (result.group = group), result;\n    }\n    containsPoint(graphic, point, params) {\n        return !!this.pickItem(graphic, point, params);\n    }\n    pickGroup(group, point, parentMatrix, params) {\n        let result = {\n            group: null,\n            graphic: null\n        };\n        if (!1 === group.attribute.visibleAll) return result;\n        const transMatrix = group.transMatrix, newPoint = new vutils_1.Point(point.x, point.y);\n        parentMatrix.transformPoint(newPoint, newPoint);\n        const insideGroup = group.AABBBounds.containsPoint(newPoint);\n        if (!insideGroup) return result;\n        const groupPicked = !1 !== group.attribute.pickable && insideGroup;\n        return parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), \n        !1 !== group.attribute.childrenPickable && group.forEachChildren((graphic => {\n            if (graphic.isContainer) result = this.pickGroup(graphic, point, parentMatrix, params); else {\n                const newPoint = new vutils_1.Point(point.x, point.y);\n                parentMatrix.transformPoint(newPoint, newPoint), result.graphic = this.pickItem(graphic, newPoint, params);\n            }\n            return !!result.graphic || !!result.group;\n        })), result.graphic || result.group || !groupPicked || (result.group = group), result;\n    }\n    pickItem(graphic, point, params) {\n        return !1 === graphic.attribute.pickable ? null : graphic.AABBBounds.containsPoint(point) ? graphic : null;\n    }\n};\n\nDefaultGlobalPickerService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultGlobalPickerService), \nexports.DefaultGlobalPickerService = DefaultGlobalPickerService;\n//# sourceMappingURL=global-picker-service.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasPickerService = void 0;\n\nconst contribution_provider_1 = require(\"../common/contribution-provider\"), inversify_1 = require(\"inversify\"), browser_1 = require(\"../canvas/contributions/browser\"), constants_1 = require(\"./contributions/constants\"), picker_service_1 = require(\"./picker-service\"), render_1 = require(\"../render\"), pick_interceptor_1 = require(\"./pick-interceptor\"), constants_2 = require(\"../constants\");\n\nlet DefaultCanvasPickerService = class extends picker_service_1.DefaultPickService {\n    constructor(contributions, circlePicker, rectPicker, arcPicker, areaPicker, imagePicker, linePicker, pathPicker, symbolPicker, textPicker, polygonPicker, richtextPicker, drawContribution, global, pickItemInterceptorContributions) {\n        super(global, pickItemInterceptorContributions), this.contributions = contributions, \n        this.circlePicker = circlePicker, this.rectPicker = rectPicker, this.arcPicker = arcPicker, \n        this.areaPicker = areaPicker, this.imagePicker = imagePicker, this.linePicker = linePicker, \n        this.pathPicker = pathPicker, this.symbolPicker = symbolPicker, this.textPicker = textPicker, \n        this.polygonPicker = polygonPicker, this.richtextPicker = richtextPicker, this.drawContribution = drawContribution, \n        this.global = global, this.pickItemInterceptorContributions = pickItemInterceptorContributions, \n        this.global.hooks.onSetEnv.tap(\"canvas-picker-service\", ((_, env, global) => {\n            this.configure(global, env);\n        })), this.configure(this.global, this.global.env), this.pickerMap = new Map;\n    }\n    init() {\n        this.contributions.getContributions().forEach((item => {\n            this.pickerMap.set(item.numberType, item);\n        })), super._init();\n    }\n    configure(global, env) {\n        const options = {\n            width: 100,\n            height: 100,\n            nativeCanvas: global.createCanvas({\n                width: 100,\n                height: 100\n            }),\n            id: \"for-pick\"\n        };\n        this.pickCanvas = new browser_1.BrowserCanvas(options), this.pickContext = this.pickCanvas.getContext(\"2d\");\n    }\n    pickItem(graphic, point, params) {\n        if (!1 === graphic.attribute.pickable) return null;\n        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {\n            const drawContribution = this.InterceptorContributions[i];\n            if (drawContribution.beforePickItem && drawContribution.beforePickItem(graphic, this, point, params)) return graphic;\n        }\n        const picker = this.pickerMap.get(graphic.numberType);\n        return picker && picker.contains(graphic, point, params) ? graphic : null;\n    }\n};\n\n__decorate([ (0, inversify_1.postConstruct)(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0) ], DefaultCanvasPickerService.prototype, \"init\", null), \nDefaultCanvasPickerService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(constants_1.CanvasPickerContribution)), __param(1, (0, inversify_1.inject)(constants_1.CanvasCirclePicker)), __param(2, (0, \ninversify_1.inject)(constants_1.CanvasRectPicker)), __param(3, (0, inversify_1.inject)(constants_1.CanvasArcPicker)), __param(4, (0, \ninversify_1.inject)(constants_1.CanvasAreaPicker)), __param(5, (0, inversify_1.inject)(constants_1.CanvasImagePicker)), __param(6, (0, \ninversify_1.inject)(constants_1.CanvasLinePicker)), __param(7, (0, inversify_1.inject)(constants_1.CanvasPathPicker)), __param(8, (0, \ninversify_1.inject)(constants_1.CanvasSymbolPicker)), __param(9, (0, inversify_1.inject)(constants_1.CanvasTextPicker)), __param(10, (0, \ninversify_1.inject)(constants_1.CanvasPolygonPicker)), __param(11, (0, inversify_1.inject)(constants_1.CanvasRichTextPicker)), __param(12, (0, \ninversify_1.inject)(render_1.DrawContribution)), __param(13, (0, inversify_1.inject)(constants_2.Global)), __param(14, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(14, (0, \ninversify_1.named)(pick_interceptor_1.PickItemInterceptor)), __metadata(\"design:paramtypes\", [ Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object ]) ], DefaultCanvasPickerService), \nexports.DefaultCanvasPickerService = DefaultCanvasPickerService;\n//# sourceMappingURL=canvas-picker-service.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./canvas\"), exports), __exportStar(require(\"./context\"), exports), \n__exportStar(require(\"./conical-gradient\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BrowserCanvas = void 0;\n\nconst inversify_1 = require(\"inversify\"), application_1 = require(\"../../../application\"), context_1 = require(\"./context\"), DefaultConfig = {\n    WIDTH: 500,\n    HEIGHT: 500,\n    DPR: 1\n};\n\nlet BrowserCanvas = class {\n    get displayWidth() {\n        return this._pixelWidth / this._dpr;\n    }\n    get displayHeight() {\n        return this._pixelHeight / this._dpr;\n    }\n    get id() {\n        return this._id;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n    get nativeCanvas() {\n        return this._nativeCanvas;\n    }\n    get width() {\n        return this._pixelWidth;\n    }\n    set width(width) {\n        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);\n    }\n    get height() {\n        return this._pixelHeight;\n    }\n    set height(height) {\n        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);\n    }\n    getContext(str) {\n        return this._context;\n    }\n    get visiable() {\n        return this._visiable;\n    }\n    set visiable(visiable) {\n        this._visiable = visiable, visiable ? this.show() : this.hide();\n    }\n    get dpr() {\n        return this._dpr;\n    }\n    set dpr(dpr) {\n        this._dpr = dpr, this.resize(this.width, this.height);\n    }\n    constructor(params) {\n        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, dpr: dpr = DefaultConfig.DPR, container: container, x: x, y: y, canvasControled: canvasControled = !0} = params;\n        if (this._x = null != x ? x : 0, this._y = null != y ? y : 0, this._pixelWidth = width * dpr, \n        this._pixelHeight = height * dpr, this._visiable = !1 !== params.visiable, this.controled = canvasControled, \n        \"string\" == typeof container) {\n            const _c = application_1.application.global.getElementById(container);\n            _c && (this._container = _c);\n        } else this._container = container;\n        this._displayWidth = width, this._displayHeight = height, this._dpr = dpr, this._nativeCanvas = nativeCanvas, \n        this._context = new context_1.BrowserContext2d(this, this._dpr), this._id = nativeCanvas.id, \n        this.initStyle();\n    }\n    initStyle() {\n        if (!this.controled) return;\n        const {nativeCanvas: nativeCanvas} = this;\n        nativeCanvas.width = this._pixelWidth, nativeCanvas.height = this._pixelHeight;\n        !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight), \n        null != this.id && (nativeCanvas.id = this.id.toString()), this._container && this._container.appendChild(nativeCanvas), \n        this.visiable || this.hide();\n    }\n    applyPosition() {\n        const canvas = this._nativeCanvas;\n        canvas.style.position = \"absolute\", canvas.style.top = `${this._y}px`, canvas.style.left = `${this._x}px`;\n    }\n    getNativeCanvas() {\n        return this._nativeCanvas;\n    }\n    resetStyle(params) {\n        if (!this.controled) return;\n        const {width: width = this._displayWidth, height: height = this._displayHeight, dpr: dpr = this._dpr, x: x = this._x, y: y = this._y} = params, {nativeCanvas: nativeCanvas} = this;\n        nativeCanvas.width = width * dpr, nativeCanvas.height = height * dpr;\n        !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, x, y, width, height), params.id && (nativeCanvas.id = params.id), \n        this.visiable || this.hide();\n    }\n    setCanvasStyle(canvas, x, y, w, h) {\n        this.controled && (canvas.style.padding = \"0\", canvas.style.margin = \"0\", canvas.style.border = \"0\", \n        canvas.style.background = \"transparent\", canvas.style.width = `${w}px`, canvas.style.height = `${h}px`);\n    }\n    hide() {\n        this._nativeCanvas && (this._nativeCanvas.style.display = \"none\");\n    }\n    show() {\n        this._nativeCanvas && (this._nativeCanvas.style.display = \"block\");\n    }\n    resize(width, height) {\n        if (!this.controled) return;\n        this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, \n        this._displayHeight = height, this._nativeCanvas.style && (this._nativeCanvas.style.width = `${width}px`, \n        this._nativeCanvas.style.height = `${height}px`), this._nativeCanvas.width = this._pixelWidth, \n        this._nativeCanvas.height = this._pixelHeight;\n        this._context.dpr = this._dpr;\n    }\n    toDataURL(mimeType, quality) {\n        return \"image/jpeg\" === mimeType ? this._nativeCanvas.toDataURL(mimeType, quality) : \"image/png\" === mimeType ? this._nativeCanvas.toDataURL(mimeType) : this._nativeCanvas.toDataURL(mimeType, quality);\n    }\n    readPixels(x, y, w, h) {\n        return this._context.getImageData(x, y, w, h);\n    }\n    convertToBlob(options) {\n        throw new Error(\"\");\n    }\n    transferToImageBitmap() {\n        throw new Error(\"\");\n    }\n    release(...params) {\n        this.controled && this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);\n    }\n};\n\nBrowserCanvas.env = \"browser\", BrowserCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", [ Object ]) ], BrowserCanvas), \nexports.BrowserCanvas = BrowserCanvas;\n//# sourceMappingURL=canvas.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BrowserContext2d = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), graphic_1 = require(\"../../../graphic\"), canvas_utils_1 = require(\"../../../common/canvas-utils\"), application_1 = require(\"../../../application\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), conical_gradient_1 = require(\"./conical-gradient\"), camera_1 = require(\"../../../core/camera\"), text_1 = require(\"../../../common/text\"), outP = [ 0, 0, 0 ], initMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) => {\n    if (clockwise) for (;endAngle > startAngle; ) endAngle -= vutils_1.pi2; else for (;endAngle < startAngle; ) endAngle += vutils_1.pi2;\n    const step = vutils_1.pi / 3 * (endAngle > startAngle ? 1 : -1);\n    let sa = startAngle, ea = sa;\n    for (;ea !== endAngle; ) {\n        ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);\n        const delta = Math.abs(ea - sa), len = 4 * Math.tan(delta / 4) / 3, dir = ea < sa ? -1 : 1, c1 = Math.cos(sa), s1 = Math.sin(sa), c2 = Math.cos(ea), s2 = Math.sin(ea), x1 = c1 * rx + cx, y1 = s1 * ry + cy, x4 = c2 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;\n        bezierPath.push([ x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4 ]), \n        sa = ea;\n    }\n};\n\nlet BrowserContext2d = class {\n    set fillStyle(d) {\n        this.nativeContext.fillStyle = d;\n    }\n    get fillStyle() {\n        return this.nativeContext.fillStyle;\n    }\n    set font(d) {\n        this.nativeContext.font = d;\n    }\n    get font() {\n        return this.nativeContext.font;\n    }\n    set globalAlpha(d) {\n        this.nativeContext.globalAlpha = d;\n    }\n    get globalAlpha() {\n        return this.nativeContext.globalAlpha;\n    }\n    set lineCap(d) {\n        this.nativeContext.lineCap = d;\n    }\n    get lineCap() {\n        return this.nativeContext.lineCap;\n    }\n    set lineDashOffset(d) {\n        this.nativeContext.lineDashOffset = d;\n    }\n    get lineDashOffset() {\n        return this.nativeContext.lineDashOffset;\n    }\n    set lineJoin(d) {\n        this.nativeContext.lineJoin = d;\n    }\n    get lineJoin() {\n        return this.nativeContext.lineJoin;\n    }\n    set lineWidth(d) {\n        this.nativeContext.lineWidth = d;\n    }\n    get lineWidth() {\n        return this.nativeContext.lineWidth;\n    }\n    set miterLimit(d) {\n        this.nativeContext.miterLimit = d;\n    }\n    get miterLimit() {\n        return this.nativeContext.miterLimit;\n    }\n    set shadowBlur(d) {\n        this.nativeContext.shadowBlur = d;\n    }\n    get shadowBlur() {\n        return this.nativeContext.shadowBlur;\n    }\n    set shadowColor(d) {\n        this.nativeContext.shadowColor = d;\n    }\n    get shadowColor() {\n        return this.nativeContext.shadowColor;\n    }\n    set shadowOffsetX(d) {\n        this.nativeContext.shadowOffsetX = d;\n    }\n    get shadowOffsetX() {\n        return this.nativeContext.shadowOffsetX;\n    }\n    set shadowOffsetY(d) {\n        this.nativeContext.shadowOffsetY = d;\n    }\n    get shadowOffsetY() {\n        return this.nativeContext.shadowOffsetY;\n    }\n    set strokeStyle(d) {\n        this.nativeContext.strokeStyle = d;\n    }\n    get strokeStyle() {\n        return this.nativeContext.strokeStyle;\n    }\n    set textAlign(d) {\n        this.nativeContext.textAlign = d;\n    }\n    get textAlign() {\n        return this.nativeContext.textAlign;\n    }\n    set textBaseline(d) {\n        this.nativeContext.textBaseline = d;\n    }\n    get textBaseline() {\n        return this.nativeContext.textBaseline;\n    }\n    get inuse() {\n        return !!this._inuse;\n    }\n    set inuse(use) {\n        use !== !!this._inuse && (this._inuse = use, use ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());\n    }\n    constructor(canvas, dpr) {\n        this.fillAttributes = Object.assign(Object.assign({}, graphic_1.DefaultFillStyle), {\n            opacity: 1\n        }), this.strokeAttributes = Object.assign(Object.assign({}, graphic_1.DefaultStrokeStyle), {\n            opacity: 1\n        }), this.textAttributes = Object.assign(Object.assign({}, graphic_1.DefaultTextStyle), {\n            opacity: 1\n        }), this._clearShadowStyle = !1, this._clearFilterStyle = !1;\n        const context = canvas.nativeCanvas.getContext(\"2d\");\n        if (!context) throw new Error(\"2d\");\n        this.nativeContext = context, this.canvas = canvas, this.matrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), \n        this.stack = [], this.dpr = dpr, this.applyedMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0);\n    }\n    reset() {\n        this.stack.length && console.warn(\"bugmatrix\"), this.matrix.setValue(1, 0, 0, 1, 0, 0), \n        this.applyedMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0, \n        this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    getContext() {\n        return this.nativeContext;\n    }\n    setTransformForCurrent(force = !1) {\n        !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f), \n        this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f));\n    }\n    get currentMatrix() {\n        return this.matrix;\n    }\n    cloneMatrix(m) {\n        return matrix_allocate_1.matrixAllocate.allocateByObj(m);\n    }\n    clear() {\n        this.save(), this.resetTransform(), this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height), \n        this.restore();\n    }\n    restore() {\n        this.nativeContext.restore(), this.stack.length > 0 && (matrix_allocate_1.matrixAllocate.free(this.matrix), \n        this.matrix = this.stack.pop(), this.setTransformForCurrent(!0));\n    }\n    highPerformanceRestore() {\n        this.stack.length > 0 && (matrix_allocate_1.matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());\n    }\n    rotate(rad, setTransform = !0) {\n        this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();\n    }\n    save() {\n        const matrix = this.cloneMatrix(this.matrix);\n        this.stack.push(matrix), this.nativeContext.save();\n    }\n    highPerformanceSave() {\n        const matrix = this.cloneMatrix(this.matrix);\n        this.stack.push(matrix);\n    }\n    scale(sx, sy, setTransform = !0) {\n        this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();\n    }\n    setScale(sx, sy, setTransform = !0) {\n        this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();\n    }\n    scalePoint(sx, sy, px, py, setTransform = !0) {\n        this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), \n        setTransform && this.setTransformForCurrent();\n    }\n    setTransform(a, b, c, d, e, f, setTransform = !0, dpr = this.dpr) {\n        this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();\n    }\n    setTransformFromMatrix(matrix, setTransform = !0, dpr = this.dpr) {\n        this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), \n        setTransform && this.setTransformForCurrent();\n    }\n    resetTransform(setTransform = !0, dpr = this.dpr) {\n        this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();\n    }\n    transform(a, b, c, d, e, f, setTransform = !0) {\n        this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();\n    }\n    transformFromMatrix(matrix, setTransform) {\n        this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), \n        setTransform && this.setTransformForCurrent();\n    }\n    translate(x, y, setTransform = !0) {\n        this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();\n    }\n    rotateDegrees(deg, setTransform = !0) {\n        const rad = deg * Math.PI / 180;\n        this.rotate(rad, setTransform);\n    }\n    rotateAbout(rad, x, y, setTransform = !0) {\n        this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();\n    }\n    rotateDegreesAbout(deg, x, y, setTransform = !0) {\n        this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), \n        setTransform && this.setTransformForCurrent();\n    }\n    beginPath() {\n        this.disableBeginPath || this.nativeContext.beginPath();\n    }\n    clip(path, fillRule) {\n        path ? \"string\" == typeof path ? this.nativeContext.clip(path) : this.nativeContext.clip(path, fillRule) : this.nativeContext.clip();\n    }\n    arc(x, y, radius, startAngle, endAngle, anticlockwise, z) {\n        if (z = z || 0, this.camera) {\n            const arr = [];\n            addArcToBezierPath(arr, startAngle, endAngle, x, y, radius, radius, anticlockwise);\n            for (let i = 0; i < arr.length; ++i) {\n                const bez = arr[i];\n                this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z);\n            }\n        } else this.nativeContext.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n    }\n    arcTo(x1, y1, x2, y2, radiusX) {\n        this.nativeContext.arcTo(x1, y1, x2, y2, radiusX);\n    }\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, z) {\n        if (z = z || 0, this.camera) {\n            let cp1z = z, cp2z = z;\n            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ cp1x, cp1y, z ], this.modelMatrix), \n            cp1x = outP[0], cp1y = outP[1], cp1z = outP[2], (0, camera_1.transformMat4)(outP, [ cp2x, cp2y, z ], this.modelMatrix), \n            cp2x = outP[0], cp2y = outP[1], cp2z = outP[2], (0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), \n            x = outP[0], y = outP[1], z = outP[2]);\n            let data = this.camera.vp(x, y, z);\n            x = data.x, y = data.y, data = this.camera.vp(cp1x, cp1y, cp1z), cp1x = data.x, \n            cp1y = data.y, data = this.camera.vp(cp2x, cp2y, cp2z), cp2x = data.x, cp2y = data.y;\n        }\n        this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    }\n    closePath() {\n        this.nativeContext.closePath();\n    }\n    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {\n        null == anticlockwise ? this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) : this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);\n    }\n    lineTo(x, y, z) {\n        if (z = z || 0, this.camera) {\n            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), \n            x = outP[0], y = outP[1], z = outP[2]);\n            const data = this.camera.vp(x, y, z);\n            x = data.x, y = data.y;\n        }\n        this.nativeContext.lineTo(x, y);\n    }\n    moveTo(x, y, z) {\n        if (z = z || 0, this.camera) {\n            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), \n            x = outP[0], y = outP[1], z = outP[2]);\n            const data = this.camera.vp(x, y, z);\n            x = data.x, y = data.y;\n        }\n        this.nativeContext.moveTo(x, y);\n    }\n    quadraticCurveTo(cpx, cpy, x, y, z) {\n        if (z = z || 0, this.camera) {\n            let cpz = z;\n            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ cpx, cpy, z ], this.modelMatrix), \n            cpx = outP[0], cpy = outP[1], cpz = outP[2], (0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), \n            x = outP[0], y = outP[1], z = outP[2]);\n            let data = this.camera.vp(x, y, z);\n            x = data.x, y = data.y, data = this.camera.vp(cpx, cpy, cpz), cpx = data.x, cpy = data.y;\n        }\n        this.nativeContext.quadraticCurveTo(cpx, cpy, x, y);\n    }\n    rect(x, y, w, h, z) {\n        z = z || 0, this.camera ? (this.moveTo(x, y, z), this.lineTo(x + w, y, z), this.lineTo(x + w, y + h, z), \n        this.lineTo(x, y + h, z), this.closePath()) : this.nativeContext.rect(x, y, w, h);\n    }\n    createImageData() {\n        const a = arguments;\n        return 2 === a.length ? this.nativeContext.createImageData(a[0], a[1]) : 1 === a.length ? this.nativeContext.createImageData(a[0]) : null;\n    }\n    createLinearGradient(x0, y0, x1, y1) {\n        return this.nativeContext.createLinearGradient(x0, y0, x1, y1);\n    }\n    createPattern(image, repetition) {\n        return 0 === image.width || 0 === image.height ? null : this.nativeContext.createPattern(image, repetition);\n    }\n    createRadialGradient(x0, y0, r0, x1, y1, r1) {\n        return this.nativeContext.createRadialGradient(x0, y0, r0, x1, y1, r1);\n    }\n    createConicGradient(x, y, startAngle, endAngle) {\n        let pattern, edit = !1;\n        const ctx = this;\n        return {\n            stops: [],\n            addColorStop(offset, color) {\n                this.stops.push([ offset, color ]), edit = !0;\n            },\n            GetPattern(minW, minH, deltaAngle) {\n                return edit && (deltaAngle || (deltaAngle = endAngle - startAngle), pattern = (0, \n                conical_gradient_1.createConicalGradient)(ctx, this.stops, x, y, deltaAngle, startAngle, endAngle, minW, minH), \n                edit = !1), pattern;\n            }\n        };\n    }\n    fill(path, fillRule) {\n        this.disableFill || (path ? this.nativeContext.fill(path) : this.nativeContext.fill());\n    }\n    fillRect(x, y, width, height) {\n        this.nativeContext.fillRect(x, y, width, height);\n    }\n    clearRect(x, y, w, h) {\n        this.nativeContext.clearRect(x, y, w, h);\n    }\n    project(x, y, z) {\n        if (z = z || 0, this.camera) {\n            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), \n            x = outP[0], y = outP[1], z = outP[2]);\n            const data = this.camera.vp(x, y, z);\n            x = data.x, y = data.y;\n        }\n        return {\n            x: x,\n            y: y\n        };\n    }\n    view(x, y, z) {\n        return z = z || 0, this.camera ? (this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), \n        x = outP[0], y = outP[1], z = outP[2]), this.camera.view(x, y, z)) : [ x, y, z ];\n    }\n    fillText(text, x, y, z) {\n        if (z = z || 0, this.camera) {\n            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), \n            x = outP[0], y = outP[1], z = outP[2]);\n            const data = this.camera.vp(x, y, z);\n            x = data.x, y = data.y;\n        }\n        this.nativeContext.fillText(text, x, y);\n    }\n    getImageData(sx, sy, sw, sh) {\n        return this.nativeContext.getImageData(sx, sy, sw, sh);\n    }\n    getLineDash() {\n        return this.nativeContext.getLineDash();\n    }\n    isPointInPath(x, y) {\n        return this.nativeContext.isPointInPath(x, y);\n    }\n    isPointInStroke(x, y) {\n        return this.nativeContext.isPointInStroke(x, y);\n    }\n    measureText(text, method = application_1.application.global.measureTextMethod) {\n        var _a, _b;\n        return method && \"native\" !== method ? (this.mathTextMeasure || (this.mathTextMeasure = application_1.application.graphicUtil.createTextMeasureInstance({}, {}, (() => this.canvas))), \n        this.mathTextMeasure.textSpec.fontFamily = null !== (_a = this.fontFamily) && void 0 !== _a ? _a : graphic_1.DefaultTextStyle.fontFamily, \n        this.mathTextMeasure.textSpec.fontSize = null !== (_b = this.fontSize) && void 0 !== _b ? _b : graphic_1.DefaultTextStyle.fontSize, \n        this.mathTextMeasure._numberCharSize = null, this.mathTextMeasure._fullCharSize = null, \n        this.mathTextMeasure._letterCharSize = null, this.mathTextMeasure._specialCharSizeMap = {}, \n        this.mathTextMeasure.measure(text, method)) : this.nativeContext.measureText(text);\n    }\n    putImageData(imagedata, dx, dy) {\n        this.nativeContext.putImageData(imagedata, dx, dy);\n    }\n    setLineDash(segments) {\n        const a = arguments, _context = this.nativeContext;\n        this.nativeContext.setLineDash ? _context.setLineDash(a[0]) : \"mozDash\" in _context ? _context.mozDash = a[0] : \"webkitLineDash\" in _context && (_context.webkitLineDash = a[0]);\n    }\n    stroke(path) {\n        this.disableStroke || (path ? this.nativeContext.stroke(path) : this.nativeContext.stroke());\n    }\n    strokeRect(x, y, width, height) {\n        this.nativeContext.strokeRect(x, y, width, height);\n    }\n    strokeText(text, x, y, z) {\n        if (z = z || 0, this.camera) {\n            this.modelMatrix && ((0, camera_1.transformMat4)(outP, [ x, y, z ], this.modelMatrix), \n            x = outP[0], y = outP[1], z = outP[2]);\n            const data = this.camera.vp(x, y, z);\n            x = data.x, y = data.y;\n        }\n        this.nativeContext.strokeText(text, x, y);\n    }\n    drawImage() {\n        const _context = this.nativeContext, a = arguments;\n        3 === a.length ? _context.drawImage(a[0], a[1], a[2]) : 5 === a.length ? _context.drawImage(a[0], a[1], a[2], a[3], a[4]) : 9 === a.length && _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n    }\n    setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {\n        if (Array.isArray(defaultParams)) {\n            if (defaultParams.length <= 1) return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams[0]);\n            const dp = {};\n            return defaultParams.forEach((p => {\n                Object.assign(dp, p);\n            })), this._setCommonStyle(params, attribute, offsetX, offsetY, dp);\n        }\n        return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams);\n    }\n    _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {\n        const _context = this.nativeContext;\n        defaultParams || (defaultParams = this.fillAttributes);\n        const {fillOpacity: fillOpacity = defaultParams.fillOpacity, opacity: opacity = defaultParams.opacity, fill: fill = defaultParams.fill} = attribute;\n        fillOpacity > 1e-12 && opacity > 1e-12 ? (_context.globalAlpha = fillOpacity * opacity, \n        _context.fillStyle = (0, canvas_utils_1.createColor)(this, fill, params, offsetX, offsetY)) : _context.globalAlpha = fillOpacity * opacity;\n    }\n    setShadowStyle(params, attribute, defaultParams) {\n        if (Array.isArray(defaultParams)) {\n            if (defaultParams.length <= 1) return this._setShadowStyle(params, defaultParams[0]);\n            const dp = {};\n            return defaultParams.forEach((p => {\n                Object.assign(dp, p);\n            })), this._setShadowStyle(params, attribute, dp);\n        }\n        return this._setShadowStyle(params, attribute, defaultParams);\n    }\n    _setShadowStyle(params, attribute, defaultParams) {\n        const _context = this.nativeContext;\n        defaultParams || (defaultParams = this.fillAttributes);\n        const {opacity: opacity = defaultParams.opacity, shadowBlur: shadowBlur = defaultParams.shadowBlur, shadowColor: shadowColor = defaultParams.shadowColor, shadowOffsetX: shadowOffsetX = defaultParams.shadowOffsetX, shadowOffsetY: shadowOffsetY = defaultParams.shadowOffsetY, blur: blur = defaultParams.blur} = attribute;\n        opacity <= 1e-12 || (shadowBlur || shadowOffsetX || shadowOffsetY ? (_context.shadowBlur = shadowBlur, \n        _context.shadowColor = shadowColor, _context.shadowOffsetX = shadowOffsetX, _context.shadowOffsetY = shadowOffsetY, \n        this._clearShadowStyle = !0) : this._clearShadowStyle && (_context.shadowBlur = 0, \n        _context.shadowOffsetX = 0, _context.shadowOffsetY = 0), blur ? (_context.filter = `blur(${blur}px)`, \n        this._clearFilterStyle = !0) : this._clearFilterStyle && (_context.filter = \"blur(0px)\", \n        this._clearFilterStyle = !1));\n    }\n    setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {\n        if (Array.isArray(defaultParams)) {\n            if (defaultParams.length <= 1) return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams[0]);\n            const dp = {};\n            return defaultParams.forEach((p => {\n                Object.assign(dp, p);\n            })), this._setStrokeStyle(params, attribute, offsetX, offsetY, dp);\n        }\n        return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams);\n    }\n    _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {\n        const _context = this.nativeContext;\n        defaultParams || (defaultParams = this.strokeAttributes);\n        const {strokeOpacity: strokeOpacity = defaultParams.strokeOpacity, opacity: opacity = defaultParams.opacity} = attribute;\n        if (strokeOpacity > 1e-12 && opacity > 1e-12) {\n            const {lineWidth: lineWidth = defaultParams.lineWidth, stroke: stroke = defaultParams.stroke, lineJoin: lineJoin = defaultParams.lineJoin, lineDash: lineDash = defaultParams.lineDash, lineCap: lineCap = defaultParams.lineCap, miterLimit: miterLimit = defaultParams.miterLimit} = attribute;\n            _context.globalAlpha = strokeOpacity * opacity, _context.lineWidth = (0, canvas_utils_1.getScaledStroke)(this, lineWidth, this.dpr), \n            _context.strokeStyle = (0, canvas_utils_1.createColor)(this, stroke, params, offsetX, offsetY), \n            _context.lineJoin = lineJoin, _context.setLineDash(lineDash), _context.lineCap = lineCap, \n            _context.miterLimit = miterLimit;\n        }\n    }\n    setTextStyleWithoutAlignBaseline(params, defaultParams, z) {\n        const _context = this.nativeContext;\n        defaultParams || (defaultParams = this.textAttributes);\n        const {scaleIn3d: scaleIn3d = defaultParams.scaleIn3d} = params;\n        params.font ? _context.font = params.font : _context.font = (0, text_1.getContextFont)(params, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z));\n        const {fontFamily: fontFamily = defaultParams.fontFamily, fontSize: fontSize = defaultParams.fontSize} = params;\n        this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = \"left\", \n        _context.textBaseline = \"alphabetic\";\n    }\n    setTextStyle(params, defaultParams, z) {\n        var _a, _b;\n        const _context = this.nativeContext;\n        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = (0, \n        text_1.getContextFont)(params, defaultParams, this.camera && this.camera.getProjectionScale(z));\n        const {fontFamily: fontFamily = defaultParams.fontFamily, fontSize: fontSize = defaultParams.fontSize} = params;\n        this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, \n        _context.textBaseline = null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;\n    }\n    draw() {}\n    clearMatrix(setTransform = !0, dpr = this.dpr) {\n        this.setTransformFromMatrix(initMatrix, setTransform, dpr);\n    }\n    onlyTranslate(dpr = this.dpr) {\n        return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;\n    }\n    release(...params) {\n        this.stack.forEach((m => matrix_allocate_1.matrixAllocate.free(m))), this.stack.length = 0;\n    }\n};\n\nBrowserContext2d.env = \"browser\", BrowserContext2d = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", [ Object, Number ]) ], BrowserContext2d), \nexports.BrowserContext2d = BrowserContext2d;\n//# sourceMappingURL=context.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.OrthoCamera = exports.transformMat4 = exports.multiply = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), matrix_allocate_1 = require(\"../allocator/matrix-allocate\"), matrix_allocate_2 = require(\"../allocator/matrix-allocate\");\n\nfunction targetTo(out, eye, target, up) {\n    const eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];\n    let z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2], len = z0 * z0 + z1 * z1 + z2 * z2;\n    len > 0 && (len = 1 / Math.sqrt(len), z0 *= len, z1 *= len, z2 *= len);\n    let x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;\n    return len = x0 * x0 + x1 * x1 + x2 * x2, len > 0 && (len = 1 / Math.sqrt(len), \n    x0 *= len, x1 *= len, x2 *= len), out[0] = x0, out[1] = x1, out[2] = x2, out[3] = 0, \n    out[4] = z1 * x2 - z2 * x1, out[5] = z2 * x0 - z0 * x2, out[6] = z0 * x1 - z1 * x0, \n    out[7] = 0, out[8] = z0, out[9] = z1, out[10] = z2, out[11] = 0, out[12] = eyex, \n    out[13] = eyey, out[14] = eyez, out[15] = 1, out;\n}\n\nfunction lookAt(out, eye, center, up) {\n    let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n    const eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center[0], centery = center[1], centerz = center[2];\n    return Math.abs(eyex - centerx) < vutils_1.epsilon && Math.abs(eyey - centery) < vutils_1.epsilon && Math.abs(eyez - centerz) < vutils_1.epsilon ? matrix_allocate_1.DefaultMat4Allocate.identity(out) : (z0 = eyex - centerx, \n    z1 = eyey - centery, z2 = eyez - centerz, len = 1 / Math.hypot(z0, z1, z2), z0 *= len, \n    z1 *= len, z2 *= len, x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0, \n    len = Math.hypot(x0, x1, x2), len ? (len = 1 / len, x0 *= len, x1 *= len, x2 *= len) : (x0 = 0, \n    x1 = 0, x2 = 0), y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0, \n    len = Math.hypot(y0, y1, y2), len ? (len = 1 / len, y0 *= len, y1 *= len, y2 *= len) : (y0 = 0, \n    y1 = 0, y2 = 0), out[0] = x0, out[1] = y0, out[2] = z0, out[3] = 0, out[4] = x1, \n    out[5] = y1, out[6] = z1, out[7] = 0, out[8] = x2, out[9] = y2, out[10] = z2, out[11] = 0, \n    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez), out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez), \n    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez), out[15] = 1, out);\n}\n\nfunction ortho(out, left, right, bottom, top, near, far) {\n    const lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);\n    return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, \n    out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left + right) * lr, \n    out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;\n}\n\nfunction multiply(out, a, b) {\n    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, \n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, \n    b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, \n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, \n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], \n    b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, \n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, \n    b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, \n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, \n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;\n}\n\nfunction transformMat4(out, a, m) {\n    const x = a[0], y = a[1], z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    return w = w || 1, out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w, out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w, \n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w, out;\n}\n\nexports.multiply = multiply, exports.transformMat4 = transformMat4;\n\nclass OrthoCamera {\n    set params(params) {\n        this._params = Object.assign({}, params), this._projectionMatrixCached = this.forceGetProjectionMatrix(), \n        this._viewMatrixCached = this.forceGetViewMatrix();\n    }\n    get params() {\n        return Object.assign({}, this._params);\n    }\n    constructor(params) {\n        this.params = params;\n    }\n    getViewMatrix() {\n        return this._viewMatrixCached || (this._viewMatrixCached = matrix_allocate_2.mat4Allocate.allocate()), \n        this._viewMatrixCached;\n    }\n    forceGetViewMatrix() {\n        this._viewMatrixCached || (this._viewMatrixCached = matrix_allocate_2.mat4Allocate.allocate());\n        const {pos: pos, center: center, up: up} = this.params.viewParams;\n        return lookAt(this._viewMatrixCached, pos, center, up), this._vp || (this._vp = matrix_allocate_2.mat4Allocate.allocate()), \n        this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), \n        this._viewMatrixCached;\n    }\n    getProjectionMatrix() {\n        return this._projectionMatrixCached || (this._projectionMatrixCached = matrix_allocate_2.mat4Allocate.allocate()), \n        this._projectionMatrixCached;\n    }\n    forceGetProjectionMatrix() {\n        this._projectionMatrixCached || (this._projectionMatrixCached = matrix_allocate_2.mat4Allocate.allocate());\n        const {left: left, top: top, right: right, bottom: bottom} = this._params;\n        return ortho(this._projectionMatrixCached, left, right, bottom, top, 0, -2e6), this._vp || (this._vp = matrix_allocate_2.mat4Allocate.allocate()), \n        this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), \n        this._projectionMatrixCached;\n    }\n    getField() {\n        const {fieldRatio: fieldRatio = .8, fieldDepth: fieldDepth, left: left, right: right} = this._params;\n        return (null != fieldDepth ? fieldDepth : right - left) * fieldRatio;\n    }\n    getProjectionScale(z) {\n        const field = this.getField();\n        return field / (field + z);\n    }\n    view(x, y, z) {\n        const outP = [ 0, 0, 0 ];\n        return transformMat4(outP, [ x, y, z ], this._viewMatrixCached), outP;\n    }\n    vp(x, y, z) {\n        const outP = [ 0, 0, 0 ], {pos: pos} = this._params.viewParams;\n        transformMat4(outP, [ x, y, z ], this._viewMatrixCached), x = outP[0], y = outP[1], \n        z = outP[2];\n        const sizeProjection = this.getProjectionScale(z);\n        return {\n            x: x * sizeProjection + pos[0],\n            y: y * sizeProjection + pos[1]\n        };\n    }\n}\n\nexports.OrthoCamera = OrthoCamera;\n//# sourceMappingURL=camera.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.MathPickerContribution = exports.MathGlyphPicker = exports.MathPolygonPicker = exports.MathTextPicker = exports.MathSymbolPicker = exports.MathRectPicker = exports.MathPathPicker = exports.MathLinePicker = exports.MathImagePicker = exports.MathCirclePicker = exports.MathAreaPicker = exports.MathArcPicker = exports.CanvasPickerContribution = exports.CanvasGlyphPicker = exports.CanvasRichTextPicker = exports.CanvasPyramid3dPicker = exports.CanvasPolygonPicker = exports.CanvasTextPicker = exports.CanvasSymbolPicker = exports.CanvasRect3dPicker = exports.CanvasRectPicker = exports.CanvasPathPicker = exports.CanvasLinePicker = exports.CanvasImagePicker = exports.CanvasCirclePicker = exports.CanvasAreaPicker = exports.CanvasArc3dPicker = exports.CanvasArcPicker = void 0, \nexports.CanvasArcPicker = Symbol.for(\"CanvasArcPicker\"), exports.CanvasArc3dPicker = Symbol.for(\"CanvasArc3dPicker\"), \nexports.CanvasAreaPicker = Symbol.for(\"CanvasAreaPicker\"), exports.CanvasCirclePicker = Symbol.for(\"CanvasCirclePicker\"), \nexports.CanvasImagePicker = Symbol.for(\"CanvasImagePicker\"), exports.CanvasLinePicker = Symbol.for(\"CanvasLinePicker\"), \nexports.CanvasPathPicker = Symbol.for(\"CanvasPathPicker\"), exports.CanvasRectPicker = Symbol.for(\"CanvasRectPicker\"), \nexports.CanvasRect3dPicker = Symbol.for(\"CanvasRect3dPicker\"), exports.CanvasSymbolPicker = Symbol.for(\"CanvasSymbolPicker\"), \nexports.CanvasTextPicker = Symbol.for(\"CanvasTextPicker\"), exports.CanvasPolygonPicker = Symbol.for(\"CanvasPolygonPicker\"), \nexports.CanvasPyramid3dPicker = Symbol.for(\"CanvasPyramid3dPicker\"), exports.CanvasRichTextPicker = Symbol.for(\"CanvasRichTextPicker\"), \nexports.CanvasGlyphPicker = Symbol.for(\"CanvasGlyphPicker\"), exports.CanvasPickerContribution = Symbol.for(\"CanvasPickerContribution\"), \nexports.MathArcPicker = Symbol.for(\"MathArcPicker\"), exports.MathAreaPicker = Symbol.for(\"MathAreaPicker\"), \nexports.MathCirclePicker = Symbol.for(\"MathCirclePicker\"), exports.MathImagePicker = Symbol.for(\"MathImagePicker\"), \nexports.MathLinePicker = Symbol.for(\"MathLinePicker\"), exports.MathPathPicker = Symbol.for(\"MathPathPicker\"), \nexports.MathRectPicker = Symbol.for(\"MathRectPicker\"), exports.MathSymbolPicker = Symbol.for(\"MathSymbolPicker\"), \nexports.MathTextPicker = Symbol.for(\"MathTextPicker\"), exports.MathPolygonPicker = Symbol.for(\"MathPolygonPicker\"), \nexports.MathGlyphPicker = Symbol.for(\"MathGlyphPicker\"), exports.MathPickerContribution = Symbol.for(\"MathPickerContribution\");\n//# sourceMappingURL=constants.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./render-service\"), exports), __exportStar(require(\"./contributions/render\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathPickerService = void 0;\n\nconst contribution_provider_1 = require(\"../common/contribution-provider\"), inversify_1 = require(\"inversify\"), picker_service_1 = require(\"./picker-service\"), canvas_1 = require(\"../canvas\"), constants_1 = require(\"./contributions/constants\"), constants_2 = require(\"../constants\"), pick_interceptor_1 = require(\"./pick-interceptor\");\n\nlet DefaultMathPickerService = class extends picker_service_1.DefaultPickService {\n    constructor(contributions, global, pickItemInterceptorContributions) {\n        super(global, pickItemInterceptorContributions), this.contributions = contributions, \n        this.global = global, this.pickItemInterceptorContributions = pickItemInterceptorContributions, \n        this.global.hooks.onSetEnv.tap(\"math-picker-service\", ((lastEnv, env, global) => {\n            this.configure(global, env);\n        })), this.configure(this.global, this.global.env), this.pickerMap = new Map;\n    }\n    init() {\n        this.contributions.getContributions().forEach((item => {\n            this.pickerMap.set(item.numberType, item);\n        })), super._init();\n    }\n    configure(global, env) {\n        this.pickContext = new canvas_1.EmptyContext2d(null, 1);\n    }\n    pickItem(graphic, point, params) {\n        if (!1 === graphic.attribute.pickable) return null;\n        const picker = this.pickerMap.get(graphic.numberType);\n        return picker && picker.contains(graphic, point, params) ? graphic : null;\n    }\n};\n\n__decorate([ (0, inversify_1.postConstruct)(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0) ], DefaultMathPickerService.prototype, \"init\", null), \nDefaultMathPickerService = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(constants_1.MathPickerContribution)), __param(1, (0, inversify_1.inject)(constants_2.Global)), __param(2, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(2, (0, \ninversify_1.named)(pick_interceptor_1.PickItemInterceptor)), __metadata(\"design:paramtypes\", [ Object, Object, Object ]) ], DefaultMathPickerService), \nexports.DefaultMathPickerService = DefaultMathPickerService;\n//# sourceMappingURL=math-picker-service.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./constants\"), exports), __exportStar(require(\"./empty-context\"), exports), \n__exportStar(require(\"./contributions/browser\"), exports);\n//# sourceMappingURL=index.js.map","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.EmptyContext2d = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), util_1 = require(\"./util\"), custom_path2d_1 = require(\"../common/custom-path2d\"), canvas_utils_1 = require(\"../common/canvas-utils\"), matrix_allocate_1 = require(\"../allocator/matrix-allocate\"), initMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), globalPoint = {\n    x: 0,\n    y: 0\n};\n\nlet EmptyContext2d = class {\n    get nativeContext() {\n        return this.path;\n    }\n    constructor(canvas, dpr) {\n        this.matrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, \n        this.applyedMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), this.path = new custom_path2d_1.CustomPath2D;\n    }\n    getCanvas() {\n        throw new Error(\"getCanvas\");\n    }\n    getContext() {\n        throw new Error(\"getContext\");\n    }\n    setTransformForCurrent(force = !1) {\n        !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));\n    }\n    get currentMatrix() {\n        return this.matrix;\n    }\n    cloneMatrix(m) {\n        return matrix_allocate_1.matrixAllocate.allocateByObj(m);\n    }\n    clear() {\n        this.save(), this.resetTransform(), this.restore();\n    }\n    restore() {\n        this.stack.length > 0 && (matrix_allocate_1.matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), \n        this.setTransformForCurrent());\n    }\n    highPerformanceRestore() {\n        this.stack.length > 0 && (matrix_allocate_1.matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());\n    }\n    rotate(rad, setTransform = !0) {\n        this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();\n    }\n    save() {\n        const matrix = this.cloneMatrix(this.matrix);\n        this.stack.push(matrix);\n    }\n    highPerformanceSave() {\n        const matrix = this.cloneMatrix(this.matrix);\n        this.stack.push(matrix);\n    }\n    scale(sx, sy, setTransform = !0) {\n        this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();\n    }\n    setScale(sx, sy, setTransform = !0) {\n        this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();\n    }\n    scalePoint(sx, sy, px, py, setTransform = !0) {\n        this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), \n        setTransform && this.setTransformForCurrent();\n    }\n    setTransform(a, b, c, d, e, f, setTransform = !0, dpr = this.dpr) {\n        this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();\n    }\n    setTransformFromMatrix(matrix, setTransform = !0, dpr = this.dpr) {\n        this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), \n        setTransform && this.setTransformForCurrent();\n    }\n    resetTransform(setTransform = !0, dpr = this.dpr) {\n        this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();\n    }\n    transform(a, b, c, d, e, f, setTransform = !0) {\n        this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();\n    }\n    transformFromMatrix(matrix, setTransform) {\n        this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), \n        setTransform && this.setTransformForCurrent();\n    }\n    translate(x, y, setTransform = !0) {\n        this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();\n    }\n    rotateDegrees(deg, setTransform = !0) {\n        const rad = deg * Math.PI / 180;\n        this.rotate(rad, setTransform);\n    }\n    rotateAbout(rad, x, y, setTransform = !0) {\n        this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();\n    }\n    rotateDegreesAbout(deg, x, y, setTransform = !0) {\n        this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), \n        setTransform && this.setTransformForCurrent();\n    }\n    beginPath() {\n        this.path.clear();\n    }\n    clip(path, fillRule) {}\n    arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n        this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n    }\n    arcTo(x1, y1, x2, y2, radiusX) {\n        this.path.arcTo(x1, y1, x2, y2, radiusX);\n    }\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n        this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    }\n    closePath() {\n        this.path.closePath();\n    }\n    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {}\n    lineTo(x, y) {\n        this.path.lineTo(x, y);\n    }\n    moveTo(x, y) {\n        this.path.moveTo(x, y);\n    }\n    quadraticCurveTo(cpx, cpy, x, y) {\n        this.path.quadraticCurveTo(cpx, cpy, x, y);\n    }\n    rect(x, y, w, h) {\n        this.path.rect(x, y, w, h);\n    }\n    createImageData(imageDataOrSw, sh) {\n        return null;\n    }\n    createLinearGradient(x0, y0, x1, y1) {\n        throw new Error(\"createLinearGradient\");\n    }\n    createPattern(image, repetition) {\n        throw new Error(\"createPattern\");\n    }\n    createRadialGradient(x0, y0, r0, x1, y1, r1) {\n        throw new Error(\"createRadialGradient\");\n    }\n    createConicGradient(x, y, startAngle, endAngle) {\n        return null;\n    }\n    fill(path, fillRule) {}\n    fillRect(x, y, width, height) {\n        this.path.rect(x, y, width, height);\n    }\n    clearRect(x, y, w, h) {}\n    fillText(text, x, y) {}\n    getImageData(sx, sy, sw, sh) {\n        return null;\n    }\n    getLineDash() {\n        return [];\n    }\n    isPointInPath(x, y) {\n        return this.matrix.transformPoint({\n            x: x,\n            y: y\n        }, globalPoint), (0, util_1.contain)(this.path.commandList, globalPoint.x, globalPoint.y);\n    }\n    isPointInStroke(x, y) {\n        if (!this.lineWidth) return !1;\n        this.matrix.transformPoint({\n            x: x,\n            y: y\n        }, globalPoint);\n        const lineWidth = (0, canvas_utils_1.getScaledStroke)(this, this.lineWidth, this.dpr);\n        return (0, util_1.containStroke)(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);\n    }\n    measureText(text) {\n        throw new Error(\"measureText\");\n    }\n    putImageData(imagedata, dx, dy) {\n        throw new Error(\"measureText\");\n    }\n    setLineDash(segments) {}\n    stroke(path) {}\n    strokeRect(x, y, width, height) {\n        this.path.rect(x, y, width, height);\n    }\n    strokeText(text, x, y) {}\n    drawImage() {}\n    setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {}\n    _setCommonStyle(params, offsetX, offsetY, defaultParams) {}\n    setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {}\n    _setStrokeStyle(params, offsetX, offsetY, defaultParams) {}\n    setTextStyleWithoutAlignBaseline(params, defaultParams) {}\n    setTextStyle(params, defaultParams) {}\n    draw() {}\n    clearMatrix(setTransform = !0, dpr = this.dpr) {\n        this.setTransformFromMatrix(initMatrix, setTransform, dpr);\n    }\n    onlyTranslate(dpr = this.dpr) {\n        return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;\n    }\n    release(...params) {\n        this.stack.forEach((m => matrix_allocate_1.matrixAllocate.free(m))), this.stack.length = 0;\n    }\n};\n\nEmptyContext2d = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", [ Object, Number ]) ], EmptyContext2d), \nexports.EmptyContext2d = EmptyContext2d;\n//# sourceMappingURL=empty-context.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), contribution_provider_1 = require(\"../../common/contribution-provider\"), arc_contribution_1 = require(\"./arc-contribution\"), circle_contribution_1 = require(\"./circle-contribution\"), graphic_service_1 = require(\"./graphic-service\"), path_contribution_1 = require(\"./path-contribution\"), rect_contribution_1 = require(\"./rect-contribution\"), symbol_contribution_1 = require(\"./symbol-contribution\"), constants_1 = require(\"../constants\"), graphic_creator_1 = require(\"../graphic-creator\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(graphic_service_1.DefaultGraphicService).toSelf().inSingletonScope(), bind(constants_1.GraphicService).toService(graphic_service_1.DefaultGraphicService), \n    bind(rect_contribution_1.DefaultRectOuterBorderBoundsContribution).toSelf().inSingletonScope(), \n    bind(rect_contribution_1.RectBoundsContribution).toService(rect_contribution_1.DefaultRectOuterBorderBoundsContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, rect_contribution_1.RectBoundsContribution), \n    bind(symbol_contribution_1.DefaultSymbolOuterBorderBoundsContribution).toSelf().inSingletonScope(), \n    bind(symbol_contribution_1.SymbolBoundsContribution).toService(symbol_contribution_1.DefaultSymbolOuterBorderBoundsContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, symbol_contribution_1.SymbolBoundsContribution), \n    bind(circle_contribution_1.DefaultCircleOuterBorderBoundsContribution).toSelf().inSingletonScope(), \n    bind(circle_contribution_1.CircleBoundsContribution).toService(circle_contribution_1.DefaultCircleOuterBorderBoundsContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, circle_contribution_1.CircleBoundsContribution), \n    bind(arc_contribution_1.DefaultArcOuterBorderBoundsContribution).toSelf().inSingletonScope(), \n    bind(arc_contribution_1.ArcBoundsContribution).toService(arc_contribution_1.DefaultArcOuterBorderBoundsContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, arc_contribution_1.ArcBoundsContribution), \n    bind(path_contribution_1.DefaultPathOuterBorderBoundsContribution).toSelf().inSingletonScope(), \n    bind(path_contribution_1.PathBoundsContribution).toService(path_contribution_1.DefaultPathOuterBorderBoundsContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, path_contribution_1.PathBoundsContribution), \n    bind(constants_1.GraphicCreator).toConstantValue(graphic_creator_1.graphicCreator);\n}));\n//# sourceMappingURL=graphic-module.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), plugin_service_1 = require(\"./plugin-service\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(plugin_service_1.DefaultPluginService).toSelf(), bind(plugin_service_1.PluginService).toService(plugin_service_1.DefaultPluginService);\n}));\n//# sourceMappingURL=plugin-modules.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultPluginService = exports.PluginService = void 0;\n\nconst inversify_1 = require(\"inversify\");\n\nexports.PluginService = Symbol.for(\"PluginService\");\n\nlet DefaultPluginService = class {\n    constructor() {\n        this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = !1;\n    }\n    active(stage) {\n        this.stage = stage, this.actived = !0;\n    }\n    findPluginsByName(name) {\n        const arr = [];\n        return this.onStartupFinishedPlugin.forEach((plugin => {\n            plugin.name === name && arr.push(plugin);\n        })), this.onRegisterPlugin.forEach((plugin => {\n            plugin.name === name && arr.push(plugin);\n        })), arr;\n    }\n    register(plugin) {\n        \"onStartupFinished\" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : \"onRegister\" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), \n        plugin.activate(this));\n    }\n    release(...params) {\n        this.onStartupFinishedPlugin.forEach((plugin => {\n            plugin.deactivate(this);\n        })), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach((plugin => {\n            plugin.deactivate(this);\n        })), this.onRegisterPlugin = [];\n    }\n};\n\nDefaultPluginService = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", []) ], DefaultPluginService), \nexports.DefaultPluginService = DefaultPluginService;\n//# sourceMappingURL=plugin-service.js.map\n","\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst modules_1 = __importDefault(require(\"./env/modules\")), modules_2 = __importDefault(require(\"./window/modules\")), modules_3 = __importDefault(require(\"./textMeasure/modules\")), modules_4 = __importDefault(require(\"./layerHandler/modules\"));\n\nfunction load(container) {\n    container.load(modules_1.default), container.load(modules_2.default), container.load(modules_3.default), \n    container.load(modules_4.default);\n}\n\nexports.default = load;\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), constants_1 = require(\"../../../constants\"), browser_contribution_1 = require(\"./browser-contribution\"), feishu_contribution_1 = require(\"./feishu-contribution\"), taro_contribution_1 = require(\"./taro-contribution\"), lynx_contribution_1 = require(\"./lynx-contribution\"), node_contribution_1 = require(\"./node-contribution\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(browser_contribution_1.BrowserEnvContribution).toSelf().inSingletonScope(), \n    bind(constants_1.EnvContribution).toService(browser_contribution_1.BrowserEnvContribution), \n    bind(feishu_contribution_1.FeishuEnvContribution).toSelf().inSingletonScope(), bind(constants_1.EnvContribution).toService(feishu_contribution_1.FeishuEnvContribution), \n    bind(taro_contribution_1.TaroEnvContribution).toSelf().inSingletonScope(), bind(constants_1.EnvContribution).toService(taro_contribution_1.TaroEnvContribution), \n    bind(lynx_contribution_1.LynxEnvContribution).toSelf().inSingletonScope(), bind(constants_1.EnvContribution).toService(lynx_contribution_1.LynxEnvContribution), \n    bind(node_contribution_1.NodeEnvContribution).toSelf().inSingletonScope(), bind(constants_1.EnvContribution).toService(node_contribution_1.NodeEnvContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, constants_1.EnvContribution);\n}));\n//# sourceMappingURL=modules.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BrowserEnvContribution = exports.createImageElement = void 0;\n\nconst inversify_1 = require(\"inversify\"), generator_1 = require(\"../../../common/generator\"), base_contribution_1 = require(\"./base-contribution\"), vutils_1 = require(\"@visactor/vutils\");\n\nfunction createImageElement(src, isSvg = !1) {\n    const img = document.createElement(\"img\");\n    if (img.crossOrigin = \"anonymous\", isSvg) {\n        const data = new Blob([ src ], {\n            type: \"image/svg+xml\"\n        });\n        src = window.URL.createObjectURL(data);\n    }\n    if (img.src = src, img.complete) return Promise.resolve(img);\n    return new Promise(((resolve, reject) => {\n        img.onload = () => {\n            resolve(img);\n        }, img.onerror = () => {\n            reject(new Error(\"\"));\n        };\n    }));\n}\n\nexports.createImageElement = createImageElement;\n\nlet BrowserEnvContribution = class extends base_contribution_1.BaseEnvContribution {\n    constructor() {\n        super(), this.type = \"browser\", this.supportEvent = !0;\n        try {\n            this.supportsTouchEvents = \"ontouchstart\" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, \n            this.supportsMouseEvents = !!globalThis.MouseEvent;\n        } catch (err) {\n            this.supportsTouchEvents = !1, this.supportsPointerEvents = !1, this.supportsPointerEvents = !1;\n        }\n        this.applyStyles = !0;\n    }\n    mapToCanvasPoint(nativeEvent, domElement) {\n        var _a;\n        if (domElement) {\n            const {clientX: x, clientY: y} = nativeEvent, rect = domElement.getBoundingClientRect(), nativeCanvas = null === (_a = domElement.getNativeHandler) || void 0 === _a ? void 0 : _a.call(domElement).nativeCanvas;\n            let scaleX, scaleY;\n            return nativeCanvas && (scaleX = rect.width / nativeCanvas.offsetWidth, scaleY = rect.height / nativeCanvas.offsetHeight), \n            {\n                x: (x - rect.left) / ((0, vutils_1.isValidNumber)(scaleX) ? scaleX : 1),\n                y: (y - rect.top) / ((0, vutils_1.isValidNumber)(scaleY) ? scaleX : 1)\n            };\n        }\n        return {\n            x: nativeEvent.offsetX,\n            y: nativeEvent.offsetY\n        };\n    }\n    loadImage(url) {\n        return createImageElement(url, !1).then((img => ({\n            data: img,\n            loadState: \"success\"\n        }))).catch((() => ({\n            data: null,\n            loadState: \"fail\"\n        })));\n    }\n    loadSvg(url) {\n        return createImageElement(url, !0).then((img => ({\n            data: img,\n            loadState: \"success\"\n        }))).catch((() => ({\n            data: null,\n            loadState: \"fail\"\n        })));\n    }\n    createCanvas(params) {\n        var _a, _b;\n        const canvas = document.createElement(\"canvas\");\n        params.id && (canvas.id = null !== (_a = params.id) && void 0 !== _a ? _a : generator_1.Generator.GenAutoIncrementId().toString());\n        const dpr = null !== (_b = params.dpr) && void 0 !== _b ? _b : window.devicePixelRatio;\n        return params.width && params.height && (canvas.style.width = `${params.width}px`, \n        canvas.style.height = `${params.height}px`, canvas.width = params.width * dpr, canvas.height = params.height * dpr), \n        canvas;\n    }\n    createOffscreenCanvas(params) {\n        var _a;\n        const dpr = null !== (_a = params.dpr) && void 0 !== _a ? _a : window.devicePixelRatio;\n        return new OffscreenCanvas(params.width * dpr, params.height * dpr);\n    }\n    releaseCanvas(canvas) {\n        let c;\n        c = \"string\" == typeof canvas ? document.getElementById(canvas) : canvas, c && c.parentElement && c.parentElement.removeChild(c);\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n    getRequestAnimationFrame() {\n        return window.requestAnimationFrame;\n    }\n    getCancelAnimationFrame() {\n        return window.cancelAnimationFrame;\n    }\n    addEventListener(type, listener, options) {\n        return document.addEventListener(type, listener, options);\n    }\n    removeEventListener(type, listener, options) {\n        return document.removeEventListener(type, listener, options);\n    }\n    dispatchEvent(event) {\n        return document.dispatchEvent(event);\n    }\n    getElementById(str) {\n        return document.getElementById(str);\n    }\n    getRootElement() {\n        return document.body;\n    }\n    getDocument() {\n        return document;\n    }\n    release(...params) {}\n};\n\nBrowserEnvContribution = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", []) ], BrowserEnvContribution), \nexports.BrowserEnvContribution = BrowserEnvContribution;\n//# sourceMappingURL=browser-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BaseEnvContribution = void 0;\n\nconst inversify_1 = require(\"inversify\");\n\nlet BaseEnvContribution = class {\n    configure(service, ...p) {\n        service.env === this.type && service.setActiveEnvContribution(this);\n    }\n    getElementById(str) {\n        return document.getElementById(str);\n    }\n    getRootElement() {\n        return document.body;\n    }\n    loadJson(url) {\n        const jsonPromise = fetch(url).then((data => data.json()));\n        return jsonPromise.then((json => ({\n            data: json,\n            state: \"success\"\n        }))).catch((() => ({\n            data: null,\n            state: \"fail\"\n        }))), jsonPromise;\n    }\n    loadArrayBuffer(url) {\n        return fetch(url).then((data => data.arrayBuffer())).then((arrayBuffer => ({\n            data: arrayBuffer,\n            loadState: \"success\"\n        }))).catch((() => ({\n            data: null,\n            loadState: \"fail\"\n        })));\n    }\n    loadBlob(url) {\n        return fetch(url).then((data => data.blob())).then((blob => ({\n            data: blob,\n            loadState: \"success\"\n        }))).catch((() => ({\n            data: null,\n            loadState: \"fail\"\n        })));\n    }\n};\n\nBaseEnvContribution = __decorate([ (0, inversify_1.injectable)() ], BaseEnvContribution), \nexports.BaseEnvContribution = BaseEnvContribution;\n//# sourceMappingURL=base-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.FeishuEnvContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), kits_1 = require(\"../../../kits\"), base_contribution_1 = require(\"./base-contribution\");\n\nfunction makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList) {\n    const dpr = tt.getSystemInfoSync().pixelRatio;\n    canvasIdLists.forEach(((id, i) => {\n        const ctx = tt.createCanvasContext(id);\n        ctx.canvas = {\n            width: domref.width * dpr,\n            height: domref.height * dpr\n        };\n        const canvas = {\n            width: domref.width,\n            height: domref.height,\n            offsetWidth: domref.width,\n            offsetHeight: domref.height,\n            id: null != id ? id : \"\",\n            getContext: () => ctx,\n            getBoundingClientRect: () => ({\n                height: domref.height,\n                width: domref.width\n            })\n        };\n        canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas);\n    }));\n}\n\nlet FeishuEnvContribution = class extends base_contribution_1.BaseEnvContribution {\n    constructor() {\n        super(), this.type = \"feishu\", this.supportEvent = !0, this.canvasMap = new Map, \n        this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = !0;\n        try {\n            this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;\n        } catch (err) {\n            this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;\n        }\n        this.applyStyles = !0;\n    }\n    configure(service, params) {\n        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList), \n        (0, kits_1.loadFeishuContributions)());\n    }\n    loadImage(url) {\n        return Promise.resolve({\n            data: url,\n            loadState: \"success\"\n        });\n    }\n    loadSvg(url) {\n        return Promise.reject();\n    }\n    createCanvas(params) {\n        const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];\n        return this.canvasIdx++, result;\n    }\n    createOffscreenCanvas(params) {}\n    releaseCanvas(canvas) {}\n    getDevicePixelRatio() {\n        return tt.getSystemInfoSync().pixelRatio;\n    }\n    getRequestAnimationFrame() {\n        return function(callback) {\n            return setTimeout(callback, 1e3 / 60, !0);\n        };\n    }\n    getCancelAnimationFrame() {\n        return h => {\n            clearTimeout(h);\n        };\n    }\n    addEventListener(type, listener, options) {\n        return null;\n    }\n    removeEventListener(type, listener, options) {\n        return null;\n    }\n    dispatchEvent(event) {\n        return null;\n    }\n    getElementById(str) {\n        return this.canvasMap.get(str);\n    }\n    getRootElement() {\n        return null;\n    }\n    getDocument() {\n        return null;\n    }\n    release(...params) {}\n    mapToCanvasPoint(event) {\n        var _a;\n        return (null === (_a = null == event ? void 0 : event.type) || void 0 === _a ? void 0 : _a.startsWith(\"mouse\")) ? event : null;\n    }\n};\n\nFeishuEnvContribution = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", []) ], FeishuEnvContribution), \nexports.FeishuEnvContribution = FeishuEnvContribution;\n//# sourceMappingURL=feishu-contribution.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./env\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.loadTaroContributions = exports.loadFeishuContributions = void 0;\n\nconst container_1 = require(\"../container\"), picker_1 = require(\"../picker\");\n\nfunction loadFeishuContributions() {\n    container_1.container.rebind(picker_1.PickerService).toService(picker_1.DefaultMathPickerService);\n}\n\nfunction loadTaroContributions() {\n    container_1.container.rebind(picker_1.PickerService).toService(picker_1.DefaultMathPickerService);\n}\n\nexports.loadFeishuContributions = loadFeishuContributions, exports.loadTaroContributions = loadTaroContributions;\n//# sourceMappingURL=env.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./picker-service\"), exports), __exportStar(require(\"./canvas-picker-service\"), exports), \n__exportStar(require(\"./math-picker-service\"), exports), __exportStar(require(\"./global-picker-service\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.TaroEnvContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), kits_1 = require(\"../../../kits\"), base_contribution_1 = require(\"./base-contribution\");\n\nfunction makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, taro, dpr) {\n    canvasIdLists.forEach(((id, i) => {\n        const ctx = taro.createCanvasContext(id);\n        ctx.canvas = {\n            width: domref.width * dpr,\n            height: domref.height * dpr\n        }, ctx.createRadialGradient || (ctx.createRadialGradient = (...cc) => ctx.createCircularGradient(...cc)), \n        !ctx.getImageData && taro.canvasGetImageData && (ctx.getImageData = (x, y, width, height) => new Promise(((resolve, reject) => {\n            try {\n                taro.canvasGetImageData({\n                    canvasId: id,\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height,\n                    success(res) {\n                        resolve(res);\n                    }\n                });\n            } catch (err) {\n                reject(err);\n            }\n        })));\n        const canvas = {\n            id: id,\n            width: domref.width,\n            height: domref.height,\n            offsetWidth: domref.width,\n            offsetHeight: domref.height,\n            getContext: () => ctx,\n            getBoundingClientRect: () => ({\n                height: domref.height,\n                width: domref.width\n            })\n        };\n        return canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), \n        canvas;\n    }));\n}\n\nlet TaroEnvContribution = class extends base_contribution_1.BaseEnvContribution {\n    constructor() {\n        super(), this.type = \"taro\", this.supportEvent = !0, this.canvasMap = new Map, this.freeCanvasList = [], \n        this.canvasIdx = 0, this.supportsTouchEvents = !0;\n        try {\n            this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;\n        } catch (err) {\n            this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;\n        }\n        this.applyStyles = !0;\n    }\n    configure(service, params) {\n        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.taro, params.pixelRatio), \n        this.taro = params.taro, this.pixelRatio = params.pixelRatio, (0, kits_1.loadTaroContributions)());\n    }\n    loadImage(url) {\n        return Promise.resolve({\n            data: url,\n            loadState: \"success\"\n        });\n    }\n    loadSvg(svgStr) {\n        const _window = window || globalThis;\n        if (_window.DOMParser) {\n            const svg = (new _window.DOMParser).parseFromString(svgStr, \"image/svg+xml\").children[0], data = (new XMLSerializer).serializeToString(svg), url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;\n            return Promise.resolve({\n                data: url,\n                loadState: \"success\"\n            });\n        }\n        if (_window.Blob) {\n            const data = new _window.Blob([ svgStr ], {\n                type: \"image/svg+xml\"\n            }), url = _window.URL.createObjectURL(data);\n            return Promise.resolve({\n                data: url,\n                loadState: \"success\"\n            });\n        }\n        return Promise.reject();\n    }\n    createCanvas(params) {\n        const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];\n        return this.canvasIdx++, result;\n    }\n    createOffscreenCanvas(params) {}\n    releaseCanvas(canvas) {}\n    getDevicePixelRatio() {\n        return this.pixelRatio;\n    }\n    getRequestAnimationFrame() {\n        return requestAnimationFrame;\n    }\n    getCancelAnimationFrame() {\n        return cancelAnimationFrame;\n    }\n    addEventListener(type, listener, options) {\n        return null;\n    }\n    removeEventListener(type, listener, options) {\n        return null;\n    }\n    dispatchEvent(event) {\n        return null;\n    }\n    getElementById(str) {\n        return this.canvasMap.get(str);\n    }\n    getRootElement() {\n        return null;\n    }\n    getDocument() {\n        return null;\n    }\n    release(...params) {}\n};\n\nTaroEnvContribution = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", []) ], TaroEnvContribution), \nexports.TaroEnvContribution = TaroEnvContribution;\n//# sourceMappingURL=taro-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.LynxEnvContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), kits_1 = require(\"../../../kits\"), base_contribution_1 = require(\"./base-contribution\");\n\nfunction makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList) {\n    SystemInfo.pixelRatio;\n    canvasIdLists.forEach(((id, i) => {\n        const ctx = lynx.createCanvas(id).getContext(\"2d\");\n        ctx.draw = (a, b) => {\n            b();\n        };\n        const canvas = {\n            width: domref.width,\n            height: domref.height,\n            offsetWidth: domref.width,\n            offsetHeight: domref.height,\n            id: null != id ? id : \"\",\n            getContext: () => ctx,\n            getBoundingClientRect: () => ({\n                height: domref.height,\n                width: domref.width\n            })\n        };\n        canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas);\n    }));\n}\n\nlet LynxEnvContribution = class extends base_contribution_1.BaseEnvContribution {\n    constructor() {\n        super(), this.type = \"lynx\", this.supportEvent = !0, this.canvasMap = new Map, this.freeCanvasList = [], \n        this.canvasIdx = 0, this.supportsTouchEvents = !0;\n        try {\n            this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;\n        } catch (err) {\n            this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;\n        }\n        this.applyStyles = !0;\n    }\n    configure(service, params) {\n        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList), \n        (0, kits_1.loadFeishuContributions)());\n    }\n    loadImage(url) {\n        return Promise.resolve({\n            data: url,\n            loadState: \"success\"\n        });\n    }\n    loadSvg(url) {\n        return Promise.reject();\n    }\n    createCanvas(params) {\n        const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];\n        return this.canvasIdx++, result;\n    }\n    createOffscreenCanvas(params) {}\n    releaseCanvas(canvas) {}\n    getDevicePixelRatio() {\n        return SystemInfo.pixelRatio;\n    }\n    getRequestAnimationFrame() {\n        return function(callback) {\n            return setTimeout(callback, 1e3 / 60, !0);\n        };\n    }\n    getCancelAnimationFrame() {\n        return h => {\n            clearTimeout(h);\n        };\n    }\n    addEventListener(type, listener, options) {\n        return null;\n    }\n    removeEventListener(type, listener, options) {\n        return null;\n    }\n    dispatchEvent(event) {\n        return null;\n    }\n    getElementById(str) {\n        return this.canvasMap.get(str);\n    }\n    getRootElement() {\n        return null;\n    }\n    getDocument() {\n        return null;\n    }\n    release(...params) {}\n};\n\nLynxEnvContribution = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", []) ], LynxEnvContribution), \nexports.LynxEnvContribution = LynxEnvContribution;\n//# sourceMappingURL=lynx-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.NodeEnvContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), base_contribution_1 = require(\"./base-contribution\");\n\nlet NodeEnvContribution = class extends base_contribution_1.BaseEnvContribution {\n    constructor() {\n        super(...arguments), this.type = \"node\", this._lastTime = 0, this.supportEvent = !1;\n    }\n    configure(service, pkg) {\n        service.env === this.type && (service.setActiveEnvContribution(this), this.pkg = pkg);\n    }\n    loadJson(url) {\n        const jsonPromise = fetch(url).then((data => data.json()));\n        return jsonPromise.then((json => ({\n            data: json,\n            state: \"success\"\n        }))).catch((() => ({\n            data: null,\n            state: \"fail\"\n        }))), jsonPromise;\n    }\n    loadArrayBuffer(url) {\n        return fetch(url).then((data => data.arrayBuffer())).then((arrayBuffer => ({\n            data: arrayBuffer,\n            loadState: \"success\"\n        }))).catch((() => ({\n            data: null,\n            loadState: \"fail\"\n        })));\n    }\n    loadImage(url) {\n        const {loadImage: loadImage} = this.pkg;\n        return loadImage ? loadImage(url).then((image => ({\n            loadState: image ? \"success\" : \"fail\",\n            data: image\n        }))).catch((() => ({\n            loadState: \"fail\",\n            data: null\n        }))) : Promise.reject(new Error(\"node-canvas loadImage could not be found!\"));\n    }\n    loadSvg(svgStr) {\n        const Resvg = this.pkg.Resvg;\n        if (!Resvg) return Promise.reject(new Error(\"@resvg/resvg-js svgParser could not be found!\"));\n        const pngData = new Resvg(svgStr).render().asPng();\n        return this.loadImage(pngData);\n    }\n    createCanvas(params) {\n        return this.pkg.createCanvas(params.width, params.height);\n    }\n    releaseCanvas(canvas) {}\n    getDevicePixelRatio() {\n        return 1;\n    }\n    getRequestAnimationFrame() {\n        return function(callback) {\n            return setTimeout(callback, 1e3 / 60, !0);\n        };\n    }\n    getCancelAnimationFrame() {\n        return h => {\n            clearTimeout(h);\n        };\n    }\n    addEventListener(type, listener, options) {}\n    removeEventListener(type, listener, options) {}\n    getElementById(str) {\n        return null;\n    }\n    getRootElement() {\n        return null;\n    }\n    dispatchEvent(event) {}\n    release(...params) {}\n    createOffscreenCanvas(params) {}\n};\n\nNodeEnvContribution = __decorate([ (0, inversify_1.injectable)() ], NodeEnvContribution), \nexports.NodeEnvContribution = NodeEnvContribution;\n//# sourceMappingURL=node-contribution.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), window_1 = require(\"../../window\"), browser_contribution_1 = require(\"./browser-contribution\"), feishu_contribution_1 = require(\"./feishu-contribution\"), taro_contribution_1 = require(\"./taro-contribution\"), lynx_contribution_1 = require(\"./lynx-contribution\"), node_contribution_1 = require(\"./node-contribution\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(browser_contribution_1.BrowserWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(browser_contribution_1.BrowserWindowHandlerContribution))).whenTargetNamed(browser_contribution_1.BrowserWindowHandlerContribution.env), \n    bind(feishu_contribution_1.FeishuWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(feishu_contribution_1.FeishuWindowHandlerContribution))).whenTargetNamed(feishu_contribution_1.FeishuWindowHandlerContribution.env), \n    bind(taro_contribution_1.TaroWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(taro_contribution_1.TaroWindowHandlerContribution))).whenTargetNamed(taro_contribution_1.TaroWindowHandlerContribution.env), \n    bind(lynx_contribution_1.LynxWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(lynx_contribution_1.LynxWindowHandlerContribution))).whenTargetNamed(lynx_contribution_1.LynxWindowHandlerContribution.env), \n    bind(node_contribution_1.NodeWindowHandlerContribution).toSelf(), bind(window_1.WindowHandlerContribution).toDynamicValue((ctx => ctx.container.get(node_contribution_1.NodeWindowHandlerContribution))).whenTargetNamed(node_contribution_1.NodeWindowHandlerContribution.env);\n}));\n//# sourceMappingURL=modules.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BrowserWindowHandlerContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), browser_1 = require(\"../../../canvas/contributions/browser\"), generator_1 = require(\"../../../common/generator\"), base_contribution_1 = require(\"./base-contribution\"), constants_1 = require(\"../../../constants\");\n\nlet BrowserWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {\n    get container() {\n        return this.canvas.nativeCanvas.parentElement;\n    }\n    constructor(global) {\n        super(), this.global = global, this.type = \"browser\";\n    }\n    getTitle() {\n        return this.canvas.id.toString();\n    }\n    getWH() {\n        return {\n            width: this.canvas.width / (this.canvas.dpr || 1),\n            height: this.canvas.height / (this.canvas.dpr || 1)\n        };\n    }\n    getXY() {\n        return this.canvas.nativeCanvas.getBoundingClientRect();\n    }\n    createWindow(params) {\n        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);\n    }\n    createWindowByConfig(params) {\n        const nativeCanvas = this.global.createCanvas({\n            width: params.width,\n            height: params.height\n        });\n        let container;\n        if (container = \"string\" == typeof params.container ? this.global.getElementById(params.container) : params.container ? params.container : this.global.getRootElement(), \n        !container) throw new Error(\"containerId\");\n        params.offscreen ? container = null : container.appendChild(nativeCanvas);\n        const options = {\n            width: params.width,\n            height: params.height,\n            dpr: params.dpr,\n            nativeCanvas: nativeCanvas,\n            container: container,\n            id: generator_1.Generator.GenAutoIncrementId().toString(),\n            canvasControled: !0\n        };\n        this.canvas = new browser_1.BrowserCanvas(options);\n    }\n    createWindowByCanvas(params) {\n        var _a;\n        let canvas;\n        if (\"string\" == typeof params.canvas) {\n            if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error(\"canvasId canvasdom\");\n        } else canvas = params.canvas;\n        if (!canvas) throw new Error(\"canvas\");\n        let width = params.width, height = params.height;\n        if (null == width || null == height || !params.canvasControled) {\n            const data = canvas.getBoundingClientRect();\n            width = data.width, height = data.height;\n        }\n        let dpr = params.dpr;\n        if (!1 === params.canvasControled && (dpr && console.warn(\"canvasControledfalsedpr\"), \n        dpr = null), null == dpr) {\n            dpr = null !== (_a = canvas.getContext(\"2d\").pixelRatio) && void 0 !== _a ? _a : canvas.width / width;\n        }\n        this.canvas = new browser_1.BrowserCanvas({\n            width: width,\n            height: height,\n            dpr: dpr,\n            nativeCanvas: canvas,\n            canvasControled: params.canvasControled\n        });\n    }\n    releaseWindow() {\n        this.canvas.release();\n    }\n    resizeWindow(width, height) {\n        this.canvas.resize(width, height);\n    }\n    setDpr(dpr) {\n        this.canvas.dpr = dpr;\n    }\n    getContext() {\n        return this.canvas.getContext();\n    }\n    getNativeHandler() {\n        return this.canvas;\n    }\n    getDpr() {\n        return this.canvas.dpr;\n    }\n    addEventListener(type, listener, options) {\n        return this.canvas.nativeCanvas.addEventListener(type, listener, options);\n    }\n    removeEventListener(type, listener, options) {\n        return this.canvas.nativeCanvas.removeEventListener(type, listener, options);\n    }\n    dispatchEvent(event) {\n        return this.canvas.nativeCanvas.dispatchEvent(event);\n    }\n    getStyle() {\n        return this.canvas.nativeCanvas.style;\n    }\n    setStyle(style) {\n        this.canvas.nativeCanvas.style = style;\n    }\n    getBoundingClientRect() {\n        const c = this.canvas.nativeCanvas, wh = this.getWH();\n        return c.parentElement ? this.canvas.nativeCanvas.getBoundingClientRect() : {\n            x: 0,\n            y: 0,\n            width: wh.width,\n            height: wh.height,\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n    }\n    clearViewBox(vb, color) {\n        const context = this.getContext(), dpr = this.getDpr();\n        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), \n        context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, \n        context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();\n    }\n};\n\nBrowserWindowHandlerContribution.env = \"browser\", BrowserWindowHandlerContribution = __decorate([ (0, \ninversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], BrowserWindowHandlerContribution), \nexports.BrowserWindowHandlerContribution = BrowserWindowHandlerContribution;\n//# sourceMappingURL=browser-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BaseWindowHandlerContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), generator_1 = require(\"../../../common/generator\");\n\nlet BaseWindowHandlerContribution = class {\n    constructor() {\n        this._uid = generator_1.Generator.GenAutoIncrementId();\n    }\n    onChange(cb) {\n        this._onChangeCb = cb;\n    }\n    configure(window, global) {\n        global.env === this.type && window.setWindowHandler(this);\n    }\n    release(...params) {\n        this.releaseWindow();\n    }\n};\n\nBaseWindowHandlerContribution = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", []) ], BaseWindowHandlerContribution), \nexports.BaseWindowHandlerContribution = BaseWindowHandlerContribution;\n//# sourceMappingURL=base-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.FeishuWindowHandlerContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), feishu_1 = require(\"../../../canvas/contributions/feishu\"), generator_1 = require(\"../../../common/generator\"), base_contribution_1 = require(\"./base-contribution\"), constants_1 = require(\"../../../constants\");\n\nclass MiniAppEventManager {\n    constructor() {\n        this.cache = {};\n    }\n    addEventListener(type, func) {\n        type && func && (this.cache[type] = this.cache[type] || {\n            listener: []\n        }, this.cache[type].listener.push(func));\n    }\n    removeEventListener(type, func) {\n        if (!type || !func) return;\n        if (!this.cache[type]) return;\n        const index = this.cache[type].listener.findIndex((f => f === func));\n        index >= 0 && this.cache[type].listener.splice(index, 1);\n    }\n    cleanEvent() {\n        this.cache = {};\n    }\n}\n\nlet FeishuWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {\n    get container() {\n        return null;\n    }\n    constructor(global) {\n        super(), this.global = global, this.type = \"feishu\", this.eventManager = new MiniAppEventManager;\n    }\n    getTitle() {\n        return this.canvas.id.toString();\n    }\n    getWH() {\n        return {\n            width: this.canvas.width / (this.canvas.dpr || 1),\n            height: this.canvas.height / (this.canvas.dpr || 1)\n        };\n    }\n    getXY() {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    createWindow(params) {\n        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);\n    }\n    createWindowByConfig(params) {\n        const nativeCanvas = this.global.createCanvas({\n            width: params.width,\n            height: params.height\n        }), options = {\n            width: params.width,\n            height: params.height,\n            dpr: params.dpr,\n            nativeCanvas: nativeCanvas,\n            id: generator_1.Generator.GenAutoIncrementId().toString(),\n            canvasControled: !1\n        };\n        this.canvas = new feishu_1.FeishuCanvas(options);\n    }\n    createWindowByCanvas(params) {\n        let canvas;\n        if (\"string\" == typeof params.canvas) {\n            if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error(\"canvasId canvasdom\");\n        } else canvas = params.canvas;\n        let width = params.width, height = params.height;\n        if (null == width || null == height || !params.canvasControled) {\n            const data = canvas.getBoundingClientRect();\n            width = data.width, height = data.height;\n        }\n        let dpr = params.dpr;\n        null == dpr && (dpr = canvas.width / width), this.canvas = new feishu_1.FeishuCanvas({\n            width: width,\n            height: height,\n            dpr: dpr,\n            nativeCanvas: canvas,\n            canvasControled: params.canvasControled\n        });\n    }\n    releaseWindow() {}\n    resizeWindow(width, height) {}\n    setDpr(dpr) {\n        this.canvas.dpr = dpr;\n    }\n    getContext() {\n        return this.canvas.getContext();\n    }\n    getNativeHandler() {\n        return this.canvas;\n    }\n    getDpr() {\n        return this.canvas.dpr;\n    }\n    addEventListener(type, listener) {\n        this.eventManager.addEventListener(type, listener);\n    }\n    removeEventListener(type, listener) {\n        this.eventManager.removeEventListener(type, listener);\n    }\n    dispatchEvent(event) {\n        const {type: type} = event;\n        return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, \n        event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, \n        event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, \n        event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {}, \n        event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f => {\n            f(event);\n        })), !0);\n    }\n    getStyle() {\n        return {};\n    }\n    setStyle(style) {}\n    getBoundingClientRect() {\n        const wh = this.getWH();\n        return {\n            x: 0,\n            y: 0,\n            width: wh.width,\n            height: wh.height,\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n    }\n    clearViewBox(vb, color) {\n        const context = this.getContext(), dpr = this.getDpr();\n        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), \n        context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, \n        context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();\n    }\n};\n\nFeishuWindowHandlerContribution.env = \"feishu\", FeishuWindowHandlerContribution = __decorate([ (0, \ninversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], FeishuWindowHandlerContribution), \nexports.FeishuWindowHandlerContribution = FeishuWindowHandlerContribution;\n//# sourceMappingURL=feishu-contribution.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./canvas\"), exports), __exportStar(require(\"./context\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.FeishuCanvas = void 0;\n\nconst inversify_1 = require(\"inversify\"), context_1 = require(\"./context\"), DefaultConfig = {\n    WIDTH: 500,\n    HEIGHT: 500,\n    DPR: 1\n};\n\nlet FeishuCanvas = class {\n    get id() {\n        return this._id;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n    get nativeCanvas() {\n        return this._nativeCanvas;\n    }\n    get width() {\n        return this._pixelWidth;\n    }\n    set width(width) {\n        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);\n    }\n    get height() {\n        return this._pixelHeight;\n    }\n    set height(height) {\n        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);\n    }\n    get displayWidth() {\n        return this._displayWidth;\n    }\n    get displayHeight() {\n        return this._displayHeight;\n    }\n    getContext(str) {\n        return this._context;\n    }\n    get visiable() {\n        return this._visiable;\n    }\n    set visiable(visiable) {\n        this._visiable = visiable, visiable ? this.show() : this.hide();\n    }\n    get dpr() {\n        return this._dpr;\n    }\n    set dpr(dpr) {\n        this._dpr = dpr;\n    }\n    constructor(params) {\n        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, dpr: dpr = DefaultConfig.DPR} = params, {x: x, y: y} = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : {\n            x: 0,\n            y: 0\n        };\n        this._x = x, this._y = y, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, \n        this._visiable = !1 !== params.visiable, this._displayWidth = width, this._displayHeight = height, \n        this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._context = new context_1.FeishuContext2d(this, this._dpr), \n        this._id = nativeCanvas.id;\n    }\n    getNativeCanvas() {\n        return this._nativeCanvas;\n    }\n    resetStyle(params) {}\n    applyPosition() {}\n    hide() {}\n    show() {}\n    resize(width, height) {}\n    toDataURL(mimeType, quality) {\n        return \"\";\n    }\n    readPixels(x, y, w, h) {\n        throw new Error(\"\");\n    }\n    convertToBlob(options) {\n        throw new Error(\"\");\n    }\n    transferToImageBitmap() {\n        throw new Error(\"\");\n    }\n    release(...params) {}\n};\n\nFeishuCanvas.env = \"feishu\", FeishuCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", [ Object ]) ], FeishuCanvas), \nexports.FeishuCanvas = FeishuCanvas;\n//# sourceMappingURL=canvas.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.FeishuContext2d = void 0;\n\nconst inversify_1 = require(\"inversify\"), browser_1 = require(\"../browser\");\n\nlet FeishuContext2d = class extends browser_1.BrowserContext2d {\n    get globalAlpha() {\n        return this._globalAlpha;\n    }\n    set globalAlpha(ga) {\n        this.nativeContext.globalAlpha = ga, this._globalAlpha = ga;\n    }\n    getImageData(sx, sy, sw, sh) {\n        return new Promise(((resolve, reject) => {\n            var _a;\n            try {\n                tt.canvasGetImageData({\n                    canvasId: null !== (_a = this.canvas.nativeCanvas.id) && void 0 !== _a ? _a : this.canvas.id,\n                    x: sx,\n                    y: sy,\n                    width: sw,\n                    height: sh,\n                    success(res) {\n                        resolve(res);\n                    }\n                });\n            } catch (err) {\n                reject(err);\n            }\n        }));\n    }\n    draw() {\n        const _context = this.nativeContext;\n        this.drawPromise = new Promise((resolve => {\n            _context.draw(!0, (() => {\n                this.drawPromise = null, resolve(null);\n            }));\n        }));\n    }\n};\n\nFeishuContext2d.env = \"feishu\", FeishuContext2d = __decorate([ (0, inversify_1.injectable)() ], FeishuContext2d), \nexports.FeishuContext2d = FeishuContext2d;\n//# sourceMappingURL=context.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.TaroWindowHandlerContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), taro_1 = require(\"../../../canvas/contributions/taro\"), generator_1 = require(\"../../../common/generator\"), base_contribution_1 = require(\"./base-contribution\"), constants_1 = require(\"../../../constants\");\n\nclass MiniAppEventManager {\n    constructor() {\n        this.cache = {};\n    }\n    addEventListener(type, func) {\n        type && func && (this.cache[type] = this.cache[type] || {\n            listener: []\n        }, this.cache[type].listener.push(func));\n    }\n    removeEventListener(type, func) {\n        if (!type || !func) return;\n        if (!this.cache[type]) return;\n        const index = this.cache[type].listener.findIndex((f => f === func));\n        index >= 0 && this.cache[type].listener.splice(index, 1);\n    }\n    cleanEvent() {\n        this.cache = {};\n    }\n}\n\nlet TaroWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {\n    get container() {\n        return null;\n    }\n    constructor(global) {\n        super(), this.global = global, this.type = \"taro\", this.eventManager = new MiniAppEventManager;\n    }\n    getTitle() {\n        return this.canvas.id.toString();\n    }\n    getWH() {\n        return {\n            width: this.canvas.width / (this.canvas.dpr || 1),\n            height: this.canvas.height / (this.canvas.dpr || 1)\n        };\n    }\n    getXY() {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    createWindow(params) {\n        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);\n    }\n    createWindowByConfig(params) {\n        const nativeCanvas = this.global.createCanvas({\n            width: params.width,\n            height: params.height\n        }), options = {\n            width: params.width,\n            height: params.height,\n            dpr: params.dpr,\n            nativeCanvas: nativeCanvas,\n            id: generator_1.Generator.GenAutoIncrementId().toString(),\n            canvasControled: !1\n        };\n        this.canvas = new taro_1.TaroCanvas(options);\n    }\n    createWindowByCanvas(params) {\n        let canvas;\n        if (\"string\" == typeof params.canvas) {\n            if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error(\"canvasId canvasdom\");\n        } else canvas = params.canvas;\n        let width = params.width, height = params.height;\n        if (null == width || null == height || !params.canvasControled) {\n            const data = canvas.getBoundingClientRect();\n            width = data.width, height = data.height;\n        }\n        let dpr = params.dpr;\n        null == dpr && (dpr = canvas.width / width), this.canvas = new taro_1.TaroCanvas({\n            width: width,\n            height: height,\n            dpr: dpr,\n            nativeCanvas: canvas,\n            canvasControled: params.canvasControled\n        });\n    }\n    releaseWindow() {}\n    resizeWindow(width, height) {}\n    setDpr(dpr) {\n        this.canvas.dpr = dpr;\n    }\n    getContext() {\n        return this.canvas.getContext();\n    }\n    getNativeHandler() {\n        return this.canvas;\n    }\n    getDpr() {\n        return this.canvas.dpr;\n    }\n    addEventListener(type, listener) {\n        this.eventManager.addEventListener(type, listener);\n    }\n    removeEventListener(type, listener) {\n        this.eventManager.removeEventListener(type, listener);\n    }\n    dispatchEvent(event) {\n        const {type: type} = event;\n        return !!this.eventManager.cache[type] && (event.changedTouches.length > 0 && (event.changedTouches.forEach(((d, i) => {\n            event.changedTouches[i] = Object.assign(Object.assign({}, event.changedTouches[i]), {\n                offsetX: d.x,\n                offsetY: d.y\n            });\n        })), event.offsetX = event.changedTouches[0].offsetX, event.offsetY = event.changedTouches[0].offsetY), \n        event.touches.length > 0 && event.touches.forEach(((d, i) => {\n            event.touches[i] = Object.assign(Object.assign({}, event.touches[i]), {\n                offsetX: d.x,\n                offsetY: d.y\n            });\n        })), event.preventDefault = () => {}, event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f => {\n            f(event);\n        })), !0);\n    }\n    getStyle() {\n        return {};\n    }\n    setStyle(style) {}\n    getBoundingClientRect() {\n        const wh = this.getWH();\n        return {\n            x: 0,\n            y: 0,\n            width: wh.width,\n            height: wh.height,\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n    }\n    clearViewBox(vb, color) {\n        const context = this.getContext(), dpr = this.getDpr();\n        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), \n        context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, \n        context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();\n    }\n};\n\nTaroWindowHandlerContribution.env = \"taro\", TaroWindowHandlerContribution = __decorate([ (0, \ninversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], TaroWindowHandlerContribution), \nexports.TaroWindowHandlerContribution = TaroWindowHandlerContribution;\n//# sourceMappingURL=taro-contribution.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./canvas\"), exports), __exportStar(require(\"./context\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.TaroCanvas = void 0;\n\nconst inversify_1 = require(\"inversify\"), context_1 = require(\"./context\"), DefaultConfig = {\n    WIDTH: 500,\n    HEIGHT: 500,\n    DPR: 1\n};\n\nlet TaroCanvas = class {\n    get id() {\n        return this._id;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n    get nativeCanvas() {\n        return this._nativeCanvas;\n    }\n    get width() {\n        return this._pixelWidth;\n    }\n    set width(width) {\n        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);\n    }\n    get height() {\n        return this._pixelHeight;\n    }\n    set height(height) {\n        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);\n    }\n    get displayWidth() {\n        return this._displayWidth;\n    }\n    get displayHeight() {\n        return this._displayHeight;\n    }\n    getContext(str) {\n        return this._context;\n    }\n    get visiable() {\n        return this._visiable;\n    }\n    set visiable(visiable) {\n        this._visiable = visiable, visiable ? this.show() : this.hide();\n    }\n    get dpr() {\n        return this._dpr;\n    }\n    set dpr(dpr) {\n        this._dpr = dpr;\n    }\n    constructor(params) {\n        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, dpr: dpr = DefaultConfig.DPR} = params, {x: x, y: y} = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : {\n            x: 0,\n            y: 0\n        };\n        this._x = x, this._y = y, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, \n        this._visiable = !1 !== params.visiable, this._displayWidth = width, this._displayHeight = height, \n        this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._context = new context_1.TaroContext2d(this, this._dpr), \n        this._id = nativeCanvas.id;\n    }\n    getNativeCanvas() {\n        return this._nativeCanvas;\n    }\n    resetStyle(params) {}\n    applyPosition() {}\n    hide() {}\n    show() {}\n    resize(width, height) {}\n    toDataURL(mimeType, quality) {\n        return \"\";\n    }\n    readPixels(x, y, w, h) {\n        throw new Error(\"\");\n    }\n    convertToBlob(options) {\n        throw new Error(\"\");\n    }\n    transferToImageBitmap() {\n        throw new Error(\"\");\n    }\n    release(...params) {}\n};\n\nTaroCanvas.env = \"taro\", TaroCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", [ Object ]) ], TaroCanvas), \nexports.TaroCanvas = TaroCanvas;\n//# sourceMappingURL=canvas.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.TaroContext2d = void 0;\n\nconst inversify_1 = require(\"inversify\"), browser_1 = require(\"../browser\"), canvas_utils_1 = require(\"../../../common/canvas-utils\"), text_1 = require(\"../../../common/text\");\n\nlet TaroContext2d = class extends browser_1.BrowserContext2d {\n    get globalAlpha() {\n        return this._globalAlpha;\n    }\n    set globalAlpha(ga) {\n        this.nativeContext.setGlobalAlpha(ga), this._globalAlpha = ga;\n    }\n    draw() {\n        this.nativeContext.draw();\n    }\n    strokeText(text, x, y) {}\n    _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {\n        const _context = this.nativeContext;\n        defaultParams || (defaultParams = this.fillAttributes);\n        const {fillOpacity: fillOpacity = defaultParams.fillOpacity, opacity: opacity = defaultParams.opacity, fill: fill = defaultParams.fill} = attribute;\n        fillOpacity > 1e-12 && opacity > 1e-12 && (_context.setGlobalAlpha(fillOpacity * opacity), \n        _context.setFillStyle((0, canvas_utils_1.createColor)(this, fill, params, offsetX, offsetY)));\n    }\n    _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {\n        const _context = this.nativeContext;\n        defaultParams || (defaultParams = this.strokeAttributes);\n        const {strokeOpacity: strokeOpacity = defaultParams.strokeOpacity, opacity: opacity = defaultParams.opacity} = attribute;\n        if (strokeOpacity > 1e-12 && opacity > 1e-12) {\n            const {lineWidth: lineWidth = defaultParams.lineWidth, stroke: stroke = defaultParams.stroke, lineJoin: lineJoin = defaultParams.lineJoin, lineDash: lineDash = defaultParams.lineDash, lineCap: lineCap = defaultParams.lineCap, miterLimit: miterLimit = defaultParams.miterLimit} = attribute;\n            _context.setGlobalAlpha(strokeOpacity * opacity), _context.setLineWidth((0, canvas_utils_1.getScaledStroke)(this, lineWidth, this.dpr)), \n            _context.setStrokeStyle((0, canvas_utils_1.createColor)(this, stroke, params, offsetX, offsetY)), \n            _context.setLineJoin(lineJoin), _context.setLineDash(lineDash), _context.setLineCap(lineCap), \n            _context.setMiterLimit(miterLimit);\n        }\n    }\n    setTextStyleWithoutAlignBaseline(params, defaultParams) {\n        var _a;\n        const _context = this.nativeContext;\n        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = (0, \n        text_1.getContextFont)(params, defaultParams), _context.setFontSize(null !== (_a = params.fontSize) && void 0 !== _a ? _a : defaultParams.fontSize);\n    }\n    setTextStyle(params, defaultParams) {\n        var _a, _b;\n        const _context = this.nativeContext;\n        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = (0, \n        text_1.getContextFont)(params, defaultParams), _context.setTextAlign(null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign), \n        _context.setTextBaseline(null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline);\n    }\n    createConicGradient(x, y, startAngle, endAngle) {\n        return null;\n    }\n};\n\nTaroContext2d.env = \"taro\", TaroContext2d = __decorate([ (0, inversify_1.injectable)() ], TaroContext2d), \nexports.TaroContext2d = TaroContext2d;\n//# sourceMappingURL=context.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.LynxWindowHandlerContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), lynx_1 = require(\"../../../canvas/contributions/lynx\"), generator_1 = require(\"../../../common/generator\"), base_contribution_1 = require(\"./base-contribution\"), constants_1 = require(\"../../../constants\");\n\nclass MiniAppEventManager {\n    constructor() {\n        this.cache = {};\n    }\n    addEventListener(type, func) {\n        type && func && (this.cache[type] = this.cache[type] || {\n            listener: []\n        }, this.cache[type].listener.push(func));\n    }\n    removeEventListener(type, func) {\n        if (!type || !func) return;\n        if (!this.cache[type]) return;\n        const index = this.cache[type].listener.findIndex((f => f === func));\n        index >= 0 && this.cache[type].listener.splice(index, 1);\n    }\n    cleanEvent() {\n        this.cache = {};\n    }\n}\n\nlet LynxWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {\n    get container() {\n        return null;\n    }\n    constructor(global) {\n        super(), this.global = global, this.type = \"lynx\", this.eventManager = new MiniAppEventManager;\n    }\n    getTitle() {\n        return this.canvas.id.toString();\n    }\n    getWH() {\n        return {\n            width: this.canvas.width / (this.canvas.dpr || 1),\n            height: this.canvas.height / (this.canvas.dpr || 1)\n        };\n    }\n    getXY() {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    createWindow(params) {\n        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);\n    }\n    createWindowByConfig(params) {\n        const nativeCanvas = this.global.createCanvas({\n            width: params.width,\n            height: params.height\n        }), options = {\n            width: params.width,\n            height: params.height,\n            dpr: params.dpr,\n            nativeCanvas: nativeCanvas,\n            id: generator_1.Generator.GenAutoIncrementId().toString(),\n            canvasControled: !1\n        };\n        this.canvas = new lynx_1.LynxCanvas(options);\n    }\n    createWindowByCanvas(params) {\n        let canvas;\n        if (\"string\" == typeof params.canvas) {\n            if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error(\"canvasId canvasdom\");\n        } else canvas = params.canvas;\n        let width = params.width, height = params.height;\n        if (null == width || null == height || !params.canvasControled) {\n            const data = canvas.getBoundingClientRect();\n            width = data.width, height = data.height;\n        }\n        let dpr = params.dpr;\n        null == dpr && (dpr = canvas.width / width), this.canvas = new lynx_1.LynxCanvas({\n            width: width,\n            height: height,\n            dpr: dpr,\n            nativeCanvas: canvas,\n            canvasControled: params.canvasControled\n        });\n    }\n    releaseWindow() {}\n    resizeWindow(width, height) {}\n    setDpr(dpr) {\n        this.canvas.dpr = dpr;\n    }\n    getContext() {\n        return this.canvas.getContext();\n    }\n    getNativeHandler() {\n        return this.canvas;\n    }\n    getDpr() {\n        return this.canvas.dpr;\n    }\n    addEventListener(type, listener) {\n        this.eventManager.addEventListener(type, listener);\n    }\n    removeEventListener(type, listener) {\n        this.eventManager.removeEventListener(type, listener);\n    }\n    dispatchEvent(event) {\n        const {type: type} = event;\n        return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, \n        event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, \n        event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, \n        event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {}, \n        event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f => {\n            f(event);\n        })), !0);\n    }\n    getStyle() {\n        return {};\n    }\n    setStyle(style) {}\n    getBoundingClientRect() {\n        const wh = this.getWH();\n        return {\n            x: 0,\n            y: 0,\n            width: wh.width,\n            height: wh.height,\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n    }\n    clearViewBox(vb, color) {\n        const context = this.getContext(), dpr = this.getDpr();\n        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), \n        context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, \n        context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();\n    }\n};\n\nLynxWindowHandlerContribution.env = \"lynx\", LynxWindowHandlerContribution = __decorate([ (0, \ninversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], LynxWindowHandlerContribution), \nexports.LynxWindowHandlerContribution = LynxWindowHandlerContribution;\n//# sourceMappingURL=lynx-contribution.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./canvas\"), exports), __exportStar(require(\"./context\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.LynxCanvas = void 0;\n\nconst inversify_1 = require(\"inversify\"), context_1 = require(\"./context\"), DefaultConfig = {\n    WIDTH: 500,\n    HEIGHT: 500,\n    DPR: 1\n};\n\nlet LynxCanvas = class {\n    get id() {\n        return this._id;\n    }\n    get x() {\n        return this._x;\n    }\n    get y() {\n        return this._y;\n    }\n    get nativeCanvas() {\n        return this._nativeCanvas;\n    }\n    get width() {\n        return this._pixelWidth;\n    }\n    set width(width) {\n        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);\n    }\n    get height() {\n        return this._pixelHeight;\n    }\n    set height(height) {\n        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);\n    }\n    get displayWidth() {\n        return this._displayWidth;\n    }\n    get displayHeight() {\n        return this._displayHeight;\n    }\n    getContext(str) {\n        return this._context;\n    }\n    get visiable() {\n        return this._visiable;\n    }\n    set visiable(visiable) {\n        this._visiable = visiable, visiable ? this.show() : this.hide();\n    }\n    get dpr() {\n        return this._dpr;\n    }\n    set dpr(dpr) {\n        this._dpr = dpr;\n    }\n    constructor(params) {\n        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, dpr: dpr = DefaultConfig.DPR} = params, {x: x, y: y} = nativeCanvas.getBoundingClientRect ? nativeCanvas.getBoundingClientRect() : {\n            x: 0,\n            y: 0\n        };\n        this._x = x, this._y = y, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, \n        this._visiable = !1 !== params.visiable, this._displayWidth = width, this._displayHeight = height, \n        this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._context = new context_1.LynxContext2d(this, this._dpr), \n        this._id = nativeCanvas.id;\n    }\n    getNativeCanvas() {\n        return this._nativeCanvas;\n    }\n    resetStyle(params) {}\n    applyPosition() {}\n    hide() {}\n    show() {}\n    resize(width, height) {}\n    toDataURL(mimeType, quality) {\n        return \"\";\n    }\n    readPixels(x, y, w, h) {\n        throw new Error(\"\");\n    }\n    convertToBlob(options) {\n        throw new Error(\"\");\n    }\n    transferToImageBitmap() {\n        throw new Error(\"\");\n    }\n    release(...params) {}\n};\n\nLynxCanvas.env = \"lynx\", LynxCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", [ Object ]) ], LynxCanvas), \nexports.LynxCanvas = LynxCanvas;\n//# sourceMappingURL=canvas.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.LynxContext2d = void 0;\n\nconst inversify_1 = require(\"inversify\"), browser_1 = require(\"../browser\");\n\nlet LynxContext2d = class extends browser_1.BrowserContext2d {\n    get globalAlpha() {\n        return this._globalAlpha;\n    }\n    set globalAlpha(ga) {\n        this.nativeContext.globalAlpha = ga, this._globalAlpha = ga;\n    }\n    setLineDash(segments) {\n        const a = arguments, _context = this.nativeContext;\n        if (this.nativeContext.setLineDash) {\n            const lineDash = a[0];\n            if (0 === lineDash[0] && 0 === lineDash[1]) return;\n            _context.setLineDash(lineDash);\n        }\n    }\n    draw() {\n        const _context = this.nativeContext;\n        this.drawPromise = new Promise((resolve => {\n            _context.draw(!0, (() => {\n                this.drawPromise = null, resolve(null);\n            }));\n        }));\n    }\n};\n\nLynxContext2d.env = \"lynx\", LynxContext2d = __decorate([ (0, inversify_1.injectable)() ], LynxContext2d), \nexports.LynxContext2d = LynxContext2d;\n//# sourceMappingURL=context.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.NodeWindowHandlerContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), node_1 = require(\"../../../canvas/contributions/node\"), generator_1 = require(\"../../../common/generator\"), base_contribution_1 = require(\"./base-contribution\"), constants_1 = require(\"../../../constants\");\n\nlet NodeWindowHandlerContribution = class extends base_contribution_1.BaseWindowHandlerContribution {\n    get container() {\n        return null;\n    }\n    constructor(global) {\n        super(), this.global = global, this.type = \"node\";\n    }\n    getTitle() {\n        return \"\";\n    }\n    getWH() {\n        return {\n            width: this.canvas.displayWidth,\n            height: this.canvas.displayHeight\n        };\n    }\n    getXY() {\n        return {\n            x: 0,\n            y: 0\n        };\n    }\n    createWindow(params) {\n        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);\n    }\n    createWindowByConfig(params) {\n        const nativeCanvas = this.global.createCanvas({\n            width: params.width,\n            height: params.height\n        }), options = {\n            width: params.width,\n            height: params.height,\n            dpr: params.dpr,\n            nativeCanvas: nativeCanvas,\n            id: generator_1.Generator.GenAutoIncrementId().toString(),\n            canvasControled: !0\n        };\n        this.canvas = new node_1.NodeCanvas(options);\n    }\n    createWindowByCanvas(params) {\n        const canvas = params.canvas;\n        let width = params.width, height = params.height;\n        null != width && null != height && params.canvasControled || (width = canvas.width, \n        height = canvas.height), this.canvas = new node_1.NodeCanvas({\n            width: width,\n            height: height,\n            dpr: 1,\n            nativeCanvas: canvas,\n            canvasControled: params.canvasControled\n        });\n    }\n    releaseWindow() {\n        this.canvas.release();\n    }\n    resizeWindow(width, height) {\n        this.canvas.resize(width, height);\n    }\n    setDpr(dpr) {\n        this.canvas.dpr = dpr;\n    }\n    getContext() {\n        return this.canvas.getContext();\n    }\n    getNativeHandler() {\n        return this.canvas;\n    }\n    getDpr() {\n        return this.canvas.dpr;\n    }\n    getImageBuffer(type = \"image/png\") {\n        return this.canvas.nativeCanvas.toBuffer(type);\n    }\n    addEventListener(type, listener, options) {}\n    dispatchEvent(event) {\n        return !0;\n    }\n    removeEventListener(type, listener, options) {}\n    getStyle() {}\n    setStyle(style) {}\n    getBoundingClientRect() {\n        return null;\n    }\n    clearViewBox(vb, color) {}\n};\n\nNodeWindowHandlerContribution.env = \"node\", NodeWindowHandlerContribution = __decorate([ (0, \ninversify_1.injectable)(), __param(0, (0, inversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], NodeWindowHandlerContribution), \nexports.NodeWindowHandlerContribution = NodeWindowHandlerContribution;\n//# sourceMappingURL=node-contribution.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./canvas\"), exports), __exportStar(require(\"./context\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.NodeCanvas = void 0;\n\nconst inversify_1 = require(\"inversify\"), context_1 = require(\"./context\"), vutils_1 = require(\"@visactor/vutils\"), DefaultConfig = {\n    WIDTH: 500,\n    HEIGHT: 500,\n    DPR: 1\n};\n\nlet NodeCanvas = class {\n    get id() {\n        return this._id;\n    }\n    get x() {\n        return 0;\n    }\n    get y() {\n        return 0;\n    }\n    get nativeCanvas() {\n        return this._nativeCanvas;\n    }\n    get width() {\n        return this._pixelWidth;\n    }\n    set width(width) {\n        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);\n    }\n    get displayWidth() {\n        return this._pixelWidth / this._dpr;\n    }\n    get displayHeight() {\n        return this._pixelHeight / this._dpr;\n    }\n    get height() {\n        return this._pixelHeight;\n    }\n    set height(height) {\n        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);\n    }\n    getContext(str) {\n        return this._context;\n    }\n    get visiable() {\n        return this._visiable;\n    }\n    set visiable(visiable) {\n        this._visiable = visiable, visiable ? this.show() : this.hide();\n    }\n    get dpr() {\n        return this._dpr;\n    }\n    set dpr(dpr) {\n        this._dpr = dpr, this.resize(this.width, this.height);\n    }\n    constructor(params) {\n        const {nativeCanvas: nativeCanvas, width: width = DefaultConfig.WIDTH, height: height = DefaultConfig.HEIGHT, canvasControled: canvasControled = !0, dpr: dpr = DefaultConfig.DPR} = params;\n        this._visiable = !1 !== params.visiable, this.controled = canvasControled, this._pixelWidth = width * dpr, \n        this._pixelHeight = height * dpr, this._displayWidth = width, this._displayHeight = height, \n        this._nativeCanvas = nativeCanvas, this._context = new context_1.NodeContext2d(this, params.dpr), \n        this._id = nativeCanvas.id, this._dpr = dpr;\n    }\n    applyPosition() {}\n    getNativeCanvas() {\n        return this._nativeCanvas;\n    }\n    resetStyle(params) {}\n    hide() {}\n    show() {}\n    resize(width, height) {\n        this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, \n        this._displayHeight = height, this._nativeCanvas && (this._nativeCanvas.width = this._pixelWidth, \n        this._nativeCanvas.height = this._pixelHeight);\n    }\n    toDataURL(mimeType, quality) {\n        return \"\";\n    }\n    readPixels(x, y, w, h) {\n        return this._context.getImageData(x, y, w, h);\n    }\n    convertToBlob(options) {\n        throw new Error(\"\");\n    }\n    transferToImageBitmap() {\n        throw new Error(\"\");\n    }\n    release(...params) {\n        this._nativeCanvas.release && (0, vutils_1.isFunction)(this._nativeCanvas.release) && this._nativeCanvas.release();\n    }\n};\n\nNodeCanvas.env = \"node\", NodeCanvas = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", [ Object ]) ], NodeCanvas), \nexports.NodeCanvas = NodeCanvas;\n//# sourceMappingURL=canvas.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.NodeContext2d = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), browser_1 = require(\"../browser\"), initMatrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0);\n\nlet NodeContext2d = class extends browser_1.BrowserContext2d {\n    constructor(canvas, dpr) {\n        super(canvas, dpr);\n        const context = canvas.nativeCanvas.getContext(\"2d\");\n        if (!context) throw new Error(\"2d\");\n        this.nativeContext = context, this.canvas = canvas, this.matrix = new vutils_1.Matrix(1, 0, 0, 1, 0, 0), \n        this.stack = [], this.dpr = null != dpr ? dpr : 1;\n    }\n    release(...params) {}\n};\n\nNodeContext2d.env = \"node\", NodeContext2d = __decorate([ (0, inversify_1.injectable)(), __metadata(\"design:paramtypes\", [ Object, Number ]) ], NodeContext2d), \nexports.NodeContext2d = NodeContext2d;\n//# sourceMappingURL=context.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), textMeasure_contribution_1 = require(\"./textMeasure-contribution\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(textMeasure_contribution_1.DefaultTextMeasureContribution).toSelf().inSingletonScope(), \n    bind(textMeasure_contribution_1.TextMeasureContribution).toService(textMeasure_contribution_1.DefaultTextMeasureContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, textMeasure_contribution_1.TextMeasureContribution);\n}));\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), layer_1 = require(\"../../layer\"), canvas2d_contribution_1 = require(\"./canvas2d-contribution\"), offscreen2d_contribution_1 = require(\"./offscreen2d-contribution\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(canvas2d_contribution_1.CanvasLayerHandlerContribution).toSelf(), bind(offscreen2d_contribution_1.OffscreenLayerHandlerContribution).toSelf(), \n    bind(layer_1.LayerHandlerContribution).toService(canvas2d_contribution_1.CanvasLayerHandlerContribution);\n}));\n//# sourceMappingURL=modules.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CanvasLayerHandlerContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), util_1 = require(\"../../../canvas/util\"), constants_1 = require(\"../../../constants\");\n\nlet CanvasLayerHandlerContribution = class {\n    constructor(global) {\n        this.global = global, this.offscreen = !1;\n    }\n    init(layer, window, params) {\n        if (this.layer = layer, params.main) this.context = window.getContext(), this.canvas = this.context.getCanvas(); else {\n            let nativeCanvas;\n            nativeCanvas = params.canvasId ? this.global.getElementById(params.canvasId) : this.global.createCanvas({\n                width: window.width,\n                height: window.height\n            });\n            const windowCanvas = window.getContext().getCanvas().nativeCanvas, canvas = (0, \n            util_1.wrapCanvas)({\n                nativeCanvas: nativeCanvas,\n                width: window.width,\n                height: window.height,\n                dpr: window.dpr,\n                canvasControled: !0,\n                container: window.getContainer(),\n                x: windowCanvas.offsetLeft,\n                y: windowCanvas.offsetTop\n            });\n            canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();\n        }\n    }\n    resize(w, h) {\n        this.canvas.resize(w, h);\n    }\n    resizeView(w, h) {}\n    render(group, params, userParams) {\n        var _a;\n        params.renderService.render(group, Object.assign(Object.assign({\n            context: this.context,\n            clear: null !== (_a = params.background) && void 0 !== _a ? _a : \"#ffffff\"\n        }, params), userParams));\n    }\n    merge(layerHandlers) {\n        layerHandlers.forEach((l => {\n            const canvas = l.getContext().canvas.nativeCanvas;\n            this.context.drawImage(canvas, 0, 0);\n        }));\n    }\n    prepare(dirtyBounds, params) {}\n    drawTo(target, group, params) {\n        var _a;\n        const context = target.getContext();\n        params.renderService.render(group, Object.assign(Object.assign({\n            context: context\n        }, params), {\n            clear: params.clear ? null !== (_a = params.background) && void 0 !== _a ? _a : \"#fff\" : void 0\n        }));\n    }\n    getContext() {\n        return this.context;\n    }\n    release() {\n        this.canvas.release();\n    }\n};\n\nCanvasLayerHandlerContribution = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], CanvasLayerHandlerContribution), \nexports.CanvasLayerHandlerContribution = CanvasLayerHandlerContribution;\n//# sourceMappingURL=canvas2d-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.OffscreenLayerHandlerContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), util_1 = require(\"../../../canvas/util\"), constants_1 = require(\"../../../constants\");\n\nlet OffscreenLayerHandlerContribution = class {\n    constructor(global) {\n        this.global = global, this.offscreen = !0;\n    }\n    init(layer, window, params) {\n        this.layer = layer;\n        const nativeCanvas = this.global.createOffscreenCanvas({\n            width: params.width,\n            height: params.height,\n            dpr: window.dpr\n        }), canvas = (0, util_1.wrapCanvas)({\n            nativeCanvas: nativeCanvas,\n            width: params.width,\n            height: params.height,\n            dpr: window.dpr,\n            canvasControled: !0\n        });\n        this.canvas = canvas, this.context = canvas.getContext();\n    }\n    resize(w, h) {\n        this.canvas.resize(w, h);\n    }\n    resizeView(w, h) {\n        this.canvas.resize(w, h);\n    }\n    render(group, params) {\n        var _a;\n        params.renderService.render(group, Object.assign(Object.assign({\n            context: this.context\n        }, params), {\n            x: 0,\n            y: 0,\n            clear: null !== (_a = params.background) && void 0 !== _a ? _a : \"#ffffff\"\n        }));\n    }\n    prepare(dirtyBounds, params) {}\n    release() {\n        this.canvas.release();\n    }\n    getContext() {\n        return this.context;\n    }\n    drawTo(target, group, params) {\n        const context = target.getContext(), targetDpr = target.dpr, {x: x = 0, y: y = 0, width: width = this.layer.viewWidth, height: height = this.layer.viewHeight} = params;\n        context.nativeContext.save(), context.nativeContext.setTransform(targetDpr, 0, 0, targetDpr, 0, 0), \n        params.clear && context.clearRect(x, y, width, height), context.drawImage(this.canvas.nativeCanvas, 0, 0, this.canvas.width, this.canvas.height, x, y, width, height), \n        context.nativeContext.restore();\n    }\n    merge(layerHandlers) {}\n};\n\nOffscreenLayerHandlerContribution = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(constants_1.Global)), __metadata(\"design:paramtypes\", [ Object ]) ], OffscreenLayerHandlerContribution), \nexports.OffscreenLayerHandlerContribution = OffscreenLayerHandlerContribution;\n//# sourceMappingURL=offscreen2d-contribution.js.map\n","\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst module_1 = __importDefault(require(\"./render/module\"));\n\nfunction load(container) {\n    container.load(module_1.default);\n}\n\nexports.default = load;\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), circle_render_1 = require(\"./circle-render\"), rect_render_1 = require(\"./rect-render\"), arc_render_1 = require(\"./arc-render\"), draw_contribution_1 = require(\"./draw-contribution\"), render_slector_1 = require(\"./render-slector\"), symbol_render_1 = require(\"./symbol-render\"), text_render_1 = require(\"./text-render\"), path_render_1 = require(\"./path-render\"), line_render_1 = require(\"./line-render\"), area_render_1 = require(\"./area-render\"), group_render_1 = require(\"./group-render\"), polygon_render_1 = require(\"./polygon-render\"), image_render_1 = require(\"./image-render\"), incremental_draw_contribution_1 = require(\"./incremental-draw-contribution\"), symbol_1 = require(\"./symbol\"), draw_interceptor_1 = require(\"./draw-interceptor\"), rect3d_render_1 = require(\"./rect3d-render\"), incremental_line_render_1 = require(\"./incremental-line-render\"), incremental_area_render_1 = require(\"./incremental-area-render\"), richtext_render_1 = require(\"./richtext-render\"), rect_contribution_render_1 = require(\"./contributions/rect-contribution-render\"), symbol_contribution_render_1 = require(\"./contributions/symbol-contribution-render\"), circle_contribution_render_1 = require(\"./contributions/circle-contribution-render\"), arc_contribution_render_1 = require(\"./contributions/arc-contribution-render\"), glyph_render_1 = require(\"./glyph-render\"), image_contribution_render_1 = require(\"./contributions/image-contribution-render\"), group_contribution_render_1 = require(\"./contributions/group-contribution-render\"), arc3d_render_1 = require(\"./arc3d-render\"), pyramid3d_render_1 = require(\"./pyramid3d-render\"), polygon_contribution_render_1 = require(\"./contributions/polygon-contribution-render\"), path_contribution_render_1 = require(\"./contributions/path-contribution-render\"), area_contribution_render_1 = require(\"./contributions/area-contribution-render\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(draw_contribution_1.DefaultDrawContribution).toSelf(), bind(symbol_1.DrawContribution).toService(draw_contribution_1.DefaultDrawContribution), \n    bind(incremental_draw_contribution_1.DefaultIncrementalDrawContribution).toSelf(), \n    bind(symbol_1.IncrementalDrawContribution).toService(incremental_draw_contribution_1.DefaultIncrementalDrawContribution), \n    bind(render_slector_1.DefaultRenderSelector).toSelf(), bind(symbol_1.RenderSelector).toService(render_slector_1.DefaultRenderSelector), \n    bind(circle_render_1.DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(symbol_1.CircleRender).to(circle_render_1.DefaultCanvasCircleRender), \n    bind(symbol_1.GraphicRender).to(circle_render_1.DefaultCanvasCircleRender), bind(circle_contribution_render_1.DefaultCircleRenderContribution).toSelf().inSingletonScope(), \n    bind(circle_contribution_render_1.DefaultCircleBackgroundRenderContribution).toSelf().inSingletonScope(), \n    bind(circle_contribution_render_1.DefaultCircleTextureRenderContribution).toSelf().inSingletonScope(), \n    bind(circle_contribution_render_1.CircleRenderContribution).toService(circle_contribution_render_1.DefaultCircleRenderContribution), \n    bind(circle_contribution_render_1.CircleRenderContribution).toService(circle_contribution_render_1.DefaultCircleBackgroundRenderContribution), \n    bind(circle_contribution_render_1.CircleRenderContribution).toService(circle_contribution_render_1.DefaultCircleTextureRenderContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, circle_contribution_render_1.CircleRenderContribution), \n    bind(rect_render_1.DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(symbol_1.RectRender).to(rect_render_1.DefaultCanvasRectRender), \n    bind(symbol_1.GraphicRender).to(rect_render_1.DefaultCanvasRectRender), bind(rect3d_render_1.DefaultCanvasRect3dRender).toSelf().inSingletonScope(), \n    bind(symbol_1.Rect3DRender).toService(rect3d_render_1.DefaultCanvasRect3dRender), \n    bind(symbol_1.GraphicRender).toService(symbol_1.Rect3DRender), bind(rect_contribution_render_1.DefaultRectRenderContribution).toSelf().inSingletonScope(), \n    bind(rect_contribution_render_1.DefaultRectBackgroundRenderContribution).toSelf().inSingletonScope(), \n    bind(rect_contribution_render_1.DefaultRectTextureRenderContribution).toSelf().inSingletonScope(), \n    bind(rect_contribution_render_1.SplitRectBeforeRenderContribution).toSelf().inSingletonScope(), \n    bind(rect_contribution_render_1.SplitRectAfterRenderContribution).toSelf().inSingletonScope(), \n    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.DefaultRectRenderContribution), \n    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.DefaultRectBackgroundRenderContribution), \n    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.DefaultRectTextureRenderContribution), \n    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.SplitRectBeforeRenderContribution), \n    bind(rect_contribution_render_1.RectRenderContribution).toService(rect_contribution_render_1.SplitRectAfterRenderContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, rect_contribution_render_1.RectRenderContribution), \n    bind(text_render_1.DefaultCanvasTextRender).toSelf().inSingletonScope(), bind(symbol_1.TextRender).to(text_render_1.DefaultCanvasTextRender), \n    bind(symbol_1.GraphicRender).to(text_render_1.DefaultCanvasTextRender), bind(path_render_1.DefaultCanvasPathRender).toSelf().inSingletonScope(), \n    bind(symbol_1.PathRender).to(path_render_1.DefaultCanvasPathRender), bind(symbol_1.GraphicRender).to(path_render_1.DefaultCanvasPathRender), \n    bind(path_contribution_render_1.DefaultPathBackgroundRenderContribution).toSelf().inSingletonScope(), \n    bind(path_contribution_render_1.DefaultPathTextureRenderContribution).toSelf().inSingletonScope(), \n    bind(path_contribution_render_1.PathRenderContribution).toService(path_contribution_render_1.DefaultPathBackgroundRenderContribution), \n    bind(path_contribution_render_1.PathRenderContribution).toService(path_contribution_render_1.DefaultPathTextureRenderContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, path_contribution_render_1.PathRenderContribution), \n    bind(symbol_render_1.DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(symbol_1.SymbolRender).to(symbol_render_1.DefaultCanvasSymbolRender), \n    bind(symbol_1.GraphicRender).to(symbol_render_1.DefaultCanvasSymbolRender), bind(symbol_contribution_render_1.DefaultSymbolRenderContribution).toSelf().inSingletonScope(), \n    bind(symbol_contribution_render_1.DefaultSymbolBackgroundRenderContribution).toSelf().inSingletonScope(), \n    bind(symbol_contribution_render_1.DefaultSymbolTextureRenderContribution).toSelf().inSingletonScope(), \n    bind(symbol_contribution_render_1.SymbolRenderContribution).toService(symbol_contribution_render_1.DefaultSymbolRenderContribution), \n    bind(symbol_contribution_render_1.SymbolRenderContribution).toService(symbol_contribution_render_1.DefaultSymbolBackgroundRenderContribution), \n    bind(symbol_contribution_render_1.SymbolRenderContribution).toService(symbol_contribution_render_1.DefaultSymbolTextureRenderContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, symbol_contribution_render_1.SymbolRenderContribution), \n    bind(arc_render_1.DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(symbol_1.ArcRender).to(arc_render_1.DefaultCanvasArcRender), \n    bind(symbol_1.GraphicRender).to(arc_render_1.DefaultCanvasArcRender), bind(arc3d_render_1.DefaultCanvasArc3DRender).toSelf().inSingletonScope(), \n    bind(symbol_1.Arc3dRender).toService(arc3d_render_1.DefaultCanvasArc3DRender), bind(symbol_1.GraphicRender).toService(symbol_1.Arc3dRender), \n    bind(arc_contribution_render_1.DefaultArcRenderContribution).toSelf().inSingletonScope(), \n    bind(arc_contribution_render_1.DefaultArcBackgroundRenderContribution).toSelf().inSingletonScope(), \n    bind(arc_contribution_render_1.DefaultArcTextureRenderContribution).toSelf().inSingletonScope(), \n    bind(arc_contribution_render_1.ArcRenderContribution).toService(arc_contribution_render_1.DefaultArcRenderContribution), \n    bind(arc_contribution_render_1.ArcRenderContribution).toService(arc_contribution_render_1.DefaultArcBackgroundRenderContribution), \n    bind(arc_contribution_render_1.ArcRenderContribution).toService(arc_contribution_render_1.DefaultArcTextureRenderContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, arc_contribution_render_1.ArcRenderContribution), \n    bind(line_render_1.DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(symbol_1.LineRender).to(line_render_1.DefaultCanvasLineRender), \n    bind(symbol_1.GraphicRender).to(line_render_1.DefaultCanvasLineRender), bind(incremental_line_render_1.DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), \n    bind(incremental_area_render_1.DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope(), \n    bind(area_render_1.DefaultCanvasAreaRender).toSelf().inSingletonScope(), bind(symbol_1.AreaRender).to(area_render_1.DefaultCanvasAreaRender), \n    bind(symbol_1.GraphicRender).to(area_render_1.DefaultCanvasAreaRender), bind(area_contribution_render_1.DefaultAreaBackgroundRenderContribution).toSelf().inSingletonScope(), \n    bind(area_contribution_render_1.DefaultAreaTextureRenderContribution).toSelf().inSingletonScope(), \n    bind(area_contribution_render_1.AreaRenderContribution).toService(area_contribution_render_1.DefaultAreaBackgroundRenderContribution), \n    bind(area_contribution_render_1.AreaRenderContribution).toService(area_contribution_render_1.DefaultAreaTextureRenderContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, area_contribution_render_1.AreaRenderContribution), \n    bind(group_render_1.DefaultCanvasGroupRender).toSelf().inSingletonScope(), bind(symbol_1.GroupRender).to(group_render_1.DefaultCanvasGroupRender), \n    bind(symbol_1.GraphicRender).to(group_render_1.DefaultCanvasGroupRender), bind(group_contribution_render_1.DefaultGroupBackgroundRenderContribution).toSelf().inSingletonScope(), \n    bind(group_contribution_render_1.GroupRenderContribution).toService(group_contribution_render_1.DefaultGroupBackgroundRenderContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, group_contribution_render_1.GroupRenderContribution), \n    bind(polygon_render_1.DefaultCanvasPolygonRender).toSelf().inSingletonScope(), bind(symbol_1.PolygonRender).to(polygon_render_1.DefaultCanvasPolygonRender), \n    bind(symbol_1.GraphicRender).to(polygon_render_1.DefaultCanvasPolygonRender), bind(polygon_contribution_render_1.DefaultPolygonBackgroundRenderContribution).toSelf().inSingletonScope(), \n    bind(polygon_contribution_render_1.DefaultPolygonTextureRenderContribution).toSelf().inSingletonScope(), \n    bind(polygon_contribution_render_1.PolygonRenderContribution).toService(polygon_contribution_render_1.DefaultPolygonBackgroundRenderContribution), \n    bind(polygon_contribution_render_1.PolygonRenderContribution).toService(polygon_contribution_render_1.DefaultPolygonTextureRenderContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, polygon_contribution_render_1.PolygonRenderContribution), \n    bind(glyph_render_1.DefaultCanvasGlyphRender).toSelf().inSingletonScope(), bind(symbol_1.GlyphRender).toService(glyph_render_1.DefaultCanvasGlyphRender), \n    bind(symbol_1.GraphicRender).toService(symbol_1.GlyphRender), bind(image_render_1.DefaultCanvasImageRender).toSelf().inSingletonScope(), \n    bind(symbol_1.ImageRender).toService(image_render_1.DefaultCanvasImageRender), bind(symbol_1.GraphicRender).toService(symbol_1.ImageRender), \n    bind(image_contribution_render_1.DefaultImageBackgroundRenderContribution).toSelf().inSingletonScope(), \n    bind(image_contribution_render_1.ImageRenderContribution).toService(image_contribution_render_1.DefaultImageBackgroundRenderContribution), \n    (0, contribution_provider_1.bindContributionProvider)(bind, image_contribution_render_1.ImageRenderContribution), \n    bind(richtext_render_1.DefaultCanvasRichTextRender).toSelf().inSingletonScope(), \n    bind(symbol_1.RichTextRender).toService(richtext_render_1.DefaultCanvasRichTextRender), \n    bind(symbol_1.GraphicRender).toService(symbol_1.RichTextRender), bind(pyramid3d_render_1.DefaultCanvasPyramid3dRender).toSelf().inSingletonScope(), \n    bind(symbol_1.Pyramid3dRender).toService(pyramid3d_render_1.DefaultCanvasPyramid3dRender), \n    bind(symbol_1.GraphicRender).toService(symbol_1.Pyramid3dRender), (0, contribution_provider_1.bindContributionProvider)(bind, symbol_1.GraphicRender), \n    bind(draw_interceptor_1.ShadowRootDrawItemInterceptorContribution).toSelf().inSingletonScope(), \n    bind(draw_interceptor_1.DrawItemInterceptor).toService(draw_interceptor_1.ShadowRootDrawItemInterceptorContribution), \n    bind(draw_interceptor_1.Canvas3DDrawItemInterceptor).toSelf().inSingletonScope(), \n    bind(draw_interceptor_1.DrawItemInterceptor).toService(draw_interceptor_1.Canvas3DDrawItemInterceptor), \n    (0, contribution_provider_1.bindContributionProvider)(bind, draw_interceptor_1.DrawItemInterceptor);\n}));\n//# sourceMappingURL=module.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultDrawContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), sort_1 = require(\"../../../common/sort\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), graphic_1 = require(\"../../../graphic\"), vutils_1 = require(\"@visactor/vutils\"), constants_1 = require(\"../../../core/constants\"), container_1 = require(\"../../../container\"), symbol_1 = require(\"./symbol\"), draw_interceptor_1 = require(\"./draw-interceptor\"), canvas_utils_1 = require(\"../../../common/canvas-utils\");\n\nlet DefaultDrawContribution = class {\n    constructor(contributions, renderSelector, layerService, drawItemInterceptorContributions) {\n        this.contributions = contributions, this.renderSelector = renderSelector, this.layerService = layerService, \n        this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.currentRenderMap = new Map, \n        this.defaultRenderMap = new Map, this.styleRenderMap = new Map, this.dirtyBounds = new vutils_1.Bounds, \n        this.backupDirtyBounds = new vutils_1.Bounds;\n    }\n    init() {\n        this.contributions.forEach((item => {\n            if (item.style) {\n                const map = this.styleRenderMap.get(item.style) || new Map;\n                map.set(item.numberType, item), this.styleRenderMap.set(item.style, map);\n            } else this.defaultRenderMap.set(item.numberType, item);\n        })), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort(((a, b) => a.order - b.order));\n    }\n    draw(renderService, drawContext) {\n        drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, \n        this.currentRenderService = renderService;\n        const {context: context, stage: stage, x: x = 0, y: y = 0, width: width, height: height} = drawContext;\n        if (!context) return;\n        const dirtyBounds = this.dirtyBounds.setValue(0, 0, width, height);\n        if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {\n            const b = (0, vutils_1.getRectIntersect)(dirtyBounds, stage.dirtyBounds, !1);\n            dirtyBounds.x1 = Math.floor(b.x1), dirtyBounds.y1 = Math.floor(b.y1), dirtyBounds.x2 = Math.ceil(b.x2), \n            dirtyBounds.y2 = Math.ceil(b.y2);\n        }\n        this.backupDirtyBounds.copy(dirtyBounds), context.inuse = !0, context.clearMatrix(), \n        context.setTransformForCurrent(!0);\n        const drawInArea = dirtyBounds.width() * context.dpr !== context.canvas.width || dirtyBounds.height() * context.dpr !== context.canvas.height;\n        context.save(), context.translate(x, y, !0), drawInArea && (context.beginPath(), \n        context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), \n        context.clip()), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), \n        this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), \n        context.save(), renderService.renderTreeRoots.sort(((a, b) => {\n            var _a, _b;\n            return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : graphic_1.DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : graphic_1.DefaultAttribute.zIndex);\n        })).forEach((group => {\n            this.renderGroup(group, drawContext);\n        })), context.restore(), context.restore(), context.draw(), context.inuse = !1;\n    }\n    doRegister() {\n        throw new Error(\"\");\n    }\n    _findNextGraphic(group) {\n        let parent = group.parent, id = group._uid;\n        for (;parent; ) {\n            const g = (0, sort_1.findNextGraphic)(parent, id, graphic_1.DefaultAttribute.zIndex);\n            if (g) return g;\n            id = parent._uid, parent = parent.parent;\n        }\n        return null;\n    }\n    renderGroup(group, drawContext, skipSort) {\n        if (drawContext.break || !1 === group.attribute.visibleAll) return;\n        if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid)) return drawContext.break = !0, \n        void this._increaseRender(group, drawContext);\n        if (!(0, vutils_1.isRectIntersect)(group.AABBBounds, this.dirtyBounds, !1)) return;\n        const tempBounds = this.dirtyBounds.clone(), m = group.globalTransMatrix.getInverse();\n        this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(m), this.renderItem(group, drawContext, {\n            drawingCb: () => {\n                var _a;\n                skipSort ? group.forEachChildren((item => {\n                    drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext) : this.renderItem(item, drawContext));\n                })) : (0, sort_1.foreach)(group, graphic_1.DefaultAttribute.zIndex, (item => {\n                    drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext) : this.renderItem(item, drawContext));\n                }), !1, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));\n            }\n        }), this.dirtyBounds.copy(tempBounds);\n    }\n    _increaseRender(group, drawContext) {\n        const {layer: layer, stage: stage} = drawContext, {subLayers: subLayers} = layer;\n        let incrementalLayer = subLayers.get(group._uid);\n        incrementalLayer || (incrementalLayer = {\n            layer: this.layerService.createLayer(stage),\n            zIndex: subLayers.size,\n            group: group\n        }, subLayers.set(group._uid, incrementalLayer));\n        const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(), idc = incrementalLayer.drawContribution || container_1.container.get(symbol_1.IncrementalDrawContribution);\n        idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), \n        idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {\n            drawContribution: idc,\n            clear: \"transparent\",\n            layer: incrementalLayer.layer,\n            context: incrementalContext,\n            startAtId: group._uid,\n            break: !1\n        })), incrementalLayer.drawContribution = idc;\n        const nextGraphic = this._findNextGraphic(group);\n        if (nextGraphic) if (nextGraphic.isContainer && nextGraphic.incremental) this._increaseRender(nextGraphic, drawContext); else {\n            let afterLayer = subLayers.get(nextGraphic._uid);\n            afterLayer || (afterLayer = {\n                layer: this.layerService.createLayer(stage),\n                zIndex: subLayers.size\n            }, subLayers.set(nextGraphic._uid, afterLayer));\n            const afterContext = afterLayer.layer.getNativeHandler().getContext();\n            this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {\n                drawContribution: idc,\n                clear: \"transparent\",\n                layer: afterLayer.layer,\n                context: afterContext,\n                startAtId: nextGraphic._uid,\n                break: !1\n            }));\n        }\n    }\n    getRenderContribution(graphic) {\n        let renderer = this.renderSelector.selector(graphic);\n        return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType)), \n        renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;\n    }\n    renderItem(graphic, drawContext, params) {\n        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {\n            const drawContribution = this.InterceptorContributions[i];\n            if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params)) return;\n        }\n        const renderer = this.getRenderContribution(graphic);\n        if (!renderer) return;\n        if (!graphic.isContainer && !(0, vutils_1.isRectIntersect)(graphic.AABBBounds, this.dirtyBounds, !1)) return;\n        const skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;\n        if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params && (params.skipDraw = skipDraw), \n        skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params) : renderer.draw(graphic, this.currentRenderService, drawContext, params), \n        this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {\n            const drawContribution = this.InterceptorContributions[i];\n            if (drawContribution.afterDrawItem && drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) return;\n        }\n    }\n    selectRenderByType(type) {\n        return console.warn(\"\"), null;\n    }\n    selectRenderByNumberType(type) {\n        return this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);\n    }\n    clearScreen(renderService, context, drawContext) {\n        const {clear: clear} = drawContext;\n        if (clear) {\n            const canvas = context.getCanvas(), {width: width = canvas.width, height: height = canvas.height} = drawContext, x = 0, y = 0;\n            context.clearRect(x, y, width, height), context.fillStyle = (0, canvas_utils_1.createColor)(context, clear, {\n                AABBBounds: {\n                    x1: x,\n                    y1: y,\n                    x2: x + width,\n                    y2: y + height\n                }\n            }, 0, 0), context.fillRect(x, y, width, height);\n        }\n    }\n};\n\n__decorate([ (0, inversify_1.postConstruct)(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0) ], DefaultDrawContribution.prototype, \"init\", null), \nDefaultDrawContribution = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.multiInject)(symbol_1.GraphicRender)), __param(1, (0, inversify_1.inject)(symbol_1.RenderSelector)), __param(2, (0, \ninversify_1.inject)(constants_1.LayerService)), __param(3, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(3, (0, \ninversify_1.named)(draw_interceptor_1.DrawItemInterceptor)), __metadata(\"design:paramtypes\", [ Array, Object, Object, Object ]) ], DefaultDrawContribution), \nexports.DefaultDrawContribution = DefaultDrawContribution;\n//# sourceMappingURL=draw-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Canvas3DDrawItemInterceptor = exports.ShadowRootDrawItemInterceptorContribution = exports.DrawItemInterceptor = void 0;\n\nconst inversify_1 = require(\"inversify\"), vutils_1 = require(\"@visactor/vutils\"), graphic_1 = require(\"../../../graphic\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), constants_1 = require(\"../../../graphic/constants\");\n\nexports.DrawItemInterceptor = Symbol.for(\"DrawItemInterceptor\");\n\nconst tempDirtyBounds = new vutils_1.AABBBounds;\n\nlet ShadowRootDrawItemInterceptorContribution = class {\n    constructor() {\n        this.order = 1;\n    }\n    afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {\n        if (!graphic.shadowRoot) return !1;\n        const {context: context} = drawContext;\n        if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, !0), \n        drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {\n            tempDirtyBounds.copy(drawContribution.dirtyBounds);\n            const m = graphic.globalTransMatrix.getInverse();\n            drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m);\n        }\n        return drawContribution.renderGroup(graphic.shadowRoot, drawContext), context.highPerformanceRestore(), \n        drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && drawContribution.dirtyBounds.copy(tempDirtyBounds), \n        !0;\n    }\n};\n\nShadowRootDrawItemInterceptorContribution = __decorate([ (0, inversify_1.injectable)() ], ShadowRootDrawItemInterceptorContribution), \nexports.ShadowRootDrawItemInterceptorContribution = ShadowRootDrawItemInterceptorContribution;\n\nlet Canvas3DDrawItemInterceptor = class {\n    constructor() {\n        this.order = 1;\n    }\n    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {\n        if (!graphic.in3dMode || drawContext.in3dInterceptor) return !1;\n        drawContext.in3dInterceptor = !0;\n        const {context: context, stage: stage} = renderService.drawParams;\n        context.canvas;\n        context.save(), this.initCanvasCtx(context), context.camera = stage.camera;\n        const m = context.currentMatrix;\n        m.a /= context.dpr, m.b /= context.dpr, m.c /= context.dpr, m.d /= context.dpr, \n        m.e /= context.dpr, m.f /= context.dpr;\n        const matrix = matrix_allocate_1.mat4Allocate.allocate();\n        (0, graphic_1.mat3Tomat4)(matrix, m);\n        const lastModelMatrix = context.modelMatrix;\n        if (lastModelMatrix) {\n            if (matrix) {\n                const m = matrix_allocate_1.mat4Allocate.allocate();\n                context.modelMatrix = (0, graphic_1.multiplyMat4Mat4)(m, lastModelMatrix, matrix);\n            }\n        } else context.modelMatrix = matrix;\n        if (context.setTransform(1, 0, 0, 1, 0, 0, !0), graphic.isContainer) {\n            let isPie = !1, is3d = !1;\n            if (graphic.forEachChildren((c => (isPie = c.numberType === constants_1.ARC3D_NUMBER_TYPE, \n            !isPie))), graphic.forEachChildren((c => (is3d = !!c.findFace, !is3d))), isPie) {\n                const children = graphic.getChildren(), sortedChildren = [ ...children ];\n                sortedChildren.sort(((a, b) => {\n                    var _a, _b, _c, _d;\n                    let angle1 = ((null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0) + (null !== (_b = a.attribute.endAngle) && void 0 !== _b ? _b : 0)) / 2, angle2 = ((null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0) + (null !== (_d = b.attribute.endAngle) && void 0 !== _d ? _d : 0)) / 2;\n                    for (;angle1 < 0; ) angle1 += vutils_1.pi2;\n                    for (;angle2 < 0; ) angle2 += vutils_1.pi2;\n                    return angle2 - angle1;\n                })), sortedChildren.forEach((c => {\n                    c._next = null, c._prev = null;\n                })), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c => {\n                    graphic.appendChild(c);\n                })), drawContext.hack_pieFace = \"outside\", drawContribution.renderGroup(graphic, drawContext), \n                drawContext.hack_pieFace = \"inside\", drawContribution.renderGroup(graphic, drawContext), \n                drawContext.hack_pieFace = \"top\", drawContribution.renderGroup(graphic, drawContext), \n                graphic.removeAllChild(), children.forEach((c => {\n                    c._next = null, c._prev = null;\n                })), children.forEach((c => {\n                    graphic.appendChild(c);\n                }));\n            } else if (is3d) {\n                const children = graphic.getChildren(), zChildren = children.map((g => ({\n                    ave_z: g.findFace().vertices.map((v => {\n                        var _a;\n                        return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];\n                    })).reduce(((a, b) => a + b), 0),\n                    g: g\n                })));\n                zChildren.sort(((a, b) => b.ave_z - a.ave_z)), graphic.removeAllChild(), zChildren.forEach((i => {\n                    i.g._next = null, i.g._prev = null;\n                })), graphic.update(), zChildren.forEach((i => {\n                    graphic.add(i.g);\n                })), drawContribution.renderGroup(graphic, drawContext, !0), graphic.removeAllChild(), \n                children.forEach((g => {\n                    g._next = null, g._prev = null;\n                })), graphic.update(), children.forEach((g => {\n                    graphic.add(g);\n                }));\n            } else drawContribution.renderGroup(graphic, drawContext);\n        } else drawContribution.renderItem(graphic, drawContext);\n        return context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n        context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = !1, !0;\n    }\n    initCanvasCtx(context) {\n        context.setTransformForCurrent();\n    }\n};\n\nCanvas3DDrawItemInterceptor = __decorate([ (0, inversify_1.injectable)() ], Canvas3DDrawItemInterceptor), \nexports.Canvas3DDrawItemInterceptor = Canvas3DDrawItemInterceptor;\n//# sourceMappingURL=draw-interceptor.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultRenderSelector = void 0;\n\nconst inversify_1 = require(\"inversify\");\n\nlet DefaultRenderSelector = class {\n    selector(graphic) {\n        return null;\n    }\n};\n\nDefaultRenderSelector = __decorate([ (0, inversify_1.injectable)() ], DefaultRenderSelector), \nexports.DefaultRenderSelector = DefaultRenderSelector;\n//# sourceMappingURL=render-slector.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasGroupRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), graphic_1 = require(\"../../../graphic\"), vutils_1 = require(\"@visactor/vutils\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), rect_1 = require(\"../../../common/shape/rect\"), utils_1 = require(\"./utils\"), group_contribution_render_1 = require(\"./contributions/group-contribution-render\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), constants_1 = require(\"../../../graphic/constants\"), enums_1 = require(\"../../../common/enums\");\n\nlet DefaultCanvasGroupRender = class {\n    constructor(groupRenderContribitions) {\n        this.groupRenderContribitions = groupRenderContribitions, this.numberType = constants_1.GROUP_NUMBER_TYPE;\n    }\n    drawShape(group, context, x, y, drawContext, params, fillCb, strokeCb) {\n        const groupAttribute = (0, graphic_1.getTheme)(group, null == params ? void 0 : params.theme).group, {fill: fill = groupAttribute.fill, background: background, stroke: stroke = groupAttribute.stroke, opacity: opacity = groupAttribute.opacity, width: width = groupAttribute.width, height: height = groupAttribute.height, clip: clip = groupAttribute.clip, fillOpacity: fillOpacity = groupAttribute.fillOpacity, strokeOpacity: strokeOpacity = groupAttribute.strokeOpacity, cornerRadius: cornerRadius = groupAttribute.cornerRadius, path: path = groupAttribute.path, lineWidth: lineWidth = groupAttribute.lineWidth, visible: visible = groupAttribute.visible} = group.attribute, fVisible = (0, \n        utils_1.rectFillVisible)(opacity, fillOpacity, width, height), sVisible = (0, utils_1.rectStrokeVisible)(opacity, strokeOpacity, width, height), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        if (!group.valid || !visible) return;\n        if (!clip) {\n            if (!(doFill || doStroke || background)) return;\n            if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;\n        }\n        if (path && path.length && drawContext.drawContribution) {\n            const disableFill = context.disableFill, disableStroke = context.disableStroke, disableBeginPath = context.disableBeginPath;\n            context.disableFill = !0, context.disableStroke = !0, context.disableBeginPath = !0, \n            path.forEach((g => {\n                drawContext.drawContribution.getRenderContribution(g).draw(g, drawContext.renderService, drawContext, params);\n            })), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;\n        } else 0 === cornerRadius || (0, vutils_1.isArray)(cornerRadius) && cornerRadius.every((num => 0 === num)) ? (context.beginPath(), \n        context.rect(x, y, width, height)) : (context.beginPath(), (0, rect_1.createRectPath)(context, x, y, width, height, cornerRadius));\n        this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || []);\n        const doFillOrStroke = {\n            doFill: doFill,\n            doStroke: doStroke\n        };\n        this._groupRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.beforeFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb, doFillOrStroke);\n        })), clip && context.clip(), context.setShadowStyle && context.setShadowStyle(group, group.attribute, groupAttribute), \n        doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, x, y, groupAttribute), \n        context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, x, y, groupAttribute), \n        context.stroke())), this._groupRenderContribitions.forEach((c => {\n            c.time === enums_1.BaseRenderContributionTime.afterFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, fillCb, strokeCb);\n        }));\n    }\n    draw(group, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        const {clip: clip} = group.attribute;\n        clip ? context.save() : context.highPerformanceSave();\n        const groupAttribute = (0, graphic_1.getTheme)(group, null == params ? void 0 : params.theme).group, lastModelMatrix = context.modelMatrix;\n        if (context.camera) {\n            const nextModelMatrix = matrix_allocate_1.mat4Allocate.allocate(), modelMatrix = matrix_allocate_1.mat4Allocate.allocate();\n            (0, graphic_1.getModelMatrix)(modelMatrix, group, groupAttribute), lastModelMatrix ? (0, \n            graphic_1.multiplyMat4Mat4)(nextModelMatrix, lastModelMatrix, modelMatrix) : (0, \n            graphic_1.multiplyMat4Mat4)(nextModelMatrix, nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, \n            matrix_allocate_1.mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, !0);\n        } else context.transformFromMatrix(group.transMatrix, !0);\n        context.beginPath(), params.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params, (() => !1), (() => !1)) : this.drawShape(group, context, 0, 0, drawContext);\n        const {scrollX: scrollX = groupAttribute.scrollX, scrollY: scrollY = groupAttribute.scrollY} = group.attribute;\n        let p;\n        (scrollX || scrollY) && context.translate(scrollX, scrollY), params && params.drawingCb && (p = params.drawingCb()), \n        context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n        context.modelMatrix = lastModelMatrix, p && p.then ? p.then((() => {\n            clip ? context.restore() : context.highPerformanceRestore();\n        })) : clip ? context.restore() : context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasGroupRender = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, \ninversify_1.named)(group_contribution_render_1.GroupRenderContribution)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasGroupRender), \nexports.DefaultCanvasGroupRender = DefaultCanvasGroupRender;\n//# sourceMappingURL=group-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n}, __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))((function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            var value;\n            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {\n                resolve(value);\n            }))).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    }));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultIncrementalDrawContribution = void 0;\n\nconst inversify_1 = require(\"inversify\"), graphic_1 = require(\"../../../graphic\"), constants_1 = require(\"../../../core/constants\"), draw_contribution_1 = require(\"./draw-contribution\"), tapable_1 = require(\"../../../tapable\"), symbol_1 = require(\"./symbol\"), incremental_line_render_1 = require(\"./incremental-line-render\"), incremental_area_render_1 = require(\"./incremental-area-render\"), draw_interceptor_1 = require(\"./draw-interceptor\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), sort_1 = require(\"../../../common/sort\"), constants_2 = require(\"../../../constants\");\n\nvar STATUS;\n\n!function(STATUS) {\n    STATUS[STATUS.NORMAL = 0] = \"NORMAL\", STATUS[STATUS.STOP = 1] = \"STOP\";\n}(STATUS || (STATUS = {}));\n\nlet DefaultIncrementalDrawContribution = class extends draw_contribution_1.DefaultDrawContribution {\n    constructor(contributions, renderSelector, lineRender, areaRender, layerService, drawItemInterceptorContributions) {\n        super(contributions, renderSelector, layerService, drawItemInterceptorContributions), \n        this.contributions = contributions, this.renderSelector = renderSelector, this.lineRender = lineRender, \n        this.areaRender = areaRender, this.layerService = layerService, this.drawItemInterceptorContributions = drawItemInterceptorContributions, \n        this.rendering = !1, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS.NORMAL, \n        this.checkingForDrawPromise = null, this.hooks = {\n            completeDraw: new tapable_1.SyncHook([])\n        };\n    }\n    init() {\n        super.init(), this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), \n        this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);\n    }\n    draw(renderService, drawContext) {\n        return __awaiter(this, void 0, void 0, (function*() {\n            if (this.checkingForDrawPromise) return;\n            this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);\n            const skipDraw = yield this.checkingForDrawPromise;\n            if (this.checkingForDrawPromise = null, skipDraw) return;\n            this.currentRenderService = renderService;\n            const {context: context, x: x = 0, y: y = 0} = drawContext;\n            context && (context.inuse = !0, context.clearMatrix(), context.setTransformForCurrent(!0), \n            context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), \n            context.translate(x, y, !0), context.save(), renderService.renderTreeRoots.sort(((a, b) => {\n                var _a, _b;\n                return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : graphic_1.DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : graphic_1.DefaultAttribute.zIndex);\n            })).forEach((group => {\n                this.renderGroup(group, drawContext);\n            })), this.hooks.completeDraw.tap(\"top-draw\", (() => {\n                context.restore(), context.restore(), context.draw(), context.inuse = !1, this.rendering = !1;\n            })));\n        }));\n    }\n    _increaseRender(group, drawContext) {\n        return __awaiter(this, void 0, void 0, (function*() {\n            this.rendering = !0, yield this._renderIncrementalGroup(group, drawContext);\n        }));\n    }\n    _renderIncrementalGroup(group, drawContext) {\n        return __awaiter(this, void 0, void 0, (function*() {\n            this.count = group.count, yield new Promise((resolve => {\n                this.renderItem(group, drawContext, {\n                    drawingCb: () => __awaiter(this, void 0, void 0, (function*() {\n                        if (2 !== group.count) yield (0, sort_1.foreachAsync)(group, graphic_1.DefaultAttribute.zIndex, ((item, i) => {\n                            if (this.status === STATUS.STOP) return !0;\n                            if (item.isContainer) return !1;\n                            if (i < this.currentIdx) return !1;\n                            const frameTail = this.currFrameStartAt + group.incremental;\n                            return i < frameTail && (this.currentIdx = i + 1, this.renderItem(item, drawContext)), \n                            i === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());\n                        })), resolve(!1); else {\n                            const graphic = group.getChildAt(0);\n                            if (graphic.incremental && graphic.attribute.segments) for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length; ) drawContext.multiGraphicOptions = {\n                                startAtIdx: graphic.incrementalAt,\n                                length: graphic.incremental\n                            }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, \n                            yield this.waitToNextFrame(); else this.renderItem(graphic, drawContext);\n                            resolve(!1);\n                        }\n                    }))\n                });\n            })), this.hooks.completeDraw.call();\n        }));\n    }\n    waitToNextFrame() {\n        return __awaiter(this, void 0, void 0, (function*() {\n            return new Promise((resolve => {\n                this.global.getRequestAnimationFrame()((() => {\n                    resolve(!1);\n                }));\n            }));\n        }));\n    }\n    checkForDraw(drawContext) {\n        return __awaiter(this, void 0, void 0, (function*() {\n            let skip = this.rendering;\n            return drawContext.restartIncremental && (skip = !1, yield this.forceStop(), this.resetToInit()), \n            skip;\n        }));\n    }\n    forceStop() {\n        return __awaiter(this, void 0, void 0, (function*() {\n            this.rendering && (this.status = STATUS.STOP, yield new Promise((resolve => {\n                this.hooks.completeDraw.tap(\"stopCb\", (() => {\n                    this.status = STATUS.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter((item => \"stopCb\" !== item.name)), \n                    resolve(!1);\n                }));\n            })));\n        }));\n    }\n    resetToInit() {\n        this.currFrameStartAt = 0, this.currentIdx = 0;\n    }\n    renderGroup(group, drawContext) {\n        return __awaiter(this, void 0, void 0, (function*() {\n            if (!drawContext.break && !1 !== group.attribute.visibleAll) return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), \n            void (drawContext.break = !0)) : void (yield new Promise((resolve => {\n                this.renderItem(group, drawContext, {\n                    drawingCb: () => __awaiter(this, void 0, void 0, (function*() {\n                        yield (0, sort_1.foreachAsync)(group, graphic_1.DefaultAttribute.zIndex, (item => __awaiter(this, void 0, void 0, (function*() {\n                            drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));\n                        })))), resolve(!1);\n                    }))\n                });\n            })));\n        }));\n    }\n};\n\n__decorate([ (0, inversify_1.inject)(constants_2.Global), __metadata(\"design:type\", Object) ], DefaultIncrementalDrawContribution.prototype, \"global\", void 0), \nDefaultIncrementalDrawContribution = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.multiInject)(symbol_1.GraphicRender)), __param(1, (0, inversify_1.inject)(symbol_1.RenderSelector)), __param(2, (0, \ninversify_1.inject)(incremental_line_render_1.DefaultIncrementalCanvasLineRender)), __param(3, (0, \ninversify_1.inject)(incremental_area_render_1.DefaultIncrementalCanvasAreaRender)), __param(4, (0, \ninversify_1.inject)(constants_1.LayerService)), __param(5, (0, inversify_1.inject)(contribution_provider_1.ContributionProvider)), __param(5, (0, \ninversify_1.named)(draw_interceptor_1.DrawItemInterceptor)), __metadata(\"design:paramtypes\", [ Array, Object, Object, Object, Object, Object ]) ], DefaultIncrementalDrawContribution), \nexports.DefaultIncrementalDrawContribution = DefaultIncrementalDrawContribution;\n//# sourceMappingURL=incremental-draw-contribution.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultIncrementalCanvasLineRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), utils_1 = require(\"./utils\"), line_render_1 = require(\"./line-render\"), render_curve_1 = require(\"../../../common/render-curve\");\n\nlet DefaultIncrementalCanvasLineRender = class extends line_render_1.DefaultCanvasLineRender {\n    constructor() {\n        super(...arguments), this.numberType = constants_1.LINE_NUMBER_TYPE;\n    }\n    drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {\n        if (line.incremental && drawContext.multiGraphicOptions) {\n            const {startAtIdx: startAtIdx, length: length} = drawContext.multiGraphicOptions, {segments: segments = []} = line.attribute;\n            if (startAtIdx > segments.length) return;\n            const lineAttribute = (0, theme_1.getTheme)(line).line, {fill: fill = lineAttribute.fill, stroke: stroke = lineAttribute.stroke, opacity: opacity = lineAttribute.opacity, fillOpacity: fillOpacity = lineAttribute.fillOpacity, strokeOpacity: strokeOpacity = lineAttribute.strokeOpacity, lineWidth: lineWidth = lineAttribute.lineWidth, visible: visible = lineAttribute.visible} = line.attribute, fVisible = (0, \n            utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n            utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n            if (!line.valid || !visible) return;\n            if (!doFill && !doStroke) return;\n            if (!(fVisible || sVisible || fillCb || strokeCb)) return;\n            const {context: context} = drawContext;\n            for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(line, context, segments[i - 1], segments[i], line.attribute.segments[i], [ lineAttribute, line.attribute ], x, y);\n        } else super.drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb);\n    }\n    drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {\n        seg && (context.beginPath(), (0, render_curve_1.drawIncrementalSegments)(context.nativeContext, lastSeg, seg, {\n            offsetX: offsetX,\n            offsetY: offsetY\n        }), context.setShadowStyle && context.setShadowStyle(line, attribute, defaultAttribute), \n        context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute), context.stroke());\n    }\n};\n\nDefaultIncrementalCanvasLineRender = __decorate([ (0, inversify_1.injectable)() ], DefaultIncrementalCanvasLineRender), \nexports.DefaultIncrementalCanvasLineRender = DefaultIncrementalCanvasLineRender;\n//# sourceMappingURL=incremental-line-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultIncrementalCanvasAreaRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), constants_1 = require(\"../../../graphic/constants\"), theme_1 = require(\"../../../graphic/theme\"), utils_1 = require(\"./utils\"), area_render_1 = require(\"./area-render\"), render_curve_1 = require(\"../../../common/render-curve\");\n\nlet DefaultIncrementalCanvasAreaRender = class extends area_render_1.DefaultCanvasAreaRender {\n    constructor() {\n        super(...arguments), this.numberType = constants_1.AREA_NUMBER_TYPE;\n    }\n    drawShape(area, context, x, y, drawContext, params, fillCb) {\n        if (area.incremental && drawContext.multiGraphicOptions) {\n            const {startAtIdx: startAtIdx, length: length} = drawContext.multiGraphicOptions, {segments: segments = []} = area.attribute;\n            if (startAtIdx > segments.length) return;\n            const areaAttribute = (0, theme_1.getTheme)(area).area, {fill: fill = areaAttribute.fill, fillOpacity: fillOpacity = areaAttribute.fillOpacity, opacity: opacity = areaAttribute.opacity, visible: visible = areaAttribute.visible} = area.attribute, fVisible = (0, \n            utils_1.fillVisible)(opacity, fillOpacity), doFill = (0, utils_1.runFill)(fill);\n            if (!area.valid || !visible) return;\n            if (!doFill) return;\n            if (!fVisible && !fillCb) return;\n            for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(area, context, segments[i - 1], segments[i], area.attribute.segments[i], [ areaAttribute, area.attribute ], x, y);\n        } else super.drawShape(area, context, x, y, drawContext, params, fillCb);\n    }\n    drawIncreaseSegment(area, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {\n        seg && (context.beginPath(), (0, render_curve_1.drawIncrementalAreaSegments)(context.camera ? context : context.nativeContext, lastSeg, seg, {\n            offsetX: offsetX,\n            offsetY: offsetY\n        }), context.setShadowStyle && context.setShadowStyle(area, attribute, defaultAttribute), \n        context.setCommonStyle(area, attribute, offsetX, offsetY, defaultAttribute), context.fill());\n    }\n};\n\nDefaultIncrementalCanvasAreaRender = __decorate([ (0, inversify_1.injectable)() ], DefaultIncrementalCanvasAreaRender), \nexports.DefaultIncrementalCanvasAreaRender = DefaultIncrementalCanvasAreaRender;\n//# sourceMappingURL=incremental-area-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasRect3dRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), utils_1 = require(\"./utils\"), color_string_1 = require(\"../../../color-string\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), base_render_1 = require(\"./base-render\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasRect3dRender = class extends base_render_1.BaseRender {\n    constructor() {\n        super(...arguments), this.type = \"rect3d\", this.numberType = constants_1.RECT3D_NUMBER_TYPE;\n    }\n    drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {\n        var _a;\n        const rectAttribute = (0, theme_1.getTheme)(rect, null == params ? void 0 : params.theme).rect3d, {fill: fill = rectAttribute.fill, stroke: stroke = rectAttribute.stroke, width: width = rectAttribute.width, height: height = rectAttribute.height, opacity: opacity = rectAttribute.opacity, fillOpacity: fillOpacity = rectAttribute.fillOpacity, lineWidth: lineWidth = rectAttribute.lineWidth, strokeOpacity: strokeOpacity = rectAttribute.strokeOpacity, visible: visible = rectAttribute.visible} = rect.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = (0, \n        utils_1.rectFillVisible)(opacity, fillOpacity, width, height), sVisible = (0, utils_1.rectStrokeVisible)(opacity, strokeOpacity, width, height), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        if (!rect.valid || !visible) return;\n        if (!doFill && !doStroke) return;\n        if (!(fVisible || sVisible || fillCb || strokeCb)) return;\n        const {light: light, camera: camera} = drawContext.stage || {}, face3d = rect.findFace();\n        if (!1 !== fill) {\n            context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);\n            let fc = fill;\n            \"string\" != typeof fc && (fc = \"black\"), this.fill(x, y, z, face3d, fc, context, light, fillCb);\n        }\n        !1 !== stroke && (context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute), \n        this.stroke(x, y, z, face3d, context));\n    }\n    stroke(x, y, z, face3d, context) {\n        const vertices = face3d.vertices;\n        face3d.edges.forEach((edge => {\n            const p1 = vertices[edge[0]], v1 = {\n                x: x + p1[0],\n                y: y + p1[1],\n                z: z + p1[2]\n            }, p2 = vertices[edge[1]], v2 = {\n                x: x + p2[0],\n                y: y + p2[1],\n                z: z + p2[2]\n            };\n            context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), \n            context.stroke();\n        }));\n    }\n    fill(x, y, z, face3d, fillColor, context, light, fillCb) {\n        const rgbArray = color_string_1.colorString.get(fillColor).value, vertices = face3d.vertices, viewdVerticesZ = vertices.map((v => context.view(v[0], v[1], v[2])[2])), sortFace = [];\n        face3d.polygons.forEach(((p, i) => {\n            sortFace.push({\n                faceIdx: i,\n                polygon: p\n            });\n            const {polygon: polygon, normal: normal} = p, z1 = viewdVerticesZ[polygon[0]], z2 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];\n            p.ave_z = z1 + z2 + z3 + z4;\n        })), sortFace.sort(((a, b) => b.polygon.ave_z - a.polygon.ave_z)), sortFace.forEach((item => {\n            const {polygon: polygon, normal: normal} = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {\n                x: x + p1[0],\n                y: y + p1[1],\n                z: z + p1[2]\n            }, v2 = {\n                x: x + p2[0],\n                y: y + p2[1],\n                z: z + p2[2]\n            }, v3 = {\n                x: x + p3[0],\n                y: y + p3[1],\n                z: z + p3[2]\n            }, v4 = {\n                x: x + p4[0],\n                y: y + p4[1],\n                z: z + p4[2]\n            };\n            context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), \n            context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), \n            fillCb ? fillCb(context, null, null) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, \n            context.fill());\n        }));\n    }\n    draw(rect, renderService, drawContext) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        context.highPerformanceSave();\n        const rectAttribute = (0, theme_1.getTheme)(rect).rect, data = this.transform(rect, rectAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        this.z = z, this.drawShape(rect, context, x, y, drawContext), this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n        context.modelMatrix = lastModelMatrix, context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasRect3dRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasRect3dRender), \nexports.DefaultCanvasRect3dRender = DefaultCanvasRect3dRender;\n//# sourceMappingURL=rect3d-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasRichTextRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), rect_1 = require(\"../../../common/shape/rect\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), utils_1 = require(\"./utils\");\n\nlet DefaultCanvasRichTextRender = class {\n    constructor() {\n        this.numberType = constants_1.RICHTEXT_NUMBER_TYPE;\n    }\n    drawShape(richtext, context, x, y, drawContext) {\n        const richtextAttribute = (0, theme_1.getTheme)(richtext).richtext, {width: width = richtextAttribute.width, height: height = richtextAttribute.height, opacity: opacity = richtextAttribute.opacity, fillOpacity: fillOpacity = richtextAttribute.fillOpacity, visible: visible = richtextAttribute.visible} = richtext.attribute;\n        if (!richtext.valid || !visible) return;\n        if (!(0, utils_1.fillVisible)(opacity, fillOpacity)) return;\n        context.translate(x, y);\n        richtext.getFrameCache().draw(context, this.drawIcon);\n    }\n    drawIcon(icon, context, x, y, baseline) {\n        var _a;\n        const richtextIconAttribute = (0, theme_1.getTheme)(icon).richtextIcon, {width: width = richtextIconAttribute.width, height: height = richtextIconAttribute.height, opacity: opacity = richtextIconAttribute.opacity, image: url, backgroundFill: backgroundFill = richtextIconAttribute.backgroundFill, backgroundFillOpacity: backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity, backgroundStroke: backgroundStroke = richtextIconAttribute.backgroundStroke, backgroundStrokeOpacity: backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity, backgroundRadius: backgroundRadius = richtextIconAttribute.backgroundRadius, margin: margin} = icon.attribute, {backgroundWidth: backgroundWidth = width, backgroundHeight: backgroundHeight = height} = icon.attribute;\n        if (margin && (x += icon._marginArray[3], y += icon._marginArray[0]), icon._hovered) {\n            const expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;\n            0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), \n            (0, rect_1.createRectPath)(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius)), \n            backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, \n            context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, \n            context.strokeStyle = backgroundStroke, context.stroke());\n        }\n        const res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));\n        res && \"success\" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));\n    }\n    draw(richtext, renderService, drawContext) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        context.highPerformanceSave();\n        const richtextAttribute = (0, theme_1.getTheme)(richtext).richtext;\n        let {x: x = richtextAttribute.x, y: y = richtextAttribute.y} = richtext.attribute;\n        if (richtext.transMatrix.onlyTranslate()) {\n            const point = richtext.getOffsetXY(richtextAttribute);\n            x += point.x, y += point.y, context.setTransformForCurrent();\n        } else x = 0, y = 0, context.transformFromMatrix(richtext.transMatrix, !0);\n        this.drawShape(richtext, context, x, y, drawContext), context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasRichTextRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasRichTextRender), \nexports.DefaultCanvasRichTextRender = DefaultCanvasRichTextRender;\n//# sourceMappingURL=richtext-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasGlyphRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasGlyphRender = class {\n    constructor() {\n        this.numberType = constants_1.GLYPH_NUMBER_TYPE;\n    }\n    drawShape(glyph, context, x, y, drawContext, params, fillCb, strokeCb) {\n        drawContext.drawContribution && glyph.getSubGraphic().forEach((item => {\n            const renderer = drawContext.drawContribution.getRenderContribution(item);\n            renderer && renderer.drawShape && renderer.drawShape(item, context, x, y, drawContext, params, fillCb, strokeCb);\n        }));\n    }\n    draw(glyph, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        if (context.highPerformanceSave(), !drawContext.drawContribution) return;\n        const glyphTheme = (0, theme_1.getTheme)(glyph), subGraphic = glyph.getSubGraphic();\n        subGraphic.length && subGraphic.forEach((g => {\n            drawContext.drawContribution.renderItem(g, drawContext, {\n                theme: glyphTheme\n            });\n        })), context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasGlyphRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasGlyphRender), \nexports.DefaultCanvasGlyphRender = DefaultCanvasGlyphRender;\n//# sourceMappingURL=glyph-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasArc3DRender = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), utils_1 = require(\"./utils\"), color_string_1 = require(\"../../../color-string\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), base_render_1 = require(\"./base-render\"), constants_1 = require(\"../../../graphic/constants\");\n\nfunction drawArcPath(arc, context, cx, cy, z, outerRadius, innerRadius) {\n    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, \n    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;\n    let collapsedToLine = !1;\n    if (outerRadius < innerRadius) {\n        const temp = outerRadius;\n        outerRadius = innerRadius, innerRadius = temp;\n    }\n    if (outerRadius <= vutils_1.epsilon) context.moveTo(cx, cy, z); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + outerRadius * (0, \n    vutils_1.cos)(startAngle), cy + outerRadius * (0, vutils_1.sin)(startAngle), z), \n    context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > vutils_1.epsilon && (context.moveTo(cx + innerRadius * (0, \n    vutils_1.cos)(endAngle), cy + innerRadius * (0, vutils_1.sin)(endAngle), z), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z)); else {\n        const {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), xors = outerRadius * (0, \n        vutils_1.cos)(outerStartAngle), yors = outerRadius * (0, vutils_1.sin)(outerStartAngle), xire = innerRadius * (0, \n        vutils_1.cos)(innerEndAngle), yire = innerRadius * (0, vutils_1.sin)(innerEndAngle);\n        outerDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z), \n        context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), \n        !(innerRadius > vutils_1.epsilon) || innerDeltaAngle < .001 ? (context.lineTo(cx + xire, cy + yire, z), \n        collapsedToLine = !0) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));\n    }\n    return context.closePath(), collapsedToLine;\n}\n\nfunction drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {\n    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, \n    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;\n    let collapsedToLine = !1;\n    if (radius <= vutils_1.epsilon) context.moveTo(cx, cy, z1); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + radius * (0, \n    vutils_1.cos)(startAngle), cy + radius * (0, vutils_1.sin)(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), \n    context.lineTo(cx + radius * (0, vutils_1.cos)(endAngle), cy + radius * (0, vutils_1.sin)(endAngle), z2), \n    context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2); else {\n        const {innerouterDeltaAngle: innerouterDeltaAngle, innerouterStartAngle: innerouterStartAngle, innerouterEndAngle: innerouterEndAngle} = getParsePadAngle(startAngle, endAngle), xors = radius * (0, \n        vutils_1.cos)(innerouterStartAngle), yors = radius * (0, vutils_1.sin)(innerouterStartAngle), xore = radius * (0, \n        vutils_1.cos)(innerouterEndAngle), yore = radius * (0, vutils_1.sin)(innerouterEndAngle);\n        innerouterDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z1), \n        context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), \n        context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));\n    }\n    return context.closePath(), collapsedToLine;\n}\n\nlet DefaultCanvasArc3DRender = class extends base_render_1.BaseRender {\n    constructor() {\n        super(...arguments), this.numberType = constants_1.ARC3D_NUMBER_TYPE;\n    }\n    drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {\n        var _a;\n        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc, {fill: fill = arcAttribute.fill, background: background, stroke: stroke = arcAttribute.stroke, opacity: opacity = arcAttribute.opacity, fillOpacity: fillOpacity = arcAttribute.fillOpacity, lineWidth: lineWidth = arcAttribute.lineWidth, strokeOpacity: strokeOpacity = arcAttribute.strokeOpacity, visible: visible = arcAttribute.visible} = arc.attribute, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth), z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;\n        if (!arc.valid || !visible) return;\n        if (!(doFill || doStroke || background)) return;\n        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;\n        const {outerRadius: outerRadius = arcAttribute.outerRadius, innerRadius: innerRadius = arcAttribute.innerRadius, height: height = 10} = arc.attribute, rgbArray = color_string_1.colorString.get(fill).value, {light: light} = drawContext.stage || {}, face = drawContext.hack_pieFace, z_face = {\n            top: z,\n            bottom: z + height\n        }, n_face = {\n            top: [ 0, 1, 0 ],\n            bottom: [ 0, -1, 0 ],\n            outside: [ 1, 0, -1 ],\n            inside: [ 1, 0, -1 ]\n        };\n        \"bottom\" === face || \"top\" === face ? (context.beginPath(), drawArcPath(arc, context, x, y, z_face[face], outerRadius, innerRadius), \n        context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), \n        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), \n        context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), \n        doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), \n        context.stroke()))) : \"outside\" !== face && \"inside\" !== face || (\"inside\" === face && (context.save(), \n        context.beginPath(), context.arc(x, y, innerRadius, 0, vutils_1.pi2, !0, z_face.top), \n        context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, \"outside\" === face ? outerRadius : innerRadius, ((startAngle, endAngle) => {\n            const {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle);\n            return \"outside\" === face ? {\n                innerouterDeltaAngle: outerDeltaAngle,\n                innerouterEndAngle: outerEndAngle,\n                innerouterStartAngle: outerStartAngle\n            } : {\n                innerouterDeltaAngle: innerDeltaAngle,\n                innerouterEndAngle: innerEndAngle,\n                innerouterStartAngle: innerStartAngle\n            };\n        })), context.setShadowStyle && context.setShadowStyle(arc, arc.attribute, arcAttribute), \n        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), \n        context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), \n        doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), \n        context.stroke())), \"inside\" === face && context.restore());\n    }\n    draw(arc, renderService, drawContext, params) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc;\n        context.save();\n        const data = this.transform(arc, arcAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        this.z = z, (0, utils_1.drawPathProxy)(arc, context, x, y, drawContext, params) || (this.drawShape(arc, context, x, y, drawContext, params), \n        this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n        context.modelMatrix = lastModelMatrix), context.restore();\n    }\n};\n\nDefaultCanvasArc3DRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasArc3DRender), \nexports.DefaultCanvasArc3DRender = DefaultCanvasArc3DRender;\n//# sourceMappingURL=arc3d-render.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasPyramid3dRender = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\"), utils_1 = require(\"./utils\"), color_string_1 = require(\"../../../color-string\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), base_render_1 = require(\"./base-render\");\n\nlet DefaultCanvasPyramid3dRender = class extends base_render_1.BaseRender {\n    constructor() {\n        super(...arguments), this.type = \"pyramid3d\", this.numberType = constants_1.PYRAMID3D_NUMBER_TYPE;\n    }\n    drawShape(pyramid3d, context, x, y, drawContext, params, fillCb, strokeCb) {\n        var _a;\n        const pyramidAttribute = (0, theme_1.getTheme)(pyramid3d, null == params ? void 0 : params.theme).polygon, {fill: fill = pyramidAttribute.fill, stroke: stroke = pyramidAttribute.stroke, opacity: opacity = pyramidAttribute.opacity, fillOpacity: fillOpacity = pyramidAttribute.fillOpacity, lineWidth: lineWidth = pyramidAttribute.lineWidth, strokeOpacity: strokeOpacity = pyramidAttribute.strokeOpacity, visible: visible = pyramidAttribute.visible, points: points, face: face = [ !0, !0, !0, !0, !0, !0 ]} = pyramid3d.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = (0, \n        utils_1.fillVisible)(opacity, fillOpacity), sVisible = (0, utils_1.strokeVisible)(opacity, strokeOpacity), doFill = (0, \n        utils_1.runFill)(fill), doStroke = (0, utils_1.runStroke)(stroke, lineWidth);\n        if (!pyramid3d.valid || !visible || 4 !== points.length) return;\n        if (!doFill && !doStroke) return;\n        if (!(fVisible || sVisible || fillCb || strokeCb)) return;\n        const {light: light, camera: camera} = drawContext.stage || {}, face3d = pyramid3d.findFace();\n        if (!1 !== fill) {\n            context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);\n            let fc = fill;\n            \"string\" != typeof fc && (fc = \"black\"), this.fill(x, y, z, face3d, face, fc, context, light, camera, pyramid3d, pyramidAttribute, fillCb);\n        }\n        !1 !== stroke && (context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute), \n        this.stroke(x, y, z, face3d, context));\n    }\n    stroke(x, y, z, face3d, context) {\n        const vertices = face3d.vertices;\n        face3d.edges.forEach((p => {\n            const p1 = vertices[p[0]], p2 = vertices[p[1]], v1 = {\n                x: x + p1[0],\n                y: y + p1[1],\n                z: z + p1[2]\n            }, v2 = {\n                x: x + p2[0],\n                y: y + p2[1],\n                z: z + p2[2]\n            };\n            context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), \n            context.stroke();\n        }));\n    }\n    fill(x, y, z, face3d, faces, fillColor, context, light, camera, pyramid3d, pyramid3dAttribute, fillCb) {\n        const rgbArray = color_string_1.colorString.get(fillColor).value, vertices = face3d.vertices, viewdVerticesZ = vertices.map((v => context.view(v[0], v[1], v[2])[2])), sortFace = [];\n        face3d.polygons.forEach(((p, i) => {\n            if (!faces[i]) return;\n            sortFace.push({\n                faceIdx: i,\n                polygon: p\n            });\n            const {polygon: polygon, normal: normal} = p, z1 = viewdVerticesZ[polygon[0]], z2 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];\n            p.ave_z = z1 + z2 + z3 + z4;\n        })), sortFace.sort(((a, b) => b.polygon.ave_z - a.polygon.ave_z)), sortFace.forEach((item => {\n            const {polygon: polygon, normal: normal} = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {\n                x: x + p1[0],\n                y: y + p1[1],\n                z: z + p1[2]\n            }, v2 = {\n                x: x + p2[0],\n                y: y + p2[1],\n                z: z + p2[2]\n            }, v3 = {\n                x: x + p3[0],\n                y: y + p3[1],\n                z: z + p3[2]\n            }, v4 = {\n                x: x + p4[0],\n                y: y + p4[1],\n                z: z + p4[2]\n            };\n            context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), \n            context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), \n            fillCb ? fillCb(context, pyramid3d.attribute, pyramid3dAttribute) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, \n            context.fill());\n        }));\n    }\n    draw(pyramid3d, renderService, drawContext) {\n        const {context: context} = drawContext;\n        if (!context) return;\n        context.highPerformanceSave();\n        const pyramid3dAttribute = (0, theme_1.getTheme)(pyramid3d).polygon, data = this.transform(pyramid3d, pyramid3dAttribute, context), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        this.z = z, this.drawShape(pyramid3d, context, x, y, drawContext), this.z = 0, context.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(context.modelMatrix), \n        context.modelMatrix = lastModelMatrix, context.highPerformanceRestore();\n    }\n};\n\nDefaultCanvasPyramid3dRender = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasPyramid3dRender), \nexports.DefaultCanvasPyramid3dRender = DefaultCanvasPyramid3dRender;\n//# sourceMappingURL=pyramid3d-render.js.map\n","\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst module_1 = __importDefault(require(\"./canvas-picker/module\")), module_2 = __importDefault(require(\"./math-picker/module\"));\n\nfunction load(container) {\n    container.load(module_1.default), container.load(module_2.default);\n}\n\nexports.default = load;\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), circle_picker_1 = require(\"./circle-picker\"), rect_picker_1 = require(\"./rect-picker\"), arc_picker_1 = require(\"./arc-picker\"), area_picker_1 = require(\"./area-picker\"), image_picker_1 = require(\"./image-picker\"), line_picker_1 = require(\"./line-picker\"), path_picker_1 = require(\"./path-picker\"), symbol_picker_1 = require(\"./symbol-picker\"), text_picker_1 = require(\"./text-picker\"), constants_1 = require(\"../constants\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), polygon_picker_1 = require(\"./polygon-picker\"), richtext_picker_1 = require(\"./richtext-picker\"), glyph_picker_1 = require(\"./glyph-picker\"), rect3d_picker_1 = require(\"./rect3d-picker\"), pyramid3d_picker_1 = require(\"./pyramid3d-picker\"), arc3d_picker_1 = require(\"./arc3d-picker\");\n\nexports.default = new inversify_1.ContainerModule(((bind, unbind, isBound, rebind) => {\n    bind(circle_picker_1.DefaultCanvasCirclePicker).toSelf().inSingletonScope(), bind(constants_1.CanvasCirclePicker).toService(circle_picker_1.DefaultCanvasCirclePicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasCirclePicker), \n    bind(rect_picker_1.DefaultCanvasRectPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasRectPicker).toService(rect_picker_1.DefaultCanvasRectPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasRectPicker), \n    bind(rect3d_picker_1.DefaultCanvasRect3dPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasRect3dPicker).toService(rect3d_picker_1.DefaultCanvasRect3dPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasRect3dPicker), \n    bind(arc_picker_1.DefaultCanvasArcPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasArcPicker).toService(arc_picker_1.DefaultCanvasArcPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasArcPicker), \n    bind(area_picker_1.DefaultCanvasAreaPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasAreaPicker).toService(area_picker_1.DefaultCanvasAreaPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasAreaPicker), \n    bind(image_picker_1.DefaultCanvasImagePicker).toSelf().inSingletonScope(), bind(constants_1.CanvasImagePicker).toService(image_picker_1.DefaultCanvasImagePicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasImagePicker), \n    bind(line_picker_1.DefaultCanvasLinePicker).toSelf().inSingletonScope(), bind(constants_1.CanvasLinePicker).toService(line_picker_1.DefaultCanvasLinePicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasLinePicker), \n    bind(path_picker_1.DefaultCanvasPathPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasPathPicker).toService(path_picker_1.DefaultCanvasPathPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasPathPicker), \n    bind(symbol_picker_1.DefaultCanvasSymbolPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasSymbolPicker).toService(symbol_picker_1.DefaultCanvasSymbolPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasSymbolPicker), \n    bind(text_picker_1.DefaultCanvasTextPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasTextPicker).toService(text_picker_1.DefaultCanvasTextPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasTextPicker), \n    bind(polygon_picker_1.DefaultCanvasPolygonPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasPolygonPicker).toService(polygon_picker_1.DefaultCanvasPolygonPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasPolygonPicker), \n    bind(pyramid3d_picker_1.DefaultCanvasPyramid3dPicker).toSelf().inSingletonScope(), \n    bind(constants_1.CanvasPyramid3dPicker).toService(pyramid3d_picker_1.DefaultCanvasPyramid3dPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasPyramid3dPicker), \n    bind(arc3d_picker_1.DefaultCanvasArc3dPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasArc3dPicker).toService(arc3d_picker_1.DefaultCanvasArc3dPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasArc3dPicker), \n    bind(richtext_picker_1.DefaultCanvasRichTextPicker).toSelf().inSingletonScope(), \n    bind(constants_1.CanvasRichTextPicker).toService(richtext_picker_1.DefaultCanvasRichTextPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasRichTextPicker), \n    bind(glyph_picker_1.DefaultCanvasGlyphPicker).toSelf().inSingletonScope(), bind(constants_1.CanvasGlyphPicker).toService(glyph_picker_1.DefaultCanvasGlyphPicker), \n    bind(constants_1.CanvasPickerContribution).toService(constants_1.CanvasGlyphPicker), \n    (0, contribution_provider_1.bindContributionProvider)(bind, constants_1.CanvasPickerContribution);\n}));\n//# sourceMappingURL=module.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasCirclePicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), canvas_utils_1 = require(\"../../../common/canvas-utils\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasCirclePicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"circle\", this.numberType = constants_1.CIRCLE_NUMBER_TYPE;\n    }\n    contains(circle, point, params) {\n        if (!circle.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === circle.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const circleAttribute = (0, theme_1.getTheme)(circle).circle;\n        let {x: x = circleAttribute.x, y: y = circleAttribute.y} = circle.attribute;\n        if (pickContext.highPerformanceSave(), circle.transMatrix.onlyTranslate()) {\n            const point = circle.getOffsetXY(circleAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(circle.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(circle, pickContext, x, y, {}, null, ((context, circleAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, circleAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), \n            picked = context.isPointInStroke(point.x, point.y), picked;\n        })), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultCanvasCirclePicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.CircleRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasCirclePicker), \nexports.DefaultCanvasCirclePicker = DefaultCanvasCirclePicker;\n//# sourceMappingURL=circle-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasRectPicker = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), canvas_utils_1 = require(\"../../../common/canvas-utils\"), inversify_1 = require(\"inversify\"), graphic_1 = require(\"../../../graphic\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\"), _bounds = new vutils_1.AABBBounds;\n\nlet DefaultCanvasRectPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"rect\", this.numberType = constants_1.RECT_NUMBER_TYPE;\n    }\n    contains(rect, point, params) {\n        if (!rect.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === rect.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const rectAttribute = (0, graphic_1.getTheme)(rect).rect, {cornerRadius: cornerRadius = rectAttribute.cornerRadius} = rect.attribute;\n        let {x: x = rectAttribute.x, y: y = rectAttribute.y} = rect.attribute;\n        pickContext.highPerformanceSave();\n        let onlyTranslate = !0;\n        if (rect.transMatrix.onlyTranslate()) {\n            const point = rect.getOffsetXY(rectAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);\n        let picked = !0;\n        if (!onlyTranslate || (0, vutils_1.isNumber)(cornerRadius, !0) && 0 !== cornerRadius || (0, \n        vutils_1.isArray)(cornerRadius) && cornerRadius.some((num => 0 !== num))) picked = !1, \n        this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, ((context, rectAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, rectAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), \n            picked = context.isPointInStroke(point.x, point.y), picked;\n        })); else if (picked) {\n            const {fill: fill = rectAttribute.fill, stroke: stroke = rectAttribute.stroke, lineWidth: lineWidth = rectAttribute.lineWidth} = rect.attribute;\n            if (fill) picked = !0; else if (stroke) {\n                const bounds = rect.AABBBounds;\n                _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), \n                picked = !_bounds.containsPoint(point);\n            }\n        }\n        return pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultCanvasRectPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.RectRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasRectPicker), \nexports.DefaultCanvasRectPicker = DefaultCanvasRectPicker;\n//# sourceMappingURL=rect-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasArcPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), canvas_utils_1 = require(\"../../../common/canvas-utils\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasArcPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"arc\", this.numberType = constants_1.ARC_NUMBER_TYPE;\n    }\n    contains(arc, point, params) {\n        if (!arc.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === arc.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const arcAttribute = (0, theme_1.getTheme)(arc).arc;\n        pickContext.highPerformanceSave();\n        let {x: x = arcAttribute.x, y: y = arcAttribute.y} = arc.attribute;\n        if (arc.transMatrix.onlyTranslate()) {\n            const point = arc.getOffsetXY(arcAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(arc.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, ((context, arcAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, arcAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), \n            picked = context.isPointInStroke(point.x, point.y), picked;\n        })), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultCanvasArcPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.ArcRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasArcPicker), \nexports.DefaultCanvasArcPicker = DefaultCanvasArcPicker;\n//# sourceMappingURL=arc-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasAreaPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasAreaPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"area\", this.numberType = constants_1.AREA_NUMBER_TYPE;\n    }\n    contains(area, point, params) {\n        if (!area.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === area.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const areaAttribute = (0, theme_1.getTheme)(area).area;\n        let {x: x = areaAttribute.x, y: y = areaAttribute.y} = area.attribute;\n        if (pickContext.highPerformanceSave(), area.transMatrix.onlyTranslate()) {\n            const point = area.getOffsetXY(areaAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(area.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(area, pickContext, x, y, {}, null, (context => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked))), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultCanvasAreaPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.AreaRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasAreaPicker), \nexports.DefaultCanvasAreaPicker = DefaultCanvasAreaPicker;\n//# sourceMappingURL=area-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasImagePicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasImagePicker = class {\n    constructor() {\n        this.type = \"image\", this.numberType = constants_1.IMAGE_NUMBER_TYPE;\n    }\n    contains(image, point, params) {\n        const {pickContext: pickContext} = null != params ? params : {};\n        return !!pickContext && !!image.AABBBounds.containsPoint(point);\n    }\n};\n\nDefaultCanvasImagePicker = __decorate([ (0, inversify_1.injectable)() ], DefaultCanvasImagePicker), \nexports.DefaultCanvasImagePicker = DefaultCanvasImagePicker;\n//# sourceMappingURL=image-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasLinePicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), render_1 = require(\"../../../render\"), theme_1 = require(\"../../../graphic/theme\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), canvas_utils_1 = require(\"../../../common/canvas-utils\"), base_picker_1 = require(\"./base-picker\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasLinePicker = class extends base_picker_1.BasePicker {\n    constructor(canvasRenderer) {\n        super(), this.canvasRenderer = canvasRenderer, this.type = \"line\", this.numberType = constants_1.LINE_NUMBER_TYPE;\n    }\n    contains(line, point, params) {\n        if (!line.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === line.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        pickContext.highPerformanceSave();\n        const lineAttribute = (0, theme_1.getTheme)(line).line, data = this.transform(line, lineAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        let pickPoint = point;\n        if (pickContext.camera) {\n            pickPoint = point.clone();\n            const globalMatrix = line.parent.globalTransMatrix;\n            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, \n            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;\n        }\n        this.canvasRenderer.z = z;\n        let picked = !1;\n        return this.canvasRenderer.drawShape(line, pickContext, x, y, {}, null, (context => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), \n        picked)), ((context, circleAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), \n            picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;\n        })), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), \n        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), \n        picked;\n    }\n};\n\nDefaultCanvasLinePicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.LineRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasLinePicker), \nexports.DefaultCanvasLinePicker = DefaultCanvasLinePicker;\n//# sourceMappingURL=line-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.BasePicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), base_render_1 = require(\"../../../render/contributions/render/base-render\");\n\nlet BasePicker = class extends base_render_1.BaseRender {};\n\nBasePicker = __decorate([ (0, inversify_1.injectable)() ], BasePicker), exports.BasePicker = BasePicker;\n//# sourceMappingURL=base-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasPathPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), canvas_utils_1 = require(\"../../../common/canvas-utils\"), base_picker_1 = require(\"./base-picker\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasPathPicker = class extends base_picker_1.BasePicker {\n    constructor(canvasRenderer) {\n        super(), this.canvasRenderer = canvasRenderer, this.type = \"path\", this.numberType = constants_1.PATH_NUMBER_TYPE;\n    }\n    contains(path, point, params) {\n        if (!path.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === path.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const pathAttribute = (0, theme_1.getTheme)(path).path;\n        pickContext.highPerformanceSave();\n        const data = this.transform(path, pathAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        let pickPoint = point;\n        if (pickContext.camera) {\n            pickPoint = point.clone();\n            const globalMatrix = path.parent.globalTransMatrix;\n            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, \n            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;\n        }\n        this.canvasRenderer.z = z;\n        let picked = !1;\n        return this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, ((context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), \n        picked)), ((context, pathAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), \n            picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;\n        })), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), \n        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), \n        picked;\n    }\n};\n\nDefaultCanvasPathPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.PathRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasPathPicker), \nexports.DefaultCanvasPathPicker = DefaultCanvasPathPicker;\n//# sourceMappingURL=path-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasSymbolPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), canvas_utils_1 = require(\"../../../common/canvas-utils\"), base_picker_1 = require(\"./base-picker\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasSymbolPicker = class extends base_picker_1.BasePicker {\n    constructor(canvasRenderer) {\n        super(), this.canvasRenderer = canvasRenderer, this.type = \"symbol\", this.numberType = constants_1.SYMBOL_NUMBER_TYPE;\n    }\n    contains(symbol, point, params) {\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        if (!pickContext.camera) {\n            if (!symbol.AABBBounds.containsPoint(point)) return !1;\n            if (\"imprecise\" === symbol.attribute.pickMode) return !0;\n        }\n        pickContext.highPerformanceSave();\n        const symbolAttribute = (0, theme_1.getTheme)(symbol).symbol, data = this.transform(symbol, symbolAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        let pickPoint = point;\n        if (pickContext.camera) {\n            pickPoint = point.clone();\n            const globalMatrix = symbol.parent.globalTransMatrix;\n            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, \n            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;\n        }\n        this.canvasRenderer.z = z;\n        let picked = !1;\n        return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, ((context, symbolAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), \n        picked)), ((context, symbolAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = (0, canvas_utils_1.getScaledStroke)(pickContext, lineWidth, pickContext.dpr), \n            picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;\n        })), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), \n        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), \n        picked;\n    }\n};\n\nDefaultCanvasSymbolPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.SymbolRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasSymbolPicker), \nexports.DefaultCanvasSymbolPicker = DefaultCanvasSymbolPicker;\n//# sourceMappingURL=symbol-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasTextPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), base_picker_1 = require(\"./base-picker\"), render_1 = require(\"../../../render\"), text_1 = require(\"../../../common/text\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasTextPicker = class extends base_picker_1.BasePicker {\n    constructor(canvasRenderer) {\n        super(), this.canvasRenderer = canvasRenderer, this.type = \"text\", this.numberType = constants_1.TEXT_NUMBER_TYPE;\n    }\n    contains(text, point, params) {\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const bounds = text.AABBBounds;\n        if (!pickContext.camera) return !!bounds.containsPoint(point);\n        pickContext.highPerformanceSave();\n        const textAttribute = (0, theme_1.getTheme)(text).text, {keepDirIn3d: keepDirIn3d = textAttribute.keepDirIn3d} = text.attribute, computed3dMatrix = !keepDirIn3d, data = this.transform(text, textAttribute, pickContext, computed3dMatrix), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        this.canvasRenderer.z = z;\n        let pickPoint = point;\n        if (pickContext.camera) {\n            pickPoint = point.clone();\n            const globalMatrix = text.parent.globalTransMatrix;\n            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, \n            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;\n        }\n        let picked = !1;\n        return this.canvasRenderer.drawShape(text, pickContext, x, y, {}, null, ((context, symbolAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const {fontSize: fontSize = textAttribute.fontSize, textBaseline: textBaseline = textAttribute.textBaseline, textAlign: textAlign = textAttribute.textAlign} = text.attribute, bounds = text.AABBBounds, height = bounds.height(), width = bounds.width(), offsetY = (0, \n            text_1.textLayoutOffsetY)(textBaseline, height, fontSize), offsetX = (0, text_1.textDrawOffsetX)(textAlign, width);\n            return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), \n            picked;\n        }), ((context, symbolAttribute, themeAttribute) => picked)), this.canvasRenderer.z = 0, \n        pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), \n        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), \n        picked;\n    }\n};\n\nDefaultCanvasTextPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.TextRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasTextPicker), \nexports.DefaultCanvasTextPicker = DefaultCanvasTextPicker;\n//# sourceMappingURL=text-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasPolygonPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultCanvasPolygonPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"polygon\", this.numberType = constants_1.POLYGON_NUMBER_TYPE;\n    }\n    contains(polygon, point, params) {\n        if (!polygon.AABBBounds.contains(point.x, point.y)) return !1;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const polygonAttribute = (0, theme_1.getTheme)(polygon).polygon;\n        let {x: x = polygonAttribute.x, y: y = polygonAttribute.y} = polygon.attribute;\n        if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {\n            const point = polygon.getOffsetXY(polygonAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(polygon.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, ((context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, pathAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), \n            picked;\n        })), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultCanvasPolygonPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.PolygonRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasPolygonPicker), \nexports.DefaultCanvasPolygonPicker = DefaultCanvasPolygonPicker;\n//# sourceMappingURL=polygon-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasRichTextPicker = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), constants_1 = require(\"../../../graphic/constants\"), render_1 = require(\"../../../render\"), _bounds = new vutils_1.AABBBounds;\n\nlet DefaultCanvasRichTextPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"richtext\", this.numberType = constants_1.RICHTEXT_NUMBER_TYPE;\n    }\n    contains(richtext, point, params) {\n        return !!richtext.AABBBounds.containsPoint(point);\n    }\n};\n\nDefaultCanvasRichTextPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.RichTextRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasRichTextPicker), \nexports.DefaultCanvasRichTextPicker = DefaultCanvasRichTextPicker;\n//# sourceMappingURL=richtext-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasGlyphPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), constants_1 = require(\"../../../graphic/constants\"), render_1 = require(\"../../../render\");\n\nlet DefaultCanvasGlyphPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"glyph\", this.numberType = constants_1.GLYPH_NUMBER_TYPE;\n    }\n    contains(glyph, point, params) {\n        if (!glyph.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === glyph.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const pickerService = null == params ? void 0 : params.pickerService;\n        if (pickerService) {\n            let picked = !1;\n            return glyph.getSubGraphic().forEach((g => {\n                picked || (picked = !!pickerService.pickItem(g, point, params));\n            })), picked;\n        }\n        return !1;\n    }\n};\n\nDefaultCanvasGlyphPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.GlyphRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasGlyphPicker), \nexports.DefaultCanvasGlyphPicker = DefaultCanvasGlyphPicker;\n//# sourceMappingURL=glyph-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasRect3dPicker = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), render_1 = require(\"../../../render\"), base_picker_1 = require(\"./base-picker\"), constants_1 = require(\"../../../graphic/constants\"), _bounds = new vutils_1.AABBBounds;\n\nlet DefaultCanvasRect3dPicker = class extends base_picker_1.BasePicker {\n    constructor(canvasRenderer) {\n        super(), this.canvasRenderer = canvasRenderer, this.type = \"rect3d\", this.numberType = constants_1.RECT3D_NUMBER_TYPE;\n    }\n    contains(rect, point, params) {\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const rectAttribute = (0, theme_1.getTheme)(rect).rect;\n        pickContext.highPerformanceSave();\n        const data = this.transform(rect, rectAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        let pickPoint = point;\n        if (pickContext.camera) {\n            pickPoint = point.clone();\n            const globalMatrix = rect.parent.globalTransMatrix;\n            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, \n            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;\n        }\n        this.canvasRenderer.z = z;\n        let picked = !1;\n        return this.canvasRenderer.drawShape(rect, pickContext, x, y, params, null, ((context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), \n        picked))), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), \n        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), \n        picked;\n    }\n};\n\nDefaultCanvasRect3dPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.Rect3DRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasRect3dPicker), \nexports.DefaultCanvasRect3dPicker = DefaultCanvasRect3dPicker;\n//# sourceMappingURL=rect3d-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasPyramid3dPicker = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), base_picker_1 = require(\"./base-picker\"), constants_1 = require(\"../../../graphic/constants\"), _bounds = new vutils_1.AABBBounds;\n\nlet DefaultCanvasPyramid3dPicker = class extends base_picker_1.BasePicker {\n    constructor(canvasRenderer) {\n        super(), this.canvasRenderer = canvasRenderer, this.type = \"pyramid3d\", this.numberType = constants_1.PYRAMID3D_NUMBER_TYPE;\n    }\n    contains(pyramid3d, point, params) {\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const pyramid3dAttribute = (0, theme_1.getTheme)(pyramid3d).polygon;\n        pickContext.highPerformanceSave();\n        const data = this.transform(pyramid3d, pyramid3dAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        let pickPoint = point;\n        if (pickContext.camera) {\n            pickPoint = point.clone();\n            const globalMatrix = pyramid3d.parent.globalTransMatrix;\n            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, \n            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;\n        }\n        this.canvasRenderer.z = z;\n        let picked = !1;\n        return this.canvasRenderer.drawShape(pyramid3d, pickContext, x, y, {}, null, ((context, pyramid3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), \n        picked)), ((context, pyramid3dAttribute, themeAttribute) => !1)), this.canvasRenderer.z = 0, \n        pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), \n        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), \n        picked;\n    }\n};\n\nDefaultCanvasPyramid3dPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.Pyramid3dRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasPyramid3dPicker), \nexports.DefaultCanvasPyramid3dPicker = DefaultCanvasPyramid3dPicker;\n//# sourceMappingURL=pyramid3d-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultCanvasArc3dPicker = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), matrix_allocate_1 = require(\"../../../allocator/matrix-allocate\"), base_picker_1 = require(\"./base-picker\"), constants_1 = require(\"../../../graphic/constants\"), _bounds = new vutils_1.AABBBounds;\n\nlet DefaultCanvasArc3dPicker = class extends base_picker_1.BasePicker {\n    constructor(canvasRenderer) {\n        super(), this.canvasRenderer = canvasRenderer, this.type = \"arc3d\", this.numberType = constants_1.ARC3D_NUMBER_TYPE;\n    }\n    contains(arc3d, point, params) {\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const arc3dAttribute = (0, theme_1.getTheme)(arc3d).arc;\n        pickContext.highPerformanceSave();\n        const data = this.transform(arc3d, arc3dAttribute, pickContext), {x: x, y: y, z: z, lastModelMatrix: lastModelMatrix} = data;\n        let pickPoint = point;\n        if (pickContext.camera) {\n            pickPoint = point.clone();\n            const globalMatrix = arc3d.parent.globalTransMatrix;\n            pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, \n            pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;\n        }\n        this.canvasRenderer.z = z;\n        let picked = !1;\n        return this.canvasRenderer.drawShape(arc3d, pickContext, x, y, params, null, ((context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), \n        picked))), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && matrix_allocate_1.mat4Allocate.free(pickContext.modelMatrix), \n        pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), \n        picked;\n    }\n};\n\nDefaultCanvasArc3dPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.Arc3dRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultCanvasArc3dPicker), \nexports.DefaultCanvasArc3dPicker = DefaultCanvasArc3dPicker;\n//# sourceMappingURL=arc3d-picker.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), path_picker_1 = require(\"./path-picker\"), constants_1 = require(\"../constants\"), contribution_provider_1 = require(\"../../../common/contribution-provider\"), circle_picker_1 = require(\"./circle-picker\"), rect_picker_1 = require(\"./rect-picker\"), arc_picker_1 = require(\"./arc-picker\"), area_picker_1 = require(\"./area-picker\"), line_picker_1 = require(\"./line-picker\"), symbol_picker_1 = require(\"./symbol-picker\"), text_picker_1 = require(\"./text-picker\"), polygon_picker_1 = require(\"./polygon-picker\"), glyph_picker_1 = require(\"./glyph-picker\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(circle_picker_1.DefaultMathCirclePicker).toSelf().inSingletonScope(), bind(constants_1.MathCirclePicker).toService(circle_picker_1.DefaultMathCirclePicker), \n    bind(constants_1.MathPickerContribution).toService(constants_1.MathCirclePicker), \n    bind(rect_picker_1.DefaultMathRectPicker).toSelf().inSingletonScope(), bind(constants_1.MathRectPicker).toService(rect_picker_1.DefaultMathRectPicker), \n    bind(constants_1.MathPickerContribution).toService(constants_1.MathRectPicker), \n    bind(arc_picker_1.DefaultMathArcPicker).toSelf().inSingletonScope(), bind(constants_1.MathArcPicker).toService(arc_picker_1.DefaultMathArcPicker), \n    bind(constants_1.MathPickerContribution).toService(constants_1.MathArcPicker), bind(area_picker_1.DefaultMathAreaPicker).toSelf().inSingletonScope(), \n    bind(constants_1.MathAreaPicker).toService(area_picker_1.DefaultMathAreaPicker), \n    bind(constants_1.MathPickerContribution).toService(constants_1.MathAreaPicker), \n    bind(line_picker_1.DefaultMathLinePicker).toSelf().inSingletonScope(), bind(constants_1.MathLinePicker).toService(line_picker_1.DefaultMathLinePicker), \n    bind(constants_1.MathPickerContribution).toService(constants_1.MathLinePicker), \n    bind(path_picker_1.DefaultMathPathPicker).toSelf().inSingletonScope(), bind(constants_1.MathPathPicker).toService(path_picker_1.DefaultMathPathPicker), \n    bind(constants_1.MathPickerContribution).toService(constants_1.MathPathPicker), \n    bind(symbol_picker_1.DefaultMathSymbolPicker).toSelf().inSingletonScope(), bind(constants_1.MathSymbolPicker).toService(symbol_picker_1.DefaultMathSymbolPicker), \n    bind(constants_1.MathPickerContribution).toService(constants_1.MathSymbolPicker), \n    bind(text_picker_1.DefaultMathTextPicker).toSelf().inSingletonScope(), bind(constants_1.MathTextPicker).toService(text_picker_1.DefaultMathTextPicker), \n    bind(constants_1.MathPickerContribution).toService(constants_1.MathTextPicker), \n    bind(polygon_picker_1.DefaultMathPolygonPicker).toSelf().inSingletonScope(), bind(constants_1.MathPolygonPicker).toService(polygon_picker_1.DefaultMathPolygonPicker), \n    bind(constants_1.MathPickerContribution).toService(constants_1.MathPolygonPicker), \n    bind(glyph_picker_1.DefaultMathGlyphPicker).toSelf().inSingletonScope(), bind(constants_1.MathGlyphPicker).toService(glyph_picker_1.DefaultMathGlyphPicker), \n    bind(glyph_picker_1.DefaultMathGlyphPicker).toService(constants_1.MathGlyphPicker), \n    (0, contribution_provider_1.bindContributionProvider)(bind, constants_1.MathPickerContribution);\n}));\n//# sourceMappingURL=module.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathPathPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultMathPathPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"path\", this.numberType = constants_1.PATH_NUMBER_TYPE;\n    }\n    contains(path, point, params) {\n        if (!path.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === path.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const pathAttribute = (0, theme_1.getTheme)(path).path;\n        let {x: x = pathAttribute.x, y: y = pathAttribute.y} = path.attribute;\n        if (pickContext.highPerformanceSave(), path.transMatrix.onlyTranslate()) {\n            const point = path.getOffsetXY(pathAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(path.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, ((context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, pathAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), \n            picked;\n        })), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultMathPathPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.PathRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultMathPathPicker), \nexports.DefaultMathPathPicker = DefaultMathPathPicker;\n//# sourceMappingURL=path-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathCirclePicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultMathCirclePicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"circle\", this.numberType = constants_1.CIRCLE_NUMBER_TYPE;\n    }\n    contains(circle, point, params) {\n        if (!circle.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === circle.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const circleAttribute = (0, theme_1.getTheme)(circle).circle;\n        let {x: x = circleAttribute.x, y: y = circleAttribute.y} = circle.attribute;\n        if (pickContext.highPerformanceSave(), circle.transMatrix.onlyTranslate()) {\n            const point = circle.getOffsetXY(circleAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(circle.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(circle, pickContext, x, y, {}, null, ((context, circleAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, circleAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), \n            picked;\n        })), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultMathCirclePicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.CircleRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultMathCirclePicker), \nexports.DefaultMathCirclePicker = DefaultMathCirclePicker;\n//# sourceMappingURL=circle-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathRectPicker = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\"), _bounds = new vutils_1.AABBBounds;\n\nlet DefaultMathRectPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"rect\", this.numberType = constants_1.RECT_NUMBER_TYPE;\n    }\n    contains(rect, point, params) {\n        if (!rect.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === rect.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const rectAttribute = (0, theme_1.getTheme)(rect).rect, {cornerRadius: cornerRadius = rectAttribute.cornerRadius} = rect.attribute;\n        let {x: x = rectAttribute.x, y: y = rectAttribute.y} = rect.attribute;\n        pickContext.highPerformanceSave();\n        let onlyTranslate = !0;\n        if (rect.transMatrix.onlyTranslate()) {\n            const point = rect.getOffsetXY(rectAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);\n        let picked = !0;\n        if (!onlyTranslate || (0, vutils_1.isNumber)(cornerRadius, !0) && 0 !== cornerRadius || (0, \n        vutils_1.isArray)(cornerRadius) && cornerRadius.some((num => 0 !== num))) picked = !1, \n        this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, ((context, rectAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, rectAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), \n            picked;\n        })); else if (picked) {\n            const {fill: fill = rectAttribute.fill, stroke: stroke = rectAttribute.stroke, lineWidth: lineWidth = rectAttribute.lineWidth} = rect.attribute;\n            if (fill) picked = !0; else if (stroke) {\n                const bounds = rect.AABBBounds;\n                _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), \n                picked = !_bounds.containsPoint(point);\n            }\n        }\n        return pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultMathRectPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.RectRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultMathRectPicker), \nexports.DefaultMathRectPicker = DefaultMathRectPicker;\n//# sourceMappingURL=rect-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathArcPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultMathArcPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"arc\", this.numberType = constants_1.ARC_NUMBER_TYPE;\n    }\n    contains(arc, point, params) {\n        if (!arc.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === arc.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const arcAttribute = (0, theme_1.getTheme)(arc).arc;\n        pickContext.highPerformanceSave();\n        let {x: x = arcAttribute.x, y: y = arcAttribute.y} = arc.attribute;\n        if (arc.transMatrix.onlyTranslate()) {\n            const point = arc.getOffsetXY(arcAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(arc.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, ((context, arcAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, arcAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), \n            picked;\n        })), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultMathArcPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.ArcRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultMathArcPicker), \nexports.DefaultMathArcPicker = DefaultMathArcPicker;\n//# sourceMappingURL=arc-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathAreaPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultMathAreaPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"area\", this.numberType = constants_1.AREA_NUMBER_TYPE;\n    }\n    contains(area, point, params) {\n        if (!area.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === area.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const areaAttribute = (0, theme_1.getTheme)(area).area;\n        let {x: x = areaAttribute.x, y: y = areaAttribute.y} = area.attribute;\n        if (pickContext.highPerformanceSave(), area.transMatrix.onlyTranslate()) {\n            const point = area.getOffsetXY(areaAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(area.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(area, pickContext, x, y, {}, null, (context => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked))), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultMathAreaPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.AreaRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultMathAreaPicker), \nexports.DefaultMathAreaPicker = DefaultMathAreaPicker;\n//# sourceMappingURL=area-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathLinePicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), render_1 = require(\"../../../render\"), theme_1 = require(\"../../../graphic/theme\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultMathLinePicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"line\", this.numberType = constants_1.LINE_NUMBER_TYPE;\n    }\n    contains(line, point, params) {\n        if (!line.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === line.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const lineAttribute = (0, theme_1.getTheme)(line).line;\n        let {x: x = lineAttribute.x, y: y = lineAttribute.y} = line.attribute;\n        if (pickContext.highPerformanceSave(), line.transMatrix.onlyTranslate()) {\n            const point = line.getOffsetXY(lineAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(line.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(line, pickContext, x, y, {}, null, (context => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, circleAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), \n            picked;\n        })), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultMathLinePicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.LineRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultMathLinePicker), \nexports.DefaultMathLinePicker = DefaultMathLinePicker;\n//# sourceMappingURL=line-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathSymbolPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultMathSymbolPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"symbol\", this.numberType = constants_1.SYMBOL_NUMBER_TYPE;\n    }\n    contains(symbol, point, params) {\n        if (!symbol.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === symbol.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const symbolAttribute = (0, theme_1.getTheme)(symbol).symbol;\n        let {x: x = symbolAttribute.x, y: y = symbolAttribute.y} = symbol.attribute;\n        if (pickContext.highPerformanceSave(), symbol.transMatrix.onlyTranslate()) {\n            const point = symbol.getOffsetXY(symbolAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(symbol.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, ((context, symbolAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, symbolAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), \n            picked;\n        })), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultMathSymbolPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.SymbolRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultMathSymbolPicker), \nexports.DefaultMathSymbolPicker = DefaultMathSymbolPicker;\n//# sourceMappingURL=symbol-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathTextPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultMathTextPicker = class {\n    constructor() {\n        this.type = \"text\", this.numberType = constants_1.TEXT_NUMBER_TYPE;\n    }\n    contains(text, point, params) {\n        return !!text.AABBBounds.containsPoint(point);\n    }\n};\n\nDefaultMathTextPicker = __decorate([ (0, inversify_1.injectable)() ], DefaultMathTextPicker), \nexports.DefaultMathTextPicker = DefaultMathTextPicker;\n//# sourceMappingURL=text-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathPolygonPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), theme_1 = require(\"../../../graphic/theme\"), render_1 = require(\"../../../render\"), constants_1 = require(\"../../../graphic/constants\");\n\nlet DefaultMathPolygonPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"polygon\", this.numberType = constants_1.POLYGON_NUMBER_TYPE;\n    }\n    contains(polygon, point, params) {\n        if (!polygon.AABBBounds.contains(point.x, point.y)) return !1;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const pathAttribute = (0, theme_1.getTheme)(polygon).polygon;\n        let {x: x = pathAttribute.x, y: y = pathAttribute.y} = polygon.attribute;\n        if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {\n            const point = polygon.getOffsetXY(pathAttribute);\n            x += point.x, y += point.y, pickContext.setTransformForCurrent();\n        } else x = 0, y = 0, pickContext.transformFromMatrix(polygon.transMatrix, !0);\n        let picked = !1;\n        return this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, ((context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), \n        picked)), ((context, pathAttribute, themeAttribute) => {\n            if (picked) return !0;\n            const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth;\n            return pickContext.lineWidth = lineWidth, picked = context.isPointInStroke(point.x, point.y), \n            picked;\n        })), pickContext.highPerformanceRestore(), picked;\n    }\n};\n\nDefaultMathPolygonPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.PolygonRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultMathPolygonPicker), \nexports.DefaultMathPolygonPicker = DefaultMathPolygonPicker;\n//# sourceMappingURL=polygon-picker.js.map\n","\n\nvar __decorate = this && this.__decorate || function(decorators, target, key, desc) {\n    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}, __metadata = this && this.__metadata || function(k, v) {\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.metadata) return Reflect.metadata(k, v);\n}, __param = this && this.__param || function(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DefaultMathGlyphPicker = void 0;\n\nconst inversify_1 = require(\"inversify\"), constants_1 = require(\"../../../graphic/constants\"), render_1 = require(\"../../../render\");\n\nlet DefaultMathGlyphPicker = class {\n    constructor(canvasRenderer) {\n        this.canvasRenderer = canvasRenderer, this.type = \"glyph\", this.numberType = constants_1.GLYPH_NUMBER_TYPE;\n    }\n    contains(glyph, point, params) {\n        if (!glyph.AABBBounds.containsPoint(point)) return !1;\n        if (\"imprecise\" === glyph.attribute.pickMode) return !0;\n        const {pickContext: pickContext} = null != params ? params : {};\n        if (!pickContext) return !1;\n        const pickerService = null == params ? void 0 : params.pickerService;\n        if (pickerService) {\n            let picked = !1;\n            return glyph.getSubGraphic().forEach((g => {\n                picked || (picked = !!pickerService.pickItem(g, point, params));\n            })), picked;\n        }\n        return !1;\n    }\n};\n\nDefaultMathGlyphPicker = __decorate([ (0, inversify_1.injectable)(), __param(0, (0, \ninversify_1.inject)(render_1.GlyphRender)), __metadata(\"design:paramtypes\", [ Object ]) ], DefaultMathGlyphPicker), \nexports.DefaultMathGlyphPicker = DefaultMathGlyphPicker;\n//# sourceMappingURL=glyph-picker.js.map\n","\n\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst modules_1 = __importDefault(require(\"./browser/modules\")), modules_2 = __importDefault(require(\"./taro/modules\")), modules_3 = __importDefault(require(\"./feishu/modules\")), modules_4 = __importDefault(require(\"./lynx/modules\")), modules_5 = __importDefault(require(\"./node/modules\"));\n\nfunction load(container) {\n    container.load(modules_1.default), container.load(modules_3.default), container.load(modules_2.default), \n    container.load(modules_4.default), container.load(modules_5.default);\n}\n\nexports.default = load;\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), canvas_1 = require(\"./canvas\"), context_1 = require(\"./context\"), constants_1 = require(\"../../constants\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.BrowserCanvas(params))).whenTargetNamed(canvas_1.BrowserCanvas.env), \n    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.BrowserContext2d(params, dpr))).whenTargetNamed(context_1.BrowserContext2d.env);\n}));\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), canvas_1 = require(\"./canvas\"), context_1 = require(\"./context\"), constants_1 = require(\"../../constants\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.TaroCanvas(params))).whenTargetNamed(canvas_1.TaroCanvas.env), \n    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.TaroContext2d(params, dpr))).whenTargetNamed(context_1.TaroContext2d.env);\n}));\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), canvas_1 = require(\"./canvas\"), context_1 = require(\"./context\"), constants_1 = require(\"../../constants\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.FeishuCanvas(params))).whenTargetNamed(canvas_1.FeishuCanvas.env), \n    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.FeishuContext2d(params, dpr))).whenTargetNamed(context_1.FeishuContext2d.env);\n}));\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), canvas_1 = require(\"./canvas\"), context_1 = require(\"./context\"), constants_1 = require(\"../../constants\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.LynxCanvas(params))).whenTargetNamed(canvas_1.LynxCanvas.env), \n    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.LynxContext2d(params, dpr))).whenTargetNamed(context_1.LynxContext2d.env);\n}));\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n\nconst inversify_1 = require(\"inversify\"), canvas_1 = require(\"./canvas\"), context_1 = require(\"./context\"), constants_1 = require(\"../../constants\");\n\nexports.default = new inversify_1.ContainerModule((bind => {\n    bind(constants_1.CanvasFactory).toDynamicValue((() => params => new canvas_1.NodeCanvas(params))).whenTargetNamed(canvas_1.NodeCanvas.env), \n    bind(constants_1.Context2dFactory).toDynamicValue((() => (params, dpr) => new context_1.NodeContext2d(params, dpr))).whenTargetNamed(context_1.NodeContext2d.env);\n}));\n//# sourceMappingURL=modules.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.createStage = void 0;\n\nconst stage_1 = require(\"./core/stage\");\n\nfunction createStage(params) {\n    return new stage_1.Stage(params);\n}\n\nexports.createStage = createStage;\n//# sourceMappingURL=create.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.Stage = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), window_1 = require(\"./window\"), layer_1 = require(\"./layer\"), event_1 = require(\"../event\"), container_1 = require(\"../container\"), render_1 = require(\"../render\"), graphic_1 = require(\"../graphic\"), picker_service_1 = require(\"../picker/picker-service\"), plugin_service_1 = require(\"../plugins/plugin-service\"), auto_render_plugin_1 = require(\"../plugins/builtin-plugin/auto-render-plugin\"), _3dview_transform_plugin_1 = require(\"../plugins/builtin-plugin/3dview-transform-plugin\"), incremental_auto_render_plugin_1 = require(\"../plugins/builtin-plugin/incremental-auto-render-plugin\"), dirty_bounds_plugin_1 = require(\"../plugins/builtin-plugin/dirty-bounds-plugin\"), default_ticker_1 = require(\"../animate/default-ticker\"), tapable_1 = require(\"../tapable\"), light_1 = require(\"./light\"), camera_1 = require(\"./camera\"), constants_1 = require(\"../constants\"), DefaultConfig = {\n    WIDTH: 500,\n    HEIGHT: 500,\n    X: 0,\n    Y: 0,\n    BACKGROUND: \"white\"\n};\n\nclass Stage extends graphic_1.Group {\n    set viewBox(b) {\n        this._viewBox.setValue(b.x1, b.y1, b.x2, b.y2);\n    }\n    get viewBox() {\n        return this._viewBox;\n    }\n    get x() {\n        return this._viewBox.x1;\n    }\n    set x(x) {\n        this._viewBox.translate(x - this._viewBox.x1, 0);\n    }\n    get y() {\n        return this._viewBox.y1;\n    }\n    set y(y) {\n        this._viewBox.translate(0, y - this._viewBox.y1);\n    }\n    get width() {\n        return this.window.width;\n    }\n    set width(w) {\n        this.resize(w, this.height);\n    }\n    get viewWidth() {\n        return this._viewBox.width();\n    }\n    set viewWidth(w) {\n        this.resizeView(w, this.viewHeight);\n    }\n    get viewHeight() {\n        return this._viewBox.height();\n    }\n    set viewHeight(h) {\n        this.resizeView(this.viewWidth, h);\n    }\n    get height() {\n        return this.window.height;\n    }\n    set height(h) {\n        this.resize(this.width, h);\n    }\n    get dpr() {\n        return this.window.dpr;\n    }\n    set dpr(r) {\n        this.setDpr(r);\n    }\n    get background() {\n        var _a;\n        return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND;\n    }\n    set background(b) {\n        this._background = b;\n    }\n    get defaultLayer() {\n        return this.at(0);\n    }\n    constructor(params) {\n        var _a;\n        super({}), this.beforeRender = stage => {\n            this._beforeRender && this._beforeRender(stage);\n        }, this.afterRender = stage => {\n            this.renderCount++, this._afterRender && this._afterRender(stage), this._afterNextRenderCbs && this._afterNextRenderCbs.forEach((cb => cb(stage))), \n            this._afterNextRenderCbs = null;\n        }, this.theme = new graphic_1.Theme, this.hooks = {\n            beforeRender: new tapable_1.SyncHook([ \"stage\" ]),\n            afterRender: new tapable_1.SyncHook([ \"stage\" ])\n        }, this.global = container_1.container.get(constants_1.Global), this.window = container_1.container.get(window_1.Window), \n        this.renderService = container_1.container.get(render_1.RenderService), this.pickerService = container_1.container.get(picker_service_1.PickerService), \n        this.pluginService = container_1.container.get(plugin_service_1.PluginService), \n        this.pluginService.active(this), this.window.create({\n            width: params.width,\n            height: params.height,\n            container: params.container,\n            dpr: params.dpr || this.global.devicePixelRatio,\n            canvasControled: !1 !== params.canvasControled,\n            title: params.title || \"\",\n            canvas: params.canvas\n        }), this._viewBox = new vutils_1.AABBBounds, params.viewBox ? this._viewBox.setValue(params.viewBox.x1, params.viewBox.y1, params.viewBox.x2, params.viewBox.y2) : this._viewBox.setValue(0, 0, this.width, this.height), \n        this.renderCount = 0, this._subView = !(this._viewBox.width() === this.width && this._viewBox.height() === this.height), \n        this._background = null !== (_a = params.background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND, \n        this.appendChild(new layer_1.Layer(this, this.global, this.window, {\n            main: !0\n        })), this.nextFrameRenderLayerSet = new Set, this.willNextFrameRender = !1, this.stage = this, \n        this.renderStyle = params.renderStyle, this.global.supportEvent && (this.eventSystem = new event_1.EventSystem({\n            targetElement: this.window,\n            resolution: this.window.dpr || this.global.devicePixelRatio,\n            rootNode: this,\n            global: this.global,\n            viewport: {\n                viewBox: this._viewBox,\n                get x() {\n                    return this.viewBox.x1;\n                },\n                get y() {\n                    return this.viewBox.y1;\n                },\n                get width() {\n                    return this.viewBox.width();\n                },\n                get height() {\n                    return this.viewBox.height();\n                }\n            }\n        })), params.autoRender && this.enableAutoRender(), !1 === params.disableDirtyBounds && this.enableDirtyBounds(), \n        this.hooks.beforeRender.tap(\"constructor\", this.beforeRender), this.hooks.afterRender.tap(\"constructor\", this.afterRender), \n        this._beforeRender = params.beforeRender, this._afterRender = params.afterRender, \n        this.ticker = params.ticker || default_ticker_1.defaultTicker;\n    }\n    get3dOptions(options) {\n        const {center: center = {\n            x: this.width / 2,\n            y: this.height / 2,\n            z: 0,\n            dx: 0,\n            dy: 0,\n            dz: 0\n        }, light: light = {}, alpha: alpha = 0, beta: beta = 0, camera: camera, fieldRatio: fieldRatio = 1, fieldDepth: fieldDepth} = options;\n        return Object.assign(Object.assign({}, options), {\n            center: center,\n            light: light,\n            alpha: alpha,\n            beta: beta,\n            camera: camera,\n            fieldRatio: fieldRatio,\n            fieldDepth: fieldDepth\n        });\n    }\n    set3dOptions(options) {\n        var _a, _b, _c, _d, _e, _f;\n        this.option3d = options;\n        const options3d = this.get3dOptions(options), {light: light, center: center, camera: camera, alpha: alpha, beta: beta, fieldRatio: fieldRatio, fieldDepth: fieldDepth} = options3d, {dir: dir = [ 1, 1, -1 ], color: color = \"white\", ambient: ambient} = light, centerX = (null !== (_a = center.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center.dx) && void 0 !== _b ? _b : 0), centerY = (null !== (_c = center.y) && void 0 !== _c ? _c : this.height / 2) + (null !== (_d = center.dy) && void 0 !== _d ? _d : 0), centerVec3 = [ centerX, centerY, (null !== (_e = center.z) && void 0 !== _e ? _e : 0) + (null !== (_f = center.dz) && void 0 !== _f ? _f : 0) ];\n        let cameraX = 0, cameraY = 0, cameraZ = 0;\n        camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, \n        cameraZ = Math.cos(alpha) * Math.cos(beta) * 1), this.light = new light_1.DirectionalLight(dir, color, ambient);\n        const cameraParams = {\n            left: 0,\n            right: this.width,\n            top: 0,\n            bottom: this.height,\n            fieldRatio: fieldRatio,\n            fieldDepth: fieldDepth,\n            viewParams: {\n                pos: [ cameraX, cameraY, cameraZ ],\n                center: centerVec3,\n                up: [ 0, 1, 0 ]\n            }\n        };\n        this.camera ? this.camera.params = cameraParams : this.camera = new camera_1.OrthoCamera(cameraParams), \n        options.enableView3dTransform && this.enableView3dTransform();\n    }\n    setBeforeRender(cb) {\n        this._beforeRender = cb;\n    }\n    setAfterRender(cb) {\n        this._afterRender = cb;\n    }\n    afterNextRender(cb) {\n        this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);\n    }\n    enableView3dTransform() {\n        this.view3dTranform || (this.view3dTranform = !0, this.pluginService.register(new _3dview_transform_plugin_1.ViewTransform3dPlugin));\n    }\n    disableView3dTranform() {\n        this.view3dTranform && (this.view3dTranform = !1, this.pluginService.findPluginsByName(\"ViewTransform3dPlugin\").forEach((plugin => {\n            plugin.deactivate(this.pluginService);\n        })));\n    }\n    enableAutoRender() {\n        this.autoRender || (this.autoRender = !0, this.pluginService.register(new auto_render_plugin_1.AutoRenderPlugin));\n    }\n    disableAutoRender() {\n        this.autoRender && (this.autoRender = !1, this.pluginService.findPluginsByName(\"AutoRenderPlugin\").forEach((plugin => {\n            plugin.deactivate(this.pluginService);\n        })));\n    }\n    enableIncrementalAutoRender() {\n        this.increaseAutoRender || (this.increaseAutoRender = !0, this.pluginService.register(new incremental_auto_render_plugin_1.IncrementalAutoRenderPlugin));\n    }\n    disableIncrementalAutoRender() {\n        this.increaseAutoRender && (this.increaseAutoRender = !1, this.pluginService.findPluginsByName(\"IncrementalAutoRenderPlugin\").forEach((plugin => {\n            plugin.deactivate(this.pluginService);\n        })));\n    }\n    enableDirtyBounds() {\n        if (this.dirtyBounds) return;\n        this.dirtyBounds = new vutils_1.Bounds;\n        let plugin = this.pluginService.findPluginsByName(\"DirtyBoundsPlugin\")[0];\n        plugin || (plugin = new dirty_bounds_plugin_1.DirtyBoundsPlugin, this.pluginService.register(plugin)), \n        plugin.activate(this.pluginService);\n    }\n    disableDirtyBounds() {\n        this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName(\"DirtyBoundsPlugin\").forEach((plugin => {\n            plugin.deactivate(this.pluginService);\n        })));\n    }\n    tryUpdateAABBBounds() {\n        const viewBox = this._viewBox;\n        return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), \n        this._AABBBounds;\n    }\n    combineLayer(ILayer1, ILayer2) {\n        throw new Error(\"\");\n    }\n    createLayer(canvasId) {\n        const layer = new layer_1.Layer(this, this.global, this.window, {\n            main: !1,\n            canvasId: canvasId\n        });\n        return this.appendChild(layer), layer;\n    }\n    sortLayer(cb) {\n        throw new Error(\"\");\n    }\n    removeLayer(ILayerId) {\n        return this.removeChild(this.findChildByUid(ILayerId));\n    }\n    clearViewBox(color) {\n        this.window.clearViewBox(this._viewBox, color);\n    }\n    render(layers, params) {\n        this.ticker.start(), this.lastRenderparams = params, this.hooks.beforeRender.call(this), \n        (layers || this).forEach(((layer, i) => {\n            layer.render({\n                renderService: this.renderService,\n                background: layer === this.defaultLayer ? this.background : void 0,\n                updateBounds: !!this.dirtyBounds\n            }, Object.assign({\n                renderStyle: this.renderStyle\n            }, params));\n        })), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear(), this.hooks.afterRender.call(this);\n    }\n    combineLayersToWindow() {\n        this.forEach(((layer, i) => {\n            layer.combineTo(this.window, {\n                clear: 0 === i,\n                x: this.x,\n                y: this.y,\n                width: this.viewWidth,\n                height: this.viewHeight,\n                renderService: this.renderService,\n                background: layer === this.defaultLayer ? this.background : void 0,\n                updateBounds: !!this.dirtyBounds\n            });\n        }));\n    }\n    renderNextFrame(layers) {\n        this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach((layer => {\n            this.nextFrameRenderLayerSet.add(layer);\n        })), this.willNextFrameRender || (this.willNextFrameRender = !0, this.global.getRequestAnimationFrame()((() => {\n            this._doRenderInThisFrame(), this.willNextFrameRender = !1;\n        })));\n    }\n    _doRenderInThisFrame() {\n        this.nextFrameRenderLayerSet.size && (this.ticker.start(), this.hooks.beforeRender.call(this), \n        this.forEach((layer => {\n            this.nextFrameRenderLayerSet.has(layer) && layer.render({\n                renderService: this.renderService,\n                background: layer === this.defaultLayer ? this.background : void 0,\n                updateBounds: !!this.dirtyBounds\n            }, Object.assign({\n                renderStyle: this.renderStyle\n            }, this.lastRenderparams || {}));\n        })), this.combineLayersToWindow(), this.hooks.afterRender.call(this), this.nextFrameRenderLayerSet.clear());\n    }\n    resizeWindow(w, h, rerender = !0) {\n        this.window.resize(w, h), rerender && this.render();\n    }\n    resize(w, h, rerender = !0) {\n        this.window.resize(w, h), this.forEachChildren((c => {\n            c.resize(w, h);\n        })), this._subView || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), \n        this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render();\n    }\n    resizeView(w, h, rerender = !0) {\n        this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), \n        this.forEachChildren((c => {\n            c.resizeView(w, h);\n        })), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {\n            right: this.width,\n            bottom: this.height\n        })), rerender && this.render();\n    }\n    setViewBox(x, y, w, h, rerender) {\n        let isRerender = !0;\n        \"object\" == typeof x ? (this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2), !1 === y && (isRerender = !1)) : (this.viewBox.setValue(x, y, x + w, y + h), \n        !1 === rerender && (isRerender = !1)), this.forEachChildren((c => {\n            c.resizeView(this.viewBox.width(), this.viewBox.height());\n        })), isRerender && this.render();\n    }\n    setDpr(dpr) {\n        this.forEachChildren((c => {\n            c.setDpr(dpr);\n        }));\n    }\n    setOrigin(x, y) {\n        throw new Error(\"\");\n    }\n    export(type) {\n        throw new Error(\"\");\n    }\n    pick(x, y) {\n        const result = this.pickerService.pick(this.children, new vutils_1.Point(x, y), {\n            bounds: this.AABBBounds\n        });\n        return !(!(null == result ? void 0 : result.graphic) && !(null == result ? void 0 : result.group)) && result;\n    }\n    startAnimate(t) {\n        throw new Error(\"\");\n    }\n    setToFrame(t) {\n        throw new Error(\"\");\n    }\n    release() {\n        super.release(), this.eventSystem && this.eventSystem.release(), this.pluginService.release(), \n        this.forEach((layer => {\n            layer.release();\n        })), this.window.release();\n    }\n    setStage(stage) {}\n    dirty(b, matrix) {\n        matrix && b.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2), \n        this.dirtyBounds.union(b);\n    }\n    renderTo(window, params) {\n        this.forEachChildren(((layer, i) => {\n            layer.drawTo(window, Object.assign(Object.assign({}, params), {\n                renderService: this.renderService,\n                background: layer === this.defaultLayer ? this.background : void 0,\n                clear: 0 === i,\n                updateBounds: !!this.dirtyBounds\n            }));\n        }));\n    }\n    renderToNewWindow(fullImage = !0) {\n        const window = container_1.container.get(window_1.Window);\n        return fullImage ? window.create({\n            width: this.viewWidth,\n            height: this.viewHeight,\n            dpr: this.window.dpr,\n            canvasControled: !0,\n            offscreen: !0,\n            title: \"\"\n        }) : window.create({\n            width: Math.min(this.viewWidth, this.window.width - this.x),\n            height: Math.min(this.viewHeight, this.window.height - this.y),\n            dpr: this.window.dpr,\n            canvasControled: !0,\n            offscreen: !0,\n            title: \"\"\n        }), this.renderTo(window, {\n            x: 0,\n            y: 0,\n            width: window.width,\n            height: window.height\n        }), window;\n    }\n    toCanvas(fullImage = !0) {\n        const c = this.renderToNewWindow(fullImage).getNativeHandler();\n        return c.nativeCanvas ? c.nativeCanvas : null;\n    }\n    setCursor(mode) {\n        this._cursor = mode, this.eventSystem.setCursor(mode);\n    }\n    getCursor() {\n        return this._cursor;\n    }\n}\n\nexports.Stage = Stage;\n//# sourceMappingURL=stage.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.AutoRenderPlugin = void 0;\n\nconst generator_1 = require(\"../../common/generator\"), application_1 = require(\"../../application\");\n\nclass AutoRenderPlugin {\n    constructor() {\n        this.name = \"AutoRenderPlugin\", this.activeEvent = \"onRegister\", this._uid = generator_1.Generator.GenAutoIncrementId(), \n        this.key = this.name + this._uid;\n    }\n    activate(context) {\n        this.pluginService = context, application_1.application.graphicService.hooks.onAttributeUpdate.tap(this.key, (graphic => {\n            graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();\n        })), application_1.application.graphicService.hooks.onSetStage.tap(this.key, (graphic => {\n            graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();\n        }));\n    }\n    deactivate(context) {\n        application_1.application.graphicService.hooks.onAttributeUpdate.taps = application_1.application.graphicService.hooks.onAttributeUpdate.taps.filter((item => item.name !== this.key)), \n        application_1.application.graphicService.hooks.onSetStage.taps = application_1.application.graphicService.hooks.onSetStage.taps.filter((item => item.name !== this.key));\n    }\n}\n\nexports.AutoRenderPlugin = AutoRenderPlugin;\n//# sourceMappingURL=auto-render-plugin.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.ViewTransform3dPlugin = void 0;\n\nconst generator_1 = require(\"../../common/generator\");\n\nclass ViewTransform3dPlugin {\n    constructor() {\n        this.name = \"ViewTransform3dPlugin\", this.activeEvent = \"onRegister\", this._uid = generator_1.Generator.GenAutoIncrementId(), \n        this.key = this.name + this._uid, this.onMouseDown = e => {\n            this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = !0, \n            this.pageX = e.page.x, this.pageY = e.page.y);\n        }, this.onMouseUp = e => {\n            this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = !1);\n        }, this.onMouseMove = e => {\n            var _a, _b;\n            const stage = this.pluginService.stage;\n            if (this.option3d || (this.option3d = stage.option3d), this.option3d && this.mousedown) if (this.pageX && this.pageY) {\n                const deltaX = e.page.x - this.pageX, deltaY = e.page.y - this.pageY;\n                this.pageX = e.page.x, this.pageY = e.page.y;\n                const angle1 = deltaX / 100, angle2 = deltaY / 100;\n                this.option3d.alpha = (null !== (_a = this.option3d.alpha) && void 0 !== _a ? _a : 0) + angle1, \n                this.option3d.beta = (null !== (_b = this.option3d.beta) && void 0 !== _b ? _b : 0) + angle2, \n                stage.set3dOptions(this.option3d), stage.renderNextFrame();\n            } else this.pageX = e.page.x, this.pageY = e.page.y;\n        };\n    }\n    activate(context) {\n        this.pluginService = context;\n        const stage = context.stage;\n        this.option3d = stage.option3d, stage.addEventListener(\"mousedown\", this.onMouseDown), \n        stage.addEventListener(\"mouseup\", this.onMouseUp), stage.addEventListener(\"mousemove\", this.onMouseMove);\n    }\n    deactivate(context) {\n        const stage = context.stage;\n        stage.removeEventListener(\"mousedown\", this.onMouseDown), stage.removeEventListener(\"mouseup\", this.onMouseUp), \n        stage.removeEventListener(\"mousemove\", this.onMouseMove);\n    }\n}\n\nexports.ViewTransform3dPlugin = ViewTransform3dPlugin;\n//# sourceMappingURL=3dview-transform-plugin.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.IncrementalAutoRenderPlugin = void 0;\n\nconst application_1 = require(\"../../application\"), generator_1 = require(\"../../common/generator\");\n\nclass IncrementalAutoRenderPlugin {\n    constructor() {\n        this.name = \"IncrementalAutoRenderPlugin\", this.activeEvent = \"onRegister\", this.nextFrameRenderGroupSet = new Set, \n        this.willNextFrameRender = !1, this.nextUserParams = {}, this._uid = generator_1.Generator.GenAutoIncrementId(), \n        this.key = this.name + this._uid;\n    }\n    activate(context) {\n        this.pluginService = context, application_1.application.graphicService.hooks.onAddIncremental.tap(this.key, ((graphic, group, stage) => {\n            graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && (this.nextUserParams.startAtId = group._uid, \n            this.renderNextFrame(group));\n        })), application_1.application.graphicService.hooks.onClearIncremental.tap(this.key, ((group, stage) => {\n            group.stage === context.stage && null != group.stage && (this.nextUserParams.startAtId = group._uid, \n            this.nextUserParams.restartIncremental = !0, this.renderNextFrame(group));\n        }));\n    }\n    deactivate(context) {\n        application_1.application.graphicService.hooks.onAddIncremental.taps = application_1.application.graphicService.hooks.onAddIncremental.taps.filter((item => item.name !== this.key)), \n        application_1.application.graphicService.hooks.onClearIncremental.taps = application_1.application.graphicService.hooks.onClearIncremental.taps.filter((item => item.name !== this.key));\n    }\n    renderNextFrame(group) {\n        this.nextFrameRenderGroupSet.add(group), this.willNextFrameRender || (this.willNextFrameRender = !0, \n        application_1.application.global.getRequestAnimationFrame()((() => {\n            this._doRenderInThisFrame(), this.willNextFrameRender = !1;\n        })));\n    }\n    _doRenderInThisFrame() {\n        const stage = this.pluginService.stage;\n        this.nextFrameRenderGroupSet.size && (this.nextFrameRenderGroupSet.forEach((group => {\n            const layer = group.layer;\n            if (!layer || !group.layer.subLayers) return;\n            const subLayer = group.layer.subLayers.get(group._uid);\n            subLayer && subLayer.drawContribution && subLayer.drawContribution.draw(stage.renderService, Object.assign({\n                x: stage.x,\n                y: stage.y,\n                width: layer.viewWidth,\n                height: layer.viewHeight,\n                stage: stage,\n                layer: layer,\n                clear: \"transparent\",\n                renderService: stage.renderService,\n                updateBounds: !1,\n                startAtId: group._uid,\n                context: subLayer.layer.getNativeHandler().getContext()\n            }, this.nextUserParams));\n        })), this.nextUserParams = {}, this.nextFrameRenderGroupSet.clear());\n    }\n}\n\nexports.IncrementalAutoRenderPlugin = IncrementalAutoRenderPlugin;\n//# sourceMappingURL=incremental-auto-render-plugin.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DirtyBoundsPlugin = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), generator_1 = require(\"../../common/generator\"), application_1 = require(\"../../application\"), globalBounds = new vutils_1.AABBBounds;\n\nclass DirtyBoundsPlugin {\n    constructor() {\n        this.name = \"DirtyBoundsPlugin\", this.activeEvent = \"onRegister\", this._uid = generator_1.Generator.GenAutoIncrementId(), \n        this.key = this.name + this._uid;\n    }\n    activate(context) {\n        this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage => {\n            stage && stage === this.pluginService.stage && stage.dirtyBounds.clear();\n        })), application_1.application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, ((graphic, stage, willUpdate, bounds) => {\n            graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds() || willUpdate && (globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), \n            stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix)));\n        })), application_1.application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, ((graphic, stage, bounds, params, selfChange) => {\n            stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !selfChange || stage.dirty(params.globalAABBBounds));\n        })), application_1.application.graphicService.hooks.onRemove.tap(this.key, (graphic => {\n            const stage = graphic.stage;\n            stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(graphic.globalAABBBounds);\n        }));\n    }\n    deactivate(context) {\n        application_1.application.graphicService.hooks.beforeUpdateAABBBounds.taps = application_1.application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter((item => item.name !== this.key)), \n        application_1.application.graphicService.hooks.afterUpdateAABBBounds.taps = application_1.application.graphicService.hooks.afterUpdateAABBBounds.taps.filter((item => item.name !== this.key)), \n        context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item => item.name !== this.key)), \n        application_1.application.graphicService.hooks.onRemove.taps = application_1.application.graphicService.hooks.onRemove.taps.filter((item => item.name !== this.key));\n    }\n}\n\nexports.DirtyBoundsPlugin = DirtyBoundsPlugin;\n//# sourceMappingURL=dirty-bounds-plugin.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.defaultTicker = void 0;\n\nconst default_ticker_1 = require(\"./Ticker/default-ticker\"), timeline_1 = require(\"./timeline\");\n\nexports.defaultTicker = new default_ticker_1.DefaultTicker, exports.defaultTicker.addTimeline(timeline_1.defaultTimeline);\n\nconst DEFAULT_TICKER_FPS = 60;\n\nexports.defaultTicker.setFPS(60);","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.DirectionalLight = void 0;\n\nconst vutils_1 = require(\"@visactor/vutils\"), color_string_1 = require(\"../color-string\");\n\nclass DirectionalLight {\n    constructor(dir, color, ambient = .8) {\n        this.dir = dir, this.color = color, this.colorRgb = color_string_1.colorString.get(color).value, \n        this.colorRgb[0] /= 255, this.colorRgb[1] /= 255, this.colorRgb[2] /= 255, this.ambient = ambient;\n        const length = (0, vutils_1.sqrt)(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);\n        this.formatedDir = [ dir[0] / length, dir[1] / length, dir[2] / length ];\n    }\n    computeColor(normal, color) {\n        const lightDir = this.formatedDir, brightness = (0, vutils_1.min)((0, vutils_1.max)((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);\n        let colorArray;\n        if ((0, vutils_1.isString)(color)) {\n            colorArray = color_string_1.colorString.get(color).value;\n        } else colorArray = color;\n        const lightColorArray = this.colorRgb;\n        return color_string_1.colorString.to.rgb(lightColorArray[0] * colorArray[0] * brightness, lightColorArray[1] * colorArray[1] * brightness, lightColorArray[2] * colorArray[2] * brightness);\n    }\n}\n\nexports.DirectionalLight = DirectionalLight;\n//# sourceMappingURL=light.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./global\"), exports), __exportStar(require(\"./common\"), exports), \n__exportStar(require(\"./node-tree\"), exports), __exportStar(require(\"./graphic\"), exports), \n__exportStar(require(\"./graphic/index\"), exports), __exportStar(require(\"./layer\"), exports), \n__exportStar(require(\"./stage\"), exports), __exportStar(require(\"./canvas\"), exports), \n__exportStar(require(\"./context\"), exports), __exportStar(require(\"./path\"), exports), \n__exportStar(require(\"./color\"), exports), __exportStar(require(\"./common\"), exports), \n__exportStar(require(\"./animate\"), exports), __exportStar(require(\"./camera\"), exports), \n__exportStar(require(\"./matrix\"), exports), __exportStar(require(\"./light\"), exports), \n__exportStar(require(\"./curve\"), exports), __exportStar(require(\"./graphic-service\"), exports), \n__exportStar(require(\"./sync-hook\"), exports), __exportStar(require(\"./allocator\"), exports), \n__exportStar(require(\"./core\"), exports), __exportStar(require(\"./event\"), exports), \n__exportStar(require(\"./loader\"), exports), __exportStar(require(\"./contribution\"), exports), \n__exportStar(require(\"./render\"), exports), __exportStar(require(\"./plugin\"), exports), \n__exportStar(require(\"./picker\"), exports), __exportStar(require(\"./text\"), exports), \n__exportStar(require(\"./window\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=global.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=common.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=node-tree.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=graphic.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./creator\"), exports), __exportStar(require(\"./theme\"), exports), \n__exportStar(require(\"./arc\"), exports), __exportStar(require(\"./arc3d\"), exports), \n__exportStar(require(\"./area\"), exports), __exportStar(require(\"./bounds\"), exports), \n__exportStar(require(\"./circle\"), exports), __exportStar(require(\"./ellipse\"), exports), \n__exportStar(require(\"./face3d\"), exports), __exportStar(require(\"./glyph\"), exports), \n__exportStar(require(\"./group\"), exports), __exportStar(require(\"./image\"), exports), \n__exportStar(require(\"./isogon\"), exports), __exportStar(require(\"./line\"), exports), \n__exportStar(require(\"./path\"), exports), __exportStar(require(\"./polygon\"), exports), \n__exportStar(require(\"./polyline\"), exports), __exportStar(require(\"./pyramid3d\"), exports), \n__exportStar(require(\"./rect\"), exports), __exportStar(require(\"./rect3d\"), exports), \n__exportStar(require(\"./richText\"), exports), __exportStar(require(\"./shadow-root\"), exports), \n__exportStar(require(\"./svg\"), exports), __exportStar(require(\"./symbol\"), exports), \n__exportStar(require(\"./text\"), exports), __exportStar(require(\"./util\"), exports);\n//# sourceMappingURL=index.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=creator.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=theme.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=arc.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=arc3d.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=area.js.map\n","\n\nvar params;\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), function(params) {\n    params[params.W = 1] = \"W\", params[params.H = 2] = \"H\", params[params.WH = 3] = \"WH\";\n}(params || (params = {}));\n//# sourceMappingURL=bounds.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=circle.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=ellipse.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=face3d.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=glyph.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=group.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=image.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=isogon.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=line.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=path.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=polygon.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=polyline.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=pyramid3d.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=rect.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=rect3d.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=richText.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=shadow-root.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=svg.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=symbol.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=text.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=util.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=layer.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=stage.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=canvas.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=context.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.strCommandMap = void 0, exports.strCommandMap = [ \"arc\", \"arcTo\", \"bezierCurveTo\", \"closePath\", \"ellipse\", \"lineTo\", \"moveTo\", \"quadraticCurveTo\", \"rect\" ];\n//# sourceMappingURL=path.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=color.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=animate.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=camera.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=matrix.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=light.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=curve.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=graphic-service.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=sync-hook.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=allocator.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=core.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=loader.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=contribution.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=render.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=plugin.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=picker.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=text.js.map\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n});\n//# sourceMappingURL=window.js.map\n","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), __exportStar(require(\"./global\"), exports), __exportStar(require(\"./window\"), exports), \n__exportStar(require(\"./layer\"), exports), __exportStar(require(\"./stage\"), exports), \n__exportStar(require(\"./graphic-utils\"), exports), __exportStar(require(\"./contributions\"), exports), \n__exportStar(require(\"./layer-service\"), exports), __exportStar(require(\"./constants\"), exports), \n__exportStar(require(\"../interface/core\"), exports);\n//# sourceMappingURL=index.js.map","\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k);\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    desc && !(\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {\n        enumerable: !0,\n        get: function() {\n            return m[k];\n        }\n    }), Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    void 0 === k2 && (k2 = k), o[k2] = m[k];\n}), __exportStar = this && this.__exportStar || function(m, exports) {\n    for (var p in m) \"default\" === p || Object.prototype.hasOwnProperty.call(exports, p) || __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: !0\n}), exports.CanvasTextLayout = void 0, __exportStar(require(\"./env/base-contribution\"), exports), \n__exportStar(require(\"./window/base-contribution\"), exports);\n\nvar layout_1 = require(\"./textMeasure/layout\");\n\nObject.defineProperty(exports, \"CanvasTextLayout\", {\n    enumerable: !0,\n    get: function() {\n        return layout_1.CanvasTextLayout;\n    }\n});\n//# sourceMappingURL=index.js.map\n"]}